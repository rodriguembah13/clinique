/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/build/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./web/assets/datatables/jquery.dataTables.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/jquery/dist/jquery.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.3.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2018-01-20T17:24Z
 */
( function( global, factory ) {

	"use strict";

	if (  true && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

      // Support: Chrome <=57, Firefox <=52
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., `typeof document.createElement( "object" ) === "function"`).
      // We don't want to classify *any* DOM node as a function.
      return typeof obj === "function" && typeof obj.nodeType !== "number";
  };


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};




	var preservedScriptAttributes = {
		type: true,
		src: true,
		noModule: true
	};

	function DOMEval( code, doc, node ) {
		doc = doc || document;

		var i,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {
				if ( node[ i ] ) {
					script[ i ] = node[ i ];
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.3.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {

					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && Array.isArray( src ) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject( src ) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {

		/* eslint-disable no-unused-vars */
		// See https://github.com/eslint/eslint/issues/6125
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		DOMEval( code );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.3
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-08-08
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	disabledAncestor = addCombinator(
		function( elem ) {
			return elem.disabled === true && ("form" in elem || "label" in elem);
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!compilerCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

				if ( nodeType !== 1 ) {
					newContext = context;
					newSelector = selector;

				// qSA looks outside Element context, which is not what we want
				// Thanks to Andrew Dupont for this workaround technique
				// Support: IE <=8
				// Exclude object elements
				} else if ( context.nodeName.toLowerCase() !== "object" ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch ( qsaError ) {
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						disabledAncestor( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		!compilerCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

};
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
        if ( nodeName( elem, "iframe" ) ) {
            return elem.contentDocument;
        }

        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
        // Treat the template element as a regular one in browsers that
        // don't support it.
        if ( nodeName( elem, "template" ) ) {
            elem = elem.content || elem;
        }

        return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			jQuery.contains( elem.ownerDocument, elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};




function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, contains, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		contains = jQuery.contains( elem.ownerDocument, elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( contains ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();
var documentElement = document.documentElement;



var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 only
// See #13393 for more info
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {

			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {

			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl ) {
								jQuery._evalUrl( node.src );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), doc, node );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		div.style.position = "absolute";
		scrollboxSizeVal = div.offsetWidth === 36 || "absolute";

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style;

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in emptyStyle ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a property mapped along what jQuery.cssProps suggests or to
// a vendor prefixed property.
function finalPropName( name ) {
	var ret = jQuery.cssProps[ name ];
	if ( !ret ) {
		ret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;
	}
	return ret;
}

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5
		) );
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),
		val = curCSS( elem, dimension, styles ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox;

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}

	// Check for style in case a browser which returns unreliable values
	// for getComputedStyle silently falls back to the reliable elem.style
	valueIsBorderBox = valueIsBorderBox &&
		( support.boxSizingReliable() || val === elem.style[ dimension ] );

	// Fall back to offsetWidth/offsetHeight when value is "auto"
	// This happens for inline elements with no explicit setting (gh-3571)
	// Support: Android <=4.1 - 4.3 only
	// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
	if ( val === "auto" ||
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) {

		val = elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ];

		// offsetWidth/offsetHeight provide border-box values
		valueIsBorderBox = true;
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			if ( type === "number" ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, dimension, extra );
						} ) :
						getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),
				isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra && boxModelAdjustment(
					elem,
					dimension,
					extra,
					isBorderBox,
					styles
				);

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && support.scrollboxSize() === styles.position ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 &&
				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
					jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = Date.now();

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,
		"throws": true
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" ).prop( {
					charset: s.scriptCharset,
					src: s.url
				} ).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( true ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
		return jQuery;
	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );


/***/ }),

/***/ "./web/assets/datatables/jquery.dataTables.js":
/*!****************************************************!*\
  !*** ./web/assets/datatables/jquery.dataTables.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*! DataTables 1.10.7
 * 2008-2014 SpryMedia Ltd - datatables.net/license
 */

/**
 * @summary     DataTables
 * @description Paginate, search and order HTML tables
 * @version     1.10.7
 * @file        jquery.dataTables.js
 * @author      SpryMedia Ltd (www.sprymedia.co.uk)
 * @contact     www.sprymedia.co.uk/contact
 * @copyright   Copyright 2008-2014 SpryMedia Ltd.
 *
 * This source file is free software, available under the following license:
 *   MIT license - http://datatables.net/license
 *
 * This source file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
 *
 * For details please refer to: http://www.datatables.net
 */

/*jslint evil: true, undef: true, browser: true */

/*globals $,require,jQuery,define,_selector_run,_selector_opts,_selector_first,_selector_row_indexes,_ext,_Api,_api_register,_api_registerPlural,_re_new_lines,_re_html,_re_formatted_numeric,_re_escape_regex,_empty,_intVal,_numToDecimal,_isNumber,_isHtml,_htmlNumeric,_pluck,_pluck_order,_range,_stripHtml,_unique,_fnBuildAjax,_fnAjaxUpdate,_fnAjaxParameters,_fnAjaxUpdateDraw,_fnAjaxDataSrc,_fnAddColumn,_fnColumnOptions,_fnAdjustColumnSizing,_fnVisibleToColumnIndex,_fnColumnIndexToVisible,_fnVisbleColumns,_fnGetColumns,_fnColumnTypes,_fnApplyColumnDefs,_fnHungarianMap,_fnCamelToHungarian,_fnLanguageCompat,_fnBrowserDetect,_fnAddData,_fnAddTr,_fnNodeToDataIndex,_fnNodeToColumnIndex,_fnGetCellData,_fnSetCellData,_fnSplitObjNotation,_fnGetObjectDataFn,_fnSetObjectDataFn,_fnGetDataMaster,_fnClearTable,_fnDeleteIndex,_fnInvalidate,_fnGetRowElements,_fnCreateTr,_fnBuildHead,_fnDrawHead,_fnDraw,_fnReDraw,_fnAddOptionsHtml,_fnDetectHeader,_fnGetUniqueThs,_fnFeatureHtmlFilter,_fnFilterComplete,_fnFilterCustom,_fnFilterColumn,_fnFilter,_fnFilterCreateSearch,_fnEscapeRegex,_fnFilterData,_fnFeatureHtmlInfo,_fnUpdateInfo,_fnInfoMacros,_fnInitialise,_fnInitComplete,_fnLengthChange,_fnFeatureHtmlLength,_fnFeatureHtmlPaginate,_fnPageChange,_fnFeatureHtmlProcessing,_fnProcessingDisplay,_fnFeatureHtmlTable,_fnScrollDraw,_fnApplyToChildren,_fnCalculateColumnWidths,_fnThrottle,_fnConvertToWidth,_fnScrollingWidthAdjust,_fnGetWidestNode,_fnGetMaxLenString,_fnStringToCss,_fnScrollBarWidth,_fnSortFlatten,_fnSort,_fnSortAria,_fnSortListener,_fnSortAttachListener,_fnSortingClasses,_fnSortData,_fnSaveState,_fnLoadState,_fnSettingsFromNode,_fnLog,_fnMap,_fnBindAction,_fnCallbackReg,_fnCallbackFire,_fnLengthOverflow,_fnRenderer,_fnDataSource,_fnRowAttributes*/

/** @lends <global> */
(function (window, document, undefined) {
  (function (factory) {
    "use strict";

    if (true) {
      // Define as an AMD module if possible
      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
  })(
  /** @lends <global> */
  function ($) {
    "use strict";
    /**
     * DataTables is a plug-in for the jQuery Javascript library. It is a highly
     * flexible tool, based upon the foundations of progressive enhancement,
     * which will add advanced interaction controls to any HTML table. For a
     * full list of features please refer to
     * [DataTables.net](href="http://datatables.net).
     *
     * Note that the `DataTable` object is not a global variable but is aliased
     * to `jQuery.fn.DataTable` and `jQuery.fn.dataTable` through which it may
     * be  accessed.
     *
     *  @class
     *  @param {object} [init={}] Configuration object for DataTables. Options
     *    are defined by {@link DataTable.defaults}
     *  @requires jQuery 1.7+
     *
     *  @example
     *    // Basic initialisation
     *    $(document).ready( function {
     *      $('#example').dataTable();
     *    } );
     *
     *  @example
     *    // Initialisation with configuration options - in this case, disable
     *    // pagination and sorting.
     *    $(document).ready( function {
     *      $('#example').dataTable( {
     *        "paginate": false,
     *        "sort": false
     *      } );
     *    } );
     */

    var _DataTable;
    /*
     * It is useful to have variables which are scoped locally so only the
     * DataTables functions can access them and they don't leak into global space.
     * At the same time these functions are often useful over multiple files in the
     * core and API, so we list, or at least document, all variables which are used
     * by DataTables as private variables here. This also ensures that there is no
     * clashing of variable names and that they can easily referenced for reuse.
     */
    // Defined else where
    //  _selector_run
    //  _selector_opts
    //  _selector_first
    //  _selector_row_indexes


    var _ext; // DataTable.ext


    var _Api2; // DataTable.Api


    var _api_register; // DataTable.Api.register


    var _api_registerPlural; // DataTable.Api.registerPlural


    var _re_dic = {};
    var _re_new_lines = /[\r\n]/g;
    var _re_html = /<.*?>/g;
    var _re_date_start = /^[\w\+\-]/;
    var _re_date_end = /[\w\+\-]$/; // Escape regular expression special characters

    var _re_escape_regex = new RegExp('(\\' + ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\', '$', '^', '-'].join('|\\') + ')', 'g'); // http://en.wikipedia.org/wiki/Foreign_exchange_market
    // - \u20BD - Russian ruble.
    // - \u20a9 - South Korean Won
    // - \u20BA - Turkish Lira
    // - \u20B9 - Indian Rupee
    // - R - Brazil (R$) and South Africa
    // - fr - Swiss Franc
    // - kr - Swedish krona, Norwegian krone and Danish krone
    // - \u2009 is thin space and \u202F is narrow no-break space, both used in many
    //   standards as thousands separators.


    var _re_formatted_numeric = /[',$%\u2009\u202F\u20BD\u20a9\u20BArfk]/gi;

    var _empty = function _empty(d) {
      return !d || d === true || d === '-' ? true : false;
    };

    var _intVal = function _intVal(s) {
      var integer = parseInt(s, 10);
      return !isNaN(integer) && isFinite(s) ? integer : null;
    }; // Convert from a formatted number with characters other than `.` as the
    // decimal place, to a Javascript number


    var _numToDecimal = function _numToDecimal(num, decimalPoint) {
      // Cache created regular expressions for speed as this function is called often
      if (!_re_dic[decimalPoint]) {
        _re_dic[decimalPoint] = new RegExp(_fnEscapeRegex(decimalPoint), 'g');
      }

      return typeof num === 'string' && decimalPoint !== '.' ? num.replace(/\./g, '').replace(_re_dic[decimalPoint], '.') : num;
    };

    var _isNumber = function _isNumber(d, decimalPoint, formatted) {
      var strType = typeof d === 'string'; // If empty return immediately so there must be a number if it is a
      // formatted string (this stops the string "k", or "kr", etc being detected
      // as a formatted number for currency

      if (_empty(d)) {
        return true;
      }

      if (decimalPoint && strType) {
        d = _numToDecimal(d, decimalPoint);
      }

      if (formatted && strType) {
        d = d.replace(_re_formatted_numeric, '');
      }

      return !isNaN(parseFloat(d)) && isFinite(d);
    }; // A string without HTML in it can be considered to be HTML still


    var _isHtml = function _isHtml(d) {
      return _empty(d) || typeof d === 'string';
    };

    var _htmlNumeric = function _htmlNumeric(d, decimalPoint, formatted) {
      if (_empty(d)) {
        return true;
      }

      var html = _isHtml(d);

      return !html ? null : _isNumber(_stripHtml(d), decimalPoint, formatted) ? true : null;
    };

    var _pluck = function _pluck(a, prop, prop2) {
      var out = [];
      var i = 0,
          ien = a.length; // Could have the test in the loop for slightly smaller code, but speed
      // is essential here

      if (prop2 !== undefined) {
        for (; i < ien; i++) {
          if (a[i] && a[i][prop]) {
            out.push(a[i][prop][prop2]);
          }
        }
      } else {
        for (; i < ien; i++) {
          if (a[i]) {
            out.push(a[i][prop]);
          }
        }
      }

      return out;
    }; // Basically the same as _pluck, but rather than looping over `a` we use `order`
    // as the indexes to pick from `a`


    var _pluck_order = function _pluck_order(a, order, prop, prop2) {
      var out = [];
      var i = 0,
          ien = order.length; // Could have the test in the loop for slightly smaller code, but speed
      // is essential here

      if (prop2 !== undefined) {
        for (; i < ien; i++) {
          if (a[order[i]][prop]) {
            out.push(a[order[i]][prop][prop2]);
          }
        }
      } else {
        for (; i < ien; i++) {
          out.push(a[order[i]][prop]);
        }
      }

      return out;
    };

    var _range = function _range(len, start) {
      var out = [];
      var end;

      if (start === undefined) {
        start = 0;
        end = len;
      } else {
        end = start;
        start = len;
      }

      for (var i = start; i < end; i++) {
        out.push(i);
      }

      return out;
    };

    var _removeEmpty = function _removeEmpty(a) {
      var out = [];

      for (var i = 0, ien = a.length; i < ien; i++) {
        if (a[i]) {
          // careful - will remove all falsy values!
          out.push(a[i]);
        }
      }

      return out;
    };

    var _stripHtml = function _stripHtml(d) {
      return d.replace(_re_html, '');
    };
    /**
     * Find the unique elements in a source array.
     *
     * @param  {array} src Source array
     * @return {array} Array of unique items
     * @ignore
     */


    var _unique = function _unique(src) {
      // A faster unique method is to use object keys to identify used values,
      // but this doesn't work with arrays or objects, which we must also
      // consider. See jsperf.com/compare-array-unique-versions/4 for more
      // information.
      var out = [],
          val,
          i,
          ien = src.length,
          j,
          k = 0;

      again: for (i = 0; i < ien; i++) {
        val = src[i];

        for (j = 0; j < k; j++) {
          if (out[j] === val) {
            continue again;
          }
        }

        out.push(val);
        k++;
      }

      return out;
    };
    /**
     * Create a mapping object that allows camel case parameters to be looked up
     * for their Hungarian counterparts. The mapping is stored in a private
     * parameter called `_hungarianMap` which can be accessed on the source object.
     *  @param {object} o
     *  @memberof DataTable#oApi
     */


    function _fnHungarianMap(o) {
      var hungarian = 'a aa ai ao as b fn i m o s ',
          match,
          newKey,
          map = {};
      $.each(o, function (key, val) {
        match = key.match(/^([^A-Z]+?)([A-Z])/);

        if (match && hungarian.indexOf(match[1] + ' ') !== -1) {
          newKey = key.replace(match[0], match[2].toLowerCase());
          map[newKey] = key;

          if (match[1] === 'o') {
            _fnHungarianMap(o[key]);
          }
        }
      });
      o._hungarianMap = map;
    }
    /**
     * Convert from camel case parameters to Hungarian, based on a Hungarian map
     * created by _fnHungarianMap.
     *  @param {object} src The model object which holds all parameters that can be
     *    mapped.
     *  @param {object} user The object to convert from camel case to Hungarian.
     *  @param {boolean} force When set to `true`, properties which already have a
     *    Hungarian value in the `user` object will be overwritten. Otherwise they
     *    won't be.
     *  @memberof DataTable#oApi
     */


    function _fnCamelToHungarian(src, user, force) {
      if (!src._hungarianMap) {
        _fnHungarianMap(src);
      }

      var hungarianKey;
      $.each(user, function (key, val) {
        hungarianKey = src._hungarianMap[key];

        if (hungarianKey !== undefined && (force || user[hungarianKey] === undefined)) {
          // For objects, we need to buzz down into the object to copy parameters
          if (hungarianKey.charAt(0) === 'o') {
            // Copy the camelCase options over to the hungarian
            if (!user[hungarianKey]) {
              user[hungarianKey] = {};
            }

            $.extend(true, user[hungarianKey], user[key]);

            _fnCamelToHungarian(src[hungarianKey], user[hungarianKey], force);
          } else {
            user[hungarianKey] = user[key];
          }
        }
      });
    }
    /**
     * Language compatibility - when certain options are given, and others aren't, we
     * need to duplicate the values over, in order to provide backwards compatibility
     * with older language files.
     *  @param {object} oSettings dataTables settings object
     *  @memberof DataTable#oApi
     */


    function _fnLanguageCompat(lang) {
      var defaults = _DataTable.defaults.oLanguage;
      var zeroRecords = lang.sZeroRecords;
      /* Backwards compatibility - if there is no sEmptyTable given, then use the same as
       * sZeroRecords - assuming that is given.
       */

      if (!lang.sEmptyTable && zeroRecords && defaults.sEmptyTable === "No data available in table") {
        _fnMap(lang, lang, 'sZeroRecords', 'sEmptyTable');
      }
      /* Likewise with loading records */


      if (!lang.sLoadingRecords && zeroRecords && defaults.sLoadingRecords === "Loading...") {
        _fnMap(lang, lang, 'sZeroRecords', 'sLoadingRecords');
      } // Old parameter name of the thousands separator mapped onto the new


      if (lang.sInfoThousands) {
        lang.sThousands = lang.sInfoThousands;
      }

      var decimal = lang.sDecimal;

      if (decimal) {
        _addNumericSort(decimal);
      }
    }
    /**
     * Map one parameter onto another
     *  @param {object} o Object to map
     *  @param {*} knew The new parameter name
     *  @param {*} old The old parameter name
     */


    var _fnCompatMap = function _fnCompatMap(o, knew, old) {
      if (o[knew] !== undefined) {
        o[old] = o[knew];
      }
    };
    /**
     * Provide backwards compatibility for the main DT options. Note that the new
     * options are mapped onto the old parameters, so this is an external interface
     * change only.
     *  @param {object} init Object to map
     */


    function _fnCompatOpts(init) {
      _fnCompatMap(init, 'ordering', 'bSort');

      _fnCompatMap(init, 'orderMulti', 'bSortMulti');

      _fnCompatMap(init, 'orderClasses', 'bSortClasses');

      _fnCompatMap(init, 'orderCellsTop', 'bSortCellsTop');

      _fnCompatMap(init, 'order', 'aaSorting');

      _fnCompatMap(init, 'orderFixed', 'aaSortingFixed');

      _fnCompatMap(init, 'paging', 'bPaginate');

      _fnCompatMap(init, 'pagingType', 'sPaginationType');

      _fnCompatMap(init, 'pageLength', 'iDisplayLength');

      _fnCompatMap(init, 'searching', 'bFilter'); // Column search objects are in an array, so it needs to be converted
      // element by element


      var searchCols = init.aoSearchCols;

      if (searchCols) {
        for (var i = 0, ien = searchCols.length; i < ien; i++) {
          if (searchCols[i]) {
            _fnCamelToHungarian(_DataTable.models.oSearch, searchCols[i]);
          }
        }
      }
    }
    /**
     * Provide backwards compatibility for column options. Note that the new options
     * are mapped onto the old parameters, so this is an external interface change
     * only.
     *  @param {object} init Object to map
     */


    function _fnCompatCols(init) {
      _fnCompatMap(init, 'orderable', 'bSortable');

      _fnCompatMap(init, 'orderData', 'aDataSort');

      _fnCompatMap(init, 'orderSequence', 'asSorting');

      _fnCompatMap(init, 'orderDataType', 'sortDataType'); // orderData can be given as an integer


      var dataSort = init.aDataSort;

      if (dataSort && !$.isArray(dataSort)) {
        init.aDataSort = [dataSort];
      }
    }
    /**
     * Browser feature detection for capabilities, quirks
     *  @param {object} settings dataTables settings object
     *  @memberof DataTable#oApi
     */


    function _fnBrowserDetect(settings) {
      var browser = settings.oBrowser; // Scrolling feature / quirks detection

      var n = $('<div/>').css({
        position: 'absolute',
        top: 0,
        left: 0,
        height: 1,
        width: 1,
        overflow: 'hidden'
      }).append($('<div/>').css({
        position: 'absolute',
        top: 1,
        left: 1,
        width: 100,
        overflow: 'scroll'
      }).append($('<div class="test"/>').css({
        width: '100%',
        height: 10
      }))).appendTo('body');
      var test = n.find('.test'); // IE6/7 will oversize a width 100% element inside a scrolling element, to
      // include the width of the scrollbar, while other browsers ensure the inner
      // element is contained without forcing scrolling

      browser.bScrollOversize = test[0].offsetWidth === 100; // In rtl text layout, some browsers (most, but not all) will place the
      // scrollbar on the left, rather than the right.

      browser.bScrollbarLeft = Math.round(test.offset().left) !== 1;
      n.remove();
    }
    /**
     * Array.prototype reduce[Right] method, used for browsers which don't support
     * JS 1.6. Done this way to reduce code size, since we iterate either way
     *  @param {object} settings dataTables settings object
     *  @memberof DataTable#oApi
     */


    function _fnReduce(that, fn, init, start, end, inc) {
      var i = start,
          value,
          isSet = false;

      if (init !== undefined) {
        value = init;
        isSet = true;
      }

      while (i !== end) {
        if (!that.hasOwnProperty(i)) {
          continue;
        }

        value = isSet ? fn(value, that[i], i, that) : that[i];
        isSet = true;
        i += inc;
      }

      return value;
    }
    /**
     * Add a column to the list used for the table with default values
     *  @param {object} oSettings dataTables settings object
     *  @param {node} nTh The th element for this column
     *  @memberof DataTable#oApi
     */


    function _fnAddColumn(oSettings, nTh) {
      // Add column to aoColumns array
      var oDefaults = _DataTable.defaults.column;
      var iCol = oSettings.aoColumns.length;
      var oCol = $.extend({}, _DataTable.models.oColumn, oDefaults, {
        "nTh": nTh ? nTh : document.createElement('th'),
        "sTitle": oDefaults.sTitle ? oDefaults.sTitle : nTh ? nTh.innerHTML : '',
        "aDataSort": oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],
        "mData": oDefaults.mData ? oDefaults.mData : iCol,
        idx: iCol
      });
      oSettings.aoColumns.push(oCol); // Add search object for column specific search. Note that the `searchCols[ iCol ]`
      // passed into extend can be undefined. This allows the user to give a default
      // with only some of the parameters defined, and also not give a default

      var searchCols = oSettings.aoPreSearchCols;
      searchCols[iCol] = $.extend({}, _DataTable.models.oSearch, searchCols[iCol]); // Use the default column options function to initialise classes etc

      _fnColumnOptions(oSettings, iCol, $(nTh).data());
    }
    /**
     * Apply options for a column
     *  @param {object} oSettings dataTables settings object
     *  @param {int} iCol column index to consider
     *  @param {object} oOptions object with sType, bVisible and bSearchable etc
     *  @memberof DataTable#oApi
     */


    function _fnColumnOptions(oSettings, iCol, oOptions) {
      var oCol = oSettings.aoColumns[iCol];
      var oClasses = oSettings.oClasses;
      var th = $(oCol.nTh); // Try to get width information from the DOM. We can't get it from CSS
      // as we'd need to parse the CSS stylesheet. `width` option can override

      if (!oCol.sWidthOrig) {
        // Width attribute
        oCol.sWidthOrig = th.attr('width') || null; // Style attribute

        var t = (th.attr('style') || '').match(/width:\s*(\d+[pxem%]+)/);

        if (t) {
          oCol.sWidthOrig = t[1];
        }
      }
      /* User specified column options */


      if (oOptions !== undefined && oOptions !== null) {
        // Backwards compatibility
        _fnCompatCols(oOptions); // Map camel case parameters to their Hungarian counterparts


        _fnCamelToHungarian(_DataTable.defaults.column, oOptions);
        /* Backwards compatibility for mDataProp */


        if (oOptions.mDataProp !== undefined && !oOptions.mData) {
          oOptions.mData = oOptions.mDataProp;
        }

        if (oOptions.sType) {
          oCol._sManualType = oOptions.sType;
        } // `class` is a reserved word in Javascript, so we need to provide
        // the ability to use a valid name for the camel case input


        if (oOptions.className && !oOptions.sClass) {
          oOptions.sClass = oOptions.className;
        }

        $.extend(oCol, oOptions);

        _fnMap(oCol, oOptions, "sWidth", "sWidthOrig");
        /* iDataSort to be applied (backwards compatibility), but aDataSort will take
         * priority if defined
         */


        if (oOptions.iDataSort !== undefined) {
          oCol.aDataSort = [oOptions.iDataSort];
        }

        _fnMap(oCol, oOptions, "aDataSort");
      }
      /* Cache the data get and set functions for speed */


      var mDataSrc = oCol.mData;

      var mData = _fnGetObjectDataFn(mDataSrc);

      var mRender = oCol.mRender ? _fnGetObjectDataFn(oCol.mRender) : null;

      var attrTest = function attrTest(src) {
        return typeof src === 'string' && src.indexOf('@') !== -1;
      };

      oCol._bAttrSrc = $.isPlainObject(mDataSrc) && (attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter));

      oCol.fnGetData = function (rowData, type, meta) {
        var innerData = mData(rowData, type, undefined, meta);
        return mRender && type ? mRender(innerData, type, rowData, meta) : innerData;
      };

      oCol.fnSetData = function (rowData, val, meta) {
        return _fnSetObjectDataFn(mDataSrc)(rowData, val, meta);
      }; // Indicate if DataTables should read DOM data as an object or array
      // Used in _fnGetRowElements


      if (typeof mDataSrc !== 'number') {
        oSettings._rowReadObject = true;
      }
      /* Feature sorting overrides column specific when off */


      if (!oSettings.oFeatures.bSort) {
        oCol.bSortable = false;
        th.addClass(oClasses.sSortableNone); // Have to add class here as order event isn't called
      }
      /* Check that the class assignment is correct for sorting */


      var bAsc = $.inArray('asc', oCol.asSorting) !== -1;
      var bDesc = $.inArray('desc', oCol.asSorting) !== -1;

      if (!oCol.bSortable || !bAsc && !bDesc) {
        oCol.sSortingClass = oClasses.sSortableNone;
        oCol.sSortingClassJUI = "";
      } else if (bAsc && !bDesc) {
        oCol.sSortingClass = oClasses.sSortableAsc;
        oCol.sSortingClassJUI = oClasses.sSortJUIAscAllowed;
      } else if (!bAsc && bDesc) {
        oCol.sSortingClass = oClasses.sSortableDesc;
        oCol.sSortingClassJUI = oClasses.sSortJUIDescAllowed;
      } else {
        oCol.sSortingClass = oClasses.sSortable;
        oCol.sSortingClassJUI = oClasses.sSortJUI;
      }
    }
    /**
     * Adjust the table column widths for new data. Note: you would probably want to
     * do a redraw after calling this function!
     *  @param {object} settings dataTables settings object
     *  @memberof DataTable#oApi
     */


    function _fnAdjustColumnSizing(settings) {
      /* Not interested in doing column width calculation if auto-width is disabled */
      if (settings.oFeatures.bAutoWidth !== false) {
        var columns = settings.aoColumns;

        _fnCalculateColumnWidths(settings);

        for (var i = 0, iLen = columns.length; i < iLen; i++) {
          columns[i].nTh.style.width = columns[i].sWidth;
        }
      }

      var scroll = settings.oScroll;

      if (scroll.sY !== '' || scroll.sX !== '') {
        _fnScrollDraw(settings);
      }

      _fnCallbackFire(settings, null, 'column-sizing', [settings]);
    }
    /**
     * Covert the index of a visible column to the index in the data array (take account
     * of hidden columns)
     *  @param {object} oSettings dataTables settings object
     *  @param {int} iMatch Visible column index to lookup
     *  @returns {int} i the data index
     *  @memberof DataTable#oApi
     */


    function _fnVisibleToColumnIndex(oSettings, iMatch) {
      var aiVis = _fnGetColumns(oSettings, 'bVisible');

      return typeof aiVis[iMatch] === 'number' ? aiVis[iMatch] : null;
    }
    /**
     * Covert the index of an index in the data array and convert it to the visible
     *   column index (take account of hidden columns)
     *  @param {int} iMatch Column index to lookup
     *  @param {object} oSettings dataTables settings object
     *  @returns {int} i the data index
     *  @memberof DataTable#oApi
     */


    function _fnColumnIndexToVisible(oSettings, iMatch) {
      var aiVis = _fnGetColumns(oSettings, 'bVisible');

      var iPos = $.inArray(iMatch, aiVis);
      return iPos !== -1 ? iPos : null;
    }
    /**
     * Get the number of visible columns
     *  @param {object} oSettings dataTables settings object
     *  @returns {int} i the number of visible columns
     *  @memberof DataTable#oApi
     */


    function _fnVisbleColumns(oSettings) {
      return _fnGetColumns(oSettings, 'bVisible').length;
    }
    /**
     * Get an array of column indexes that match a given property
     *  @param {object} oSettings dataTables settings object
     *  @param {string} sParam Parameter in aoColumns to look for - typically
     *    bVisible or bSearchable
     *  @returns {array} Array of indexes with matched properties
     *  @memberof DataTable#oApi
     */


    function _fnGetColumns(oSettings, sParam) {
      var a = [];
      $.map(oSettings.aoColumns, function (val, i) {
        if (val[sParam]) {
          a.push(i);
        }
      });
      return a;
    }
    /**
     * Calculate the 'type' of a column
     *  @param {object} settings dataTables settings object
     *  @memberof DataTable#oApi
     */


    function _fnColumnTypes(settings) {
      var columns = settings.aoColumns;
      var data = settings.aoData;
      var types = _DataTable.ext.type.detect;
      var i, ien, j, jen, k, ken;
      var col, cell, detectedType, cache; // For each column, spin over the 

      for (i = 0, ien = columns.length; i < ien; i++) {
        col = columns[i];
        cache = [];

        if (!col.sType && col._sManualType) {
          col.sType = col._sManualType;
        } else if (!col.sType) {
          for (j = 0, jen = types.length; j < jen; j++) {
            for (k = 0, ken = data.length; k < ken; k++) {
              // Use a cache array so we only need to get the type data
              // from the formatter once (when using multiple detectors)
              if (cache[k] === undefined) {
                cache[k] = _fnGetCellData(settings, k, i, 'type');
              }

              detectedType = types[j](cache[k], settings); // If null, then this type can't apply to this column, so
              // rather than testing all cells, break out. There is an
              // exception for the last type which is `html`. We need to
              // scan all rows since it is possible to mix string and HTML
              // types

              if (!detectedType && j !== types.length - 1) {
                break;
              } // Only a single match is needed for html type since it is
              // bottom of the pile and very similar to string


              if (detectedType === 'html') {
                break;
              }
            } // Type is valid for all data points in the column - use this
            // type


            if (detectedType) {
              col.sType = detectedType;
              break;
            }
          } // Fall back - if no type was detected, always use string


          if (!col.sType) {
            col.sType = 'string';
          }
        }
      }
    }
    /**
     * Take the column definitions and static columns arrays and calculate how
     * they relate to column indexes. The callback function will then apply the
     * definition found for a column to a suitable configuration object.
     *  @param {object} oSettings dataTables settings object
     *  @param {array} aoColDefs The aoColumnDefs array that is to be applied
     *  @param {array} aoCols The aoColumns array that defines columns individually
     *  @param {function} fn Callback function - takes two parameters, the calculated
     *    column index and the definition for that column.
     *  @memberof DataTable#oApi
     */


    function _fnApplyColumnDefs(oSettings, aoColDefs, aoCols, fn) {
      var i, iLen, j, jLen, k, kLen, def;
      var columns = oSettings.aoColumns; // Column definitions with aTargets

      if (aoColDefs) {
        /* Loop over the definitions array - loop in reverse so first instance has priority */
        for (i = aoColDefs.length - 1; i >= 0; i--) {
          def = aoColDefs[i];
          /* Each definition can target multiple columns, as it is an array */

          var aTargets = def.targets !== undefined ? def.targets : def.aTargets;

          if (!$.isArray(aTargets)) {
            aTargets = [aTargets];
          }

          for (j = 0, jLen = aTargets.length; j < jLen; j++) {
            if (typeof aTargets[j] === 'number' && aTargets[j] >= 0) {
              /* Add columns that we don't yet know about */
              while (columns.length <= aTargets[j]) {
                _fnAddColumn(oSettings);
              }
              /* Integer, basic index */


              fn(aTargets[j], def);
            } else if (typeof aTargets[j] === 'number' && aTargets[j] < 0) {
              /* Negative integer, right to left column counting */
              fn(columns.length + aTargets[j], def);
            } else if (typeof aTargets[j] === 'string') {
              /* Class name matching on TH element */
              for (k = 0, kLen = columns.length; k < kLen; k++) {
                if (aTargets[j] == "_all" || $(columns[k].nTh).hasClass(aTargets[j])) {
                  fn(k, def);
                }
              }
            }
          }
        }
      } // Statically defined columns array


      if (aoCols) {
        for (i = 0, iLen = aoCols.length; i < iLen; i++) {
          fn(i, aoCols[i]);
        }
      }
    }
    /**
     * Add a data array to the table, creating DOM node etc. This is the parallel to
     * _fnGatherData, but for adding rows from a Javascript source, rather than a
     * DOM source.
     *  @param {object} oSettings dataTables settings object
     *  @param {array} aData data array to be added
     *  @param {node} [nTr] TR element to add to the table - optional. If not given,
     *    DataTables will create a row automatically
     *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
     *    if nTr is.
     *  @returns {int} >=0 if successful (index of new aoData entry), -1 if failed
     *  @memberof DataTable#oApi
     */


    function _fnAddData(oSettings, aDataIn, nTr, anTds) {
      /* Create the object for storing information about this new row */
      var iRow = oSettings.aoData.length;
      var oData = $.extend(true, {}, _DataTable.models.oRow, {
        src: nTr ? 'dom' : 'data'
      });
      oData._aData = aDataIn;
      oSettings.aoData.push(oData);
      /* Create the cells */

      var nTd, sThisType;
      var columns = oSettings.aoColumns;

      for (var i = 0, iLen = columns.length; i < iLen; i++) {
        // When working with a row, the data source object must be populated. In
        // all other cases, the data source object is already populated, so we
        // don't overwrite it, which might break bindings etc
        if (nTr) {
          _fnSetCellData(oSettings, iRow, i, _fnGetCellData(oSettings, iRow, i));
        }

        columns[i].sType = null;
      }
      /* Add to the display array */


      oSettings.aiDisplayMaster.push(iRow);
      /* Create the DOM information, or register it if already present */

      if (nTr || !oSettings.oFeatures.bDeferRender) {
        _fnCreateTr(oSettings, iRow, nTr, anTds);
      }

      return iRow;
    }
    /**
     * Add one or more TR elements to the table. Generally we'd expect to
     * use this for reading data from a DOM sourced table, but it could be
     * used for an TR element. Note that if a TR is given, it is used (i.e.
     * it is not cloned).
     *  @param {object} settings dataTables settings object
     *  @param {array|node|jQuery} trs The TR element(s) to add to the table
     *  @returns {array} Array of indexes for the added rows
     *  @memberof DataTable#oApi
     */


    function _fnAddTr(settings, trs) {
      var row; // Allow an individual node to be passed in

      if (!(trs instanceof $)) {
        trs = $(trs);
      }

      return trs.map(function (i, el) {
        row = _fnGetRowElements(settings, el);
        return _fnAddData(settings, row.data, el, row.cells);
      });
    }
    /**
     * Take a TR element and convert it to an index in aoData
     *  @param {object} oSettings dataTables settings object
     *  @param {node} n the TR element to find
     *  @returns {int} index if the node is found, null if not
     *  @memberof DataTable#oApi
     */


    function _fnNodeToDataIndex(oSettings, n) {
      return n._DT_RowIndex !== undefined ? n._DT_RowIndex : null;
    }
    /**
     * Take a TD element and convert it into a column data index (not the visible index)
     *  @param {object} oSettings dataTables settings object
     *  @param {int} iRow The row number the TD/TH can be found in
     *  @param {node} n The TD/TH element to find
     *  @returns {int} index if the node is found, -1 if not
     *  @memberof DataTable#oApi
     */


    function _fnNodeToColumnIndex(oSettings, iRow, n) {
      return $.inArray(n, oSettings.aoData[iRow].anCells);
    }
    /**
     * Get the data for a given cell from the internal cache, taking into account data mapping
     *  @param {object} settings dataTables settings object
     *  @param {int} rowIdx aoData row id
     *  @param {int} colIdx Column index
     *  @param {string} type data get type ('display', 'type' 'filter' 'sort')
     *  @returns {*} Cell data
     *  @memberof DataTable#oApi
     */


    function _fnGetCellData(settings, rowIdx, colIdx, type) {
      var draw = settings.iDraw;
      var col = settings.aoColumns[colIdx];
      var rowData = settings.aoData[rowIdx]._aData;
      var defaultContent = col.sDefaultContent;
      var cellData = col.fnGetData(rowData, type, {
        settings: settings,
        row: rowIdx,
        col: colIdx
      });

      if (cellData === undefined) {
        if (settings.iDrawError != draw && defaultContent === null) {
          _fnLog(settings, 0, "Requested unknown parameter " + (typeof col.mData == 'function' ? '{function}' : "'" + col.mData + "'") + " for row " + rowIdx, 4);

          settings.iDrawError = draw;
        }

        return defaultContent;
      }
      /* When the data source is null, we can use default column data */


      if ((cellData === rowData || cellData === null) && defaultContent !== null) {
        cellData = defaultContent;
      } else if (typeof cellData === 'function') {
        // If the data source is a function, then we run it and use the return,
        // executing in the scope of the data object (for instances)
        return cellData.call(rowData);
      }

      if (cellData === null && type == 'display') {
        return '';
      }

      return cellData;
    }
    /**
     * Set the value for a specific cell, into the internal data cache
     *  @param {object} settings dataTables settings object
     *  @param {int} rowIdx aoData row id
     *  @param {int} colIdx Column index
     *  @param {*} val Value to set
     *  @memberof DataTable#oApi
     */


    function _fnSetCellData(settings, rowIdx, colIdx, val) {
      var col = settings.aoColumns[colIdx];
      var rowData = settings.aoData[rowIdx]._aData;
      col.fnSetData(rowData, val, {
        settings: settings,
        row: rowIdx,
        col: colIdx
      });
    } // Private variable that is used to match action syntax in the data property object


    var __reArray = /\[.*?\]$/;
    var __reFn = /\(\)$/;
    /**
     * Split string on periods, taking into account escaped periods
     * @param  {string} str String to split
     * @return {array} Split string
     */

    function _fnSplitObjNotation(str) {
      return $.map(str.match(/(\\.|[^\.])+/g), function (s) {
        return s.replace(/\\./g, '.');
      });
    }
    /**
     * Return a function that can be used to get data from a source object, taking
     * into account the ability to use nested objects as a source
     *  @param {string|int|function} mSource The data source for the object
     *  @returns {function} Data get function
     *  @memberof DataTable#oApi
     */


    function _fnGetObjectDataFn(mSource) {
      if ($.isPlainObject(mSource)) {
        /* Build an object of get functions, and wrap them in a single call */
        var o = {};
        $.each(mSource, function (key, val) {
          if (val) {
            o[key] = _fnGetObjectDataFn(val);
          }
        });
        return function (data, type, row, meta) {
          var t = o[type] || o._;
          return t !== undefined ? t(data, type, row, meta) : data;
        };
      } else if (mSource === null) {
        /* Give an empty string for rendering / sorting etc */
        return function (data) {
          // type, row and meta also passed, but not used
          return data;
        };
      } else if (typeof mSource === 'function') {
        return function (data, type, row, meta) {
          return mSource(data, type, row, meta);
        };
      } else if (typeof mSource === 'string' && (mSource.indexOf('.') !== -1 || mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1)) {
        /* If there is a . in the source string then the data source is in a
         * nested object so we loop over the data for each level to get the next
         * level down. On each loop we test for undefined, and if found immediately
         * return. This allows entire objects to be missing and sDefaultContent to
         * be used if defined, rather than throwing an error
         */
        var fetchData = function fetchData(data, type, src) {
          var arrayNotation, funcNotation, out, innerSrc;

          if (src !== "") {
            var a = _fnSplitObjNotation(src);

            for (var i = 0, iLen = a.length; i < iLen; i++) {
              // Check if we are dealing with special notation
              arrayNotation = a[i].match(__reArray);
              funcNotation = a[i].match(__reFn);

              if (arrayNotation) {
                // Array notation
                a[i] = a[i].replace(__reArray, ''); // Condition allows simply [] to be passed in

                if (a[i] !== "") {
                  data = data[a[i]];
                }

                out = []; // Get the remainder of the nested object to get

                a.splice(0, i + 1);
                innerSrc = a.join('.'); // Traverse each entry in the array getting the properties requested

                for (var j = 0, jLen = data.length; j < jLen; j++) {
                  out.push(fetchData(data[j], type, innerSrc));
                } // If a string is given in between the array notation indicators, that
                // is used to join the strings together, otherwise an array is returned


                var join = arrayNotation[0].substring(1, arrayNotation[0].length - 1);
                data = join === "" ? out : out.join(join); // The inner call to fetchData has already traversed through the remainder
                // of the source requested, so we exit from the loop

                break;
              } else if (funcNotation) {
                // Function call
                a[i] = a[i].replace(__reFn, '');
                data = data[a[i]]();
                continue;
              }

              if (data === null || data[a[i]] === undefined) {
                return undefined;
              }

              data = data[a[i]];
            }
          }

          return data;
        };

        return function (data, type) {
          // row and meta also passed, but not used
          return fetchData(data, type, mSource);
        };
      } else {
        /* Array or flat object mapping */
        return function (data, type) {
          // row and meta also passed, but not used
          return data[mSource];
        };
      }
    }
    /**
     * Return a function that can be used to set data from a source object, taking
     * into account the ability to use nested objects as a source
     *  @param {string|int|function} mSource The data source for the object
     *  @returns {function} Data set function
     *  @memberof DataTable#oApi
     */


    function _fnSetObjectDataFn(mSource) {
      if ($.isPlainObject(mSource)) {
        /* Unlike get, only the underscore (global) option is used for for
         * setting data since we don't know the type here. This is why an object
         * option is not documented for `mData` (which is read/write), but it is
         * for `mRender` which is read only.
         */
        return _fnSetObjectDataFn(mSource._);
      } else if (mSource === null) {
        /* Nothing to do when the data source is null */
        return function () {};
      } else if (typeof mSource === 'function') {
        return function (data, val, meta) {
          mSource(data, 'set', val, meta);
        };
      } else if (typeof mSource === 'string' && (mSource.indexOf('.') !== -1 || mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1)) {
        /* Like the get, we need to get data from a nested object */
        var setData = function setData(data, val, src) {
          var a = _fnSplitObjNotation(src),
              b;

          var aLast = a[a.length - 1];
          var arrayNotation, funcNotation, o, innerSrc;

          for (var i = 0, iLen = a.length - 1; i < iLen; i++) {
            // Check if we are dealing with an array notation request
            arrayNotation = a[i].match(__reArray);
            funcNotation = a[i].match(__reFn);

            if (arrayNotation) {
              a[i] = a[i].replace(__reArray, '');
              data[a[i]] = []; // Get the remainder of the nested object to set so we can recurse

              b = a.slice();
              b.splice(0, i + 1);
              innerSrc = b.join('.'); // Traverse each entry in the array setting the properties requested

              for (var j = 0, jLen = val.length; j < jLen; j++) {
                o = {};
                setData(o, val[j], innerSrc);
                data[a[i]].push(o);
              } // The inner call to setData has already traversed through the remainder
              // of the source and has set the data, thus we can exit here


              return;
            } else if (funcNotation) {
              // Function call
              a[i] = a[i].replace(__reFn, '');
              data = data[a[i]](val);
            } // If the nested object doesn't currently exist - since we are
            // trying to set the value - create it


            if (data[a[i]] === null || data[a[i]] === undefined) {
              data[a[i]] = {};
            }

            data = data[a[i]];
          } // Last item in the input - i.e, the actual set


          if (aLast.match(__reFn)) {
            // Function call
            data = data[aLast.replace(__reFn, '')](val);
          } else {
            // If array notation is used, we just want to strip it and use the property name
            // and assign the value. If it isn't used, then we get the result we want anyway
            data[aLast.replace(__reArray, '')] = val;
          }
        };

        return function (data, val) {
          // meta is also passed in, but not used
          return setData(data, val, mSource);
        };
      } else {
        /* Array or flat object mapping */
        return function (data, val) {
          // meta is also passed in, but not used
          data[mSource] = val;
        };
      }
    }
    /**
     * Return an array with the full table data
     *  @param {object} oSettings dataTables settings object
     *  @returns array {array} aData Master data array
     *  @memberof DataTable#oApi
     */


    function _fnGetDataMaster(settings) {
      return _pluck(settings.aoData, '_aData');
    }
    /**
     * Nuke the table
     *  @param {object} oSettings dataTables settings object
     *  @memberof DataTable#oApi
     */


    function _fnClearTable(settings) {
      settings.aoData.length = 0;
      settings.aiDisplayMaster.length = 0;
      settings.aiDisplay.length = 0;
    }
    /**
    * Take an array of integers (index array) and remove a target integer (value - not
    * the key!)
    *  @param {array} a Index array to target
    *  @param {int} iTarget value to find
    *  @memberof DataTable#oApi
    */


    function _fnDeleteIndex(a, iTarget, splice) {
      var iTargetIndex = -1;

      for (var i = 0, iLen = a.length; i < iLen; i++) {
        if (a[i] == iTarget) {
          iTargetIndex = i;
        } else if (a[i] > iTarget) {
          a[i]--;
        }
      }

      if (iTargetIndex != -1 && splice === undefined) {
        a.splice(iTargetIndex, 1);
      }
    }
    /**
     * Mark cached data as invalid such that a re-read of the data will occur when
     * the cached data is next requested. Also update from the data source object.
     *
     * @param {object} settings DataTables settings object
     * @param {int}    rowIdx   Row index to invalidate
     * @param {string} [src]    Source to invalidate from: undefined, 'auto', 'dom'
     *     or 'data'
     * @param {int}    [colIdx] Column index to invalidate. If undefined the whole
     *     row will be invalidated
     * @memberof DataTable#oApi
     *
     * @todo For the modularisation of v1.11 this will need to become a callback, so
     *   the sort and filter methods can subscribe to it. That will required
     *   initialisation options for sorting, which is why it is not already baked in
     */


    function _fnInvalidate(settings, rowIdx, src, colIdx) {
      var row = settings.aoData[rowIdx];
      var i, ien;

      var cellWrite = function cellWrite(cell, col) {
        // This is very frustrating, but in IE if you just write directly
        // to innerHTML, and elements that are overwritten are GC'ed,
        // even if there is a reference to them elsewhere
        while (cell.childNodes.length) {
          cell.removeChild(cell.firstChild);
        }

        cell.innerHTML = _fnGetCellData(settings, rowIdx, col, 'display');
      }; // Are we reading last data from DOM or the data object?


      if (src === 'dom' || (!src || src === 'auto') && row.src === 'dom') {
        // Read the data from the DOM
        row._aData = _fnGetRowElements(settings, row, colIdx, colIdx === undefined ? undefined : row._aData).data;
      } else {
        // Reading from data object, update the DOM
        var cells = row.anCells;

        if (cells) {
          if (colIdx !== undefined) {
            cellWrite(cells[colIdx], colIdx);
          } else {
            for (i = 0, ien = cells.length; i < ien; i++) {
              cellWrite(cells[i], i);
            }
          }
        }
      } // For both row and cell invalidation, the cached data for sorting and
      // filtering is nulled out


      row._aSortData = null;
      row._aFilterData = null; // Invalidate the type for a specific column (if given) or all columns since
      // the data might have changed

      var cols = settings.aoColumns;

      if (colIdx !== undefined) {
        cols[colIdx].sType = null;
      } else {
        for (i = 0, ien = cols.length; i < ien; i++) {
          cols[i].sType = null;
        } // Update DataTables special `DT_*` attributes for the row


        _fnRowAttributes(row);
      }
    }
    /**
     * Build a data source object from an HTML row, reading the contents of the
     * cells that are in the row.
     *
     * @param {object} settings DataTables settings object
     * @param {node|object} TR element from which to read data or existing row
     *   object from which to re-read the data from the cells
     * @param {int} [colIdx] Optional column index
     * @param {array|object} [d] Data source object. If `colIdx` is given then this
     *   parameter should also be given and will be used to write the data into.
     *   Only the column in question will be written
     * @returns {object} Object with two parameters: `data` the data read, in
     *   document order, and `cells` and array of nodes (they can be useful to the
     *   caller, so rather than needing a second traversal to get them, just return
     *   them from here).
     * @memberof DataTable#oApi
     */


    function _fnGetRowElements(settings, row, colIdx, d) {
      var tds = [],
          td = row.firstChild,
          name,
          col,
          o,
          i = 0,
          contents,
          columns = settings.aoColumns,
          objectRead = settings._rowReadObject; // Allow the data object to be passed in, or construct

      d = d || objectRead ? {} : [];

      var attr = function attr(str, td) {
        if (typeof str === 'string') {
          var idx = str.indexOf('@');

          if (idx !== -1) {
            var attr = str.substring(idx + 1);

            var setter = _fnSetObjectDataFn(str);

            setter(d, td.getAttribute(attr));
          }
        }
      }; // Read data from a cell and store into the data object


      var cellProcess = function cellProcess(cell) {
        if (colIdx === undefined || colIdx === i) {
          col = columns[i];
          contents = $.trim(cell.innerHTML);

          if (col && col._bAttrSrc) {
            var setter = _fnSetObjectDataFn(col.mData._);

            setter(d, contents);
            attr(col.mData.sort, cell);
            attr(col.mData.type, cell);
            attr(col.mData.filter, cell);
          } else {
            // Depending on the `data` option for the columns the data can
            // be read to either an object or an array.
            if (objectRead) {
              if (!col._setter) {
                // Cache the setter function
                col._setter = _fnSetObjectDataFn(col.mData);
              }

              col._setter(d, contents);
            } else {
              d[i] = contents;
            }
          }
        }

        i++;
      };

      if (td) {
        // `tr` element was passed in
        while (td) {
          name = td.nodeName.toUpperCase();

          if (name == "TD" || name == "TH") {
            cellProcess(td);
            tds.push(td);
          }

          td = td.nextSibling;
        }
      } else {
        // Existing row object passed in
        tds = row.anCells;

        for (var j = 0, jen = tds.length; j < jen; j++) {
          cellProcess(tds[j]);
        }
      }

      return {
        data: d,
        cells: tds
      };
    }
    /**
     * Create a new TR element (and it's TD children) for a row
     *  @param {object} oSettings dataTables settings object
     *  @param {int} iRow Row to consider
     *  @param {node} [nTrIn] TR element to add to the table - optional. If not given,
     *    DataTables will create a row automatically
     *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
     *    if nTr is.
     *  @memberof DataTable#oApi
     */


    function _fnCreateTr(oSettings, iRow, nTrIn, anTds) {
      var row = oSettings.aoData[iRow],
          rowData = row._aData,
          cells = [],
          nTr,
          nTd,
          oCol,
          i,
          iLen;

      if (row.nTr === null) {
        nTr = nTrIn || document.createElement('tr');
        row.nTr = nTr;
        row.anCells = cells;
        /* Use a private property on the node to allow reserve mapping from the node
         * to the aoData array for fast look up
         */

        nTr._DT_RowIndex = iRow;
        /* Special parameters can be given by the data source to be used on the row */

        _fnRowAttributes(row);
        /* Process each column */


        for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
          oCol = oSettings.aoColumns[i];
          nTd = nTrIn ? anTds[i] : document.createElement(oCol.sCellType);
          cells.push(nTd); // Need to create the HTML if new, or if a rendering function is defined

          if (!nTrIn || oCol.mRender || oCol.mData !== i) {
            nTd.innerHTML = _fnGetCellData(oSettings, iRow, i, 'display');
          }
          /* Add user defined class */


          if (oCol.sClass) {
            nTd.className += ' ' + oCol.sClass;
          } // Visibility - add or remove as required


          if (oCol.bVisible && !nTrIn) {
            nTr.appendChild(nTd);
          } else if (!oCol.bVisible && nTrIn) {
            nTd.parentNode.removeChild(nTd);
          }

          if (oCol.fnCreatedCell) {
            oCol.fnCreatedCell.call(oSettings.oInstance, nTd, _fnGetCellData(oSettings, iRow, i), rowData, iRow, i);
          }
        }

        _fnCallbackFire(oSettings, 'aoRowCreatedCallback', null, [nTr, rowData, iRow]);
      } // Remove once webkit bug 131819 and Chromium bug 365619 have been resolved
      // and deployed


      row.nTr.setAttribute('role', 'row');
    }
    /**
     * Add attributes to a row based on the special `DT_*` parameters in a data
     * source object.
     *  @param {object} DataTables row object for the row to be modified
     *  @memberof DataTable#oApi
     */


    function _fnRowAttributes(row) {
      var tr = row.nTr;
      var data = row._aData;

      if (tr) {
        if (data.DT_RowId) {
          tr.id = data.DT_RowId;
        }

        if (data.DT_RowClass) {
          // Remove any classes added by DT_RowClass before
          var a = data.DT_RowClass.split(' ');
          row.__rowc = row.__rowc ? _unique(row.__rowc.concat(a)) : a;
          $(tr).removeClass(row.__rowc.join(' ')).addClass(data.DT_RowClass);
        }

        if (data.DT_RowAttr) {
          $(tr).attr(data.DT_RowAttr);
        }

        if (data.DT_RowData) {
          $(tr).data(data.DT_RowData);
        }
      }
    }
    /**
     * Create the HTML header for the table
     *  @param {object} oSettings dataTables settings object
     *  @memberof DataTable#oApi
     */


    function _fnBuildHead(oSettings) {
      var i, ien, cell, row, column;
      var thead = oSettings.nTHead;
      var tfoot = oSettings.nTFoot;
      var createHeader = $('th, td', thead).length === 0;
      var classes = oSettings.oClasses;
      var columns = oSettings.aoColumns;

      if (createHeader) {
        row = $('<tr/>').appendTo(thead);
      }

      for (i = 0, ien = columns.length; i < ien; i++) {
        column = columns[i];
        cell = $(column.nTh).addClass(column.sClass);

        if (createHeader) {
          cell.appendTo(row);
        } // 1.11 move into sorting


        if (oSettings.oFeatures.bSort) {
          cell.addClass(column.sSortingClass);

          if (column.bSortable !== false) {
            cell.attr('tabindex', oSettings.iTabIndex).attr('aria-controls', oSettings.sTableId);

            _fnSortAttachListener(oSettings, column.nTh, i);
          }
        }

        if (column.sTitle != cell.html()) {
          cell.html(column.sTitle);
        }

        _fnRenderer(oSettings, 'header')(oSettings, cell, column, classes);
      }

      if (createHeader) {
        _fnDetectHeader(oSettings.aoHeader, thead);
      }
      /* ARIA role for the rows */


      $(thead).find('>tr').attr('role', 'row');
      /* Deal with the footer - add classes if required */

      $(thead).find('>tr>th, >tr>td').addClass(classes.sHeaderTH);
      $(tfoot).find('>tr>th, >tr>td').addClass(classes.sFooterTH); // Cache the footer cells. Note that we only take the cells from the first
      // row in the footer. If there is more than one row the user wants to
      // interact with, they need to use the table().foot() method. Note also this
      // allows cells to be used for multiple columns using colspan

      if (tfoot !== null) {
        var cells = oSettings.aoFooter[0];

        for (i = 0, ien = cells.length; i < ien; i++) {
          column = columns[i];
          column.nTf = cells[i].cell;

          if (column.sClass) {
            $(column.nTf).addClass(column.sClass);
          }
        }
      }
    }
    /**
     * Draw the header (or footer) element based on the column visibility states. The
     * methodology here is to use the layout array from _fnDetectHeader, modified for
     * the instantaneous column visibility, to construct the new layout. The grid is
     * traversed over cell at a time in a rows x columns grid fashion, although each
     * cell insert can cover multiple elements in the grid - which is tracks using the
     * aApplied array. Cell inserts in the grid will only occur where there isn't
     * already a cell in that position.
     *  @param {object} oSettings dataTables settings object
     *  @param array {objects} aoSource Layout array from _fnDetectHeader
     *  @param {boolean} [bIncludeHidden=false] If true then include the hidden columns in the calc,
     *  @memberof DataTable#oApi
     */


    function _fnDrawHead(oSettings, aoSource, bIncludeHidden) {
      var i, iLen, j, jLen, k, kLen, n, nLocalTr;
      var aoLocal = [];
      var aApplied = [];
      var iColumns = oSettings.aoColumns.length;
      var iRowspan, iColspan;

      if (!aoSource) {
        return;
      }

      if (bIncludeHidden === undefined) {
        bIncludeHidden = false;
      }
      /* Make a copy of the master layout array, but without the visible columns in it */


      for (i = 0, iLen = aoSource.length; i < iLen; i++) {
        aoLocal[i] = aoSource[i].slice();
        aoLocal[i].nTr = aoSource[i].nTr;
        /* Remove any columns which are currently hidden */

        for (j = iColumns - 1; j >= 0; j--) {
          if (!oSettings.aoColumns[j].bVisible && !bIncludeHidden) {
            aoLocal[i].splice(j, 1);
          }
        }
        /* Prep the applied array - it needs an element for each row */


        aApplied.push([]);
      }

      for (i = 0, iLen = aoLocal.length; i < iLen; i++) {
        nLocalTr = aoLocal[i].nTr;
        /* All cells are going to be replaced, so empty out the row */

        if (nLocalTr) {
          while (n = nLocalTr.firstChild) {
            nLocalTr.removeChild(n);
          }
        }

        for (j = 0, jLen = aoLocal[i].length; j < jLen; j++) {
          iRowspan = 1;
          iColspan = 1;
          /* Check to see if there is already a cell (row/colspan) covering our target
           * insert point. If there is, then there is nothing to do.
           */

          if (aApplied[i][j] === undefined) {
            nLocalTr.appendChild(aoLocal[i][j].cell);
            aApplied[i][j] = 1;
            /* Expand the cell to cover as many rows as needed */

            while (aoLocal[i + iRowspan] !== undefined && aoLocal[i][j].cell == aoLocal[i + iRowspan][j].cell) {
              aApplied[i + iRowspan][j] = 1;
              iRowspan++;
            }
            /* Expand the cell to cover as many columns as needed */


            while (aoLocal[i][j + iColspan] !== undefined && aoLocal[i][j].cell == aoLocal[i][j + iColspan].cell) {
              /* Must update the applied array over the rows for the columns */
              for (k = 0; k < iRowspan; k++) {
                aApplied[i + k][j + iColspan] = 1;
              }

              iColspan++;
            }
            /* Do the actual expansion in the DOM */


            $(aoLocal[i][j].cell).attr('rowspan', iRowspan).attr('colspan', iColspan);
          }
        }
      }
    }
    /**
     * Insert the required TR nodes into the table for display
     *  @param {object} oSettings dataTables settings object
     *  @memberof DataTable#oApi
     */


    function _fnDraw(oSettings) {
      /* Provide a pre-callback function which can be used to cancel the draw is false is returned */
      var aPreDraw = _fnCallbackFire(oSettings, 'aoPreDrawCallback', 'preDraw', [oSettings]);

      if ($.inArray(false, aPreDraw) !== -1) {
        _fnProcessingDisplay(oSettings, false);

        return;
      }

      var i, iLen, n;
      var anRows = [];
      var iRowCount = 0;
      var asStripeClasses = oSettings.asStripeClasses;
      var iStripes = asStripeClasses.length;
      var iOpenRows = oSettings.aoOpenRows.length;
      var oLang = oSettings.oLanguage;
      var iInitDisplayStart = oSettings.iInitDisplayStart;
      var bServerSide = _fnDataSource(oSettings) == 'ssp';
      var aiDisplay = oSettings.aiDisplay;
      oSettings.bDrawing = true;
      /* Check and see if we have an initial draw position from state saving */

      if (iInitDisplayStart !== undefined && iInitDisplayStart !== -1) {
        oSettings._iDisplayStart = bServerSide ? iInitDisplayStart : iInitDisplayStart >= oSettings.fnRecordsDisplay() ? 0 : iInitDisplayStart;
        oSettings.iInitDisplayStart = -1;
      }

      var iDisplayStart = oSettings._iDisplayStart;
      var iDisplayEnd = oSettings.fnDisplayEnd();
      /* Server-side processing draw intercept */

      if (oSettings.bDeferLoading) {
        oSettings.bDeferLoading = false;
        oSettings.iDraw++;

        _fnProcessingDisplay(oSettings, false);
      } else if (!bServerSide) {
        oSettings.iDraw++;
      } else if (!oSettings.bDestroying && !_fnAjaxUpdate(oSettings)) {
        return;
      }

      if (aiDisplay.length !== 0) {
        var iStart = bServerSide ? 0 : iDisplayStart;
        var iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd;

        for (var j = iStart; j < iEnd; j++) {
          var iDataIndex = aiDisplay[j];
          var aoData = oSettings.aoData[iDataIndex];

          if (aoData.nTr === null) {
            _fnCreateTr(oSettings, iDataIndex);
          }

          var nRow = aoData.nTr;
          /* Remove the old striping classes and then add the new one */

          if (iStripes !== 0) {
            var sStripe = asStripeClasses[iRowCount % iStripes];

            if (aoData._sRowStripe != sStripe) {
              $(nRow).removeClass(aoData._sRowStripe).addClass(sStripe);
              aoData._sRowStripe = sStripe;
            }
          } // Row callback functions - might want to manipulate the row
          // iRowCount and j are not currently documented. Are they at all
          // useful?


          _fnCallbackFire(oSettings, 'aoRowCallback', null, [nRow, aoData._aData, iRowCount, j]);

          anRows.push(nRow);
          iRowCount++;
        }
      } else {
        /* Table is empty - create a row with an empty message in it */
        var sZero = oLang.sZeroRecords;

        if (oSettings.iDraw == 1 && _fnDataSource(oSettings) == 'ajax') {
          sZero = oLang.sLoadingRecords;
        } else if (oLang.sEmptyTable && oSettings.fnRecordsTotal() === 0) {
          sZero = oLang.sEmptyTable;
        }

        anRows[0] = $('<tr/>', {
          'class': iStripes ? asStripeClasses[0] : ''
        }).append($('<td />', {
          'valign': 'top',
          'colSpan': _fnVisbleColumns(oSettings),
          'class': oSettings.oClasses.sRowEmpty
        }).html(sZero))[0];
      }
      /* Header and footer callbacks */


      _fnCallbackFire(oSettings, 'aoHeaderCallback', 'header', [$(oSettings.nTHead).children('tr')[0], _fnGetDataMaster(oSettings), iDisplayStart, iDisplayEnd, aiDisplay]);

      _fnCallbackFire(oSettings, 'aoFooterCallback', 'footer', [$(oSettings.nTFoot).children('tr')[0], _fnGetDataMaster(oSettings), iDisplayStart, iDisplayEnd, aiDisplay]);

      var body = $(oSettings.nTBody);
      body.children().detach();
      body.append($(anRows));
      /* Call all required callback functions for the end of a draw */

      _fnCallbackFire(oSettings, 'aoDrawCallback', 'draw', [oSettings]);
      /* Draw is complete, sorting and filtering must be as well */


      oSettings.bSorted = false;
      oSettings.bFiltered = false;
      oSettings.bDrawing = false;
    }
    /**
     * Redraw the table - taking account of the various features which are enabled
     *  @param {object} oSettings dataTables settings object
     *  @param {boolean} [holdPosition] Keep the current paging position. By default
     *    the paging is reset to the first page
     *  @memberof DataTable#oApi
     */


    function _fnReDraw(settings, holdPosition) {
      var features = settings.oFeatures,
          sort = features.bSort,
          filter = features.bFilter;

      if (sort) {
        _fnSort(settings);
      }

      if (filter) {
        _fnFilterComplete(settings, settings.oPreviousSearch);
      } else {
        // No filtering, so we want to just use the display master
        settings.aiDisplay = settings.aiDisplayMaster.slice();
      }

      if (holdPosition !== true) {
        settings._iDisplayStart = 0;
      } // Let any modules know about the draw hold position state (used by
      // scrolling internally)


      settings._drawHold = holdPosition;

      _fnDraw(settings);

      settings._drawHold = false;
    }
    /**
     * Add the options to the page HTML for the table
     *  @param {object} oSettings dataTables settings object
     *  @memberof DataTable#oApi
     */


    function _fnAddOptionsHtml(oSettings) {
      var classes = oSettings.oClasses;
      var table = $(oSettings.nTable);
      var holding = $('<div/>').insertBefore(table); // Holding element for speed

      var features = oSettings.oFeatures; // All DataTables are wrapped in a div

      var insert = $('<div/>', {
        id: oSettings.sTableId + '_wrapper',
        'class': classes.sWrapper + (oSettings.nTFoot ? '' : ' ' + classes.sNoFooter)
      });
      oSettings.nHolding = holding[0];
      oSettings.nTableWrapper = insert[0];
      oSettings.nTableReinsertBefore = oSettings.nTable.nextSibling;
      /* Loop over the user set positioning and place the elements as needed */

      var aDom = oSettings.sDom.split('');
      var featureNode, cOption, nNewNode, cNext, sAttr, j;

      for (var i = 0; i < aDom.length; i++) {
        featureNode = null;
        cOption = aDom[i];

        if (cOption == '<') {
          /* New container div */
          nNewNode = $('<div/>')[0];
          /* Check to see if we should append an id and/or a class name to the container */

          cNext = aDom[i + 1];

          if (cNext == "'" || cNext == '"') {
            sAttr = "";
            j = 2;

            while (aDom[i + j] != cNext) {
              sAttr += aDom[i + j];
              j++;
            }
            /* Replace jQuery UI constants @todo depreciated */


            if (sAttr == "H") {
              sAttr = classes.sJUIHeader;
            } else if (sAttr == "F") {
              sAttr = classes.sJUIFooter;
            }
            /* The attribute can be in the format of "#id.class", "#id" or "class" This logic
             * breaks the string into parts and applies them as needed
             */


            if (sAttr.indexOf('.') != -1) {
              var aSplit = sAttr.split('.');
              nNewNode.id = aSplit[0].substr(1, aSplit[0].length - 1);
              nNewNode.className = aSplit[1];
            } else if (sAttr.charAt(0) == "#") {
              nNewNode.id = sAttr.substr(1, sAttr.length - 1);
            } else {
              nNewNode.className = sAttr;
            }

            i += j;
            /* Move along the position array */
          }

          insert.append(nNewNode);
          insert = $(nNewNode);
        } else if (cOption == '>') {
          /* End container div */
          insert = insert.parent();
        } // @todo Move options into their own plugins?
        else if (cOption == 'l' && features.bPaginate && features.bLengthChange) {
            /* Length */
            featureNode = _fnFeatureHtmlLength(oSettings);
          } else if (cOption == 'f' && features.bFilter) {
            /* Filter */
            featureNode = _fnFeatureHtmlFilter(oSettings);
          } else if (cOption == 'r' && features.bProcessing) {
            /* pRocessing */
            featureNode = _fnFeatureHtmlProcessing(oSettings);
          } else if (cOption == 't') {
            /* Table */
            featureNode = _fnFeatureHtmlTable(oSettings);
          } else if (cOption == 'i' && features.bInfo) {
            /* Info */
            featureNode = _fnFeatureHtmlInfo(oSettings);
          } else if (cOption == 'p' && features.bPaginate) {
            /* Pagination */
            featureNode = _fnFeatureHtmlPaginate(oSettings);
          } else if (_DataTable.ext.feature.length !== 0) {
            /* Plug-in features */
            var aoFeatures = _DataTable.ext.feature;

            for (var k = 0, kLen = aoFeatures.length; k < kLen; k++) {
              if (cOption == aoFeatures[k].cFeature) {
                featureNode = aoFeatures[k].fnInit(oSettings);
                break;
              }
            }
          }
        /* Add to the 2D features array */


        if (featureNode) {
          var aanFeatures = oSettings.aanFeatures;

          if (!aanFeatures[cOption]) {
            aanFeatures[cOption] = [];
          }

          aanFeatures[cOption].push(featureNode);
          insert.append(featureNode);
        }
      }
      /* Built our DOM structure - replace the holding div with what we want */


      holding.replaceWith(insert);
    }
    /**
     * Use the DOM source to create up an array of header cells. The idea here is to
     * create a layout grid (array) of rows x columns, which contains a reference
     * to the cell that that point in the grid (regardless of col/rowspan), such that
     * any column / row could be removed and the new grid constructed
     *  @param array {object} aLayout Array to store the calculated layout in
     *  @param {node} nThead The header/footer element for the table
     *  @memberof DataTable#oApi
     */


    function _fnDetectHeader(aLayout, nThead) {
      var nTrs = $(nThead).children('tr');
      var nTr, nCell;
      var i, k, l, iLen, jLen, iColShifted, iColumn, iColspan, iRowspan;
      var bUnique;

      var fnShiftCol = function fnShiftCol(a, i, j) {
        var k = a[i];

        while (k[j]) {
          j++;
        }

        return j;
      };

      aLayout.splice(0, aLayout.length);
      /* We know how many rows there are in the layout - so prep it */

      for (i = 0, iLen = nTrs.length; i < iLen; i++) {
        aLayout.push([]);
      }
      /* Calculate a layout array */


      for (i = 0, iLen = nTrs.length; i < iLen; i++) {
        nTr = nTrs[i];
        iColumn = 0;
        /* For every cell in the row... */

        nCell = nTr.firstChild;

        while (nCell) {
          if (nCell.nodeName.toUpperCase() == "TD" || nCell.nodeName.toUpperCase() == "TH") {
            /* Get the col and rowspan attributes from the DOM and sanitise them */
            iColspan = nCell.getAttribute('colspan') * 1;
            iRowspan = nCell.getAttribute('rowspan') * 1;
            iColspan = !iColspan || iColspan === 0 || iColspan === 1 ? 1 : iColspan;
            iRowspan = !iRowspan || iRowspan === 0 || iRowspan === 1 ? 1 : iRowspan;
            /* There might be colspan cells already in this row, so shift our target
             * accordingly
             */

            iColShifted = fnShiftCol(aLayout, i, iColumn);
            /* Cache calculation for unique columns */

            bUnique = iColspan === 1 ? true : false;
            /* If there is col / rowspan, copy the information into the layout grid */

            for (l = 0; l < iColspan; l++) {
              for (k = 0; k < iRowspan; k++) {
                aLayout[i + k][iColShifted + l] = {
                  "cell": nCell,
                  "unique": bUnique
                };
                aLayout[i + k].nTr = nTr;
              }
            }
          }

          nCell = nCell.nextSibling;
        }
      }
    }
    /**
     * Get an array of unique th elements, one for each column
     *  @param {object} oSettings dataTables settings object
     *  @param {node} nHeader automatically detect the layout from this node - optional
     *  @param {array} aLayout thead/tfoot layout from _fnDetectHeader - optional
     *  @returns array {node} aReturn list of unique th's
     *  @memberof DataTable#oApi
     */


    function _fnGetUniqueThs(oSettings, nHeader, aLayout) {
      var aReturn = [];

      if (!aLayout) {
        aLayout = oSettings.aoHeader;

        if (nHeader) {
          aLayout = [];

          _fnDetectHeader(aLayout, nHeader);
        }
      }

      for (var i = 0, iLen = aLayout.length; i < iLen; i++) {
        for (var j = 0, jLen = aLayout[i].length; j < jLen; j++) {
          if (aLayout[i][j].unique && (!aReturn[j] || !oSettings.bSortCellsTop)) {
            aReturn[j] = aLayout[i][j].cell;
          }
        }
      }

      return aReturn;
    }
    /**
     * Create an Ajax call based on the table's settings, taking into account that
     * parameters can have multiple forms, and backwards compatibility.
     *
     * @param {object} oSettings dataTables settings object
     * @param {array} data Data to send to the server, required by
     *     DataTables - may be augmented by developer callbacks
     * @param {function} fn Callback function to run when data is obtained
     */


    function _fnBuildAjax(oSettings, data, fn) {
      // Compatibility with 1.9-, allow fnServerData and event to manipulate
      _fnCallbackFire(oSettings, 'aoServerParams', 'serverParams', [data]); // Convert to object based for 1.10+ if using the old array scheme which can
      // come from server-side processing or serverParams


      if (data && $.isArray(data)) {
        var tmp = {};
        var rbracket = /(.*?)\[\]$/;
        $.each(data, function (key, val) {
          var match = val.name.match(rbracket);

          if (match) {
            // Support for arrays
            var name = match[0];

            if (!tmp[name]) {
              tmp[name] = [];
            }

            tmp[name].push(val.value);
          } else {
            tmp[val.name] = val.value;
          }
        });
        data = tmp;
      }

      var ajaxData;
      var ajax = oSettings.ajax;
      var instance = oSettings.oInstance;

      var callback = function callback(json) {
        _fnCallbackFire(oSettings, null, 'xhr', [oSettings, json, oSettings.jqXHR]);

        fn(json);
      };

      if ($.isPlainObject(ajax) && ajax.data) {
        ajaxData = ajax.data;
        var newData = $.isFunction(ajaxData) ? ajaxData(data, oSettings) : // fn can manipulate data or return
        ajaxData; // an object object or array to merge
        // If the function returned something, use that alone

        data = $.isFunction(ajaxData) && newData ? newData : $.extend(true, data, newData); // Remove the data property as we've resolved it already and don't want
        // jQuery to do it again (it is restored at the end of the function)

        delete ajax.data;
      }

      var baseAjax = {
        "data": data,
        "success": function success(json) {
          var error = json.error || json.sError;

          if (error) {
            _fnLog(oSettings, 0, error);
          }

          oSettings.json = json;
          callback(json);
        },
        "dataType": "json",
        "cache": false,
        "type": oSettings.sServerMethod,
        "error": function error(xhr, _error, thrown) {
          var ret = _fnCallbackFire(oSettings, null, 'xhr', [oSettings, null, oSettings.jqXHR]);

          if ($.inArray(true, ret) === -1) {
            if (_error == "parsererror") {
              _fnLog(oSettings, 0, 'Invalid JSON response', 1);
            } else if (xhr.readyState === 4) {
              _fnLog(oSettings, 0, 'Ajax error', 7);
            }
          }

          _fnProcessingDisplay(oSettings, false);
        }
      }; // Store the data submitted for the API

      oSettings.oAjaxData = data; // Allow plug-ins and external processes to modify the data

      _fnCallbackFire(oSettings, null, 'preXhr', [oSettings, data]);

      if (oSettings.fnServerData) {
        // DataTables 1.9- compatibility
        oSettings.fnServerData.call(instance, oSettings.sAjaxSource, $.map(data, function (val, key) {
          // Need to convert back to 1.9 trad format
          return {
            name: key,
            value: val
          };
        }), callback, oSettings);
      } else if (oSettings.sAjaxSource || typeof ajax === 'string') {
        // DataTables 1.9- compatibility
        oSettings.jqXHR = $.ajax($.extend(baseAjax, {
          url: ajax || oSettings.sAjaxSource
        }));
      } else if ($.isFunction(ajax)) {
        // Is a function - let the caller define what needs to be done
        oSettings.jqXHR = ajax.call(instance, data, callback, oSettings);
      } else {
        // Object to extend the base settings
        oSettings.jqXHR = $.ajax($.extend(baseAjax, ajax)); // Restore for next time around

        ajax.data = ajaxData;
      }
    }
    /**
     * Update the table using an Ajax call
     *  @param {object} settings dataTables settings object
     *  @returns {boolean} Block the table drawing or not
     *  @memberof DataTable#oApi
     */


    function _fnAjaxUpdate(settings) {
      if (settings.bAjaxDataGet) {
        settings.iDraw++;

        _fnProcessingDisplay(settings, true);

        _fnBuildAjax(settings, _fnAjaxParameters(settings), function (json) {
          _fnAjaxUpdateDraw(settings, json);
        });

        return false;
      }

      return true;
    }
    /**
     * Build up the parameters in an object needed for a server-side processing
     * request. Note that this is basically done twice, is different ways - a modern
     * method which is used by default in DataTables 1.10 which uses objects and
     * arrays, or the 1.9- method with is name / value pairs. 1.9 method is used if
     * the sAjaxSource option is used in the initialisation, or the legacyAjax
     * option is set.
     *  @param {object} oSettings dataTables settings object
     *  @returns {bool} block the table drawing or not
     *  @memberof DataTable#oApi
     */


    function _fnAjaxParameters(settings) {
      var columns = settings.aoColumns,
          columnCount = columns.length,
          features = settings.oFeatures,
          preSearch = settings.oPreviousSearch,
          preColSearch = settings.aoPreSearchCols,
          i,
          data = [],
          dataProp,
          column,
          columnSearch,
          sort = _fnSortFlatten(settings),
          displayStart = settings._iDisplayStart,
          displayLength = features.bPaginate !== false ? settings._iDisplayLength : -1;

      var param = function param(name, value) {
        data.push({
          'name': name,
          'value': value
        });
      }; // DataTables 1.9- compatible method


      param('sEcho', settings.iDraw);
      param('iColumns', columnCount);
      param('sColumns', _pluck(columns, 'sName').join(','));
      param('iDisplayStart', displayStart);
      param('iDisplayLength', displayLength); // DataTables 1.10+ method

      var d = {
        draw: settings.iDraw,
        columns: [],
        order: [],
        start: displayStart,
        length: displayLength,
        search: {
          value: preSearch.sSearch,
          regex: preSearch.bRegex
        }
      };

      for (i = 0; i < columnCount; i++) {
        column = columns[i];
        columnSearch = preColSearch[i];
        dataProp = typeof column.mData == "function" ? 'function' : column.mData;
        d.columns.push({
          data: dataProp,
          name: column.sName,
          searchable: column.bSearchable,
          orderable: column.bSortable,
          search: {
            value: columnSearch.sSearch,
            regex: columnSearch.bRegex
          }
        });
        param("mDataProp_" + i, dataProp);

        if (features.bFilter) {
          param('sSearch_' + i, columnSearch.sSearch);
          param('bRegex_' + i, columnSearch.bRegex);
          param('bSearchable_' + i, column.bSearchable);
        }

        if (features.bSort) {
          param('bSortable_' + i, column.bSortable);
        }
      }

      if (features.bFilter) {
        param('sSearch', preSearch.sSearch);
        param('bRegex', preSearch.bRegex);
      }

      if (features.bSort) {
        $.each(sort, function (i, val) {
          d.order.push({
            column: val.col,
            dir: val.dir
          });
          param('iSortCol_' + i, val.col);
          param('sSortDir_' + i, val.dir);
        });
        param('iSortingCols', sort.length);
      } // If the legacy.ajax parameter is null, then we automatically decide which
      // form to use, based on sAjaxSource


      var legacy = _DataTable.ext.legacy.ajax;

      if (legacy === null) {
        return settings.sAjaxSource ? data : d;
      } // Otherwise, if legacy has been specified then we use that to decide on the
      // form


      return legacy ? data : d;
    }
    /**
     * Data the data from the server (nuking the old) and redraw the table
     *  @param {object} oSettings dataTables settings object
     *  @param {object} json json data return from the server.
     *  @param {string} json.sEcho Tracking flag for DataTables to match requests
     *  @param {int} json.iTotalRecords Number of records in the data set, not accounting for filtering
     *  @param {int} json.iTotalDisplayRecords Number of records in the data set, accounting for filtering
     *  @param {array} json.aaData The data to display on this page
     *  @param {string} [json.sColumns] Column ordering (sName, comma separated)
     *  @memberof DataTable#oApi
     */


    function _fnAjaxUpdateDraw(settings, json) {
      // v1.10 uses camelCase variables, while 1.9 uses Hungarian notation.
      // Support both
      var compat = function compat(old, modern) {
        return json[old] !== undefined ? json[old] : json[modern];
      };

      var data = _fnAjaxDataSrc(settings, json);

      var draw = compat('sEcho', 'draw');
      var recordsTotal = compat('iTotalRecords', 'recordsTotal');
      var recordsFiltered = compat('iTotalDisplayRecords', 'recordsFiltered');

      if (draw) {
        // Protect against out of sequence returns
        if (draw * 1 < settings.iDraw) {
          return;
        }

        settings.iDraw = draw * 1;
      }

      _fnClearTable(settings);

      settings._iRecordsTotal = parseInt(recordsTotal, 10);
      settings._iRecordsDisplay = parseInt(recordsFiltered, 10);

      for (var i = 0, ien = data.length; i < ien; i++) {
        _fnAddData(settings, data[i]);
      }

      settings.aiDisplay = settings.aiDisplayMaster.slice();
      settings.bAjaxDataGet = false;

      _fnDraw(settings);

      if (!settings._bInitComplete) {
        _fnInitComplete(settings, json);
      }

      settings.bAjaxDataGet = true;

      _fnProcessingDisplay(settings, false);
    }
    /**
     * Get the data from the JSON data source to use for drawing a table. Using
     * `_fnGetObjectDataFn` allows the data to be sourced from a property of the
     * source object, or from a processing function.
     *  @param {object} oSettings dataTables settings object
     *  @param  {object} json Data source object / array from the server
     *  @return {array} Array of data to use
     */


    function _fnAjaxDataSrc(oSettings, json) {
      var dataSrc = $.isPlainObject(oSettings.ajax) && oSettings.ajax.dataSrc !== undefined ? oSettings.ajax.dataSrc : oSettings.sAjaxDataProp; // Compatibility with 1.9-.
      // Compatibility with 1.9-. In order to read from aaData, check if the
      // default has been changed, if not, check for aaData

      if (dataSrc === 'data') {
        return json.aaData || json[dataSrc];
      }

      return dataSrc !== "" ? _fnGetObjectDataFn(dataSrc)(json) : json;
    }
    /**
     * Generate the node required for filtering text
     *  @returns {node} Filter control element
     *  @param {object} oSettings dataTables settings object
     *  @memberof DataTable#oApi
     */


    function _fnFeatureHtmlFilter(settings) {
      var classes = settings.oClasses;
      var tableId = settings.sTableId;
      var language = settings.oLanguage;
      var previousSearch = settings.oPreviousSearch;
      var features = settings.aanFeatures;
      var input = '<input type="search" class="' + classes.sFilterInput + '"/>';
      var str = language.sSearch;
      str = str.match(/_INPUT_/) ? str.replace('_INPUT_', input) : str + input;
      var filter = $('<div/>', {
        'id': !features.f ? tableId + '_filter' : null,
        'class': classes.sFilter
      }).append($('<label/>').append(str));

      var searchFn = function searchFn() {
        /* Update all other filter input elements for the new display */
        var n = features.f;
        var val = !this.value ? "" : this.value; // mental IE8 fix :-(

        /* Now do the filter */

        if (val != previousSearch.sSearch) {
          _fnFilterComplete(settings, {
            "sSearch": val,
            "bRegex": previousSearch.bRegex,
            "bSmart": previousSearch.bSmart,
            "bCaseInsensitive": previousSearch.bCaseInsensitive
          }); // Need to redraw, without resorting


          settings._iDisplayStart = 0;

          _fnDraw(settings);
        }
      };

      var searchDelay = settings.searchDelay !== null ? settings.searchDelay : _fnDataSource(settings) === 'ssp' ? 400 : 0;
      var jqFilter = $('input', filter).val(previousSearch.sSearch).attr('placeholder', language.sSearchPlaceholder).bind('keyup.DT search.DT input.DT paste.DT cut.DT', searchDelay ? _fnThrottle(searchFn, searchDelay) : searchFn).bind('keypress.DT', function (e) {
        /* Prevent form submission */
        if (e.keyCode == 13) {
          return false;
        }
      }).attr('aria-controls', tableId); // Update the input elements whenever the table is filtered

      $(settings.nTable).on('search.dt.DT', function (ev, s) {
        if (settings === s) {
          // IE9 throws an 'unknown error' if document.activeElement is used
          // inside an iframe or frame...
          try {
            if (jqFilter[0] !== document.activeElement) {
              jqFilter.val(previousSearch.sSearch);
            }
          } catch (e) {}
        }
      });
      return filter[0];
    }
    /**
     * Filter the table using both the global filter and column based filtering
     *  @param {object} oSettings dataTables settings object
     *  @param {object} oSearch search information
     *  @param {int} [iForce] force a research of the master array (1) or not (undefined or 0)
     *  @memberof DataTable#oApi
     */


    function _fnFilterComplete(oSettings, oInput, iForce) {
      var oPrevSearch = oSettings.oPreviousSearch;
      var aoPrevSearch = oSettings.aoPreSearchCols;

      var fnSaveFilter = function fnSaveFilter(oFilter) {
        /* Save the filtering values */
        oPrevSearch.sSearch = oFilter.sSearch;
        oPrevSearch.bRegex = oFilter.bRegex;
        oPrevSearch.bSmart = oFilter.bSmart;
        oPrevSearch.bCaseInsensitive = oFilter.bCaseInsensitive;
      };

      var fnRegex = function fnRegex(o) {
        // Backwards compatibility with the bEscapeRegex option
        return o.bEscapeRegex !== undefined ? !o.bEscapeRegex : o.bRegex;
      }; // Resolve any column types that are unknown due to addition or invalidation
      // @todo As per sort - can this be moved into an event handler?


      _fnColumnTypes(oSettings);
      /* In server-side processing all filtering is done by the server, so no point hanging around here */


      if (_fnDataSource(oSettings) != 'ssp') {
        /* Global filter */
        _fnFilter(oSettings, oInput.sSearch, iForce, fnRegex(oInput), oInput.bSmart, oInput.bCaseInsensitive);

        fnSaveFilter(oInput);
        /* Now do the individual column filter */

        for (var i = 0; i < aoPrevSearch.length; i++) {
          _fnFilterColumn(oSettings, aoPrevSearch[i].sSearch, i, fnRegex(aoPrevSearch[i]), aoPrevSearch[i].bSmart, aoPrevSearch[i].bCaseInsensitive);
        }
        /* Custom filtering */


        _fnFilterCustom(oSettings);
      } else {
        fnSaveFilter(oInput);
      }
      /* Tell the draw function we have been filtering */


      oSettings.bFiltered = true;

      _fnCallbackFire(oSettings, null, 'search', [oSettings]);
    }
    /**
     * Apply custom filtering functions
     *  @param {object} oSettings dataTables settings object
     *  @memberof DataTable#oApi
     */


    function _fnFilterCustom(settings) {
      var filters = _DataTable.ext.search;
      var displayRows = settings.aiDisplay;
      var row, rowIdx;

      for (var i = 0, ien = filters.length; i < ien; i++) {
        var rows = []; // Loop over each row and see if it should be included

        for (var j = 0, jen = displayRows.length; j < jen; j++) {
          rowIdx = displayRows[j];
          row = settings.aoData[rowIdx];

          if (filters[i](settings, row._aFilterData, rowIdx, row._aData, j)) {
            rows.push(rowIdx);
          }
        } // So the array reference doesn't break set the results into the
        // existing array


        displayRows.length = 0;
        displayRows.push.apply(displayRows, rows);
      }
    }
    /**
     * Filter the table on a per-column basis
     *  @param {object} oSettings dataTables settings object
     *  @param {string} sInput string to filter on
     *  @param {int} iColumn column to filter
     *  @param {bool} bRegex treat search string as a regular expression or not
     *  @param {bool} bSmart use smart filtering or not
     *  @param {bool} bCaseInsensitive Do case insenstive matching or not
     *  @memberof DataTable#oApi
     */


    function _fnFilterColumn(settings, searchStr, colIdx, regex, smart, caseInsensitive) {
      if (searchStr === '') {
        return;
      }

      var data;
      var display = settings.aiDisplay;

      var rpSearch = _fnFilterCreateSearch(searchStr, regex, smart, caseInsensitive);

      for (var i = display.length - 1; i >= 0; i--) {
        data = settings.aoData[display[i]]._aFilterData[colIdx];

        if (!rpSearch.test(data)) {
          display.splice(i, 1);
        }
      }
    }
    /**
     * Filter the data table based on user input and draw the table
     *  @param {object} settings dataTables settings object
     *  @param {string} input string to filter on
     *  @param {int} force optional - force a research of the master array (1) or not (undefined or 0)
     *  @param {bool} regex treat as a regular expression or not
     *  @param {bool} smart perform smart filtering or not
     *  @param {bool} caseInsensitive Do case insenstive matching or not
     *  @memberof DataTable#oApi
     */


    function _fnFilter(settings, input, force, regex, smart, caseInsensitive) {
      var rpSearch = _fnFilterCreateSearch(input, regex, smart, caseInsensitive);

      var prevSearch = settings.oPreviousSearch.sSearch;
      var displayMaster = settings.aiDisplayMaster;
      var display, invalidated, i; // Need to take account of custom filtering functions - always filter

      if (_DataTable.ext.search.length !== 0) {
        force = true;
      } // Check if any of the rows were invalidated


      invalidated = _fnFilterData(settings); // If the input is blank - we just want the full data set

      if (input.length <= 0) {
        settings.aiDisplay = displayMaster.slice();
      } else {
        // New search - start from the master array
        if (invalidated || force || prevSearch.length > input.length || input.indexOf(prevSearch) !== 0 || settings.bSorted // On resort, the display master needs to be
        // re-filtered since indexes will have changed
        ) {
            settings.aiDisplay = displayMaster.slice();
          } // Search the display array


        display = settings.aiDisplay;

        for (i = display.length - 1; i >= 0; i--) {
          if (!rpSearch.test(settings.aoData[display[i]]._sFilterRow)) {
            display.splice(i, 1);
          }
        }
      }
    }
    /**
     * Build a regular expression object suitable for searching a table
     *  @param {string} sSearch string to search for
     *  @param {bool} bRegex treat as a regular expression or not
     *  @param {bool} bSmart perform smart filtering or not
     *  @param {bool} bCaseInsensitive Do case insensitive matching or not
     *  @returns {RegExp} constructed object
     *  @memberof DataTable#oApi
     */


    function _fnFilterCreateSearch(search, regex, smart, caseInsensitive) {
      search = regex ? search : _fnEscapeRegex(search);

      if (smart) {
        /* For smart filtering we want to allow the search to work regardless of
         * word order. We also want double quoted text to be preserved, so word
         * order is important - a la google. So this is what we want to
         * generate:
         * 
         * ^(?=.*?\bone\b)(?=.*?\btwo three\b)(?=.*?\bfour\b).*$
         */
        var a = $.map(search.match(/"[^"]+"|[^ ]+/g) || [''], function (word) {
          if (word.charAt(0) === '"') {
            var m = word.match(/^"(.*)"$/);
            word = m ? m[1] : word;
          }

          return word.replace('"', '');
        });
        search = '^(?=.*?' + a.join(')(?=.*?') + ').*$';
      }

      return new RegExp(search, caseInsensitive ? 'i' : '');
    }
    /**
     * Escape a string such that it can be used in a regular expression
     *  @param {string} sVal string to escape
     *  @returns {string} escaped string
     *  @memberof DataTable#oApi
     */


    function _fnEscapeRegex(sVal) {
      return sVal.replace(_re_escape_regex, '\\$1');
    }

    var __filter_div = $('<div>')[0];

    var __filter_div_textContent = __filter_div.textContent !== undefined; // Update the filtering data for each row if needed (by invalidation or first run)


    function _fnFilterData(settings) {
      var columns = settings.aoColumns;
      var column;
      var i, j, ien, jen, filterData, cellData, row;
      var fomatters = _DataTable.ext.type.search;
      var wasInvalidated = false;

      for (i = 0, ien = settings.aoData.length; i < ien; i++) {
        row = settings.aoData[i];

        if (!row._aFilterData) {
          filterData = [];

          for (j = 0, jen = columns.length; j < jen; j++) {
            column = columns[j];

            if (column.bSearchable) {
              cellData = _fnGetCellData(settings, i, j, 'filter');

              if (fomatters[column.sType]) {
                cellData = fomatters[column.sType](cellData);
              } // Search in DataTables 1.10 is string based. In 1.11 this
              // should be altered to also allow strict type checking.


              if (cellData === null) {
                cellData = '';
              }

              if (typeof cellData !== 'string' && cellData.toString) {
                cellData = cellData.toString();
              }
            } else {
              cellData = '';
            } // If it looks like there is an HTML entity in the string,
            // attempt to decode it so sorting works as expected. Note that
            // we could use a single line of jQuery to do this, but the DOM
            // method used here is much faster http://jsperf.com/html-decode


            if (cellData.indexOf && cellData.indexOf('&') !== -1) {
              __filter_div.innerHTML = cellData;
              cellData = __filter_div_textContent ? __filter_div.textContent : __filter_div.innerText;
            }

            if (cellData.replace) {
              cellData = cellData.replace(/[\r\n]/g, '');
            }

            filterData.push(cellData);
          }

          row._aFilterData = filterData;
          row._sFilterRow = filterData.join('  ');
          wasInvalidated = true;
        }
      }

      return wasInvalidated;
    }
    /**
     * Convert from the internal Hungarian notation to camelCase for external
     * interaction
     *  @param {object} obj Object to convert
     *  @returns {object} Inverted object
     *  @memberof DataTable#oApi
     */


    function _fnSearchToCamel(obj) {
      return {
        search: obj.sSearch,
        smart: obj.bSmart,
        regex: obj.bRegex,
        caseInsensitive: obj.bCaseInsensitive
      };
    }
    /**
     * Convert from camelCase notation to the internal Hungarian. We could use the
     * Hungarian convert function here, but this is cleaner
     *  @param {object} obj Object to convert
     *  @returns {object} Inverted object
     *  @memberof DataTable#oApi
     */


    function _fnSearchToHung(obj) {
      return {
        sSearch: obj.search,
        bSmart: obj.smart,
        bRegex: obj.regex,
        bCaseInsensitive: obj.caseInsensitive
      };
    }
    /**
     * Generate the node required for the info display
     *  @param {object} oSettings dataTables settings object
     *  @returns {node} Information element
     *  @memberof DataTable#oApi
     */


    function _fnFeatureHtmlInfo(settings) {
      var tid = settings.sTableId,
          nodes = settings.aanFeatures.i,
          n = $('<div/>', {
        'class': settings.oClasses.sInfo,
        'id': !nodes ? tid + '_info' : null
      });

      if (!nodes) {
        // Update display on each draw
        settings.aoDrawCallback.push({
          "fn": _fnUpdateInfo,
          "sName": "information"
        });
        n.attr('role', 'status').attr('aria-live', 'polite'); // Table is described by our info div

        $(settings.nTable).attr('aria-describedby', tid + '_info');
      }

      return n[0];
    }
    /**
     * Update the information elements in the display
     *  @param {object} settings dataTables settings object
     *  @memberof DataTable#oApi
     */


    function _fnUpdateInfo(settings) {
      /* Show information about the table */
      var nodes = settings.aanFeatures.i;

      if (nodes.length === 0) {
        return;
      }

      var lang = settings.oLanguage,
          start = settings._iDisplayStart + 1,
          end = settings.fnDisplayEnd(),
          max = settings.fnRecordsTotal(),
          total = settings.fnRecordsDisplay(),
          out = total ? lang.sInfo : lang.sInfoEmpty;

      if (total !== max) {
        /* Record set after filtering */
        out += ' ' + lang.sInfoFiltered;
      } // Convert the macros


      out += lang.sInfoPostFix;
      out = _fnInfoMacros(settings, out);
      var callback = lang.fnInfoCallback;

      if (callback !== null) {
        out = callback.call(settings.oInstance, settings, start, end, max, total, out);
      }

      $(nodes).html(out);
    }

    function _fnInfoMacros(settings, str) {
      // When infinite scrolling, we are always starting at 1. _iDisplayStart is used only
      // internally
      var formatter = settings.fnFormatNumber,
          start = settings._iDisplayStart + 1,
          len = settings._iDisplayLength,
          vis = settings.fnRecordsDisplay(),
          all = len === -1;
      return str.replace(/_START_/g, formatter.call(settings, start)).replace(/_END_/g, formatter.call(settings, settings.fnDisplayEnd())).replace(/_MAX_/g, formatter.call(settings, settings.fnRecordsTotal())).replace(/_TOTAL_/g, formatter.call(settings, vis)).replace(/_PAGE_/g, formatter.call(settings, all ? 1 : Math.ceil(start / len))).replace(/_PAGES_/g, formatter.call(settings, all ? 1 : Math.ceil(vis / len)));
    }
    /**
     * Draw the table for the first time, adding all required features
     *  @param {object} settings dataTables settings object
     *  @memberof DataTable#oApi
     */


    function _fnInitialise(settings) {
      var i,
          iLen,
          iAjaxStart = settings.iInitDisplayStart;
      var columns = settings.aoColumns,
          column;
      var features = settings.oFeatures;
      /* Ensure that the table data is fully initialised */

      if (!settings.bInitialised) {
        setTimeout(function () {
          _fnInitialise(settings);
        }, 200);
        return;
      }
      /* Show the display HTML options */


      _fnAddOptionsHtml(settings);
      /* Build and draw the header / footer for the table */


      _fnBuildHead(settings);

      _fnDrawHead(settings, settings.aoHeader);

      _fnDrawHead(settings, settings.aoFooter);
      /* Okay to show that something is going on now */


      _fnProcessingDisplay(settings, true);
      /* Calculate sizes for columns */


      if (features.bAutoWidth) {
        _fnCalculateColumnWidths(settings);
      }

      for (i = 0, iLen = columns.length; i < iLen; i++) {
        column = columns[i];

        if (column.sWidth) {
          column.nTh.style.width = _fnStringToCss(column.sWidth);
        }
      } // If there is default sorting required - let's do it. The sort function
      // will do the drawing for us. Otherwise we draw the table regardless of the
      // Ajax source - this allows the table to look initialised for Ajax sourcing
      // data (show 'loading' message possibly)


      _fnReDraw(settings); // Server-side processing init complete is done by _fnAjaxUpdateDraw


      var dataSrc = _fnDataSource(settings);

      if (dataSrc != 'ssp') {
        // if there is an ajax source load the data
        if (dataSrc == 'ajax') {
          _fnBuildAjax(settings, [], function (json) {
            var aData = _fnAjaxDataSrc(settings, json); // Got the data - add it to the table


            for (i = 0; i < aData.length; i++) {
              _fnAddData(settings, aData[i]);
            } // Reset the init display for cookie saving. We've already done
            // a filter, and therefore cleared it before. So we need to make
            // it appear 'fresh'


            settings.iInitDisplayStart = iAjaxStart;

            _fnReDraw(settings);

            _fnProcessingDisplay(settings, false);

            _fnInitComplete(settings, json);
          }, settings);
        } else {
          _fnProcessingDisplay(settings, false);

          _fnInitComplete(settings);
        }
      }
    }
    /**
     * Draw the table for the first time, adding all required features
     *  @param {object} oSettings dataTables settings object
     *  @param {object} [json] JSON from the server that completed the table, if using Ajax source
     *    with client-side processing (optional)
     *  @memberof DataTable#oApi
     */


    function _fnInitComplete(settings, json) {
      settings._bInitComplete = true; // On an Ajax load we now have data and therefore want to apply the column
      // sizing

      if (json) {
        _fnAdjustColumnSizing(settings);
      }

      _fnCallbackFire(settings, 'aoInitComplete', 'init', [settings, json]);
    }

    function _fnLengthChange(settings, val) {
      var len = parseInt(val, 10);
      settings._iDisplayLength = len;

      _fnLengthOverflow(settings); // Fire length change event


      _fnCallbackFire(settings, null, 'length', [settings, len]);
    }
    /**
     * Generate the node required for user display length changing
     *  @param {object} settings dataTables settings object
     *  @returns {node} Display length feature node
     *  @memberof DataTable#oApi
     */


    function _fnFeatureHtmlLength(settings) {
      var classes = settings.oClasses,
          tableId = settings.sTableId,
          menu = settings.aLengthMenu,
          d2 = $.isArray(menu[0]),
          lengths = d2 ? menu[0] : menu,
          language = d2 ? menu[1] : menu;
      var select = $('<select/>', {
        'name': tableId + '_length',
        'aria-controls': tableId,
        'class': classes.sLengthSelect
      });

      for (var i = 0, ien = lengths.length; i < ien; i++) {
        select[0][i] = new Option(language[i], lengths[i]);
      }

      var div = $('<div><label/></div>').addClass(classes.sLength);

      if (!settings.aanFeatures.l) {
        div[0].id = tableId + '_length';
      }

      div.children().append(settings.oLanguage.sLengthMenu.replace('_MENU_', select[0].outerHTML)); // Can't use `select` variable as user might provide their own and the
      // reference is broken by the use of outerHTML

      $('select', div).val(settings._iDisplayLength).bind('change.DT', function (e) {
        _fnLengthChange(settings, $(this).val());

        _fnDraw(settings);
      }); // Update node value whenever anything changes the table's length

      $(settings.nTable).bind('length.dt.DT', function (e, s, len) {
        if (settings === s) {
          $('select', div).val(len);
        }
      });
      return div[0];
    }
    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
     * Note that most of the paging logic is done in
     * DataTable.ext.pager
     */

    /**
     * Generate the node required for default pagination
     *  @param {object} oSettings dataTables settings object
     *  @returns {node} Pagination feature node
     *  @memberof DataTable#oApi
     */


    function _fnFeatureHtmlPaginate(settings) {
      var type = settings.sPaginationType,
          plugin = _DataTable.ext.pager[type],
          modern = typeof plugin === 'function',
          redraw = function redraw(settings) {
        _fnDraw(settings);
      },
          node = $('<div/>').addClass(settings.oClasses.sPaging + type)[0],
          features = settings.aanFeatures;

      if (!modern) {
        plugin.fnInit(settings, node, redraw);
      }
      /* Add a draw callback for the pagination on first instance, to update the paging display */


      if (!features.p) {
        node.id = settings.sTableId + '_paginate';
        settings.aoDrawCallback.push({
          "fn": function fn(settings) {
            if (modern) {
              var start = settings._iDisplayStart,
                  len = settings._iDisplayLength,
                  visRecords = settings.fnRecordsDisplay(),
                  all = len === -1,
                  page = all ? 0 : Math.ceil(start / len),
                  pages = all ? 1 : Math.ceil(visRecords / len),
                  buttons = plugin(page, pages),
                  i,
                  ien;

              for (i = 0, ien = features.p.length; i < ien; i++) {
                _fnRenderer(settings, 'pageButton')(settings, features.p[i], i, buttons, page, pages);
              }
            } else {
              plugin.fnUpdate(settings, redraw);
            }
          },
          "sName": "pagination"
        });
      }

      return node;
    }
    /**
     * Alter the display settings to change the page
     *  @param {object} settings DataTables settings object
     *  @param {string|int} action Paging action to take: "first", "previous",
     *    "next" or "last" or page number to jump to (integer)
     *  @param [bool] redraw Automatically draw the update or not
     *  @returns {bool} true page has changed, false - no change
     *  @memberof DataTable#oApi
     */


    function _fnPageChange(settings, action, redraw) {
      var start = settings._iDisplayStart,
          len = settings._iDisplayLength,
          records = settings.fnRecordsDisplay();

      if (records === 0 || len === -1) {
        start = 0;
      } else if (typeof action === "number") {
        start = action * len;

        if (start > records) {
          start = 0;
        }
      } else if (action == "first") {
        start = 0;
      } else if (action == "previous") {
        start = len >= 0 ? start - len : 0;

        if (start < 0) {
          start = 0;
        }
      } else if (action == "next") {
        if (start + len < records) {
          start += len;
        }
      } else if (action == "last") {
        start = Math.floor((records - 1) / len) * len;
      } else {
        _fnLog(settings, 0, "Unknown paging action: " + action, 5);
      }

      var changed = settings._iDisplayStart !== start;
      settings._iDisplayStart = start;

      if (changed) {
        _fnCallbackFire(settings, null, 'page', [settings]);

        if (redraw) {
          _fnDraw(settings);
        }
      }

      return changed;
    }
    /**
     * Generate the node required for the processing node
     *  @param {object} settings dataTables settings object
     *  @returns {node} Processing element
     *  @memberof DataTable#oApi
     */


    function _fnFeatureHtmlProcessing(settings) {
      return $('<div/>', {
        'id': !settings.aanFeatures.r ? settings.sTableId + '_processing' : null,
        'class': settings.oClasses.sProcessing
      }).html(settings.oLanguage.sProcessing).insertBefore(settings.nTable)[0];
    }
    /**
     * Display or hide the processing indicator
     *  @param {object} settings dataTables settings object
     *  @param {bool} show Show the processing indicator (true) or not (false)
     *  @memberof DataTable#oApi
     */


    function _fnProcessingDisplay(settings, show) {
      if (settings.oFeatures.bProcessing) {
        $(settings.aanFeatures.r).css('display', show ? 'block' : 'none');
      }

      _fnCallbackFire(settings, null, 'processing', [settings, show]);
    }
    /**
     * Add any control elements for the table - specifically scrolling
     *  @param {object} settings dataTables settings object
     *  @returns {node} Node to add to the DOM
     *  @memberof DataTable#oApi
     */


    function _fnFeatureHtmlTable(settings) {
      var table = $(settings.nTable); // Add the ARIA grid role to the table

      table.attr('role', 'grid'); // Scrolling from here on in

      var scroll = settings.oScroll;

      if (scroll.sX === '' && scroll.sY === '') {
        return settings.nTable;
      }

      var scrollX = scroll.sX;
      var scrollY = scroll.sY;
      var classes = settings.oClasses;
      var caption = table.children('caption');
      var captionSide = caption.length ? caption[0]._captionSide : null;
      var headerClone = $(table[0].cloneNode(false));
      var footerClone = $(table[0].cloneNode(false));
      var footer = table.children('tfoot');
      var _div = '<div/>';

      var size = function size(s) {
        return !s ? null : _fnStringToCss(s);
      }; // This is fairly messy, but with x scrolling enabled, if the table has a
      // width attribute, regardless of any width applied using the column width
      // options, the browser will shrink or grow the table as needed to fit into
      // that 100%. That would make the width options useless. So we remove it.
      // This is okay, under the assumption that width:100% is applied to the
      // table in CSS (it is in the default stylesheet) which will set the table
      // width as appropriate (the attribute and css behave differently...)


      if (scroll.sX && table.attr('width') === '100%') {
        table.removeAttr('width');
      }

      if (!footer.length) {
        footer = null;
      }
      /*
       * The HTML structure that we want to generate in this function is:
       *  div - scroller
       *    div - scroll head
       *      div - scroll head inner
       *        table - scroll head table
       *          thead - thead
       *    div - scroll body
       *      table - table (master table)
       *        thead - thead clone for sizing
       *        tbody - tbody
       *    div - scroll foot
       *      div - scroll foot inner
       *        table - scroll foot table
       *          tfoot - tfoot
       */


      var scroller = $(_div, {
        'class': classes.sScrollWrapper
      }).append($(_div, {
        'class': classes.sScrollHead
      }).css({
        overflow: 'hidden',
        position: 'relative',
        border: 0,
        width: scrollX ? size(scrollX) : '100%'
      }).append($(_div, {
        'class': classes.sScrollHeadInner
      }).css({
        'box-sizing': 'content-box',
        width: scroll.sXInner || '100%'
      }).append(headerClone.removeAttr('id').css('margin-left', 0).append(captionSide === 'top' ? caption : null).append(table.children('thead'))))).append($(_div, {
        'class': classes.sScrollBody
      }).css({
        overflow: 'auto',
        height: size(scrollY),
        width: size(scrollX)
      }).append(table));

      if (footer) {
        scroller.append($(_div, {
          'class': classes.sScrollFoot
        }).css({
          overflow: 'hidden',
          border: 0,
          width: scrollX ? size(scrollX) : '100%'
        }).append($(_div, {
          'class': classes.sScrollFootInner
        }).append(footerClone.removeAttr('id').css('margin-left', 0).append(captionSide === 'bottom' ? caption : null).append(table.children('tfoot')))));
      }

      var children = scroller.children();
      var scrollHead = children[0];
      var scrollBody = children[1];
      var scrollFoot = footer ? children[2] : null; // When the body is scrolled, then we also want to scroll the headers

      if (scrollX) {
        $(scrollBody).on('scroll.DT', function (e) {
          var scrollLeft = this.scrollLeft;
          scrollHead.scrollLeft = scrollLeft;

          if (footer) {
            scrollFoot.scrollLeft = scrollLeft;
          }
        });
      }

      settings.nScrollHead = scrollHead;
      settings.nScrollBody = scrollBody;
      settings.nScrollFoot = scrollFoot; // On redraw - align columns

      settings.aoDrawCallback.push({
        "fn": _fnScrollDraw,
        "sName": "scrolling"
      });
      return scroller[0];
    }
    /**
     * Update the header, footer and body tables for resizing - i.e. column
     * alignment.
     *
     * Welcome to the most horrible function DataTables. The process that this
     * function follows is basically:
     *   1. Re-create the table inside the scrolling div
     *   2. Take live measurements from the DOM
     *   3. Apply the measurements to align the columns
     *   4. Clean up
     *
     *  @param {object} settings dataTables settings object
     *  @memberof DataTable#oApi
     */


    function _fnScrollDraw(settings) {
      // Given that this is such a monster function, a lot of variables are use
      // to try and keep the minimised size as small as possible
      var scroll = settings.oScroll,
          scrollX = scroll.sX,
          scrollXInner = scroll.sXInner,
          scrollY = scroll.sY,
          barWidth = scroll.iBarWidth,
          divHeader = $(settings.nScrollHead),
          divHeaderStyle = divHeader[0].style,
          divHeaderInner = divHeader.children('div'),
          divHeaderInnerStyle = divHeaderInner[0].style,
          divHeaderTable = divHeaderInner.children('table'),
          divBodyEl = settings.nScrollBody,
          divBody = $(divBodyEl),
          divBodyStyle = divBodyEl.style,
          divFooter = $(settings.nScrollFoot),
          divFooterInner = divFooter.children('div'),
          divFooterTable = divFooterInner.children('table'),
          header = $(settings.nTHead),
          table = $(settings.nTable),
          tableEl = table[0],
          tableStyle = tableEl.style,
          footer = settings.nTFoot ? $(settings.nTFoot) : null,
          browser = settings.oBrowser,
          ie67 = browser.bScrollOversize,
          headerTrgEls,
          footerTrgEls,
          headerSrcEls,
          footerSrcEls,
          headerCopy,
          footerCopy,
          headerWidths = [],
          footerWidths = [],
          headerContent = [],
          idx,
          correction,
          sanityWidth,
          zeroOut = function zeroOut(nSizer) {
        var style = nSizer.style;
        style.paddingTop = "0";
        style.paddingBottom = "0";
        style.borderTopWidth = "0";
        style.borderBottomWidth = "0";
        style.height = 0;
      };
      /*
       * 1. Re-create the table inside the scrolling div
       */
      // Remove the old minimised thead and tfoot elements in the inner table


      table.children('thead, tfoot').remove(); // Clone the current header and footer elements and then place it into the inner table

      headerCopy = header.clone().prependTo(table);
      headerTrgEls = header.find('tr'); // original header is in its own table

      headerSrcEls = headerCopy.find('tr');
      headerCopy.find('th, td').removeAttr('tabindex');

      if (footer) {
        footerCopy = footer.clone().prependTo(table);
        footerTrgEls = footer.find('tr'); // the original tfoot is in its own table and must be sized

        footerSrcEls = footerCopy.find('tr');
      }
      /*
       * 2. Take live measurements from the DOM - do not alter the DOM itself!
       */
      // Remove old sizing and apply the calculated column widths
      // Get the unique column headers in the newly created (cloned) header. We want to apply the
      // calculated sizes to this header


      if (!scrollX) {
        divBodyStyle.width = '100%';
        divHeader[0].style.width = '100%';
      }

      $.each(_fnGetUniqueThs(settings, headerCopy), function (i, el) {
        idx = _fnVisibleToColumnIndex(settings, i);
        el.style.width = settings.aoColumns[idx].sWidth;
      });

      if (footer) {
        _fnApplyToChildren(function (n) {
          n.style.width = "";
        }, footerSrcEls);
      } // If scroll collapse is enabled, when we put the headers back into the body for sizing, we
      // will end up forcing the scrollbar to appear, making our measurements wrong for when we
      // then hide it (end of this function), so add the header height to the body scroller.


      if (scroll.bCollapse && scrollY !== "") {
        divBodyStyle.height = divBody[0].offsetHeight + header[0].offsetHeight + "px";
      } // Size the table as a whole


      sanityWidth = table.outerWidth();

      if (scrollX === "") {
        // No x scrolling
        tableStyle.width = "100%"; // IE7 will make the width of the table when 100% include the scrollbar
        // - which is shouldn't. When there is a scrollbar we need to take this
        // into account.

        if (ie67 && (table.find('tbody').height() > divBodyEl.offsetHeight || divBody.css('overflow-y') == "scroll")) {
          tableStyle.width = _fnStringToCss(table.outerWidth() - barWidth);
        }
      } else {
        // x scrolling
        if (scrollXInner !== "") {
          // x scroll inner has been given - use it
          tableStyle.width = _fnStringToCss(scrollXInner);
        } else if (sanityWidth == divBody.width() && divBody.height() < table.height()) {
          // There is y-scrolling - try to take account of the y scroll bar
          tableStyle.width = _fnStringToCss(sanityWidth - barWidth);

          if (table.outerWidth() > sanityWidth - barWidth) {
            // Not possible to take account of it
            tableStyle.width = _fnStringToCss(sanityWidth);
          }
        } else {
          // When all else fails
          tableStyle.width = _fnStringToCss(sanityWidth);
        }
      } // Recalculate the sanity width - now that we've applied the required width,
      // before it was a temporary variable. This is required because the column
      // width calculation is done before this table DOM is created.


      sanityWidth = table.outerWidth(); // Hidden header should have zero height, so remove padding and borders. Then
      // set the width based on the real headers
      // Apply all styles in one pass

      _fnApplyToChildren(zeroOut, headerSrcEls); // Read all widths in next pass


      _fnApplyToChildren(function (nSizer) {
        headerContent.push(nSizer.innerHTML);
        headerWidths.push(_fnStringToCss($(nSizer).css('width')));
      }, headerSrcEls); // Apply all widths in final pass


      _fnApplyToChildren(function (nToSize, i) {
        nToSize.style.width = headerWidths[i];
      }, headerTrgEls);

      $(headerSrcEls).height(0);
      /* Same again with the footer if we have one */

      if (footer) {
        _fnApplyToChildren(zeroOut, footerSrcEls);

        _fnApplyToChildren(function (nSizer) {
          footerWidths.push(_fnStringToCss($(nSizer).css('width')));
        }, footerSrcEls);

        _fnApplyToChildren(function (nToSize, i) {
          nToSize.style.width = footerWidths[i];
        }, footerTrgEls);

        $(footerSrcEls).height(0);
      }
      /*
       * 3. Apply the measurements
       */
      // "Hide" the header and footer that we used for the sizing. We need to keep
      // the content of the cell so that the width applied to the header and body
      // both match, but we want to hide it completely. We want to also fix their
      // width to what they currently are


      _fnApplyToChildren(function (nSizer, i) {
        nSizer.innerHTML = '<div class="dataTables_sizing" style="height:0;overflow:hidden;">' + headerContent[i] + '</div>';
        nSizer.style.width = headerWidths[i];
      }, headerSrcEls);

      if (footer) {
        _fnApplyToChildren(function (nSizer, i) {
          nSizer.innerHTML = "";
          nSizer.style.width = footerWidths[i];
        }, footerSrcEls);
      } // Sanity check that the table is of a sensible width. If not then we are going to get
      // misalignment - try to prevent this by not allowing the table to shrink below its min width


      if (table.outerWidth() < sanityWidth) {
        // The min width depends upon if we have a vertical scrollbar visible or not */
        correction = divBodyEl.scrollHeight > divBodyEl.offsetHeight || divBody.css('overflow-y') == "scroll" ? sanityWidth + barWidth : sanityWidth; // IE6/7 are a law unto themselves...

        if (ie67 && (divBodyEl.scrollHeight > divBodyEl.offsetHeight || divBody.css('overflow-y') == "scroll")) {
          tableStyle.width = _fnStringToCss(correction - barWidth);
        } // And give the user a warning that we've stopped the table getting too small


        if (scrollX === "" || scrollXInner !== "") {
          _fnLog(settings, 1, 'Possible column misalignment', 6);
        }
      } else {
        correction = '100%';
      } // Apply to the container elements


      divBodyStyle.width = _fnStringToCss(correction);
      divHeaderStyle.width = _fnStringToCss(correction);

      if (footer) {
        settings.nScrollFoot.style.width = _fnStringToCss(correction);
      }
      /*
       * 4. Clean up
       */


      if (!scrollY) {
        /* IE7< puts a vertical scrollbar in place (when it shouldn't be) due to subtracting
         * the scrollbar height from the visible display, rather than adding it on. We need to
         * set the height in order to sort this. Don't want to do it in any other browsers.
         */
        if (ie67) {
          divBodyStyle.height = _fnStringToCss(tableEl.offsetHeight + barWidth);
        }
      }

      if (scrollY && scroll.bCollapse) {
        divBodyStyle.height = _fnStringToCss(scrollY);
        var iExtra = scrollX && tableEl.offsetWidth > divBodyEl.offsetWidth ? barWidth : 0;

        if (tableEl.offsetHeight < divBodyEl.offsetHeight) {
          divBodyStyle.height = _fnStringToCss(tableEl.offsetHeight + iExtra);
        }
      }
      /* Finally set the width's of the header and footer tables */


      var iOuterWidth = table.outerWidth();
      divHeaderTable[0].style.width = _fnStringToCss(iOuterWidth);
      divHeaderInnerStyle.width = _fnStringToCss(iOuterWidth); // Figure out if there are scrollbar present - if so then we need a the header and footer to
      // provide a bit more space to allow "overflow" scrolling (i.e. past the scrollbar)

      var bScrolling = table.height() > divBodyEl.clientHeight || divBody.css('overflow-y') == "scroll";
      var padding = 'padding' + (browser.bScrollbarLeft ? 'Left' : 'Right');
      divHeaderInnerStyle[padding] = bScrolling ? barWidth + "px" : "0px";

      if (footer) {
        divFooterTable[0].style.width = _fnStringToCss(iOuterWidth);
        divFooterInner[0].style.width = _fnStringToCss(iOuterWidth);
        divFooterInner[0].style[padding] = bScrolling ? barWidth + "px" : "0px";
      }
      /* Adjust the position of the header in case we loose the y-scrollbar */


      divBody.scroll(); // If sorting or filtering has occurred, jump the scrolling back to the top
      // only if we aren't holding the position

      if ((settings.bSorted || settings.bFiltered) && !settings._drawHold) {
        divBodyEl.scrollTop = 0;
      }
    }
    /**
     * Apply a given function to the display child nodes of an element array (typically
     * TD children of TR rows
     *  @param {function} fn Method to apply to the objects
     *  @param array {nodes} an1 List of elements to look through for display children
     *  @param array {nodes} an2 Another list (identical structure to the first) - optional
     *  @memberof DataTable#oApi
     */


    function _fnApplyToChildren(fn, an1, an2) {
      var index = 0,
          i = 0,
          iLen = an1.length;
      var nNode1, nNode2;

      while (i < iLen) {
        nNode1 = an1[i].firstChild;
        nNode2 = an2 ? an2[i].firstChild : null;

        while (nNode1) {
          if (nNode1.nodeType === 1) {
            if (an2) {
              fn(nNode1, nNode2, index);
            } else {
              fn(nNode1, index);
            }

            index++;
          }

          nNode1 = nNode1.nextSibling;
          nNode2 = an2 ? nNode2.nextSibling : null;
        }

        i++;
      }
    }

    var __re_html_remove = /<.*?>/g;
    /**
     * Calculate the width of columns for the table
     *  @param {object} oSettings dataTables settings object
     *  @memberof DataTable#oApi
     */

    function _fnCalculateColumnWidths(oSettings) {
      var table = oSettings.nTable,
          columns = oSettings.aoColumns,
          scroll = oSettings.oScroll,
          scrollY = scroll.sY,
          scrollX = scroll.sX,
          scrollXInner = scroll.sXInner,
          columnCount = columns.length,
          visibleColumns = _fnGetColumns(oSettings, 'bVisible'),
          headerCells = $('th', oSettings.nTHead),
          tableWidthAttr = table.getAttribute('width'),
          // from DOM element
      tableContainer = table.parentNode,
          userInputs = false,
          i,
          column,
          columnIdx,
          width,
          outerWidth;

      var styleWidth = table.style.width;

      if (styleWidth && styleWidth.indexOf('%') !== -1) {
        tableWidthAttr = styleWidth;
      }
      /* Convert any user input sizes into pixel sizes */


      for (i = 0; i < visibleColumns.length; i++) {
        column = columns[visibleColumns[i]];

        if (column.sWidth !== null) {
          column.sWidth = _fnConvertToWidth(column.sWidthOrig, tableContainer);
          userInputs = true;
        }
      }
      /* If the number of columns in the DOM equals the number that we have to
       * process in DataTables, then we can use the offsets that are created by
       * the web- browser. No custom sizes can be set in order for this to happen,
       * nor scrolling used
       */


      if (!userInputs && !scrollX && !scrollY && columnCount == _fnVisbleColumns(oSettings) && columnCount == headerCells.length) {
        for (i = 0; i < columnCount; i++) {
          columns[i].sWidth = _fnStringToCss(headerCells.eq(i).width());
        }
      } else {
        // Otherwise construct a single row, worst case, table with the widest
        // node in the data, assign any user defined widths, then insert it into
        // the DOM and allow the browser to do all the hard work of calculating
        // table widths
        var tmpTable = $(table).clone() // don't use cloneNode - IE8 will remove events on the main table
        .css('visibility', 'hidden').removeAttr('id'); // Clean up the table body

        tmpTable.find('tbody tr').remove();
        var tr = $('<tr/>').appendTo(tmpTable.find('tbody')); // Remove any assigned widths from the footer (from scrolling)

        tmpTable.find('tfoot th, tfoot td').css('width', ''); // Apply custom sizing to the cloned header

        headerCells = _fnGetUniqueThs(oSettings, tmpTable.find('thead')[0]);

        for (i = 0; i < visibleColumns.length; i++) {
          column = columns[visibleColumns[i]];
          headerCells[i].style.width = column.sWidthOrig !== null && column.sWidthOrig !== '' ? _fnStringToCss(column.sWidthOrig) : '';
        } // Find the widest cell for each column and put it into the table


        if (oSettings.aoData.length) {
          for (i = 0; i < visibleColumns.length; i++) {
            columnIdx = visibleColumns[i];
            column = columns[columnIdx];
            $(_fnGetWidestNode(oSettings, columnIdx)).clone(false).append(column.sContentPadding).appendTo(tr);
          }
        } // Table has been built, attach to the document so we can work with it


        tmpTable.appendTo(tableContainer); // When scrolling (X or Y) we want to set the width of the table as 
        // appropriate. However, when not scrolling leave the table width as it
        // is. This results in slightly different, but I think correct behaviour

        if (scrollX && scrollXInner) {
          tmpTable.width(scrollXInner);
        } else if (scrollX) {
          tmpTable.css('width', 'auto');

          if (tmpTable.width() < tableContainer.offsetWidth) {
            tmpTable.width(tableContainer.offsetWidth);
          }
        } else if (scrollY) {
          tmpTable.width(tableContainer.offsetWidth);
        } else if (tableWidthAttr) {
          tmpTable.width(tableWidthAttr);
        } // Take into account the y scrollbar


        _fnScrollingWidthAdjust(oSettings, tmpTable[0]); // Browsers need a bit of a hand when a width is assigned to any columns
        // when x-scrolling as they tend to collapse the table to the min-width,
        // even if we sent the column widths. So we need to keep track of what
        // the table width should be by summing the user given values, and the
        // automatic values


        if (scrollX) {
          var total = 0;

          for (i = 0; i < visibleColumns.length; i++) {
            column = columns[visibleColumns[i]];
            outerWidth = $(headerCells[i]).outerWidth();
            total += column.sWidthOrig === null ? outerWidth : parseInt(column.sWidth, 10) + outerWidth - $(headerCells[i]).width();
          }

          tmpTable.width(_fnStringToCss(total));
          table.style.width = _fnStringToCss(total);
        } // Get the width of each column in the constructed table


        for (i = 0; i < visibleColumns.length; i++) {
          column = columns[visibleColumns[i]];
          width = $(headerCells[i]).width();

          if (width) {
            column.sWidth = _fnStringToCss(width);
          }
        }

        table.style.width = _fnStringToCss(tmpTable.css('width')); // Finished with the table - ditch it

        tmpTable.remove();
      } // If there is a width attr, we want to attach an event listener which
      // allows the table sizing to automatically adjust when the window is
      // resized. Use the width attr rather than CSS, since we can't know if the
      // CSS is a relative value or absolute - DOM read is always px.


      if (tableWidthAttr) {
        table.style.width = _fnStringToCss(tableWidthAttr);
      }

      if ((tableWidthAttr || scrollX) && !oSettings._reszEvt) {
        var bindResize = function bindResize() {
          $(window).bind('resize.DT-' + oSettings.sInstance, _fnThrottle(function () {
            _fnAdjustColumnSizing(oSettings);
          }));
        }; // IE6/7 will crash if we bind a resize event handler on page load.
        // To be removed in 1.11 which drops IE6/7 support


        if (oSettings.oBrowser.bScrollOversize) {
          setTimeout(bindResize, 1000);
        } else {
          bindResize();
        }

        oSettings._reszEvt = true;
      }
    }
    /**
     * Throttle the calls to a function. Arguments and context are maintained for
     * the throttled function
     *  @param {function} fn Function to be called
     *  @param {int} [freq=200] call frequency in mS
     *  @returns {function} wrapped function
     *  @memberof DataTable#oApi
     */


    function _fnThrottle(fn, freq) {
      var frequency = freq !== undefined ? freq : 200,
          last,
          timer;
      return function () {
        var that = this,
            now = +new Date(),
            args = arguments;

        if (last && now < last + frequency) {
          clearTimeout(timer);
          timer = setTimeout(function () {
            last = undefined;
            fn.apply(that, args);
          }, frequency);
        } else {
          last = now;
          fn.apply(that, args);
        }
      };
    }
    /**
     * Convert a CSS unit width to pixels (e.g. 2em)
     *  @param {string} width width to be converted
     *  @param {node} parent parent to get the with for (required for relative widths) - optional
     *  @returns {int} width in pixels
     *  @memberof DataTable#oApi
     */


    function _fnConvertToWidth(width, parent) {
      if (!width) {
        return 0;
      }

      var n = $('<div/>').css('width', _fnStringToCss(width)).appendTo(parent || document.body);
      var val = n[0].offsetWidth;
      n.remove();
      return val;
    }
    /**
     * Adjust a table's width to take account of vertical scroll bar
     *  @param {object} oSettings dataTables settings object
     *  @param {node} n table node
     *  @memberof DataTable#oApi
     */


    function _fnScrollingWidthAdjust(settings, n) {
      var scroll = settings.oScroll;

      if (scroll.sX || scroll.sY) {
        // When y-scrolling only, we want to remove the width of the scroll bar
        // so the table + scroll bar will fit into the area available, otherwise
        // we fix the table at its current size with no adjustment
        var correction = !scroll.sX ? scroll.iBarWidth : 0;
        n.style.width = _fnStringToCss($(n).outerWidth() - correction);
      }
    }
    /**
     * Get the widest node
     *  @param {object} settings dataTables settings object
     *  @param {int} colIdx column of interest
     *  @returns {node} widest table node
     *  @memberof DataTable#oApi
     */


    function _fnGetWidestNode(settings, colIdx) {
      var idx = _fnGetMaxLenString(settings, colIdx);

      if (idx < 0) {
        return null;
      }

      var data = settings.aoData[idx];
      return !data.nTr ? // Might not have been created when deferred rendering
      $('<td/>').html(_fnGetCellData(settings, idx, colIdx, 'display'))[0] : data.anCells[colIdx];
    }
    /**
     * Get the maximum strlen for each data column
     *  @param {object} settings dataTables settings object
     *  @param {int} colIdx column of interest
     *  @returns {string} max string length for each column
     *  @memberof DataTable#oApi
     */


    function _fnGetMaxLenString(settings, colIdx) {
      var s,
          max = -1,
          maxIdx = -1;

      for (var i = 0, ien = settings.aoData.length; i < ien; i++) {
        s = _fnGetCellData(settings, i, colIdx, 'display') + '';
        s = s.replace(__re_html_remove, '');

        if (s.length > max) {
          max = s.length;
          maxIdx = i;
        }
      }

      return maxIdx;
    }
    /**
     * Append a CSS unit (only if required) to a string
     *  @param {string} value to css-ify
     *  @returns {string} value with css unit
     *  @memberof DataTable#oApi
     */


    function _fnStringToCss(s) {
      if (s === null) {
        return '0px';
      }

      if (typeof s == 'number') {
        return s < 0 ? '0px' : s + 'px';
      } // Check it has a unit character already


      return s.match(/\d$/) ? s + 'px' : s;
    }
    /**
     * Get the width of a scroll bar in this browser being used
     *  @returns {int} width in pixels
     *  @memberof DataTable#oApi
     */


    function _fnScrollBarWidth() {
      // On first run a static variable is set, since this is only needed once.
      // Subsequent runs will just use the previously calculated value
      var width = _DataTable.__scrollbarWidth;

      if (width === undefined) {
        var sizer = $('<p/>').css({
          position: 'absolute',
          top: 0,
          left: 0,
          width: '100%',
          height: 150,
          padding: 0,
          overflow: 'scroll',
          visibility: 'hidden'
        }).appendTo('body');
        width = sizer[0].offsetWidth - sizer[0].clientWidth;
        _DataTable.__scrollbarWidth = width;
        sizer.remove();
      }

      return width;
    }

    function _fnSortFlatten(settings) {
      var i,
          iLen,
          k,
          kLen,
          aSort = [],
          aiOrig = [],
          aoColumns = settings.aoColumns,
          aDataSort,
          iCol,
          sType,
          srcCol,
          fixed = settings.aaSortingFixed,
          fixedObj = $.isPlainObject(fixed),
          nestedSort = [],
          add = function add(a) {
        if (a.length && !$.isArray(a[0])) {
          // 1D array
          nestedSort.push(a);
        } else {
          // 2D array
          nestedSort.push.apply(nestedSort, a);
        }
      }; // Build the sort array, with pre-fix and post-fix options if they have been
      // specified


      if ($.isArray(fixed)) {
        add(fixed);
      }

      if (fixedObj && fixed.pre) {
        add(fixed.pre);
      }

      add(settings.aaSorting);

      if (fixedObj && fixed.post) {
        add(fixed.post);
      }

      for (i = 0; i < nestedSort.length; i++) {
        srcCol = nestedSort[i][0];
        aDataSort = aoColumns[srcCol].aDataSort;

        for (k = 0, kLen = aDataSort.length; k < kLen; k++) {
          iCol = aDataSort[k];
          sType = aoColumns[iCol].sType || 'string';

          if (nestedSort[i]._idx === undefined) {
            nestedSort[i]._idx = $.inArray(nestedSort[i][1], aoColumns[iCol].asSorting);
          }

          aSort.push({
            src: srcCol,
            col: iCol,
            dir: nestedSort[i][1],
            index: nestedSort[i]._idx,
            type: sType,
            formatter: _DataTable.ext.type.order[sType + "-pre"]
          });
        }
      }

      return aSort;
    }
    /**
     * Change the order of the table
     *  @param {object} oSettings dataTables settings object
     *  @memberof DataTable#oApi
     *  @todo This really needs split up!
     */


    function _fnSort(oSettings) {
      var i,
          ien,
          iLen,
          j,
          jLen,
          k,
          kLen,
          sDataType,
          nTh,
          aiOrig = [],
          oExtSort = _DataTable.ext.type.order,
          aoData = oSettings.aoData,
          aoColumns = oSettings.aoColumns,
          aDataSort,
          data,
          iCol,
          sType,
          oSort,
          formatters = 0,
          sortCol,
          displayMaster = oSettings.aiDisplayMaster,
          aSort; // Resolve any column types that are unknown due to addition or invalidation
      // @todo Can this be moved into a 'data-ready' handler which is called when
      //   data is going to be used in the table?

      _fnColumnTypes(oSettings);

      aSort = _fnSortFlatten(oSettings);

      for (i = 0, ien = aSort.length; i < ien; i++) {
        sortCol = aSort[i]; // Track if we can use the fast sort algorithm

        if (sortCol.formatter) {
          formatters++;
        } // Load the data needed for the sort, for each cell


        _fnSortData(oSettings, sortCol.col);
      }
      /* No sorting required if server-side or no sorting array */


      if (_fnDataSource(oSettings) != 'ssp' && aSort.length !== 0) {
        // Create a value - key array of the current row positions such that we can use their
        // current position during the sort, if values match, in order to perform stable sorting
        for (i = 0, iLen = displayMaster.length; i < iLen; i++) {
          aiOrig[displayMaster[i]] = i;
        }
        /* Do the sort - here we want multi-column sorting based on a given data source (column)
         * and sorting function (from oSort) in a certain direction. It's reasonably complex to
         * follow on it's own, but this is what we want (example two column sorting):
         *  fnLocalSorting = function(a,b){
         *    var iTest;
         *    iTest = oSort['string-asc']('data11', 'data12');
         *      if (iTest !== 0)
         *        return iTest;
         *    iTest = oSort['numeric-desc']('data21', 'data22');
         *    if (iTest !== 0)
         *      return iTest;
         *    return oSort['numeric-asc']( aiOrig[a], aiOrig[b] );
         *  }
         * Basically we have a test for each sorting column, if the data in that column is equal,
         * test the next column. If all columns match, then we use a numeric sort on the row
         * positions in the original data array to provide a stable sort.
         *
         * Note - I know it seems excessive to have two sorting methods, but the first is around
         * 15% faster, so the second is only maintained for backwards compatibility with sorting
         * methods which do not have a pre-sort formatting function.
         */


        if (formatters === aSort.length) {
          // All sort types have formatting functions
          displayMaster.sort(function (a, b) {
            var x,
                y,
                k,
                test,
                sort,
                len = aSort.length,
                dataA = aoData[a]._aSortData,
                dataB = aoData[b]._aSortData;

            for (k = 0; k < len; k++) {
              sort = aSort[k];
              x = dataA[sort.col];
              y = dataB[sort.col];
              test = x < y ? -1 : x > y ? 1 : 0;

              if (test !== 0) {
                return sort.dir === 'asc' ? test : -test;
              }
            }

            x = aiOrig[a];
            y = aiOrig[b];
            return x < y ? -1 : x > y ? 1 : 0;
          });
        } else {
          // Depreciated - remove in 1.11 (providing a plug-in option)
          // Not all sort types have formatting methods, so we have to call their sorting
          // methods.
          displayMaster.sort(function (a, b) {
            var x,
                y,
                k,
                l,
                test,
                sort,
                fn,
                len = aSort.length,
                dataA = aoData[a]._aSortData,
                dataB = aoData[b]._aSortData;

            for (k = 0; k < len; k++) {
              sort = aSort[k];
              x = dataA[sort.col];
              y = dataB[sort.col];
              fn = oExtSort[sort.type + "-" + sort.dir] || oExtSort["string-" + sort.dir];
              test = fn(x, y);

              if (test !== 0) {
                return test;
              }
            }

            x = aiOrig[a];
            y = aiOrig[b];
            return x < y ? -1 : x > y ? 1 : 0;
          });
        }
      }
      /* Tell the draw function that we have sorted the data */


      oSettings.bSorted = true;
    }

    function _fnSortAria(settings) {
      var label;
      var nextSort;
      var columns = settings.aoColumns;

      var aSort = _fnSortFlatten(settings);

      var oAria = settings.oLanguage.oAria; // ARIA attributes - need to loop all columns, to update all (removing old
      // attributes as needed)

      for (var i = 0, iLen = columns.length; i < iLen; i++) {
        var col = columns[i];
        var asSorting = col.asSorting;
        var sTitle = col.sTitle.replace(/<.*?>/g, "");
        var th = col.nTh; // IE7 is throwing an error when setting these properties with jQuery's
        // attr() and removeAttr() methods...

        th.removeAttribute('aria-sort');
        /* In ARIA only the first sorting column can be marked as sorting - no multi-sort option */

        if (col.bSortable) {
          if (aSort.length > 0 && aSort[0].col == i) {
            th.setAttribute('aria-sort', aSort[0].dir == "asc" ? "ascending" : "descending");
            nextSort = asSorting[aSort[0].index + 1] || asSorting[0];
          } else {
            nextSort = asSorting[0];
          }

          label = sTitle + (nextSort === "asc" ? oAria.sSortAscending : oAria.sSortDescending);
        } else {
          label = sTitle;
        }

        th.setAttribute('aria-label', label);
      }
    }
    /**
     * Function to run on user sort request
     *  @param {object} settings dataTables settings object
     *  @param {node} attachTo node to attach the handler to
     *  @param {int} colIdx column sorting index
     *  @param {boolean} [append=false] Append the requested sort to the existing
     *    sort if true (i.e. multi-column sort)
     *  @param {function} [callback] callback function
     *  @memberof DataTable#oApi
     */


    function _fnSortListener(settings, colIdx, append, callback) {
      var col = settings.aoColumns[colIdx];
      var sorting = settings.aaSorting;
      var asSorting = col.asSorting;
      var nextSortIdx;

      var next = function next(a, overflow) {
        var idx = a._idx;

        if (idx === undefined) {
          idx = $.inArray(a[1], asSorting);
        }

        return idx + 1 < asSorting.length ? idx + 1 : overflow ? null : 0;
      }; // Convert to 2D array if needed


      if (typeof sorting[0] === 'number') {
        sorting = settings.aaSorting = [sorting];
      } // If appending the sort then we are multi-column sorting


      if (append && settings.oFeatures.bSortMulti) {
        // Are we already doing some kind of sort on this column?
        var sortIdx = $.inArray(colIdx, _pluck(sorting, '0'));

        if (sortIdx !== -1) {
          // Yes, modify the sort
          nextSortIdx = next(sorting[sortIdx], true);

          if (nextSortIdx === null && sorting.length === 1) {
            nextSortIdx = 0; // can't remove sorting completely
          }

          if (nextSortIdx === null) {
            sorting.splice(sortIdx, 1);
          } else {
            sorting[sortIdx][1] = asSorting[nextSortIdx];
            sorting[sortIdx]._idx = nextSortIdx;
          }
        } else {
          // No sort on this column yet
          sorting.push([colIdx, asSorting[0], 0]);
          sorting[sorting.length - 1]._idx = 0;
        }
      } else if (sorting.length && sorting[0][0] == colIdx) {
        // Single column - already sorting on this column, modify the sort
        nextSortIdx = next(sorting[0]);
        sorting.length = 1;
        sorting[0][1] = asSorting[nextSortIdx];
        sorting[0]._idx = nextSortIdx;
      } else {
        // Single column - sort only on this column
        sorting.length = 0;
        sorting.push([colIdx, asSorting[0]]);
        sorting[0]._idx = 0;
      } // Run the sort by calling a full redraw


      _fnReDraw(settings); // callback used for async user interaction


      if (typeof callback == 'function') {
        callback(settings);
      }
    }
    /**
     * Attach a sort handler (click) to a node
     *  @param {object} settings dataTables settings object
     *  @param {node} attachTo node to attach the handler to
     *  @param {int} colIdx column sorting index
     *  @param {function} [callback] callback function
     *  @memberof DataTable#oApi
     */


    function _fnSortAttachListener(settings, attachTo, colIdx, callback) {
      var col = settings.aoColumns[colIdx];

      _fnBindAction(attachTo, {}, function (e) {
        /* If the column is not sortable - don't to anything */
        if (col.bSortable === false) {
          return;
        } // If processing is enabled use a timeout to allow the processing
        // display to be shown - otherwise to it synchronously


        if (settings.oFeatures.bProcessing) {
          _fnProcessingDisplay(settings, true);

          setTimeout(function () {
            _fnSortListener(settings, colIdx, e.shiftKey, callback); // In server-side processing, the draw callback will remove the
            // processing display


            if (_fnDataSource(settings) !== 'ssp') {
              _fnProcessingDisplay(settings, false);
            }
          }, 0);
        } else {
          _fnSortListener(settings, colIdx, e.shiftKey, callback);
        }
      });
    }
    /**
     * Set the sorting classes on table's body, Note: it is safe to call this function
     * when bSort and bSortClasses are false
     *  @param {object} oSettings dataTables settings object
     *  @memberof DataTable#oApi
     */


    function _fnSortingClasses(settings) {
      var oldSort = settings.aLastSort;
      var sortClass = settings.oClasses.sSortColumn;

      var sort = _fnSortFlatten(settings);

      var features = settings.oFeatures;
      var i, ien, colIdx;

      if (features.bSort && features.bSortClasses) {
        // Remove old sorting classes
        for (i = 0, ien = oldSort.length; i < ien; i++) {
          colIdx = oldSort[i].src; // Remove column sorting

          $(_pluck(settings.aoData, 'anCells', colIdx)).removeClass(sortClass + (i < 2 ? i + 1 : 3));
        } // Add new column sorting


        for (i = 0, ien = sort.length; i < ien; i++) {
          colIdx = sort[i].src;
          $(_pluck(settings.aoData, 'anCells', colIdx)).addClass(sortClass + (i < 2 ? i + 1 : 3));
        }
      }

      settings.aLastSort = sort;
    } // Get the data to sort a column, be it from cache, fresh (populating the
    // cache), or from a sort formatter


    function _fnSortData(settings, idx) {
      // Custom sorting function - provided by the sort data type
      var column = settings.aoColumns[idx];
      var customSort = _DataTable.ext.order[column.sSortDataType];
      var customData;

      if (customSort) {
        customData = customSort.call(settings.oInstance, settings, idx, _fnColumnIndexToVisible(settings, idx));
      } // Use / populate cache


      var row, cellData;
      var formatter = _DataTable.ext.type.order[column.sType + "-pre"];

      for (var i = 0, ien = settings.aoData.length; i < ien; i++) {
        row = settings.aoData[i];

        if (!row._aSortData) {
          row._aSortData = [];
        }

        if (!row._aSortData[idx] || customSort) {
          cellData = customSort ? customData[i] : // If there was a custom sort function, use data from there
          _fnGetCellData(settings, i, idx, 'sort');
          row._aSortData[idx] = formatter ? formatter(cellData) : cellData;
        }
      }
    }
    /**
     * Save the state of a table
     *  @param {object} oSettings dataTables settings object
     *  @memberof DataTable#oApi
     */


    function _fnSaveState(settings) {
      if (!settings.oFeatures.bStateSave || settings.bDestroying) {
        return;
      }
      /* Store the interesting variables */


      var state = {
        time: +new Date(),
        start: settings._iDisplayStart,
        length: settings._iDisplayLength,
        order: $.extend(true, [], settings.aaSorting),
        search: _fnSearchToCamel(settings.oPreviousSearch),
        columns: $.map(settings.aoColumns, function (col, i) {
          return {
            visible: col.bVisible,
            search: _fnSearchToCamel(settings.aoPreSearchCols[i])
          };
        })
      };

      _fnCallbackFire(settings, "aoStateSaveParams", 'stateSaveParams', [settings, state]);

      settings.oSavedState = state;
      settings.fnStateSaveCallback.call(settings.oInstance, settings, state);
    }
    /**
     * Attempt to load a saved table state
     *  @param {object} oSettings dataTables settings object
     *  @param {object} oInit DataTables init object so we can override settings
     *  @memberof DataTable#oApi
     */


    function _fnLoadState(settings, oInit) {
      var i, ien;
      var columns = settings.aoColumns;

      if (!settings.oFeatures.bStateSave) {
        return;
      }

      var state = settings.fnStateLoadCallback.call(settings.oInstance, settings);

      if (!state || !state.time) {
        return;
      }
      /* Allow custom and plug-in manipulation functions to alter the saved data set and
       * cancelling of loading by returning false
       */


      var abStateLoad = _fnCallbackFire(settings, 'aoStateLoadParams', 'stateLoadParams', [settings, state]);

      if ($.inArray(false, abStateLoad) !== -1) {
        return;
      }
      /* Reject old data */


      var duration = settings.iStateDuration;

      if (duration > 0 && state.time < +new Date() - duration * 1000) {
        return;
      } // Number of columns have changed - all bets are off, no restore of settings


      if (columns.length !== state.columns.length) {
        return;
      } // Store the saved state so it might be accessed at any time


      settings.oLoadedState = $.extend(true, {}, state); // Restore key features - todo - for 1.11 this needs to be done by
      // subscribed events

      if (state.start !== undefined) {
        settings._iDisplayStart = state.start;
        settings.iInitDisplayStart = state.start;
      }

      if (state.length !== undefined) {
        settings._iDisplayLength = state.length;
      } // Order


      if (state.order !== undefined) {
        settings.aaSorting = [];
        $.each(state.order, function (i, col) {
          settings.aaSorting.push(col[0] >= columns.length ? [0, col[1]] : col);
        });
      } // Search


      if (state.search !== undefined) {
        $.extend(settings.oPreviousSearch, _fnSearchToHung(state.search));
      } // Columns


      for (i = 0, ien = state.columns.length; i < ien; i++) {
        var col = state.columns[i]; // Visibility

        if (col.visible !== undefined) {
          columns[i].bVisible = col.visible;
        } // Search


        if (col.search !== undefined) {
          $.extend(settings.aoPreSearchCols[i], _fnSearchToHung(col.search));
        }
      }

      _fnCallbackFire(settings, 'aoStateLoaded', 'stateLoaded', [settings, state]);
    }
    /**
     * Return the settings object for a particular table
     *  @param {node} table table we are using as a dataTable
     *  @returns {object} Settings object - or null if not found
     *  @memberof DataTable#oApi
     */


    function _fnSettingsFromNode(table) {
      var settings = _DataTable.settings;
      var idx = $.inArray(table, _pluck(settings, 'nTable'));
      return idx !== -1 ? settings[idx] : null;
    }
    /**
     * Log an error message
     *  @param {object} settings dataTables settings object
     *  @param {int} level log error messages, or display them to the user
     *  @param {string} msg error message
     *  @param {int} tn Technical note id to get more information about the error.
     *  @memberof DataTable#oApi
     */


    function _fnLog(settings, level, msg, tn) {
      msg = 'DataTables warning: ' + (settings !== null ? 'table id=' + settings.sTableId + ' - ' : '') + msg;

      if (tn) {
        msg += '. For more information about this error, please see ' + 'http://datatables.net/tn/' + tn;
      }

      if (!level) {
        // Backwards compatibility pre 1.10
        var ext = _DataTable.ext;
        var type = ext.sErrMode || ext.errMode;

        _fnCallbackFire(settings, null, 'error', [settings, tn, msg]);

        if (type == 'alert') {
          alert(msg);
        } else if (type == 'throw') {
          throw new Error(msg);
        } else if (typeof type == 'function') {
          type(settings, tn, msg);
        }
      } else if (window.console && console.log) {
        console.log(msg);
      }
    }
    /**
     * See if a property is defined on one object, if so assign it to the other object
     *  @param {object} ret target object
     *  @param {object} src source object
     *  @param {string} name property
     *  @param {string} [mappedName] name to map too - optional, name used if not given
     *  @memberof DataTable#oApi
     */


    function _fnMap(ret, src, name, mappedName) {
      if ($.isArray(name)) {
        $.each(name, function (i, val) {
          if ($.isArray(val)) {
            _fnMap(ret, src, val[0], val[1]);
          } else {
            _fnMap(ret, src, val);
          }
        });
        return;
      }

      if (mappedName === undefined) {
        mappedName = name;
      }

      if (src[name] !== undefined) {
        ret[mappedName] = src[name];
      }
    }
    /**
     * Extend objects - very similar to jQuery.extend, but deep copy objects, and
     * shallow copy arrays. The reason we need to do this, is that we don't want to
     * deep copy array init values (such as aaSorting) since the dev wouldn't be
     * able to override them, but we do want to deep copy arrays.
     *  @param {object} out Object to extend
     *  @param {object} extender Object from which the properties will be applied to
     *      out
     *  @param {boolean} breakRefs If true, then arrays will be sliced to take an
     *      independent copy with the exception of the `data` or `aaData` parameters
     *      if they are present. This is so you can pass in a collection to
     *      DataTables and have that used as your data source without breaking the
     *      references
     *  @returns {object} out Reference, just for convenience - out === the return.
     *  @memberof DataTable#oApi
     *  @todo This doesn't take account of arrays inside the deep copied objects.
     */


    function _fnExtend(out, extender, breakRefs) {
      var val;

      for (var prop in extender) {
        if (extender.hasOwnProperty(prop)) {
          val = extender[prop];

          if ($.isPlainObject(val)) {
            if (!$.isPlainObject(out[prop])) {
              out[prop] = {};
            }

            $.extend(true, out[prop], val);
          } else if (breakRefs && prop !== 'data' && prop !== 'aaData' && $.isArray(val)) {
            out[prop] = val.slice();
          } else {
            out[prop] = val;
          }
        }
      }

      return out;
    }
    /**
     * Bind an event handers to allow a click or return key to activate the callback.
     * This is good for accessibility since a return on the keyboard will have the
     * same effect as a click, if the element has focus.
     *  @param {element} n Element to bind the action to
     *  @param {object} oData Data object to pass to the triggered function
     *  @param {function} fn Callback function for when the event is triggered
     *  @memberof DataTable#oApi
     */


    function _fnBindAction(n, oData, fn) {
      $(n).bind('click.DT', oData, function (e) {
        n.blur(); // Remove focus outline for mouse users

        fn(e);
      }).bind('keypress.DT', oData, function (e) {
        if (e.which === 13) {
          e.preventDefault();
          fn(e);
        }
      }).bind('selectstart.DT', function () {
        /* Take the brutal approach to cancelling text selection */
        return false;
      });
    }
    /**
     * Register a callback function. Easily allows a callback function to be added to
     * an array store of callback functions that can then all be called together.
     *  @param {object} oSettings dataTables settings object
     *  @param {string} sStore Name of the array storage for the callbacks in oSettings
     *  @param {function} fn Function to be called back
     *  @param {string} sName Identifying name for the callback (i.e. a label)
     *  @memberof DataTable#oApi
     */


    function _fnCallbackReg(oSettings, sStore, fn, sName) {
      if (fn) {
        oSettings[sStore].push({
          "fn": fn,
          "sName": sName
        });
      }
    }
    /**
     * Fire callback functions and trigger events. Note that the loop over the
     * callback array store is done backwards! Further note that you do not want to
     * fire off triggers in time sensitive applications (for example cell creation)
     * as its slow.
     *  @param {object} settings dataTables settings object
     *  @param {string} callbackArr Name of the array storage for the callbacks in
     *      oSettings
     *  @param {string} eventName Name of the jQuery custom event to trigger. If
     *      null no trigger is fired
     *  @param {array} args Array of arguments to pass to the callback function /
     *      trigger
     *  @memberof DataTable#oApi
     */


    function _fnCallbackFire(settings, callbackArr, eventName, args) {
      var ret = [];

      if (callbackArr) {
        ret = $.map(settings[callbackArr].slice().reverse(), function (val, i) {
          return val.fn.apply(settings.oInstance, args);
        });
      }

      if (eventName !== null) {
        var e = $.Event(eventName + '.dt');
        $(settings.nTable).trigger(e, args);
        ret.push(e.result);
      }

      return ret;
    }

    function _fnLengthOverflow(settings) {
      var start = settings._iDisplayStart,
          end = settings.fnDisplayEnd(),
          len = settings._iDisplayLength;
      /* If we have space to show extra rows (backing up from the end point - then do so */

      if (start >= end) {
        start = end - len;
      } // Keep the start record on the current page


      start -= start % len;

      if (len === -1 || start < 0) {
        start = 0;
      }

      settings._iDisplayStart = start;
    }

    function _fnRenderer(settings, type) {
      var renderer = settings.renderer;
      var host = _DataTable.ext.renderer[type];

      if ($.isPlainObject(renderer) && renderer[type]) {
        // Specific renderer for this type. If available use it, otherwise use
        // the default.
        return host[renderer[type]] || host._;
      } else if (typeof renderer === 'string') {
        // Common renderer - if there is one available for this type use it,
        // otherwise use the default
        return host[renderer] || host._;
      } // Use the default


      return host._;
    }
    /**
     * Detect the data source being used for the table. Used to simplify the code
     * a little (ajax) and to make it compress a little smaller.
     *
     *  @param {object} settings dataTables settings object
     *  @returns {string} Data source
     *  @memberof DataTable#oApi
     */


    function _fnDataSource(settings) {
      if (settings.oFeatures.bServerSide) {
        return 'ssp';
      } else if (settings.ajax || settings.sAjaxSource) {
        return 'ajax';
      }

      return 'dom';
    }

    _DataTable = function DataTable(options) {
      /**
       * Perform a jQuery selector action on the table's TR elements (from the tbody) and
       * return the resulting jQuery object.
       *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
       *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
       *  @param {string} [oOpts.filter=none] Select TR elements that meet the current filter
       *    criterion ("applied") or all TR elements (i.e. no filter).
       *  @param {string} [oOpts.order=current] Order of the TR elements in the processed array.
       *    Can be either 'current', whereby the current sorting of the table is used, or
       *    'original' whereby the original order the data was read into the table is used.
       *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
       *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
       *    'current' and filter is 'applied', regardless of what they might be given as.
       *  @returns {object} jQuery object, filtered by the given selector.
       *  @dtopt API
       *  @deprecated Since v1.10
       *
       *  @example
       *    $(document).ready(function() {
       *      var oTable = $('#example').dataTable();
       *
       *      // Highlight every second row
       *      oTable.$('tr:odd').css('backgroundColor', 'blue');
       *    } );
       *
       *  @example
       *    $(document).ready(function() {
       *      var oTable = $('#example').dataTable();
       *
       *      // Filter to rows with 'Webkit' in them, add a background colour and then
       *      // remove the filter, thus highlighting the 'Webkit' rows only.
       *      oTable.fnFilter('Webkit');
       *      oTable.$('tr', {"search": "applied"}).css('backgroundColor', 'blue');
       *      oTable.fnFilter('');
       *    } );
       */
      this.$ = function (sSelector, oOpts) {
        return this.api(true).$(sSelector, oOpts);
      };
      /**
       * Almost identical to $ in operation, but in this case returns the data for the matched
       * rows - as such, the jQuery selector used should match TR row nodes or TD/TH cell nodes
       * rather than any descendants, so the data can be obtained for the row/cell. If matching
       * rows are found, the data returned is the original data array/object that was used to
       * create the row (or a generated array if from a DOM source).
       *
       * This method is often useful in-combination with $ where both functions are given the
       * same parameters and the array indexes will match identically.
       *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
       *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
       *  @param {string} [oOpts.filter=none] Select elements that meet the current filter
       *    criterion ("applied") or all elements (i.e. no filter).
       *  @param {string} [oOpts.order=current] Order of the data in the processed array.
       *    Can be either 'current', whereby the current sorting of the table is used, or
       *    'original' whereby the original order the data was read into the table is used.
       *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
       *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
       *    'current' and filter is 'applied', regardless of what they might be given as.
       *  @returns {array} Data for the matched elements. If any elements, as a result of the
       *    selector, were not TR, TD or TH elements in the DataTable, they will have a null
       *    entry in the array.
       *  @dtopt API
       *  @deprecated Since v1.10
       *
       *  @example
       *    $(document).ready(function() {
       *      var oTable = $('#example').dataTable();
       *
       *      // Get the data from the first row in the table
       *      var data = oTable._('tr:first');
       *
       *      // Do something useful with the data
       *      alert( "First cell is: "+data[0] );
       *    } );
       *
       *  @example
       *    $(document).ready(function() {
       *      var oTable = $('#example').dataTable();
       *
       *      // Filter to 'Webkit' and get all data for
       *      oTable.fnFilter('Webkit');
       *      var data = oTable._('tr', {"search": "applied"});
       *
       *      // Do something with the data
       *      alert( data.length+" rows matched the search" );
       *    } );
       */


      this._ = function (sSelector, oOpts) {
        return this.api(true).rows(sSelector, oOpts).data();
      };
      /**
       * Create a DataTables Api instance, with the currently selected tables for
       * the Api's context.
       * @param {boolean} [traditional=false] Set the API instance's context to be
       *   only the table referred to by the `DataTable.ext.iApiIndex` option, as was
       *   used in the API presented by DataTables 1.9- (i.e. the traditional mode),
       *   or if all tables captured in the jQuery object should be used.
       * @return {DataTables.Api}
       */


      this.api = function (traditional) {
        return traditional ? new _Api2(_fnSettingsFromNode(this[_ext.iApiIndex])) : new _Api2(this);
      };
      /**
       * Add a single new row or multiple rows of data to the table. Please note
       * that this is suitable for client-side processing only - if you are using
       * server-side processing (i.e. "bServerSide": true), then to add data, you
       * must add it to the data source, i.e. the server-side, through an Ajax call.
       *  @param {array|object} data The data to be added to the table. This can be:
       *    <ul>
       *      <li>1D array of data - add a single row with the data provided</li>
       *      <li>2D array of arrays - add multiple rows in a single call</li>
       *      <li>object - data object when using <i>mData</i></li>
       *      <li>array of objects - multiple data objects when using <i>mData</i></li>
       *    </ul>
       *  @param {bool} [redraw=true] redraw the table or not
       *  @returns {array} An array of integers, representing the list of indexes in
       *    <i>aoData</i> ({@link DataTable.models.oSettings}) that have been added to
       *    the table.
       *  @dtopt API
       *  @deprecated Since v1.10
       *
       *  @example
       *    // Global var for counter
       *    var giCount = 2;
       *
       *    $(document).ready(function() {
       *      $('#example').dataTable();
       *    } );
       *
       *    function fnClickAddRow() {
       *      $('#example').dataTable().fnAddData( [
       *        giCount+".1",
       *        giCount+".2",
       *        giCount+".3",
       *        giCount+".4" ]
       *      );
       *
       *      giCount++;
       *    }
       */


      this.fnAddData = function (data, redraw) {
        var api = this.api(true);
        /* Check if we want to add multiple rows or not */

        var rows = $.isArray(data) && ($.isArray(data[0]) || $.isPlainObject(data[0])) ? api.rows.add(data) : api.row.add(data);

        if (redraw === undefined || redraw) {
          api.draw();
        }

        return rows.flatten().toArray();
      };
      /**
       * This function will make DataTables recalculate the column sizes, based on the data
       * contained in the table and the sizes applied to the columns (in the DOM, CSS or
       * through the sWidth parameter). This can be useful when the width of the table's
       * parent element changes (for example a window resize).
       *  @param {boolean} [bRedraw=true] Redraw the table or not, you will typically want to
       *  @dtopt API
       *  @deprecated Since v1.10
       *
       *  @example
       *    $(document).ready(function() {
       *      var oTable = $('#example').dataTable( {
       *        "sScrollY": "200px",
       *        "bPaginate": false
       *      } );
       *
       *      $(window).bind('resize', function () {
       *        oTable.fnAdjustColumnSizing();
       *      } );
       *    } );
       */


      this.fnAdjustColumnSizing = function (bRedraw) {
        var api = this.api(true).columns.adjust();
        var settings = api.settings()[0];
        var scroll = settings.oScroll;

        if (bRedraw === undefined || bRedraw) {
          api.draw(false);
        } else if (scroll.sX !== "" || scroll.sY !== "") {
          /* If not redrawing, but scrolling, we want to apply the new column sizes anyway */
          _fnScrollDraw(settings);
        }
      };
      /**
       * Quickly and simply clear a table
       *  @param {bool} [bRedraw=true] redraw the table or not
       *  @dtopt API
       *  @deprecated Since v1.10
       *
       *  @example
       *    $(document).ready(function() {
       *      var oTable = $('#example').dataTable();
       *
       *      // Immediately 'nuke' the current rows (perhaps waiting for an Ajax callback...)
       *      oTable.fnClearTable();
       *    } );
       */


      this.fnClearTable = function (bRedraw) {
        var api = this.api(true).clear();

        if (bRedraw === undefined || bRedraw) {
          api.draw();
        }
      };
      /**
       * The exact opposite of 'opening' a row, this function will close any rows which
       * are currently 'open'.
       *  @param {node} nTr the table row to 'close'
       *  @returns {int} 0 on success, or 1 if failed (can't find the row)
       *  @dtopt API
       *  @deprecated Since v1.10
       *
       *  @example
       *    $(document).ready(function() {
       *      var oTable;
       *
       *      // 'open' an information row when a row is clicked on
       *      $('#example tbody tr').click( function () {
       *        if ( oTable.fnIsOpen(this) ) {
       *          oTable.fnClose( this );
       *        } else {
       *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
       *        }
       *      } );
       *
       *      oTable = $('#example').dataTable();
       *    } );
       */


      this.fnClose = function (nTr) {
        this.api(true).row(nTr).child.hide();
      };
      /**
       * Remove a row for the table
       *  @param {mixed} target The index of the row from aoData to be deleted, or
       *    the TR element you want to delete
       *  @param {function|null} [callBack] Callback function
       *  @param {bool} [redraw=true] Redraw the table or not
       *  @returns {array} The row that was deleted
       *  @dtopt API
       *  @deprecated Since v1.10
       *
       *  @example
       *    $(document).ready(function() {
       *      var oTable = $('#example').dataTable();
       *
       *      // Immediately remove the first row
       *      oTable.fnDeleteRow( 0 );
       *    } );
       */


      this.fnDeleteRow = function (target, callback, redraw) {
        var api = this.api(true);
        var rows = api.rows(target);
        var settings = rows.settings()[0];
        var data = settings.aoData[rows[0][0]];
        rows.remove();

        if (callback) {
          callback.call(this, settings, data);
        }

        if (redraw === undefined || redraw) {
          api.draw();
        }

        return data;
      };
      /**
       * Restore the table to it's original state in the DOM by removing all of DataTables
       * enhancements, alterations to the DOM structure of the table and event listeners.
       *  @param {boolean} [remove=false] Completely remove the table from the DOM
       *  @dtopt API
       *  @deprecated Since v1.10
       *
       *  @example
       *    $(document).ready(function() {
       *      // This example is fairly pointless in reality, but shows how fnDestroy can be used
       *      var oTable = $('#example').dataTable();
       *      oTable.fnDestroy();
       *    } );
       */


      this.fnDestroy = function (remove) {
        this.api(true).destroy(remove);
      };
      /**
       * Redraw the table
       *  @param {bool} [complete=true] Re-filter and resort (if enabled) the table before the draw.
       *  @dtopt API
       *  @deprecated Since v1.10
       *
       *  @example
       *    $(document).ready(function() {
       *      var oTable = $('#example').dataTable();
       *
       *      // Re-draw the table - you wouldn't want to do it here, but it's an example :-)
       *      oTable.fnDraw();
       *    } );
       */


      this.fnDraw = function (complete) {
        // Note that this isn't an exact match to the old call to _fnDraw - it takes
        // into account the new data, but can hold position.
        this.api(true).draw(complete);
      };
      /**
       * Filter the input based on data
       *  @param {string} sInput String to filter the table on
       *  @param {int|null} [iColumn] Column to limit filtering to
       *  @param {bool} [bRegex=false] Treat as regular expression or not
       *  @param {bool} [bSmart=true] Perform smart filtering or not
       *  @param {bool} [bShowGlobal=true] Show the input global filter in it's input box(es)
       *  @param {bool} [bCaseInsensitive=true] Do case-insensitive matching (true) or not (false)
       *  @dtopt API
       *  @deprecated Since v1.10
       *
       *  @example
       *    $(document).ready(function() {
       *      var oTable = $('#example').dataTable();
       *
       *      // Sometime later - filter...
       *      oTable.fnFilter( 'test string' );
       *    } );
       */


      this.fnFilter = function (sInput, iColumn, bRegex, bSmart, bShowGlobal, bCaseInsensitive) {
        var api = this.api(true);

        if (iColumn === null || iColumn === undefined) {
          api.search(sInput, bRegex, bSmart, bCaseInsensitive);
        } else {
          api.column(iColumn).search(sInput, bRegex, bSmart, bCaseInsensitive);
        }

        api.draw();
      };
      /**
       * Get the data for the whole table, an individual row or an individual cell based on the
       * provided parameters.
       *  @param {int|node} [src] A TR row node, TD/TH cell node or an integer. If given as
       *    a TR node then the data source for the whole row will be returned. If given as a
       *    TD/TH cell node then iCol will be automatically calculated and the data for the
       *    cell returned. If given as an integer, then this is treated as the aoData internal
       *    data index for the row (see fnGetPosition) and the data for that row used.
       *  @param {int} [col] Optional column index that you want the data of.
       *  @returns {array|object|string} If mRow is undefined, then the data for all rows is
       *    returned. If mRow is defined, just data for that row, and is iCol is
       *    defined, only data for the designated cell is returned.
       *  @dtopt API
       *  @deprecated Since v1.10
       *
       *  @example
       *    // Row data
       *    $(document).ready(function() {
       *      oTable = $('#example').dataTable();
       *
       *      oTable.$('tr').click( function () {
       *        var data = oTable.fnGetData( this );
       *        // ... do something with the array / object of data for the row
       *      } );
       *    } );
       *
       *  @example
       *    // Individual cell data
       *    $(document).ready(function() {
       *      oTable = $('#example').dataTable();
       *
       *      oTable.$('td').click( function () {
       *        var sData = oTable.fnGetData( this );
       *        alert( 'The cell clicked on had the value of '+sData );
       *      } );
       *    } );
       */


      this.fnGetData = function (src, col) {
        var api = this.api(true);

        if (src !== undefined) {
          var type = src.nodeName ? src.nodeName.toLowerCase() : '';
          return col !== undefined || type == 'td' || type == 'th' ? api.cell(src, col).data() : api.row(src).data() || null;
        }

        return api.data().toArray();
      };
      /**
       * Get an array of the TR nodes that are used in the table's body. Note that you will
       * typically want to use the '$' API method in preference to this as it is more
       * flexible.
       *  @param {int} [iRow] Optional row index for the TR element you want
       *  @returns {array|node} If iRow is undefined, returns an array of all TR elements
       *    in the table's body, or iRow is defined, just the TR element requested.
       *  @dtopt API
       *  @deprecated Since v1.10
       *
       *  @example
       *    $(document).ready(function() {
       *      var oTable = $('#example').dataTable();
       *
       *      // Get the nodes from the table
       *      var nNodes = oTable.fnGetNodes( );
       *    } );
       */


      this.fnGetNodes = function (iRow) {
        var api = this.api(true);
        return iRow !== undefined ? api.row(iRow).node() : api.rows().nodes().flatten().toArray();
      };
      /**
       * Get the array indexes of a particular cell from it's DOM element
       * and column index including hidden columns
       *  @param {node} node this can either be a TR, TD or TH in the table's body
       *  @returns {int} If nNode is given as a TR, then a single index is returned, or
       *    if given as a cell, an array of [row index, column index (visible),
       *    column index (all)] is given.
       *  @dtopt API
       *  @deprecated Since v1.10
       *
       *  @example
       *    $(document).ready(function() {
       *      $('#example tbody td').click( function () {
       *        // Get the position of the current data from the node
       *        var aPos = oTable.fnGetPosition( this );
       *
       *        // Get the data array for this row
       *        var aData = oTable.fnGetData( aPos[0] );
       *
       *        // Update the data array and return the value
       *        aData[ aPos[1] ] = 'clicked';
       *        this.innerHTML = 'clicked';
       *      } );
       *
       *      // Init DataTables
       *      oTable = $('#example').dataTable();
       *    } );
       */


      this.fnGetPosition = function (node) {
        var api = this.api(true);
        var nodeName = node.nodeName.toUpperCase();

        if (nodeName == 'TR') {
          return api.row(node).index();
        } else if (nodeName == 'TD' || nodeName == 'TH') {
          var cell = api.cell(node).index();
          return [cell.row, cell.columnVisible, cell.column];
        }

        return null;
      };
      /**
       * Check to see if a row is 'open' or not.
       *  @param {node} nTr the table row to check
       *  @returns {boolean} true if the row is currently open, false otherwise
       *  @dtopt API
       *  @deprecated Since v1.10
       *
       *  @example
       *    $(document).ready(function() {
       *      var oTable;
       *
       *      // 'open' an information row when a row is clicked on
       *      $('#example tbody tr').click( function () {
       *        if ( oTable.fnIsOpen(this) ) {
       *          oTable.fnClose( this );
       *        } else {
       *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
       *        }
       *      } );
       *
       *      oTable = $('#example').dataTable();
       *    } );
       */


      this.fnIsOpen = function (nTr) {
        return this.api(true).row(nTr).child.isShown();
      };
      /**
       * This function will place a new row directly after a row which is currently
       * on display on the page, with the HTML contents that is passed into the
       * function. This can be used, for example, to ask for confirmation that a
       * particular record should be deleted.
       *  @param {node} nTr The table row to 'open'
       *  @param {string|node|jQuery} mHtml The HTML to put into the row
       *  @param {string} sClass Class to give the new TD cell
       *  @returns {node} The row opened. Note that if the table row passed in as the
       *    first parameter, is not found in the table, this method will silently
       *    return.
       *  @dtopt API
       *  @deprecated Since v1.10
       *
       *  @example
       *    $(document).ready(function() {
       *      var oTable;
       *
       *      // 'open' an information row when a row is clicked on
       *      $('#example tbody tr').click( function () {
       *        if ( oTable.fnIsOpen(this) ) {
       *          oTable.fnClose( this );
       *        } else {
       *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
       *        }
       *      } );
       *
       *      oTable = $('#example').dataTable();
       *    } );
       */


      this.fnOpen = function (nTr, mHtml, sClass) {
        return this.api(true).row(nTr).child(mHtml, sClass).show().child()[0];
      };
      /**
       * Change the pagination - provides the internal logic for pagination in a simple API
       * function. With this function you can have a DataTables table go to the next,
       * previous, first or last pages.
       *  @param {string|int} mAction Paging action to take: "first", "previous", "next" or "last"
       *    or page number to jump to (integer), note that page 0 is the first page.
       *  @param {bool} [bRedraw=true] Redraw the table or not
       *  @dtopt API
       *  @deprecated Since v1.10
       *
       *  @example
       *    $(document).ready(function() {
       *      var oTable = $('#example').dataTable();
       *      oTable.fnPageChange( 'next' );
       *    } );
       */


      this.fnPageChange = function (mAction, bRedraw) {
        var api = this.api(true).page(mAction);

        if (bRedraw === undefined || bRedraw) {
          api.draw(false);
        }
      };
      /**
       * Show a particular column
       *  @param {int} iCol The column whose display should be changed
       *  @param {bool} bShow Show (true) or hide (false) the column
       *  @param {bool} [bRedraw=true] Redraw the table or not
       *  @dtopt API
       *  @deprecated Since v1.10
       *
       *  @example
       *    $(document).ready(function() {
       *      var oTable = $('#example').dataTable();
       *
       *      // Hide the second column after initialisation
       *      oTable.fnSetColumnVis( 1, false );
       *    } );
       */


      this.fnSetColumnVis = function (iCol, bShow, bRedraw) {
        var api = this.api(true).column(iCol).visible(bShow);

        if (bRedraw === undefined || bRedraw) {
          api.columns.adjust().draw();
        }
      };
      /**
       * Get the settings for a particular table for external manipulation
       *  @returns {object} DataTables settings object. See
       *    {@link DataTable.models.oSettings}
       *  @dtopt API
       *  @deprecated Since v1.10
       *
       *  @example
       *    $(document).ready(function() {
       *      var oTable = $('#example').dataTable();
       *      var oSettings = oTable.fnSettings();
       *
       *      // Show an example parameter from the settings
       *      alert( oSettings._iDisplayStart );
       *    } );
       */


      this.fnSettings = function () {
        return _fnSettingsFromNode(this[_ext.iApiIndex]);
      };
      /**
       * Sort the table by a particular column
       *  @param {int} iCol the data index to sort on. Note that this will not match the
       *    'display index' if you have hidden data entries
       *  @dtopt API
       *  @deprecated Since v1.10
       *
       *  @example
       *    $(document).ready(function() {
       *      var oTable = $('#example').dataTable();
       *
       *      // Sort immediately with columns 0 and 1
       *      oTable.fnSort( [ [0,'asc'], [1,'asc'] ] );
       *    } );
       */


      this.fnSort = function (aaSort) {
        this.api(true).order(aaSort).draw();
      };
      /**
       * Attach a sort listener to an element for a given column
       *  @param {node} nNode the element to attach the sort listener to
       *  @param {int} iColumn the column that a click on this node will sort on
       *  @param {function} [fnCallback] callback function when sort is run
       *  @dtopt API
       *  @deprecated Since v1.10
       *
       *  @example
       *    $(document).ready(function() {
       *      var oTable = $('#example').dataTable();
       *
       *      // Sort on column 1, when 'sorter' is clicked on
       *      oTable.fnSortListener( document.getElementById('sorter'), 1 );
       *    } );
       */


      this.fnSortListener = function (nNode, iColumn, fnCallback) {
        this.api(true).order.listener(nNode, iColumn, fnCallback);
      };
      /**
       * Update a table cell or row - this method will accept either a single value to
       * update the cell with, an array of values with one element for each column or
       * an object in the same format as the original data source. The function is
       * self-referencing in order to make the multi column updates easier.
       *  @param {object|array|string} mData Data to update the cell/row with
       *  @param {node|int} mRow TR element you want to update or the aoData index
       *  @param {int} [iColumn] The column to update, give as null or undefined to
       *    update a whole row.
       *  @param {bool} [bRedraw=true] Redraw the table or not
       *  @param {bool} [bAction=true] Perform pre-draw actions or not
       *  @returns {int} 0 on success, 1 on error
       *  @dtopt API
       *  @deprecated Since v1.10
       *
       *  @example
       *    $(document).ready(function() {
       *      var oTable = $('#example').dataTable();
       *      oTable.fnUpdate( 'Example update', 0, 0 ); // Single cell
       *      oTable.fnUpdate( ['a', 'b', 'c', 'd', 'e'], $('tbody tr')[0] ); // Row
       *    } );
       */


      this.fnUpdate = function (mData, mRow, iColumn, bRedraw, bAction) {
        var api = this.api(true);

        if (iColumn === undefined || iColumn === null) {
          api.row(mRow).data(mData);
        } else {
          api.cell(mRow, iColumn).data(mData);
        }

        if (bAction === undefined || bAction) {
          api.columns.adjust();
        }

        if (bRedraw === undefined || bRedraw) {
          api.draw();
        }

        return 0;
      };
      /**
       * Provide a common method for plug-ins to check the version of DataTables being used, in order
       * to ensure compatibility.
       *  @param {string} sVersion Version string to check for, in the format "X.Y.Z". Note that the
       *    formats "X" and "X.Y" are also acceptable.
       *  @returns {boolean} true if this version of DataTables is greater or equal to the required
       *    version, or false if this version of DataTales is not suitable
       *  @method
       *  @dtopt API
       *  @deprecated Since v1.10
       *
       *  @example
       *    $(document).ready(function() {
       *      var oTable = $('#example').dataTable();
       *      alert( oTable.fnVersionCheck( '1.9.0' ) );
       *    } );
       */


      this.fnVersionCheck = _ext.fnVersionCheck;

      var _that = this;

      var emptyInit = options === undefined;
      var len = this.length;

      if (emptyInit) {
        options = {};
      }

      this.oApi = this.internal = _ext.internal; // Extend with old style plug-in API methods

      for (var fn in _DataTable.ext.internal) {
        if (fn) {
          this[fn] = _fnExternApiFunc(fn);
        }
      }

      this.each(function () {
        // For each initialisation we want to give it a clean initialisation
        // object that can be bashed around
        var o = {};
        var oInit = len > 1 ? // optimisation for single table case
        _fnExtend(o, options, true) : options;
        /*global oInit,_that,emptyInit*/

        var i = 0,
            iLen,
            j,
            jLen,
            k,
            kLen;
        var sId = this.getAttribute('id');
        var bInitHandedOff = false;
        var defaults = _DataTable.defaults;
        var $this = $(this);
        /* Sanity check */

        if (this.nodeName.toLowerCase() != 'table') {
          _fnLog(null, 0, 'Non-table node initialisation (' + this.nodeName + ')', 2);

          return;
        }
        /* Backwards compatibility for the defaults */


        _fnCompatOpts(defaults);

        _fnCompatCols(defaults.column);
        /* Convert the camel-case defaults to Hungarian */


        _fnCamelToHungarian(defaults, defaults, true);

        _fnCamelToHungarian(defaults.column, defaults.column, true);
        /* Setting up the initialisation object */


        _fnCamelToHungarian(defaults, $.extend(oInit, $this.data()));
        /* Check to see if we are re-initialising a table */


        var allSettings = _DataTable.settings;

        for (i = 0, iLen = allSettings.length; i < iLen; i++) {
          var s = allSettings[i];
          /* Base check on table node */

          if (s.nTable == this || s.nTHead.parentNode == this || s.nTFoot && s.nTFoot.parentNode == this) {
            var bRetrieve = oInit.bRetrieve !== undefined ? oInit.bRetrieve : defaults.bRetrieve;
            var bDestroy = oInit.bDestroy !== undefined ? oInit.bDestroy : defaults.bDestroy;

            if (emptyInit || bRetrieve) {
              return s.oInstance;
            } else if (bDestroy) {
              s.oInstance.fnDestroy();
              break;
            } else {
              _fnLog(s, 0, 'Cannot reinitialise DataTable', 3);

              return;
            }
          }
          /* If the element we are initialising has the same ID as a table which was previously
           * initialised, but the table nodes don't match (from before) then we destroy the old
           * instance by simply deleting it. This is under the assumption that the table has been
           * destroyed by other methods. Anyone using non-id selectors will need to do this manually
           */


          if (s.sTableId == this.id) {
            allSettings.splice(i, 1);
            break;
          }
        }
        /* Ensure the table has an ID - required for accessibility */


        if (sId === null || sId === "") {
          sId = "DataTables_Table_" + _DataTable.ext._unique++;
          this.id = sId;
        }
        /* Create the settings object for this table and set some of the default parameters */


        var oSettings = $.extend(true, {}, _DataTable.models.oSettings, {
          "sDestroyWidth": $this[0].style.width,
          "sInstance": sId,
          "sTableId": sId
        });
        oSettings.nTable = this;
        oSettings.oApi = _that.internal;
        oSettings.oInit = oInit;
        allSettings.push(oSettings); // Need to add the instance after the instance after the settings object has been added
        // to the settings array, so we can self reference the table instance if more than one

        oSettings.oInstance = _that.length === 1 ? _that : $this.dataTable(); // Backwards compatibility, before we apply all the defaults

        _fnCompatOpts(oInit);

        if (oInit.oLanguage) {
          _fnLanguageCompat(oInit.oLanguage);
        } // If the length menu is given, but the init display length is not, use the length menu


        if (oInit.aLengthMenu && !oInit.iDisplayLength) {
          oInit.iDisplayLength = $.isArray(oInit.aLengthMenu[0]) ? oInit.aLengthMenu[0][0] : oInit.aLengthMenu[0];
        } // Apply the defaults and init options to make a single init object will all
        // options defined from defaults and instance options.


        oInit = _fnExtend($.extend(true, {}, defaults), oInit); // Map the initialisation options onto the settings object

        _fnMap(oSettings.oFeatures, oInit, ["bPaginate", "bLengthChange", "bFilter", "bSort", "bSortMulti", "bInfo", "bProcessing", "bAutoWidth", "bSortClasses", "bServerSide", "bDeferRender"]);

        _fnMap(oSettings, oInit, ["asStripeClasses", "ajax", "fnServerData", "fnFormatNumber", "sServerMethod", "aaSorting", "aaSortingFixed", "aLengthMenu", "sPaginationType", "sAjaxSource", "sAjaxDataProp", "iStateDuration", "sDom", "bSortCellsTop", "iTabIndex", "fnStateLoadCallback", "fnStateSaveCallback", "renderer", "searchDelay", ["iCookieDuration", "iStateDuration"], // backwards compat
        ["oSearch", "oPreviousSearch"], ["aoSearchCols", "aoPreSearchCols"], ["iDisplayLength", "_iDisplayLength"], ["bJQueryUI", "bJUI"]]);

        _fnMap(oSettings.oScroll, oInit, [["sScrollX", "sX"], ["sScrollXInner", "sXInner"], ["sScrollY", "sY"], ["bScrollCollapse", "bCollapse"]]);

        _fnMap(oSettings.oLanguage, oInit, "fnInfoCallback");
        /* Callback functions which are array driven */


        _fnCallbackReg(oSettings, 'aoDrawCallback', oInit.fnDrawCallback, 'user');

        _fnCallbackReg(oSettings, 'aoServerParams', oInit.fnServerParams, 'user');

        _fnCallbackReg(oSettings, 'aoStateSaveParams', oInit.fnStateSaveParams, 'user');

        _fnCallbackReg(oSettings, 'aoStateLoadParams', oInit.fnStateLoadParams, 'user');

        _fnCallbackReg(oSettings, 'aoStateLoaded', oInit.fnStateLoaded, 'user');

        _fnCallbackReg(oSettings, 'aoRowCallback', oInit.fnRowCallback, 'user');

        _fnCallbackReg(oSettings, 'aoRowCreatedCallback', oInit.fnCreatedRow, 'user');

        _fnCallbackReg(oSettings, 'aoHeaderCallback', oInit.fnHeaderCallback, 'user');

        _fnCallbackReg(oSettings, 'aoFooterCallback', oInit.fnFooterCallback, 'user');

        _fnCallbackReg(oSettings, 'aoInitComplete', oInit.fnInitComplete, 'user');

        _fnCallbackReg(oSettings, 'aoPreDrawCallback', oInit.fnPreDrawCallback, 'user');

        var oClasses = oSettings.oClasses; // @todo Remove in 1.11

        if (oInit.bJQueryUI) {
          /* Use the JUI classes object for display. You could clone the oStdClasses object if
           * you want to have multiple tables with multiple independent classes
           */
          $.extend(oClasses, _DataTable.ext.oJUIClasses, oInit.oClasses);

          if (oInit.sDom === defaults.sDom && defaults.sDom === "lfrtip") {
            /* Set the DOM to use a layout suitable for jQuery UI's theming */
            oSettings.sDom = '<"H"lfr>t<"F"ip>';
          }

          if (!oSettings.renderer) {
            oSettings.renderer = 'jqueryui';
          } else if ($.isPlainObject(oSettings.renderer) && !oSettings.renderer.header) {
            oSettings.renderer.header = 'jqueryui';
          }
        } else {
          $.extend(oClasses, _DataTable.ext.classes, oInit.oClasses);
        }

        $this.addClass(oClasses.sTable);
        /* Calculate the scroll bar width and cache it for use later on */

        if (oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "") {
          oSettings.oScroll.iBarWidth = _fnScrollBarWidth();
        }

        if (oSettings.oScroll.sX === true) {
          // Easy initialisation of x-scrolling
          oSettings.oScroll.sX = '100%';
        }

        if (oSettings.iInitDisplayStart === undefined) {
          /* Display start point, taking into account the save saving */
          oSettings.iInitDisplayStart = oInit.iDisplayStart;
          oSettings._iDisplayStart = oInit.iDisplayStart;
        }

        if (oInit.iDeferLoading !== null) {
          oSettings.bDeferLoading = true;
          var tmp = $.isArray(oInit.iDeferLoading);
          oSettings._iRecordsDisplay = tmp ? oInit.iDeferLoading[0] : oInit.iDeferLoading;
          oSettings._iRecordsTotal = tmp ? oInit.iDeferLoading[1] : oInit.iDeferLoading;
        }
        /* Language definitions */


        var oLanguage = oSettings.oLanguage;
        $.extend(true, oLanguage, oInit.oLanguage);

        if (oLanguage.sUrl !== "") {
          /* Get the language definitions from a file - because this Ajax call makes the language
           * get async to the remainder of this function we use bInitHandedOff to indicate that
           * _fnInitialise will be fired by the returned Ajax handler, rather than the constructor
           */
          $.ajax({
            dataType: 'json',
            url: oLanguage.sUrl,
            success: function success(json) {
              _fnLanguageCompat(json);

              _fnCamelToHungarian(defaults.oLanguage, json);

              $.extend(true, oLanguage, json);

              _fnInitialise(oSettings);
            },
            error: function error() {
              // Error occurred loading language file, continue on as best we can
              _fnInitialise(oSettings);
            }
          });
          bInitHandedOff = true;
        }
        /*
         * Stripes
         */


        if (oInit.asStripeClasses === null) {
          oSettings.asStripeClasses = [oClasses.sStripeOdd, oClasses.sStripeEven];
        }
        /* Remove row stripe classes if they are already on the table row */


        var stripeClasses = oSettings.asStripeClasses;
        var rowOne = $this.children('tbody').find('tr').eq(0);

        if ($.inArray(true, $.map(stripeClasses, function (el, i) {
          return rowOne.hasClass(el);
        })) !== -1) {
          $('tbody tr', this).removeClass(stripeClasses.join(' '));
          oSettings.asDestroyStripes = stripeClasses.slice();
        }
        /*
         * Columns
         * See if we should load columns automatically or use defined ones
         */


        var anThs = [];
        var aoColumnsInit;
        var nThead = this.getElementsByTagName('thead');

        if (nThead.length !== 0) {
          _fnDetectHeader(oSettings.aoHeader, nThead[0]);

          anThs = _fnGetUniqueThs(oSettings);
        }
        /* If not given a column array, generate one with nulls */


        if (oInit.aoColumns === null) {
          aoColumnsInit = [];

          for (i = 0, iLen = anThs.length; i < iLen; i++) {
            aoColumnsInit.push(null);
          }
        } else {
          aoColumnsInit = oInit.aoColumns;
        }
        /* Add the columns */


        for (i = 0, iLen = aoColumnsInit.length; i < iLen; i++) {
          _fnAddColumn(oSettings, anThs ? anThs[i] : null);
        }
        /* Apply the column definitions */


        _fnApplyColumnDefs(oSettings, oInit.aoColumnDefs, aoColumnsInit, function (iCol, oDef) {
          _fnColumnOptions(oSettings, iCol, oDef);
        });
        /* HTML5 attribute detection - build an mData object automatically if the
         * attributes are found
         */


        if (rowOne.length) {
          var a = function a(cell, name) {
            return cell.getAttribute('data-' + name) !== null ? name : null;
          };

          $.each(_fnGetRowElements(oSettings, rowOne[0]).cells, function (i, cell) {
            var col = oSettings.aoColumns[i];

            if (col.mData === i) {
              var sort = a(cell, 'sort') || a(cell, 'order');
              var filter = a(cell, 'filter') || a(cell, 'search');

              if (sort !== null || filter !== null) {
                col.mData = {
                  _: i + '.display',
                  sort: sort !== null ? i + '.@data-' + sort : undefined,
                  type: sort !== null ? i + '.@data-' + sort : undefined,
                  filter: filter !== null ? i + '.@data-' + filter : undefined
                };

                _fnColumnOptions(oSettings, i);
              }
            }
          });
        }

        var features = oSettings.oFeatures;
        /* Must be done after everything which can be overridden by the state saving! */

        if (oInit.bStateSave) {
          features.bStateSave = true;

          _fnLoadState(oSettings, oInit);

          _fnCallbackReg(oSettings, 'aoDrawCallback', _fnSaveState, 'state_save');
        }
        /*
         * Sorting
         * @todo For modularisation (1.11) this needs to do into a sort start up handler
         */
        // If aaSorting is not defined, then we use the first indicator in asSorting
        // in case that has been altered, so the default sort reflects that option


        if (oInit.aaSorting === undefined) {
          var sorting = oSettings.aaSorting;

          for (i = 0, iLen = sorting.length; i < iLen; i++) {
            sorting[i][1] = oSettings.aoColumns[i].asSorting[0];
          }
        }
        /* Do a first pass on the sorting classes (allows any size changes to be taken into
         * account, and also will apply sorting disabled classes if disabled
         */


        _fnSortingClasses(oSettings);

        if (features.bSort) {
          _fnCallbackReg(oSettings, 'aoDrawCallback', function () {
            if (oSettings.bSorted) {
              var aSort = _fnSortFlatten(oSettings);

              var sortedColumns = {};
              $.each(aSort, function (i, val) {
                sortedColumns[val.src] = val.dir;
              });

              _fnCallbackFire(oSettings, null, 'order', [oSettings, aSort, sortedColumns]);

              _fnSortAria(oSettings);
            }
          });
        }

        _fnCallbackReg(oSettings, 'aoDrawCallback', function () {
          if (oSettings.bSorted || _fnDataSource(oSettings) === 'ssp' || features.bDeferRender) {
            _fnSortingClasses(oSettings);
          }
        }, 'sc');
        /*
         * Final init
         * Cache the header, body and footer as required, creating them if needed
         */

        /* Browser support detection */


        _fnBrowserDetect(oSettings); // Work around for Webkit bug 83867 - store the caption-side before removing from doc


        var captions = $this.children('caption').each(function () {
          this._captionSide = $this.css('caption-side');
        });
        var thead = $this.children('thead');

        if (thead.length === 0) {
          thead = $('<thead/>').appendTo(this);
        }

        oSettings.nTHead = thead[0];
        var tbody = $this.children('tbody');

        if (tbody.length === 0) {
          tbody = $('<tbody/>').appendTo(this);
        }

        oSettings.nTBody = tbody[0];
        var tfoot = $this.children('tfoot');

        if (tfoot.length === 0 && captions.length > 0 && (oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "")) {
          // If we are a scrolling table, and no footer has been given, then we need to create
          // a tfoot element for the caption element to be appended to
          tfoot = $('<tfoot/>').appendTo(this);
        }

        if (tfoot.length === 0 || tfoot.children().length === 0) {
          $this.addClass(oClasses.sNoFooter);
        } else if (tfoot.length > 0) {
          oSettings.nTFoot = tfoot[0];

          _fnDetectHeader(oSettings.aoFooter, oSettings.nTFoot);
        }
        /* Check if there is data passing into the constructor */


        if (oInit.aaData) {
          for (i = 0; i < oInit.aaData.length; i++) {
            _fnAddData(oSettings, oInit.aaData[i]);
          }
        } else if (oSettings.bDeferLoading || _fnDataSource(oSettings) == 'dom') {
          /* Grab the data from the page - only do this when deferred loading or no Ajax
           * source since there is no point in reading the DOM data if we are then going
           * to replace it with Ajax data
           */
          _fnAddTr(oSettings, $(oSettings.nTBody).children('tr'));
        }
        /* Copy the data index array */


        oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
        /* Initialisation complete - table can be drawn */

        oSettings.bInitialised = true;
        /* Check if we need to initialise the table (it might not have been handed off to the
         * language processor)
         */

        if (bInitHandedOff === false) {
          _fnInitialise(oSettings);
        }
      });
      _that = null;
      return this;
    };
    /**
     * Computed structure of the DataTables API, defined by the options passed to
     * `DataTable.Api.register()` when building the API.
     *
     * The structure is built in order to speed creation and extension of the Api
     * objects since the extensions are effectively pre-parsed.
     *
     * The array is an array of objects with the following structure, where this
     * base array represents the Api prototype base:
     *
     *     [
     *       {
     *         name:      'data'                -- string   - Property name
     *         val:       function () {},       -- function - Api method (or undefined if just an object
     *         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
     *         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
     *       },
     *       {
     *         name:     'row'
     *         val:       {},
     *         methodExt: [ ... ],
     *         propExt:   [
     *           {
     *             name:      'data'
     *             val:       function () {},
     *             methodExt: [ ... ],
     *             propExt:   [ ... ]
     *           },
     *           ...
     *         ]
     *       }
     *     ]
     *
     * @type {Array}
     * @ignore
     */


    var __apiStruct = [];
    /**
     * `Array.prototype` reference.
     *
     * @type object
     * @ignore
     */

    var __arrayProto = Array.prototype;
    /**
     * Abstraction for `context` parameter of the `Api` constructor to allow it to
     * take several different forms for ease of use.
     *
     * Each of the input parameter types will be converted to a DataTables settings
     * object where possible.
     *
     * @param  {string|node|jQuery|object} mixed DataTable identifier. Can be one
     *   of:
     *
     *   * `string` - jQuery selector. Any DataTables' matching the given selector
     *     with be found and used.
     *   * `node` - `TABLE` node which has already been formed into a DataTable.
     *   * `jQuery` - A jQuery object of `TABLE` nodes.
     *   * `object` - DataTables settings object
     *   * `DataTables.Api` - API instance
     * @return {array|null} Matching DataTables settings objects. `null` or
     *   `undefined` is returned if no matching DataTable is found.
     * @ignore
     */

    var _toSettings = function _toSettings(mixed) {
      var idx, jq;
      var settings = _DataTable.settings;
      var tables = $.map(settings, function (el, i) {
        return el.nTable;
      });

      if (!mixed) {
        return [];
      } else if (mixed.nTable && mixed.oApi) {
        // DataTables settings object
        return [mixed];
      } else if (mixed.nodeName && mixed.nodeName.toLowerCase() === 'table') {
        // Table node
        idx = $.inArray(mixed, tables);
        return idx !== -1 ? [settings[idx]] : null;
      } else if (mixed && typeof mixed.settings === 'function') {
        return mixed.settings().toArray();
      } else if (typeof mixed === 'string') {
        // jQuery selector
        jq = $(mixed);
      } else if (mixed instanceof $) {
        // jQuery object (also DataTables instance)
        jq = mixed;
      }

      if (jq) {
        return jq.map(function (i) {
          idx = $.inArray(this, tables);
          return idx !== -1 ? settings[idx] : null;
        }).toArray();
      }
    };
    /**
     * DataTables API class - used to control and interface with  one or more
     * DataTables enhanced tables.
     *
     * The API class is heavily based on jQuery, presenting a chainable interface
     * that you can use to interact with tables. Each instance of the API class has
     * a "context" - i.e. the tables that it will operate on. This could be a single
     * table, all tables on a page or a sub-set thereof.
     *
     * Additionally the API is designed to allow you to easily work with the data in
     * the tables, retrieving and manipulating it as required. This is done by
     * presenting the API class as an array like interface. The contents of the
     * array depend upon the actions requested by each method (for example
     * `rows().nodes()` will return an array of nodes, while `rows().data()` will
     * return an array of objects or arrays depending upon your table's
     * configuration). The API object has a number of array like methods (`push`,
     * `pop`, `reverse` etc) as well as additional helper methods (`each`, `pluck`,
     * `unique` etc) to assist your working with the data held in a table.
     *
     * Most methods (those which return an Api instance) are chainable, which means
     * the return from a method call also has all of the methods available that the
     * top level object had. For example, these two calls are equivalent:
     *
     *     // Not chained
     *     api.row.add( {...} );
     *     api.draw();
     *
     *     // Chained
     *     api.row.add( {...} ).draw();
     *
     * @class DataTable.Api
     * @param {array|object|string|jQuery} context DataTable identifier. This is
     *   used to define which DataTables enhanced tables this API will operate on.
     *   Can be one of:
     *
     *   * `string` - jQuery selector. Any DataTables' matching the given selector
     *     with be found and used.
     *   * `node` - `TABLE` node which has already been formed into a DataTable.
     *   * `jQuery` - A jQuery object of `TABLE` nodes.
     *   * `object` - DataTables settings object
     * @param {array} [data] Data to initialise the Api instance with.
     *
     * @example
     *   // Direct initialisation during DataTables construction
     *   var api = $('#example').DataTable();
     *
     * @example
     *   // Initialisation using a DataTables jQuery object
     *   var api = $('#example').dataTable().api();
     *
     * @example
     *   // Initialisation as a constructor
     *   var api = new $.fn.DataTable.Api( 'table.dataTable' );
     */


    _Api2 = function _Api(context, data) {
      if (!(this instanceof _Api2)) {
        return new _Api2(context, data);
      }

      var settings = [];

      var ctxSettings = function ctxSettings(o) {
        var a = _toSettings(o);

        if (a) {
          settings.push.apply(settings, a);
        }
      };

      if ($.isArray(context)) {
        for (var i = 0, ien = context.length; i < ien; i++) {
          ctxSettings(context[i]);
        }
      } else {
        ctxSettings(context);
      } // Remove duplicates


      this.context = _unique(settings); // Initial data

      if (data) {
        this.push.apply(this, data.toArray ? data.toArray() : data);
      } // selector


      this.selector = {
        rows: null,
        cols: null,
        opts: null
      };

      _Api2.extend(this, this, __apiStruct);
    };

    _DataTable.Api = _Api2;
    _Api2.prototype =
    /** @lends DataTables.Api */
    {
      any: function any() {
        return this.flatten().length !== 0;
      },
      concat: __arrayProto.concat,
      context: [],
      // array of table settings objects
      each: function each(fn) {
        for (var i = 0, ien = this.length; i < ien; i++) {
          fn.call(this, this[i], i, this);
        }

        return this;
      },
      eq: function eq(idx) {
        var ctx = this.context;
        return ctx.length > idx ? new _Api2(ctx[idx], this[idx]) : null;
      },
      filter: function filter(fn) {
        var a = [];

        if (__arrayProto.filter) {
          a = __arrayProto.filter.call(this, fn, this);
        } else {
          // Compatibility for browsers without EMCA-252-5 (JS 1.6)
          for (var i = 0, ien = this.length; i < ien; i++) {
            if (fn.call(this, this[i], i, this)) {
              a.push(this[i]);
            }
          }
        }

        return new _Api2(this.context, a);
      },
      flatten: function flatten() {
        var a = [];
        return new _Api2(this.context, a.concat.apply(a, this.toArray()));
      },
      join: __arrayProto.join,
      indexOf: __arrayProto.indexOf || function (obj, start) {
        for (var i = start || 0, ien = this.length; i < ien; i++) {
          if (this[i] === obj) {
            return i;
          }
        }

        return -1;
      },
      iterator: function iterator(flatten, type, fn, alwaysNew) {
        var a = [],
            ret,
            i,
            ien,
            j,
            jen,
            context = this.context,
            rows,
            items,
            item,
            selector = this.selector; // Argument shifting

        if (typeof flatten === 'string') {
          alwaysNew = fn;
          fn = type;
          type = flatten;
          flatten = false;
        }

        for (i = 0, ien = context.length; i < ien; i++) {
          var apiInst = new _Api2(context[i]);

          if (type === 'table') {
            ret = fn.call(apiInst, context[i], i);

            if (ret !== undefined) {
              a.push(ret);
            }
          } else if (type === 'columns' || type === 'rows') {
            // this has same length as context - one entry for each table
            ret = fn.call(apiInst, context[i], this[i], i);

            if (ret !== undefined) {
              a.push(ret);
            }
          } else if (type === 'column' || type === 'column-rows' || type === 'row' || type === 'cell') {
            // columns and rows share the same structure.
            // 'this' is an array of column indexes for each context
            items = this[i];

            if (type === 'column-rows') {
              rows = _selector_row_indexes(context[i], selector.opts);
            }

            for (j = 0, jen = items.length; j < jen; j++) {
              item = items[j];

              if (type === 'cell') {
                ret = fn.call(apiInst, context[i], item.row, item.column, i, j);
              } else {
                ret = fn.call(apiInst, context[i], item, i, j, rows);
              }

              if (ret !== undefined) {
                a.push(ret);
              }
            }
          }
        }

        if (a.length || alwaysNew) {
          var api = new _Api2(context, flatten ? a.concat.apply([], a) : a);
          var apiSelector = api.selector;
          apiSelector.rows = selector.rows;
          apiSelector.cols = selector.cols;
          apiSelector.opts = selector.opts;
          return api;
        }

        return this;
      },
      lastIndexOf: __arrayProto.lastIndexOf || function (obj, start) {
        // Bit cheeky...
        return this.indexOf.apply(this.toArray.reverse(), arguments);
      },
      length: 0,
      map: function map(fn) {
        var a = [];

        if (__arrayProto.map) {
          a = __arrayProto.map.call(this, fn, this);
        } else {
          // Compatibility for browsers without EMCA-252-5 (JS 1.6)
          for (var i = 0, ien = this.length; i < ien; i++) {
            a.push(fn.call(this, this[i], i));
          }
        }

        return new _Api2(this.context, a);
      },
      pluck: function pluck(prop) {
        return this.map(function (el) {
          return el[prop];
        });
      },
      pop: __arrayProto.pop,
      push: __arrayProto.push,
      // Does not return an API instance
      reduce: __arrayProto.reduce || function (fn, init) {
        return _fnReduce(this, fn, init, 0, this.length, 1);
      },
      reduceRight: __arrayProto.reduceRight || function (fn, init) {
        return _fnReduce(this, fn, init, this.length - 1, -1, -1);
      },
      reverse: __arrayProto.reverse,
      // Object with rows, columns and opts
      selector: null,
      shift: __arrayProto.shift,
      sort: __arrayProto.sort,
      // ? name - order?
      splice: __arrayProto.splice,
      toArray: function toArray() {
        return __arrayProto.slice.call(this);
      },
      to$: function to$() {
        return $(this);
      },
      toJQuery: function toJQuery() {
        return $(this);
      },
      unique: function unique() {
        return new _Api2(this.context, _unique(this));
      },
      unshift: __arrayProto.unshift
    };

    _Api2.extend = function (scope, obj, ext) {
      // Only extend API instances and static properties of the API
      if (!ext.length || !obj || !(obj instanceof _Api2) && !obj.__dt_wrapper) {
        return;
      }

      var i,
          ien,
          j,
          jen,
          struct,
          inner,
          methodScoping = function methodScoping(scope, fn, struc) {
        return function () {
          var ret = fn.apply(scope, arguments); // Method extension

          _Api2.extend(ret, ret, struc.methodExt);

          return ret;
        };
      };

      for (i = 0, ien = ext.length; i < ien; i++) {
        struct = ext[i]; // Value

        obj[struct.name] = typeof struct.val === 'function' ? methodScoping(scope, struct.val, struct) : $.isPlainObject(struct.val) ? {} : struct.val;
        obj[struct.name].__dt_wrapper = true; // Property extension

        _Api2.extend(scope, obj[struct.name], struct.propExt);
      }
    }; // @todo - Is there need for an augment function?
    // _Api.augment = function ( inst, name )
    // {
    // 	// Find src object in the structure from the name
    // 	var parts = name.split('.');
    // 	_Api.extend( inst, obj );
    // };
    //     [
    //       {
    //         name:      'data'                -- string   - Property name
    //         val:       function () {},       -- function - Api method (or undefined if just an object
    //         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
    //         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
    //       },
    //       {
    //         name:     'row'
    //         val:       {},
    //         methodExt: [ ... ],
    //         propExt:   [
    //           {
    //             name:      'data'
    //             val:       function () {},
    //             methodExt: [ ... ],
    //             propExt:   [ ... ]
    //           },
    //           ...
    //         ]
    //       }
    //     ]


    _Api2.register = _api_register = function _api_register(name, val) {
      if ($.isArray(name)) {
        for (var j = 0, jen = name.length; j < jen; j++) {
          _Api2.register(name[j], val);
        }

        return;
      }

      var i,
          ien,
          heir = name.split('.'),
          struct = __apiStruct,
          key,
          method;

      var find = function find(src, name) {
        for (var i = 0, ien = src.length; i < ien; i++) {
          if (src[i].name === name) {
            return src[i];
          }
        }

        return null;
      };

      for (i = 0, ien = heir.length; i < ien; i++) {
        method = heir[i].indexOf('()') !== -1;
        key = method ? heir[i].replace('()', '') : heir[i];
        var src = find(struct, key);

        if (!src) {
          src = {
            name: key,
            val: {},
            methodExt: [],
            propExt: []
          };
          struct.push(src);
        }

        if (i === ien - 1) {
          src.val = val;
        } else {
          struct = method ? src.methodExt : src.propExt;
        }
      }
    };

    _Api2.registerPlural = _api_registerPlural = function _api_registerPlural(pluralName, singularName, val) {
      _Api2.register(pluralName, val);

      _Api2.register(singularName, function () {
        var ret = val.apply(this, arguments);

        if (ret === this) {
          // Returned item is the API instance that was passed in, return it
          return this;
        } else if (ret instanceof _Api2) {
          // New API instance returned, want the value from the first item
          // in the returned array for the singular result.
          return ret.length ? $.isArray(ret[0]) ? new _Api2(ret.context, ret[0]) : // Array results are 'enhanced'
          ret[0] : undefined;
        } // Non-API return - just fire it back


        return ret;
      });
    };
    /**
     * Selector for HTML tables. Apply the given selector to the give array of
     * DataTables settings objects.
     *
     * @param {string|integer} [selector] jQuery selector string or integer
     * @param  {array} Array of DataTables settings objects to be filtered
     * @return {array}
     * @ignore
     */


    var __table_selector = function __table_selector(selector, a) {
      // Integer is used to pick out a table by index
      if (typeof selector === 'number') {
        return [a[selector]];
      } // Perform a jQuery selector on the table nodes


      var nodes = $.map(a, function (el, i) {
        return el.nTable;
      });
      return $(nodes).filter(selector).map(function (i) {
        // Need to translate back from the table node to the settings
        var idx = $.inArray(this, nodes);
        return a[idx];
      }).toArray();
    };
    /**
     * Context selector for the API's context (i.e. the tables the API instance
     * refers to.
     *
     * @name    DataTable.Api#tables
     * @param {string|integer} [selector] Selector to pick which tables the iterator
     *   should operate on. If not given, all tables in the current context are
     *   used. This can be given as a jQuery selector (for example `':gt(0)'`) to
     *   select multiple tables or as an integer to select a single table.
     * @returns {DataTable.Api} Returns a new API instance if a selector is given.
     */


    _api_register('tables()', function (selector) {
      // A new instance is created if there was a selector specified
      return selector ? new _Api2(__table_selector(selector, this.context)) : this;
    });

    _api_register('table()', function (selector) {
      var tables = this.tables(selector);
      var ctx = tables.context; // Truncate to the first matched table

      return ctx.length ? new _Api2(ctx[0]) : tables;
    });

    _api_registerPlural('tables().nodes()', 'table().node()', function () {
      return this.iterator('table', function (ctx) {
        return ctx.nTable;
      }, 1);
    });

    _api_registerPlural('tables().body()', 'table().body()', function () {
      return this.iterator('table', function (ctx) {
        return ctx.nTBody;
      }, 1);
    });

    _api_registerPlural('tables().header()', 'table().header()', function () {
      return this.iterator('table', function (ctx) {
        return ctx.nTHead;
      }, 1);
    });

    _api_registerPlural('tables().footer()', 'table().footer()', function () {
      return this.iterator('table', function (ctx) {
        return ctx.nTFoot;
      }, 1);
    });

    _api_registerPlural('tables().containers()', 'table().container()', function () {
      return this.iterator('table', function (ctx) {
        return ctx.nTableWrapper;
      }, 1);
    });
    /**
     * Redraw the tables in the current context.
     *
     * @param {boolean} [reset=true] Reset (default) or hold the current paging
     *   position. A full re-sort and re-filter is performed when this method is
     *   called, which is why the pagination reset is the default action.
     * @returns {DataTables.Api} this
     */


    _api_register('draw()', function (resetPaging) {
      return this.iterator('table', function (settings) {
        _fnReDraw(settings, resetPaging === false);
      });
    });
    /**
     * Get the current page index.
     *
     * @return {integer} Current page index (zero based)
     */

    /**
    * Set the current page.
    *
    * Note that if you attempt to show a page which does not exist, DataTables will
    * not throw an error, but rather reset the paging.
    *
    * @param {integer|string} action The paging action to take. This can be one of:
    *  * `integer` - The page index to jump to
    *  * `string` - An action to take:
    *    * `first` - Jump to first page.
    *    * `next` - Jump to the next page
    *    * `previous` - Jump to previous page
    *    * `last` - Jump to the last page.
    * @returns {DataTables.Api} this
    */


    _api_register('page()', function (action) {
      if (action === undefined) {
        return this.page.info().page; // not an expensive call
      } // else, have an action to take on all tables


      return this.iterator('table', function (settings) {
        _fnPageChange(settings, action);
      });
    });
    /**
     * Paging information for the first table in the current context.
     *
     * If you require paging information for another table, use the `table()` method
     * with a suitable selector.
     *
     * @return {object} Object with the following properties set:
     *  * `page` - Current page index (zero based - i.e. the first page is `0`)
     *  * `pages` - Total number of pages
     *  * `start` - Display index for the first record shown on the current page
     *  * `end` - Display index for the last record shown on the current page
     *  * `length` - Display length (number of records). Note that generally `start
     *    + length = end`, but this is not always true, for example if there are
     *    only 2 records to show on the final page, with a length of 10.
     *  * `recordsTotal` - Full data set length
     *  * `recordsDisplay` - Data set length once the current filtering criterion
     *    are applied.
     */


    _api_register('page.info()', function (action) {
      if (this.context.length === 0) {
        return undefined;
      }

      var settings = this.context[0],
          start = settings._iDisplayStart,
          len = settings._iDisplayLength,
          visRecords = settings.fnRecordsDisplay(),
          all = len === -1;
      return {
        "page": all ? 0 : Math.floor(start / len),
        "pages": all ? 1 : Math.ceil(visRecords / len),
        "start": start,
        "end": settings.fnDisplayEnd(),
        "length": len,
        "recordsTotal": settings.fnRecordsTotal(),
        "recordsDisplay": visRecords
      };
    });
    /**
     * Get the current page length.
     *
     * @return {integer} Current page length. Note `-1` indicates that all records
     *   are to be shown.
     */

    /**
    * Set the current page length.
    *
    * @param {integer} Page length to set. Use `-1` to show all records.
    * @returns {DataTables.Api} this
    */


    _api_register('page.len()', function (len) {
      // Note that we can't call this function 'length()' because `length`
      // is a Javascript property of functions which defines how many arguments
      // the function expects.
      if (len === undefined) {
        return this.context.length !== 0 ? this.context[0]._iDisplayLength : undefined;
      } // else, set the page length


      return this.iterator('table', function (settings) {
        _fnLengthChange(settings, len);
      });
    });

    var __reload = function __reload(settings, holdPosition, callback) {
      // Use the draw event to trigger a callback
      if (callback) {
        var api = new _Api2(settings);
        api.one('draw', function () {
          callback(api.ajax.json());
        });
      }

      if (_fnDataSource(settings) == 'ssp') {
        _fnReDraw(settings, holdPosition);
      } else {
        // Trigger xhr
        _fnProcessingDisplay(settings, true);

        _fnBuildAjax(settings, [], function (json) {
          _fnClearTable(settings);

          var data = _fnAjaxDataSrc(settings, json);

          for (var i = 0, ien = data.length; i < ien; i++) {
            _fnAddData(settings, data[i]);
          }

          _fnReDraw(settings, holdPosition);

          _fnProcessingDisplay(settings, false);
        });
      }
    };
    /**
     * Get the JSON response from the last Ajax request that DataTables made to the
     * server. Note that this returns the JSON from the first table in the current
     * context.
     *
     * @return {object} JSON received from the server.
     */


    _api_register('ajax.json()', function () {
      var ctx = this.context;

      if (ctx.length > 0) {
        return ctx[0].json;
      } // else return undefined;

    });
    /**
     * Get the data submitted in the last Ajax request
     */


    _api_register('ajax.params()', function () {
      var ctx = this.context;

      if (ctx.length > 0) {
        return ctx[0].oAjaxData;
      } // else return undefined;

    });
    /**
     * Reload tables from the Ajax data source. Note that this function will
     * automatically re-draw the table when the remote data has been loaded.
     *
     * @param {boolean} [reset=true] Reset (default) or hold the current paging
     *   position. A full re-sort and re-filter is performed when this method is
     *   called, which is why the pagination reset is the default action.
     * @returns {DataTables.Api} this
     */


    _api_register('ajax.reload()', function (callback, resetPaging) {
      return this.iterator('table', function (settings) {
        __reload(settings, resetPaging === false, callback);
      });
    });
    /**
     * Get the current Ajax URL. Note that this returns the URL from the first
     * table in the current context.
     *
     * @return {string} Current Ajax source URL
     */

    /**
    * Set the Ajax URL. Note that this will set the URL for all tables in the
    * current context.
    *
    * @param {string} url URL to set.
    * @returns {DataTables.Api} this
    */


    _api_register('ajax.url()', function (url) {
      var ctx = this.context;

      if (url === undefined) {
        // get
        if (ctx.length === 0) {
          return undefined;
        }

        ctx = ctx[0];
        return ctx.ajax ? $.isPlainObject(ctx.ajax) ? ctx.ajax.url : ctx.ajax : ctx.sAjaxSource;
      } // set


      return this.iterator('table', function (settings) {
        if ($.isPlainObject(settings.ajax)) {
          settings.ajax.url = url;
        } else {
          settings.ajax = url;
        } // No need to consider sAjaxSource here since DataTables gives priority
        // to `ajax` over `sAjaxSource`. So setting `ajax` here, renders any
        // value of `sAjaxSource` redundant.

      });
    });
    /**
     * Load data from the newly set Ajax URL. Note that this method is only
     * available when `ajax.url()` is used to set a URL. Additionally, this method
     * has the same effect as calling `ajax.reload()` but is provided for
     * convenience when setting a new URL. Like `ajax.reload()` it will
     * automatically redraw the table once the remote data has been loaded.
     *
     * @returns {DataTables.Api} this
     */


    _api_register('ajax.url().load()', function (callback, resetPaging) {
      // Same as a reload, but makes sense to present it for easy access after a
      // url change
      return this.iterator('table', function (ctx) {
        __reload(ctx, resetPaging === false, callback);
      });
    });

    var _selector_run = function _selector_run(type, selector, selectFn, settings, opts) {
      var out = [],
          res,
          a,
          i,
          ien,
          j,
          jen,
          selectorType = _typeof(selector); // Can't just check for isArray here, as an API or jQuery instance might be
      // given with their array like look


      if (!selector || selectorType === 'string' || selectorType === 'function' || selector.length === undefined) {
        selector = [selector];
      }

      for (i = 0, ien = selector.length; i < ien; i++) {
        a = selector[i] && selector[i].split ? selector[i].split(',') : [selector[i]];

        for (j = 0, jen = a.length; j < jen; j++) {
          res = selectFn(typeof a[j] === 'string' ? $.trim(a[j]) : a[j]);

          if (res && res.length) {
            out.push.apply(out, res);
          }
        }
      } // selector extensions


      var ext = _ext.selector[type];

      if (ext.length) {
        for (i = 0, ien = ext.length; i < ien; i++) {
          out = ext[i](settings, opts, out);
        }
      }

      return out;
    };

    var _selector_opts = function _selector_opts(opts) {
      if (!opts) {
        opts = {};
      } // Backwards compatibility for 1.9- which used the terminology filter rather
      // than search


      if (opts.filter && opts.search === undefined) {
        opts.search = opts.filter;
      }

      return $.extend({
        search: 'none',
        order: 'current',
        page: 'all'
      }, opts);
    };

    var _selector_first = function _selector_first(inst) {
      // Reduce the API instance to the first item found
      for (var i = 0, ien = inst.length; i < ien; i++) {
        if (inst[i].length > 0) {
          // Assign the first element to the first item in the instance
          // and truncate the instance and context
          inst[0] = inst[i];
          inst[0].length = 1;
          inst.length = 1;
          inst.context = [inst.context[i]];
          return inst;
        }
      } // Not found - return an empty instance


      inst.length = 0;
      return inst;
    };

    var _selector_row_indexes = function _selector_row_indexes(settings, opts) {
      var i,
          ien,
          tmp,
          a = [],
          displayFiltered = settings.aiDisplay,
          displayMaster = settings.aiDisplayMaster;
      var search = opts.search,
          // none, applied, removed
      order = opts.order,
          // applied, current, index (original - compatibility with 1.9)
      page = opts.page; // all, current

      if (_fnDataSource(settings) == 'ssp') {
        // In server-side processing mode, most options are irrelevant since
        // rows not shown don't exist and the index order is the applied order
        // Removed is a special case - for consistency just return an empty
        // array
        return search === 'removed' ? [] : _range(0, displayMaster.length);
      } else if (page == 'current') {
        // Current page implies that order=current and fitler=applied, since it is
        // fairly senseless otherwise, regardless of what order and search actually
        // are
        for (i = settings._iDisplayStart, ien = settings.fnDisplayEnd(); i < ien; i++) {
          a.push(displayFiltered[i]);
        }
      } else if (order == 'current' || order == 'applied') {
        a = search == 'none' ? displayMaster.slice() : // no search
        search == 'applied' ? displayFiltered.slice() : // applied search
        $.map(displayMaster, function (el, i) {
          // removed search
          return $.inArray(el, displayFiltered) === -1 ? el : null;
        });
      } else if (order == 'index' || order == 'original') {
        for (i = 0, ien = settings.aoData.length; i < ien; i++) {
          if (search == 'none') {
            a.push(i);
          } else {
            // applied | removed
            tmp = $.inArray(i, displayFiltered);

            if (tmp === -1 && search == 'removed' || tmp >= 0 && search == 'applied') {
              a.push(i);
            }
          }
        }
      }

      return a;
    };
    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
     * Rows
     *
     * {}          - no selector - use all available rows
     * {integer}   - row aoData index
     * {node}      - TR node
     * {string}    - jQuery selector to apply to the TR elements
     * {array}     - jQuery array of nodes, or simply an array of TR nodes
     *
     */


    var __row_selector = function __row_selector(settings, selector, opts) {
      var run = function run(sel) {
        var selInt = _intVal(sel);

        var i, ien; // Short cut - selector is a number and no options provided (default is
        // all records, so no need to check if the index is in there, since it
        // must be - dev error if the index doesn't exist).

        if (selInt !== null && !opts) {
          return [selInt];
        }

        var rows = _selector_row_indexes(settings, opts);

        if (selInt !== null && $.inArray(selInt, rows) !== -1) {
          // Selector - integer
          return [selInt];
        } else if (!sel) {
          // Selector - none
          return rows;
        } // Selector - function


        if (typeof sel === 'function') {
          return $.map(rows, function (idx) {
            var row = settings.aoData[idx];
            return sel(idx, row._aData, row.nTr) ? idx : null;
          });
        } // Get nodes in the order from the `rows` array with null values removed


        var nodes = _removeEmpty(_pluck_order(settings.aoData, rows, 'nTr')); // Selector - node


        if (sel.nodeName) {
          if ($.inArray(sel, nodes) !== -1) {
            return [sel._DT_RowIndex]; // sel is a TR node that is in the table
            // and DataTables adds a prop for fast lookup
          }
        } // Selector - jQuery selector string, array of nodes or jQuery object/
        // As jQuery's .filter() allows jQuery objects to be passed in filter,
        // it also allows arrays, so this will cope with all three options


        return $(nodes).filter(sel).map(function () {
          return this._DT_RowIndex;
        }).toArray();
      };

      return _selector_run('row', selector, run, settings, opts);
    };

    _api_register('rows()', function (selector, opts) {
      // argument shifting
      if (selector === undefined) {
        selector = '';
      } else if ($.isPlainObject(selector)) {
        opts = selector;
        selector = '';
      }

      opts = _selector_opts(opts);
      var inst = this.iterator('table', function (settings) {
        return __row_selector(settings, selector, opts);
      }, 1); // Want argument shifting here and in __row_selector?

      inst.selector.rows = selector;
      inst.selector.opts = opts;
      return inst;
    });

    _api_register('rows().nodes()', function () {
      return this.iterator('row', function (settings, row) {
        return settings.aoData[row].nTr || undefined;
      }, 1);
    });

    _api_register('rows().data()', function () {
      return this.iterator(true, 'rows', function (settings, rows) {
        return _pluck_order(settings.aoData, rows, '_aData');
      }, 1);
    });

    _api_registerPlural('rows().cache()', 'row().cache()', function (type) {
      return this.iterator('row', function (settings, row) {
        var r = settings.aoData[row];
        return type === 'search' ? r._aFilterData : r._aSortData;
      }, 1);
    });

    _api_registerPlural('rows().invalidate()', 'row().invalidate()', function (src) {
      return this.iterator('row', function (settings, row) {
        _fnInvalidate(settings, row, src);
      });
    });

    _api_registerPlural('rows().indexes()', 'row().index()', function () {
      return this.iterator('row', function (settings, row) {
        return row;
      }, 1);
    });

    _api_registerPlural('rows().remove()', 'row().remove()', function () {
      var that = this;
      return this.iterator('row', function (settings, row, thatIdx) {
        var data = settings.aoData;
        data.splice(row, 1); // Update the _DT_RowIndex parameter on all rows in the table

        for (var i = 0, ien = data.length; i < ien; i++) {
          if (data[i].nTr !== null) {
            data[i].nTr._DT_RowIndex = i;
          }
        } // Remove the target row from the search array


        var displayIndex = $.inArray(row, settings.aiDisplay); // Delete from the display arrays

        _fnDeleteIndex(settings.aiDisplayMaster, row);

        _fnDeleteIndex(settings.aiDisplay, row);

        _fnDeleteIndex(that[thatIdx], row, false); // maintain local indexes
        // Check for an 'overflow' they case for displaying the table


        _fnLengthOverflow(settings);
      });
    });

    _api_register('rows.add()', function (rows) {
      var newRows = this.iterator('table', function (settings) {
        var row, i, ien;
        var out = [];

        for (i = 0, ien = rows.length; i < ien; i++) {
          row = rows[i];

          if (row.nodeName && row.nodeName.toUpperCase() === 'TR') {
            out.push(_fnAddTr(settings, row)[0]);
          } else {
            out.push(_fnAddData(settings, row));
          }
        }

        return out;
      }, 1); // Return an Api.rows() extended instance, so rows().nodes() etc can be used

      var modRows = this.rows(-1);
      modRows.pop();
      modRows.push.apply(modRows, newRows.toArray());
      return modRows;
    });
    /**
     *
     */


    _api_register('row()', function (selector, opts) {
      return _selector_first(this.rows(selector, opts));
    });

    _api_register('row().data()', function (data) {
      var ctx = this.context;

      if (data === undefined) {
        // Get
        return ctx.length && this.length ? ctx[0].aoData[this[0]]._aData : undefined;
      } // Set


      ctx[0].aoData[this[0]]._aData = data; // Automatically invalidate

      _fnInvalidate(ctx[0], this[0], 'data');

      return this;
    });

    _api_register('row().node()', function () {
      var ctx = this.context;
      return ctx.length && this.length ? ctx[0].aoData[this[0]].nTr || null : null;
    });

    _api_register('row.add()', function (row) {
      // Allow a jQuery object to be passed in - only a single row is added from
      // it though - the first element in the set
      if (row instanceof $ && row.length) {
        row = row[0];
      }

      var rows = this.iterator('table', function (settings) {
        if (row.nodeName && row.nodeName.toUpperCase() === 'TR') {
          return _fnAddTr(settings, row)[0];
        }

        return _fnAddData(settings, row);
      }); // Return an Api.rows() extended instance, with the newly added row selected

      return this.row(rows[0]);
    });

    var __details_add = function __details_add(ctx, row, data, klass) {
      // Convert to array of TR elements
      var rows = [];

      var addRow = function addRow(r, k) {
        // Recursion to allow for arrays of jQuery objects
        if ($.isArray(r) || r instanceof $) {
          for (var i = 0, ien = r.length; i < ien; i++) {
            addRow(r[i], k);
          }

          return;
        } // If we get a TR element, then just add it directly - up to the dev
        // to add the correct number of columns etc


        if (r.nodeName && r.nodeName.toLowerCase() === 'tr') {
          rows.push(r);
        } else {
          // Otherwise create a row with a wrapper
          var created = $('<tr><td/></tr>').addClass(k);
          $('td', created).addClass(k).html(r)[0].colSpan = _fnVisbleColumns(ctx);
          rows.push(created[0]);
        }
      };

      addRow(data, klass);

      if (row._details) {
        row._details.remove();
      }

      row._details = $(rows); // If the children were already shown, that state should be retained

      if (row._detailsShow) {
        row._details.insertAfter(row.nTr);
      }
    };

    var __details_remove = function __details_remove(api, idx) {
      var ctx = api.context;

      if (ctx.length) {
        var row = ctx[0].aoData[idx !== undefined ? idx : api[0]];

        if (row._details) {
          row._details.remove();

          row._detailsShow = undefined;
          row._details = undefined;
        }
      }
    };

    var __details_display = function __details_display(api, show) {
      var ctx = api.context;

      if (ctx.length && api.length) {
        var row = ctx[0].aoData[api[0]];

        if (row._details) {
          row._detailsShow = show;

          if (show) {
            row._details.insertAfter(row.nTr);
          } else {
            row._details.detach();
          }

          __details_events(ctx[0]);
        }
      }
    };

    var __details_events = function __details_events(settings) {
      var api = new _Api2(settings);
      var namespace = '.dt.DT_details';
      var drawEvent = 'draw' + namespace;
      var colvisEvent = 'column-visibility' + namespace;
      var destroyEvent = 'destroy' + namespace;
      var data = settings.aoData;
      api.off(drawEvent + ' ' + colvisEvent + ' ' + destroyEvent);

      if (_pluck(data, '_details').length > 0) {
        // On each draw, insert the required elements into the document
        api.on(drawEvent, function (e, ctx) {
          if (settings !== ctx) {
            return;
          }

          api.rows({
            page: 'current'
          }).eq(0).each(function (idx) {
            // Internal data grab
            var row = data[idx];

            if (row._detailsShow) {
              row._details.insertAfter(row.nTr);
            }
          });
        }); // Column visibility change - update the colspan

        api.on(colvisEvent, function (e, ctx, idx, vis) {
          if (settings !== ctx) {
            return;
          } // Update the colspan for the details rows (note, only if it already has
          // a colspan)


          var row,
              visible = _fnVisbleColumns(ctx);

          for (var i = 0, ien = data.length; i < ien; i++) {
            row = data[i];

            if (row._details) {
              row._details.children('td[colspan]').attr('colspan', visible);
            }
          }
        }); // Table destroyed - nuke any child rows

        api.on(destroyEvent, function (e, ctx) {
          if (settings !== ctx) {
            return;
          }

          for (var i = 0, ien = data.length; i < ien; i++) {
            if (data[i]._details) {
              __details_remove(api, i);
            }
          }
        });
      }
    }; // Strings for the method names to help minification


    var _emp = '';

    var _child_obj = _emp + 'row().child';

    var _child_mth = _child_obj + '()'; // data can be:
    //  tr
    //  string
    //  jQuery or array of any of the above


    _api_register(_child_mth, function (data, klass) {
      var ctx = this.context;

      if (data === undefined) {
        // get
        return ctx.length && this.length ? ctx[0].aoData[this[0]]._details : undefined;
      } else if (data === true) {
        // show
        this.child.show();
      } else if (data === false) {
        // remove
        __details_remove(this);
      } else if (ctx.length && this.length) {
        // set
        __details_add(ctx[0], ctx[0].aoData[this[0]], data, klass);
      }

      return this;
    });

    _api_register([_child_obj + '.show()', _child_mth + '.show()' // only when `child()` was called with parameters (without
    ], function (show) {
      // it returns an object and this method is not executed)
      __details_display(this, true);

      return this;
    });

    _api_register([_child_obj + '.hide()', _child_mth + '.hide()' // only when `child()` was called with parameters (without
    ], function () {
      // it returns an object and this method is not executed)
      __details_display(this, false);

      return this;
    });

    _api_register([_child_obj + '.remove()', _child_mth + '.remove()' // only when `child()` was called with parameters (without
    ], function () {
      // it returns an object and this method is not executed)
      __details_remove(this);

      return this;
    });

    _api_register(_child_obj + '.isShown()', function () {
      var ctx = this.context;

      if (ctx.length && this.length) {
        // _detailsShown as false or undefined will fall through to return false
        return ctx[0].aoData[this[0]]._detailsShow || false;
      }

      return false;
    });
    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
     * Columns
     *
     * {integer}           - column index (>=0 count from left, <0 count from right)
     * "{integer}:visIdx"  - visible column index (i.e. translate to column index)  (>=0 count from left, <0 count from right)
     * "{integer}:visible" - alias for {integer}:visIdx  (>=0 count from left, <0 count from right)
     * "{string}:name"     - column name
     * "{string}"          - jQuery selector on column header nodes
     *
     */
    // can be an array of these items, comma separated list, or an array of comma
    // separated lists


    var __re_column_selector = /^(.+):(name|visIdx|visible)$/; // r1 and r2 are redundant - but it means that the parameters match for the
    // iterator callback in columns().data()

    var __columnData = function __columnData(settings, column, r1, r2, rows) {
      var a = [];

      for (var row = 0, ien = rows.length; row < ien; row++) {
        a.push(_fnGetCellData(settings, rows[row], column));
      }

      return a;
    };

    var __column_selector = function __column_selector(settings, selector, opts) {
      var columns = settings.aoColumns,
          names = _pluck(columns, 'sName'),
          nodes = _pluck(columns, 'nTh');

      var run = function run(s) {
        var selInt = _intVal(s); // Selector - all


        if (s === '') {
          return _range(columns.length);
        } // Selector - index


        if (selInt !== null) {
          return [selInt >= 0 ? selInt : // Count from left
          columns.length + selInt // Count from right (+ because its a negative value)
          ];
        } // Selector = function


        if (typeof s === 'function') {
          var rows = _selector_row_indexes(settings, opts);

          return $.map(columns, function (col, idx) {
            return s(idx, __columnData(settings, idx, 0, 0, rows), nodes[idx]) ? idx : null;
          });
        } // jQuery or string selector


        var match = typeof s === 'string' ? s.match(__re_column_selector) : '';

        if (match) {
          switch (match[2]) {
            case 'visIdx':
            case 'visible':
              var idx = parseInt(match[1], 10); // Visible index given, convert to column index

              if (idx < 0) {
                // Counting from the right
                var visColumns = $.map(columns, function (col, i) {
                  return col.bVisible ? i : null;
                });
                return [visColumns[visColumns.length + idx]];
              } // Counting from the left


              return [_fnVisibleToColumnIndex(settings, idx)];

            case 'name':
              // match by name. `names` is column index complete and in order
              return $.map(names, function (name, i) {
                return name === match[1] ? i : null;
              });
          }
        } else {
          // jQuery selector on the TH elements for the columns
          return $(nodes).filter(s).map(function () {
            return $.inArray(this, nodes); // `nodes` is column index complete and in order
          }).toArray();
        }
      };

      return _selector_run('column', selector, run, settings, opts);
    };

    var __setColumnVis = function __setColumnVis(settings, column, vis, recalc) {
      var cols = settings.aoColumns,
          col = cols[column],
          data = settings.aoData,
          row,
          cells,
          i,
          ien,
          tr; // Get

      if (vis === undefined) {
        return col.bVisible;
      } // Set
      // No change


      if (col.bVisible === vis) {
        return;
      }

      if (vis) {
        // Insert column
        // Need to decide if we should use appendChild or insertBefore
        var insertBefore = $.inArray(true, _pluck(cols, 'bVisible'), column + 1);

        for (i = 0, ien = data.length; i < ien; i++) {
          tr = data[i].nTr;
          cells = data[i].anCells;

          if (tr) {
            // insertBefore can act like appendChild if 2nd arg is null
            tr.insertBefore(cells[column], cells[insertBefore] || null);
          }
        }
      } else {
        // Remove column
        $(_pluck(settings.aoData, 'anCells', column)).detach();
      } // Common actions


      col.bVisible = vis;

      _fnDrawHead(settings, settings.aoHeader);

      _fnDrawHead(settings, settings.aoFooter);

      if (recalc === undefined || recalc) {
        // Automatically adjust column sizing
        _fnAdjustColumnSizing(settings); // Realign columns for scrolling


        if (settings.oScroll.sX || settings.oScroll.sY) {
          _fnScrollDraw(settings);
        }
      }

      _fnCallbackFire(settings, null, 'column-visibility', [settings, column, vis]);

      _fnSaveState(settings);
    };

    _api_register('columns()', function (selector, opts) {
      // argument shifting
      if (selector === undefined) {
        selector = '';
      } else if ($.isPlainObject(selector)) {
        opts = selector;
        selector = '';
      }

      opts = _selector_opts(opts);
      var inst = this.iterator('table', function (settings) {
        return __column_selector(settings, selector, opts);
      }, 1); // Want argument shifting here and in _row_selector?

      inst.selector.cols = selector;
      inst.selector.opts = opts;
      return inst;
    });

    _api_registerPlural('columns().header()', 'column().header()', function (selector, opts) {
      return this.iterator('column', function (settings, column) {
        return settings.aoColumns[column].nTh;
      }, 1);
    });

    _api_registerPlural('columns().footer()', 'column().footer()', function (selector, opts) {
      return this.iterator('column', function (settings, column) {
        return settings.aoColumns[column].nTf;
      }, 1);
    });

    _api_registerPlural('columns().data()', 'column().data()', function () {
      return this.iterator('column-rows', __columnData, 1);
    });

    _api_registerPlural('columns().dataSrc()', 'column().dataSrc()', function () {
      return this.iterator('column', function (settings, column) {
        return settings.aoColumns[column].mData;
      }, 1);
    });

    _api_registerPlural('columns().cache()', 'column().cache()', function (type) {
      return this.iterator('column-rows', function (settings, column, i, j, rows) {
        return _pluck_order(settings.aoData, rows, type === 'search' ? '_aFilterData' : '_aSortData', column);
      }, 1);
    });

    _api_registerPlural('columns().nodes()', 'column().nodes()', function () {
      return this.iterator('column-rows', function (settings, column, i, j, rows) {
        return _pluck_order(settings.aoData, rows, 'anCells', column);
      }, 1);
    });

    _api_registerPlural('columns().visible()', 'column().visible()', function (vis, calc) {
      return this.iterator('column', function (settings, column) {
        if (vis === undefined) {
          return settings.aoColumns[column].bVisible;
        } // else


        __setColumnVis(settings, column, vis, calc);
      });
    });

    _api_registerPlural('columns().indexes()', 'column().index()', function (type) {
      return this.iterator('column', function (settings, column) {
        return type === 'visible' ? _fnColumnIndexToVisible(settings, column) : column;
      }, 1);
    });

    _api_register('columns.adjust()', function () {
      return this.iterator('table', function (settings) {
        _fnAdjustColumnSizing(settings);
      }, 1);
    });

    _api_register('column.index()', function (type, idx) {
      if (this.context.length !== 0) {
        var ctx = this.context[0];

        if (type === 'fromVisible' || type === 'toData') {
          return _fnVisibleToColumnIndex(ctx, idx);
        } else if (type === 'fromData' || type === 'toVisible') {
          return _fnColumnIndexToVisible(ctx, idx);
        }
      }
    });

    _api_register('column()', function (selector, opts) {
      return _selector_first(this.columns(selector, opts));
    });

    var __cell_selector = function __cell_selector(settings, selector, opts) {
      var data = settings.aoData;

      var rows = _selector_row_indexes(settings, opts);

      var cells = _removeEmpty(_pluck_order(data, rows, 'anCells'));

      var allCells = $([].concat.apply([], cells));
      var row;
      var columns = settings.aoColumns.length;
      var a, i, ien, j, o, host;

      var run = function run(s) {
        var fnSelector = typeof s === 'function';

        if (s === null || s === undefined || fnSelector) {
          // All cells and function selectors
          a = [];

          for (i = 0, ien = rows.length; i < ien; i++) {
            row = rows[i];

            for (j = 0; j < columns; j++) {
              o = {
                row: row,
                column: j
              };

              if (fnSelector) {
                // Selector - function
                host = settings.aoData[row];

                if (s(o, _fnGetCellData(settings, row, j), host.anCells ? host.anCells[j] : null)) {
                  a.push(o);
                }
              } else {
                // Selector - all
                a.push(o);
              }
            }
          }

          return a;
        } // Selector - index


        if ($.isPlainObject(s)) {
          return [s];
        } // Selector - jQuery filtered cells


        return allCells.filter(s).map(function (i, el) {
          row = el.parentNode._DT_RowIndex;
          return {
            row: row,
            column: $.inArray(el, data[row].anCells)
          };
        }).toArray();
      };

      return _selector_run('cell', selector, run, settings, opts);
    };

    _api_register('cells()', function (rowSelector, columnSelector, opts) {
      // Argument shifting
      if ($.isPlainObject(rowSelector)) {
        // Indexes
        if (rowSelector.row === undefined) {
          // Selector options in first parameter
          opts = rowSelector;
          rowSelector = null;
        } else {
          // Cell index objects in first parameter
          opts = columnSelector;
          columnSelector = null;
        }
      }

      if ($.isPlainObject(columnSelector)) {
        opts = columnSelector;
        columnSelector = null;
      } // Cell selector


      if (columnSelector === null || columnSelector === undefined) {
        return this.iterator('table', function (settings) {
          return __cell_selector(settings, rowSelector, _selector_opts(opts));
        });
      } // Row + column selector


      var columns = this.columns(columnSelector, opts);
      var rows = this.rows(rowSelector, opts);
      var a, i, ien, j, jen;
      var cells = this.iterator('table', function (settings, idx) {
        a = [];

        for (i = 0, ien = rows[idx].length; i < ien; i++) {
          for (j = 0, jen = columns[idx].length; j < jen; j++) {
            a.push({
              row: rows[idx][i],
              column: columns[idx][j]
            });
          }
        }

        return a;
      }, 1);
      $.extend(cells.selector, {
        cols: columnSelector,
        rows: rowSelector,
        opts: opts
      });
      return cells;
    });

    _api_registerPlural('cells().nodes()', 'cell().node()', function () {
      return this.iterator('cell', function (settings, row, column) {
        var cells = settings.aoData[row].anCells;
        return cells ? cells[column] : undefined;
      }, 1);
    });

    _api_register('cells().data()', function () {
      return this.iterator('cell', function (settings, row, column) {
        return _fnGetCellData(settings, row, column);
      }, 1);
    });

    _api_registerPlural('cells().cache()', 'cell().cache()', function (type) {
      type = type === 'search' ? '_aFilterData' : '_aSortData';
      return this.iterator('cell', function (settings, row, column) {
        return settings.aoData[row][type][column];
      }, 1);
    });

    _api_registerPlural('cells().render()', 'cell().render()', function (type) {
      return this.iterator('cell', function (settings, row, column) {
        return _fnGetCellData(settings, row, column, type);
      }, 1);
    });

    _api_registerPlural('cells().indexes()', 'cell().index()', function () {
      return this.iterator('cell', function (settings, row, column) {
        return {
          row: row,
          column: column,
          columnVisible: _fnColumnIndexToVisible(settings, column)
        };
      }, 1);
    });

    _api_registerPlural('cells().invalidate()', 'cell().invalidate()', function (src) {
      return this.iterator('cell', function (settings, row, column) {
        _fnInvalidate(settings, row, src, column);
      });
    });

    _api_register('cell()', function (rowSelector, columnSelector, opts) {
      return _selector_first(this.cells(rowSelector, columnSelector, opts));
    });

    _api_register('cell().data()', function (data) {
      var ctx = this.context;
      var cell = this[0];

      if (data === undefined) {
        // Get
        return ctx.length && cell.length ? _fnGetCellData(ctx[0], cell[0].row, cell[0].column) : undefined;
      } // Set


      _fnSetCellData(ctx[0], cell[0].row, cell[0].column, data);

      _fnInvalidate(ctx[0], cell[0].row, 'data', cell[0].column);

      return this;
    });
    /**
     * Get current ordering (sorting) that has been applied to the table.
     *
     * @returns {array} 2D array containing the sorting information for the first
     *   table in the current context. Each element in the parent array represents
     *   a column being sorted upon (i.e. multi-sorting with two columns would have
     *   2 inner arrays). The inner arrays may have 2 or 3 elements. The first is
     *   the column index that the sorting condition applies to, the second is the
     *   direction of the sort (`desc` or `asc`) and, optionally, the third is the
     *   index of the sorting order from the `column.sorting` initialisation array.
     */

    /**
    * Set the ordering for the table.
    *
    * @param {integer} order Column index to sort upon.
    * @param {string} direction Direction of the sort to be applied (`asc` or `desc`)
    * @returns {DataTables.Api} this
    */

    /**
    * Set the ordering for the table.
    *
    * @param {array} order 1D array of sorting information to be applied.
    * @param {array} [...] Optional additional sorting conditions
    * @returns {DataTables.Api} this
    */

    /**
    * Set the ordering for the table.
    *
    * @param {array} order 2D array of sorting information to be applied.
    * @returns {DataTables.Api} this
    */


    _api_register('order()', function (order, dir) {
      var ctx = this.context;

      if (order === undefined) {
        // get
        return ctx.length !== 0 ? ctx[0].aaSorting : undefined;
      } // set


      if (typeof order === 'number') {
        // Simple column / direction passed in
        order = [[order, dir]];
      } else if (!$.isArray(order[0])) {
        // Arguments passed in (list of 1D arrays)
        order = Array.prototype.slice.call(arguments);
      } // otherwise a 2D array was passed in


      return this.iterator('table', function (settings) {
        settings.aaSorting = order.slice();
      });
    });
    /**
     * Attach a sort listener to an element for a given column
     *
     * @param {node|jQuery|string} node Identifier for the element(s) to attach the
     *   listener to. This can take the form of a single DOM node, a jQuery
     *   collection of nodes or a jQuery selector which will identify the node(s).
     * @param {integer} column the column that a click on this node will sort on
     * @param {function} [callback] callback function when sort is run
     * @returns {DataTables.Api} this
     */


    _api_register('order.listener()', function (node, column, callback) {
      return this.iterator('table', function (settings) {
        _fnSortAttachListener(settings, node, column, callback);
      });
    }); // Order by the selected column(s)


    _api_register(['columns().order()', 'column().order()'], function (dir) {
      var that = this;
      return this.iterator('table', function (settings, i) {
        var sort = [];
        $.each(that[i], function (j, col) {
          sort.push([col, dir]);
        });
        settings.aaSorting = sort;
      });
    });

    _api_register('search()', function (input, regex, smart, caseInsen) {
      var ctx = this.context;

      if (input === undefined) {
        // get
        return ctx.length !== 0 ? ctx[0].oPreviousSearch.sSearch : undefined;
      } // set


      return this.iterator('table', function (settings) {
        if (!settings.oFeatures.bFilter) {
          return;
        }

        _fnFilterComplete(settings, $.extend({}, settings.oPreviousSearch, {
          "sSearch": input + "",
          "bRegex": regex === null ? false : regex,
          "bSmart": smart === null ? true : smart,
          "bCaseInsensitive": caseInsen === null ? true : caseInsen
        }), 1);
      });
    });

    _api_registerPlural('columns().search()', 'column().search()', function (input, regex, smart, caseInsen) {
      return this.iterator('column', function (settings, column) {
        var preSearch = settings.aoPreSearchCols;

        if (input === undefined) {
          // get
          return preSearch[column].sSearch;
        } // set


        if (!settings.oFeatures.bFilter) {
          return;
        }

        $.extend(preSearch[column], {
          "sSearch": input + "",
          "bRegex": regex === null ? false : regex,
          "bSmart": smart === null ? true : smart,
          "bCaseInsensitive": caseInsen === null ? true : caseInsen
        });

        _fnFilterComplete(settings, settings.oPreviousSearch, 1);
      });
    });
    /*
     * State API methods
     */


    _api_register('state()', function () {
      return this.context.length ? this.context[0].oSavedState : null;
    });

    _api_register('state.clear()', function () {
      return this.iterator('table', function (settings) {
        // Save an empty object
        settings.fnStateSaveCallback.call(settings.oInstance, settings, {});
      });
    });

    _api_register('state.loaded()', function () {
      return this.context.length ? this.context[0].oLoadedState : null;
    });

    _api_register('state.save()', function () {
      return this.iterator('table', function (settings) {
        _fnSaveState(settings);
      });
    });
    /**
     * Provide a common method for plug-ins to check the version of DataTables being
     * used, in order to ensure compatibility.
     *
     *  @param {string} version Version string to check for, in the format "X.Y.Z".
     *    Note that the formats "X" and "X.Y" are also acceptable.
     *  @returns {boolean} true if this version of DataTables is greater or equal to
     *    the required version, or false if this version of DataTales is not
     *    suitable
     *  @static
     *  @dtopt API-Static
     *
     *  @example
     *    alert( $.fn.dataTable.versionCheck( '1.9.0' ) );
     */


    _DataTable.versionCheck = _DataTable.fnVersionCheck = function (version) {
      var aThis = _DataTable.version.split('.');

      var aThat = version.split('.');
      var iThis, iThat;

      for (var i = 0, iLen = aThat.length; i < iLen; i++) {
        iThis = parseInt(aThis[i], 10) || 0;
        iThat = parseInt(aThat[i], 10) || 0; // Parts are the same, keep comparing

        if (iThis === iThat) {
          continue;
        } // Parts are different, return immediately


        return iThis > iThat;
      }

      return true;
    };
    /**
     * Check if a `<table>` node is a DataTable table already or not.
     *
     *  @param {node|jquery|string} table Table node, jQuery object or jQuery
     *      selector for the table to test. Note that if more than more than one
     *      table is passed on, only the first will be checked
     *  @returns {boolean} true the table given is a DataTable, or false otherwise
     *  @static
     *  @dtopt API-Static
     *
     *  @example
     *    if ( ! $.fn.DataTable.isDataTable( '#example' ) ) {
     *      $('#example').dataTable();
     *    }
     */


    _DataTable.isDataTable = _DataTable.fnIsDataTable = function (table) {
      var t = $(table).get(0);
      var is = false;
      $.each(_DataTable.settings, function (i, o) {
        var head = o.nScrollHead ? $('table', o.nScrollHead)[0] : null;
        var foot = o.nScrollFoot ? $('table', o.nScrollFoot)[0] : null;

        if (o.nTable === t || head === t || foot === t) {
          is = true;
        }
      });
      return is;
    };
    /**
     * Get all DataTable tables that have been initialised - optionally you can
     * select to get only currently visible tables.
     *
     *  @param {boolean} [visible=false] Flag to indicate if you want all (default)
     *    or visible tables only.
     *  @returns {array} Array of `table` nodes (not DataTable instances) which are
     *    DataTables
     *  @static
     *  @dtopt API-Static
     *
     *  @example
     *    $.each( $.fn.dataTable.tables(true), function () {
     *      $(table).DataTable().columns.adjust();
     *    } );
     */


    _DataTable.tables = _DataTable.fnTables = function (visible) {
      return $.map(_DataTable.settings, function (o) {
        if (!visible || visible && $(o.nTable).is(':visible')) {
          return o.nTable;
        }
      });
    };
    /**
     * DataTables utility methods
     * 
     * This namespace provides helper methods that DataTables uses internally to
     * create a DataTable, but which are not exclusively used only for DataTables.
     * These methods can be used by extension authors to save the duplication of
     * code.
     *
     *  @namespace
     */


    _DataTable.util = {
      /**
       * Throttle the calls to a function. Arguments and context are maintained
       * for the throttled function.
       *
       * @param {function} fn Function to be called
       * @param {integer} freq Call frequency in mS
       * @return {function} Wrapped function
       */
      throttle: _fnThrottle,

      /**
       * Escape a string such that it can be used in a regular expression
       *
       *  @param {string} sVal string to escape
       *  @returns {string} escaped string
       */
      escapeRegex: _fnEscapeRegex
    };
    /**
     * Convert from camel case parameters to Hungarian notation. This is made public
     * for the extensions to provide the same ability as DataTables core to accept
     * either the 1.9 style Hungarian notation, or the 1.10+ style camelCase
     * parameters.
     *
     *  @param {object} src The model object which holds all parameters that can be
     *    mapped.
     *  @param {object} user The object to convert from camel case to Hungarian.
     *  @param {boolean} force When set to `true`, properties which already have a
     *    Hungarian value in the `user` object will be overwritten. Otherwise they
     *    won't be.
     */

    _DataTable.camelToHungarian = _fnCamelToHungarian;
    /**
     *
     */

    _api_register('$()', function (selector, opts) {
      var rows = this.rows(opts).nodes(),
          // Get all rows
      jqRows = $(rows);
      return $([].concat(jqRows.filter(selector).toArray(), jqRows.find(selector).toArray()));
    }); // jQuery functions to operate on the tables


    $.each(['on', 'one', 'off'], function (i, key) {
      _api_register(key + '()', function ()
      /* event, handler */
      {
        var args = Array.prototype.slice.call(arguments); // Add the `dt` namespace automatically if it isn't already present

        if (!args[0].match(/\.dt\b/)) {
          args[0] += '.dt';
        }

        var inst = $(this.tables().nodes());
        inst[key].apply(inst, args);
        return this;
      });
    });

    _api_register('clear()', function () {
      return this.iterator('table', function (settings) {
        _fnClearTable(settings);
      });
    });

    _api_register('settings()', function () {
      return new _Api2(this.context, this.context);
    });

    _api_register('init()', function () {
      var ctx = this.context;
      return ctx.length ? ctx[0].oInit : null;
    });

    _api_register('data()', function () {
      return this.iterator('table', function (settings) {
        return _pluck(settings.aoData, '_aData');
      }).flatten();
    });

    _api_register('destroy()', function (remove) {
      remove = remove || false;
      return this.iterator('table', function (settings) {
        var orig = settings.nTableWrapper.parentNode;
        var classes = settings.oClasses;
        var table = settings.nTable;
        var tbody = settings.nTBody;
        var thead = settings.nTHead;
        var tfoot = settings.nTFoot;
        var jqTable = $(table);
        var jqTbody = $(tbody);
        var jqWrapper = $(settings.nTableWrapper);
        var rows = $.map(settings.aoData, function (r) {
          return r.nTr;
        });
        var i, ien; // Flag to note that the table is currently being destroyed - no action
        // should be taken

        settings.bDestroying = true; // Fire off the destroy callbacks for plug-ins etc

        _fnCallbackFire(settings, "aoDestroyCallback", "destroy", [settings]); // If not being removed from the document, make all columns visible


        if (!remove) {
          new _Api2(settings).columns().visible(true);
        } // Blitz all `DT` namespaced events (these are internal events, the
        // lowercase, `dt` events are user subscribed and they are responsible
        // for removing them


        jqWrapper.unbind('.DT').find(':not(tbody *)').unbind('.DT');
        $(window).unbind('.DT-' + settings.sInstance); // When scrolling we had to break the table up - restore it

        if (table != thead.parentNode) {
          jqTable.children('thead').detach();
          jqTable.append(thead);
        }

        if (tfoot && table != tfoot.parentNode) {
          jqTable.children('tfoot').detach();
          jqTable.append(tfoot);
        } // Remove the DataTables generated nodes, events and classes


        jqTable.detach();
        jqWrapper.detach();
        settings.aaSorting = [];
        settings.aaSortingFixed = [];

        _fnSortingClasses(settings);

        $(rows).removeClass(settings.asStripeClasses.join(' '));
        $('th, td', thead).removeClass(classes.sSortable + ' ' + classes.sSortableAsc + ' ' + classes.sSortableDesc + ' ' + classes.sSortableNone);

        if (settings.bJUI) {
          $('th span.' + classes.sSortIcon + ', td span.' + classes.sSortIcon, thead).detach();
          $('th, td', thead).each(function () {
            var wrapper = $('div.' + classes.sSortJUIWrapper, this);
            $(this).append(wrapper.contents());
            wrapper.detach();
          });
        }

        if (!remove && orig) {
          // insertBefore acts like appendChild if !arg[1]
          orig.insertBefore(table, settings.nTableReinsertBefore);
        } // Add the TR elements back into the table in their original order


        jqTbody.children().detach();
        jqTbody.append(rows); // Restore the width of the original table - was read from the style property,
        // so we can restore directly to that

        jqTable.css('width', settings.sDestroyWidth).removeClass(classes.sTable); // If the were originally stripe classes - then we add them back here.
        // Note this is not fool proof (for example if not all rows had stripe
        // classes - but it's a good effort without getting carried away

        ien = settings.asDestroyStripes.length;

        if (ien) {
          jqTbody.children().each(function (i) {
            $(this).addClass(settings.asDestroyStripes[i % ien]);
          });
        }
        /* Remove the settings object from the settings array */


        var idx = $.inArray(settings, _DataTable.settings);

        if (idx !== -1) {
          _DataTable.settings.splice(idx, 1);
        }
      });
    }); // Add the `every()` method for rows, columns and cells in a compact form


    $.each(['column', 'row', 'cell'], function (i, type) {
      _api_register(type + 's().every()', function (fn) {
        return this.iterator(type, function (settings, idx, idx2) {
          // idx2 is undefined for rows and columns.
          fn.call(new _Api2(settings)[type](idx, idx2));
        });
      });
    }); // i18n method for extensions to be able to use the language object from the
    // DataTable

    _api_register('i18n()', function (token, def, plural) {
      var ctx = this.context[0];

      var resolved = _fnGetObjectDataFn(token)(ctx.oLanguage);

      if (resolved === undefined) {
        resolved = def;
      }

      if (plural !== undefined && $.isPlainObject(resolved)) {
        resolved = resolved[plural] !== undefined ? resolved[plural] : resolved._;
      }

      return resolved.replace('%d', plural); // nb: plural might be undefined,
    });
    /**
     * Version string for plug-ins to check compatibility. Allowed format is
     * `a.b.c-d` where: a:int, b:int, c:int, d:string(dev|beta|alpha). `d` is used
     * only for non-release builds. See http://semver.org/ for more information.
     *  @member
     *  @type string
     *  @default Version number
     */


    _DataTable.version = "1.10.7";
    /**
     * Private data store, containing all of the settings objects that are
     * created for the tables on a given page.
     *
     * Note that the `DataTable.settings` object is aliased to
     * `jQuery.fn.dataTableExt` through which it may be accessed and
     * manipulated, or `jQuery.fn.dataTable.settings`.
     *  @member
     *  @type array
     *  @default []
     *  @private
     */

    _DataTable.settings = [];
    /**
     * Object models container, for the various models that DataTables has
     * available to it. These models define the objects that are used to hold
     * the active state and configuration of the table.
     *  @namespace
     */

    _DataTable.models = {};
    /**
     * Template object for the way in which DataTables holds information about
     * search information for the global filter and individual column filters.
     *  @namespace
     */

    _DataTable.models.oSearch = {
      /**
       * Flag to indicate if the filtering should be case insensitive or not
       *  @type boolean
       *  @default true
       */
      "bCaseInsensitive": true,

      /**
       * Applied search term
       *  @type string
       *  @default <i>Empty string</i>
       */
      "sSearch": "",

      /**
       * Flag to indicate if the search term should be interpreted as a
       * regular expression (true) or not (false) and therefore and special
       * regex characters escaped.
       *  @type boolean
       *  @default false
       */
      "bRegex": false,

      /**
       * Flag to indicate if DataTables is to use its smart filtering or not.
       *  @type boolean
       *  @default true
       */
      "bSmart": true
    };
    /**
     * Template object for the way in which DataTables holds information about
     * each individual row. This is the object format used for the settings
     * aoData array.
     *  @namespace
     */

    _DataTable.models.oRow = {
      /**
       * TR element for the row
       *  @type node
       *  @default null
       */
      "nTr": null,

      /**
       * Array of TD elements for each row. This is null until the row has been
       * created.
       *  @type array nodes
       *  @default []
       */
      "anCells": null,

      /**
       * Data object from the original data source for the row. This is either
       * an array if using the traditional form of DataTables, or an object if
       * using mData options. The exact type will depend on the passed in
       * data from the data source, or will be an array if using DOM a data
       * source.
       *  @type array|object
       *  @default []
       */
      "_aData": [],

      /**
       * Sorting data cache - this array is ostensibly the same length as the
       * number of columns (although each index is generated only as it is
       * needed), and holds the data that is used for sorting each column in the
       * row. We do this cache generation at the start of the sort in order that
       * the formatting of the sort data need be done only once for each cell
       * per sort. This array should not be read from or written to by anything
       * other than the master sorting methods.
       *  @type array
       *  @default null
       *  @private
       */
      "_aSortData": null,

      /**
       * Per cell filtering data cache. As per the sort data cache, used to
       * increase the performance of the filtering in DataTables
       *  @type array
       *  @default null
       *  @private
       */
      "_aFilterData": null,

      /**
       * Filtering data cache. This is the same as the cell filtering cache, but
       * in this case a string rather than an array. This is easily computed with
       * a join on `_aFilterData`, but is provided as a cache so the join isn't
       * needed on every search (memory traded for performance)
       *  @type array
       *  @default null
       *  @private
       */
      "_sFilterRow": null,

      /**
       * Cache of the class name that DataTables has applied to the row, so we
       * can quickly look at this variable rather than needing to do a DOM check
       * on className for the nTr property.
       *  @type string
       *  @default <i>Empty string</i>
       *  @private
       */
      "_sRowStripe": "",

      /**
       * Denote if the original data source was from the DOM, or the data source
       * object. This is used for invalidating data, so DataTables can
       * automatically read data from the original source, unless uninstructed
       * otherwise.
       *  @type string
       *  @default null
       *  @private
       */
      "src": null
    };
    /**
     * Template object for the column information object in DataTables. This object
     * is held in the settings aoColumns array and contains all the information that
     * DataTables needs about each individual column.
     *
     * Note that this object is related to {@link DataTable.defaults.column}
     * but this one is the internal data store for DataTables's cache of columns.
     * It should NOT be manipulated outside of DataTables. Any configuration should
     * be done through the initialisation options.
     *  @namespace
     */

    _DataTable.models.oColumn = {
      /**
       * Column index. This could be worked out on-the-fly with $.inArray, but it
       * is faster to just hold it as a variable
       *  @type integer
       *  @default null
       */
      "idx": null,

      /**
       * A list of the columns that sorting should occur on when this column
       * is sorted. That this property is an array allows multi-column sorting
       * to be defined for a column (for example first name / last name columns
       * would benefit from this). The values are integers pointing to the
       * columns to be sorted on (typically it will be a single integer pointing
       * at itself, but that doesn't need to be the case).
       *  @type array
       */
      "aDataSort": null,

      /**
       * Define the sorting directions that are applied to the column, in sequence
       * as the column is repeatedly sorted upon - i.e. the first value is used
       * as the sorting direction when the column if first sorted (clicked on).
       * Sort it again (click again) and it will move on to the next index.
       * Repeat until loop.
       *  @type array
       */
      "asSorting": null,

      /**
       * Flag to indicate if the column is searchable, and thus should be included
       * in the filtering or not.
       *  @type boolean
       */
      "bSearchable": null,

      /**
       * Flag to indicate if the column is sortable or not.
       *  @type boolean
       */
      "bSortable": null,

      /**
       * Flag to indicate if the column is currently visible in the table or not
       *  @type boolean
       */
      "bVisible": null,

      /**
       * Store for manual type assignment using the `column.type` option. This
       * is held in store so we can manipulate the column's `sType` property.
       *  @type string
       *  @default null
       *  @private
       */
      "_sManualType": null,

      /**
       * Flag to indicate if HTML5 data attributes should be used as the data
       * source for filtering or sorting. True is either are.
       *  @type boolean
       *  @default false
       *  @private
       */
      "_bAttrSrc": false,

      /**
       * Developer definable function that is called whenever a cell is created (Ajax source,
       * etc) or processed for input (DOM source). This can be used as a compliment to mRender
       * allowing you to modify the DOM element (add background colour for example) when the
       * element is available.
       *  @type function
       *  @param {element} nTd The TD node that has been created
       *  @param {*} sData The Data for the cell
       *  @param {array|object} oData The data for the whole row
       *  @param {int} iRow The row index for the aoData data store
       *  @default null
       */
      "fnCreatedCell": null,

      /**
       * Function to get data from a cell in a column. You should <b>never</b>
       * access data directly through _aData internally in DataTables - always use
       * the method attached to this property. It allows mData to function as
       * required. This function is automatically assigned by the column
       * initialisation method
       *  @type function
       *  @param {array|object} oData The data array/object for the array
       *    (i.e. aoData[]._aData)
       *  @param {string} sSpecific The specific data type you want to get -
       *    'display', 'type' 'filter' 'sort'
       *  @returns {*} The data for the cell from the given row's data
       *  @default null
       */
      "fnGetData": null,

      /**
       * Function to set data for a cell in the column. You should <b>never</b>
       * set the data directly to _aData internally in DataTables - always use
       * this method. It allows mData to function as required. This function
       * is automatically assigned by the column initialisation method
       *  @type function
       *  @param {array|object} oData The data array/object for the array
       *    (i.e. aoData[]._aData)
       *  @param {*} sValue Value to set
       *  @default null
       */
      "fnSetData": null,

      /**
       * Property to read the value for the cells in the column from the data
       * source array / object. If null, then the default content is used, if a
       * function is given then the return from the function is used.
       *  @type function|int|string|null
       *  @default null
       */
      "mData": null,

      /**
       * Partner property to mData which is used (only when defined) to get
       * the data - i.e. it is basically the same as mData, but without the
       * 'set' option, and also the data fed to it is the result from mData.
       * This is the rendering method to match the data method of mData.
       *  @type function|int|string|null
       *  @default null
       */
      "mRender": null,

      /**
       * Unique header TH/TD element for this column - this is what the sorting
       * listener is attached to (if sorting is enabled.)
       *  @type node
       *  @default null
       */
      "nTh": null,

      /**
       * Unique footer TH/TD element for this column (if there is one). Not used
       * in DataTables as such, but can be used for plug-ins to reference the
       * footer for each column.
       *  @type node
       *  @default null
       */
      "nTf": null,

      /**
       * The class to apply to all TD elements in the table's TBODY for the column
       *  @type string
       *  @default null
       */
      "sClass": null,

      /**
       * When DataTables calculates the column widths to assign to each column,
       * it finds the longest string in each column and then constructs a
       * temporary table and reads the widths from that. The problem with this
       * is that "mmm" is much wider then "iiii", but the latter is a longer
       * string - thus the calculation can go wrong (doing it properly and putting
       * it into an DOM object and measuring that is horribly(!) slow). Thus as
       * a "work around" we provide this option. It will append its value to the
       * text that is found to be the longest string for the column - i.e. padding.
       *  @type string
       */
      "sContentPadding": null,

      /**
       * Allows a default value to be given for a column's data, and will be used
       * whenever a null data source is encountered (this can be because mData
       * is set to null, or because the data source itself is null).
       *  @type string
       *  @default null
       */
      "sDefaultContent": null,

      /**
       * Name for the column, allowing reference to the column by name as well as
       * by index (needs a lookup to work by name).
       *  @type string
       */
      "sName": null,

      /**
       * Custom sorting data type - defines which of the available plug-ins in
       * afnSortData the custom sorting will use - if any is defined.
       *  @type string
       *  @default std
       */
      "sSortDataType": 'std',

      /**
       * Class to be applied to the header element when sorting on this column
       *  @type string
       *  @default null
       */
      "sSortingClass": null,

      /**
       * Class to be applied to the header element when sorting on this column -
       * when jQuery UI theming is used.
       *  @type string
       *  @default null
       */
      "sSortingClassJUI": null,

      /**
       * Title of the column - what is seen in the TH element (nTh).
       *  @type string
       */
      "sTitle": null,

      /**
       * Column sorting and filtering type
       *  @type string
       *  @default null
       */
      "sType": null,

      /**
       * Width of the column
       *  @type string
       *  @default null
       */
      "sWidth": null,

      /**
       * Width of the column when it was first "encountered"
       *  @type string
       *  @default null
       */
      "sWidthOrig": null
    };
    /*
     * Developer note: The properties of the object below are given in Hungarian
     * notation, that was used as the interface for DataTables prior to v1.10, however
     * from v1.10 onwards the primary interface is camel case. In order to avoid
     * breaking backwards compatibility utterly with this change, the Hungarian
     * version is still, internally the primary interface, but is is not documented
     * - hence the @name tags in each doc comment. This allows a Javascript function
     * to create a map from Hungarian notation to camel case (going the other direction
     * would require each property to be listed, which would at around 3K to the size
     * of DataTables, while this method is about a 0.5K hit.
     *
     * Ultimately this does pave the way for Hungarian notation to be dropped
     * completely, but that is a massive amount of work and will break current
     * installs (therefore is on-hold until v2).
     */

    /**
     * Initialisation options that can be given to DataTables at initialisation
     * time.
     *  @namespace
     */

    _DataTable.defaults = {
      /**
       * An array of data to use for the table, passed in at initialisation which
       * will be used in preference to any data which is already in the DOM. This is
       * particularly useful for constructing tables purely in Javascript, for
       * example with a custom Ajax call.
       *  @type array
       *  @default null
       *
       *  @dtopt Option
       *  @name DataTable.defaults.data
       *
       *  @example
       *    // Using a 2D array data source
       *    $(document).ready( function () {
       *      $('#example').dataTable( {
       *        "data": [
       *          ['Trident', 'Internet Explorer 4.0', 'Win 95+', 4, 'X'],
       *          ['Trident', 'Internet Explorer 5.0', 'Win 95+', 5, 'C'],
       *        ],
       *        "columns": [
       *          { "title": "Engine" },
       *          { "title": "Browser" },
       *          { "title": "Platform" },
       *          { "title": "Version" },
       *          { "title": "Grade" }
       *        ]
       *      } );
       *    } );
       *
       *  @example
       *    // Using an array of objects as a data source (`data`)
       *    $(document).ready( function () {
       *      $('#example').dataTable( {
       *        "data": [
       *          {
       *            "engine":   "Trident",
       *            "browser":  "Internet Explorer 4.0",
       *            "platform": "Win 95+",
       *            "version":  4,
       *            "grade":    "X"
       *          },
       *          {
       *            "engine":   "Trident",
       *            "browser":  "Internet Explorer 5.0",
       *            "platform": "Win 95+",
       *            "version":  5,
       *            "grade":    "C"
       *          }
       *        ],
       *        "columns": [
       *          { "title": "Engine",   "data": "engine" },
       *          { "title": "Browser",  "data": "browser" },
       *          { "title": "Platform", "data": "platform" },
       *          { "title": "Version",  "data": "version" },
       *          { "title": "Grade",    "data": "grade" }
       *        ]
       *      } );
       *    } );
       */
      "aaData": null,

      /**
       * If ordering is enabled, then DataTables will perform a first pass sort on
       * initialisation. You can define which column(s) the sort is performed
       * upon, and the sorting direction, with this variable. The `sorting` array
       * should contain an array for each column to be sorted initially containing
       * the column's index and a direction string ('asc' or 'desc').
       *  @type array
       *  @default [[0,'asc']]
       *
       *  @dtopt Option
       *  @name DataTable.defaults.order
       *
       *  @example
       *    // Sort by 3rd column first, and then 4th column
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "order": [[2,'asc'], [3,'desc']]
       *      } );
       *    } );
       *
       *    // No initial sorting
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "order": []
       *      } );
       *    } );
       */
      "aaSorting": [[0, 'asc']],

      /**
       * This parameter is basically identical to the `sorting` parameter, but
       * cannot be overridden by user interaction with the table. What this means
       * is that you could have a column (visible or hidden) which the sorting
       * will always be forced on first - any sorting after that (from the user)
       * will then be performed as required. This can be useful for grouping rows
       * together.
       *  @type array
       *  @default null
       *
       *  @dtopt Option
       *  @name DataTable.defaults.orderFixed
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "orderFixed": [[0,'asc']]
       *      } );
       *    } )
       */
      "aaSortingFixed": [],

      /**
       * DataTables can be instructed to load data to display in the table from a
       * Ajax source. This option defines how that Ajax call is made and where to.
       *
       * The `ajax` property has three different modes of operation, depending on
       * how it is defined. These are:
       *
       * * `string` - Set the URL from where the data should be loaded from.
       * * `object` - Define properties for `jQuery.ajax`.
       * * `function` - Custom data get function
       *
       * `string`
       * --------
       *
       * As a string, the `ajax` property simply defines the URL from which
       * DataTables will load data.
       *
       * `object`
       * --------
       *
       * As an object, the parameters in the object are passed to
       * [jQuery.ajax](http://api.jquery.com/jQuery.ajax/) allowing fine control
       * of the Ajax request. DataTables has a number of default parameters which
       * you can override using this option. Please refer to the jQuery
       * documentation for a full description of the options available, although
       * the following parameters provide additional options in DataTables or
       * require special consideration:
       *
       * * `data` - As with jQuery, `data` can be provided as an object, but it
       *   can also be used as a function to manipulate the data DataTables sends
       *   to the server. The function takes a single parameter, an object of
       *   parameters with the values that DataTables has readied for sending. An
       *   object may be returned which will be merged into the DataTables
       *   defaults, or you can add the items to the object that was passed in and
       *   not return anything from the function. This supersedes `fnServerParams`
       *   from DataTables 1.9-.
       *
       * * `dataSrc` - By default DataTables will look for the property `data` (or
       *   `aaData` for compatibility with DataTables 1.9-) when obtaining data
       *   from an Ajax source or for server-side processing - this parameter
       *   allows that property to be changed. You can use Javascript dotted
       *   object notation to get a data source for multiple levels of nesting, or
       *   it my be used as a function. As a function it takes a single parameter,
       *   the JSON returned from the server, which can be manipulated as
       *   required, with the returned value being that used by DataTables as the
       *   data source for the table. This supersedes `sAjaxDataProp` from
       *   DataTables 1.9-.
       *
       * * `success` - Should not be overridden it is used internally in
       *   DataTables. To manipulate / transform the data returned by the server
       *   use `ajax.dataSrc`, or use `ajax` as a function (see below).
       *
       * `function`
       * ----------
       *
       * As a function, making the Ajax call is left up to yourself allowing
       * complete control of the Ajax request. Indeed, if desired, a method other
       * than Ajax could be used to obtain the required data, such as Web storage
       * or an AIR database.
       *
       * The function is given four parameters and no return is required. The
       * parameters are:
       *
       * 1. _object_ - Data to send to the server
       * 2. _function_ - Callback function that must be executed when the required
       *    data has been obtained. That data should be passed into the callback
       *    as the only parameter
       * 3. _object_ - DataTables settings object for the table
       *
       * Note that this supersedes `fnServerData` from DataTables 1.9-.
       *
       *  @type string|object|function
       *  @default null
       *
       *  @dtopt Option
       *  @name DataTable.defaults.ajax
       *  @since 1.10.0
       *
       * @example
       *   // Get JSON data from a file via Ajax.
       *   // Note DataTables expects data in the form `{ data: [ ...data... ] }` by default).
       *   $('#example').dataTable( {
       *     "ajax": "data.json"
       *   } );
       *
       * @example
       *   // Get JSON data from a file via Ajax, using `dataSrc` to change
       *   // `data` to `tableData` (i.e. `{ tableData: [ ...data... ] }`)
       *   $('#example').dataTable( {
       *     "ajax": {
       *       "url": "data.json",
       *       "dataSrc": "tableData"
       *     }
       *   } );
       *
       * @example
       *   // Get JSON data from a file via Ajax, using `dataSrc` to read data
       *   // from a plain array rather than an array in an object
       *   $('#example').dataTable( {
       *     "ajax": {
       *       "url": "data.json",
       *       "dataSrc": ""
       *     }
       *   } );
       *
       * @example
       *   // Manipulate the data returned from the server - add a link to data
       *   // (note this can, should, be done using `render` for the column - this
       *   // is just a simple example of how the data can be manipulated).
       *   $('#example').dataTable( {
       *     "ajax": {
       *       "url": "data.json",
       *       "dataSrc": function ( json ) {
       *         for ( var i=0, ien=json.length ; i<ien ; i++ ) {
       *           json[i][0] = '<a href="/message/'+json[i][0]+'>View message</a>';
       *         }
       *         return json;
       *       }
       *     }
       *   } );
       *
       * @example
       *   // Add data to the request
       *   $('#example').dataTable( {
       *     "ajax": {
       *       "url": "data.json",
       *       "data": function ( d ) {
       *         return {
       *           "extra_search": $('#extra').val()
       *         };
       *       }
       *     }
       *   } );
       *
       * @example
       *   // Send request as POST
       *   $('#example').dataTable( {
       *     "ajax": {
       *       "url": "data.json",
       *       "type": "POST"
       *     }
       *   } );
       *
       * @example
       *   // Get the data from localStorage (could interface with a form for
       *   // adding, editing and removing rows).
       *   $('#example').dataTable( {
       *     "ajax": function (data, callback, settings) {
       *       callback(
       *         JSON.parse( localStorage.getItem('dataTablesData') )
       *       );
       *     }
       *   } );
       */
      "ajax": null,

      /**
       * This parameter allows you to readily specify the entries in the length drop
       * down menu that DataTables shows when pagination is enabled. It can be
       * either a 1D array of options which will be used for both the displayed
       * option and the value, or a 2D array which will use the array in the first
       * position as the value, and the array in the second position as the
       * displayed options (useful for language strings such as 'All').
       *
       * Note that the `pageLength` property will be automatically set to the
       * first value given in this array, unless `pageLength` is also provided.
       *  @type array
       *  @default [ 10, 25, 50, 100 ]
       *
       *  @dtopt Option
       *  @name DataTable.defaults.lengthMenu
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "lengthMenu": [[10, 25, 50, -1], [10, 25, 50, "All"]]
       *      } );
       *    } );
       */
      "aLengthMenu": [10, 25, 50, 100],

      /**
       * The `columns` option in the initialisation parameter allows you to define
       * details about the way individual columns behave. For a full list of
       * column options that can be set, please see
       * {@link DataTable.defaults.column}. Note that if you use `columns` to
       * define your columns, you must have an entry in the array for every single
       * column that you have in your table (these can be null if you don't which
       * to specify any options).
       *  @member
       *
       *  @name DataTable.defaults.column
       */
      "aoColumns": null,

      /**
       * Very similar to `columns`, `columnDefs` allows you to target a specific
       * column, multiple columns, or all columns, using the `targets` property of
       * each object in the array. This allows great flexibility when creating
       * tables, as the `columnDefs` arrays can be of any length, targeting the
       * columns you specifically want. `columnDefs` may use any of the column
       * options available: {@link DataTable.defaults.column}, but it _must_
       * have `targets` defined in each object in the array. Values in the `targets`
       * array may be:
       *   <ul>
       *     <li>a string - class name will be matched on the TH for the column</li>
       *     <li>0 or a positive integer - column index counting from the left</li>
       *     <li>a negative integer - column index counting from the right</li>
       *     <li>the string "_all" - all columns (i.e. assign a default)</li>
       *   </ul>
       *  @member
       *
       *  @name DataTable.defaults.columnDefs
       */
      "aoColumnDefs": null,

      /**
       * Basically the same as `search`, this parameter defines the individual column
       * filtering state at initialisation time. The array must be of the same size
       * as the number of columns, and each element be an object with the parameters
       * `search` and `escapeRegex` (the latter is optional). 'null' is also
       * accepted and the default will be used.
       *  @type array
       *  @default []
       *
       *  @dtopt Option
       *  @name DataTable.defaults.searchCols
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "searchCols": [
       *          null,
       *          { "search": "My filter" },
       *          null,
       *          { "search": "^[0-9]", "escapeRegex": false }
       *        ]
       *      } );
       *    } )
       */
      "aoSearchCols": [],

      /**
       * An array of CSS classes that should be applied to displayed rows. This
       * array may be of any length, and DataTables will apply each class
       * sequentially, looping when required.
       *  @type array
       *  @default null <i>Will take the values determined by the `oClasses.stripe*`
       *    options</i>
       *
       *  @dtopt Option
       *  @name DataTable.defaults.stripeClasses
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "stripeClasses": [ 'strip1', 'strip2', 'strip3' ]
       *      } );
       *    } )
       */
      "asStripeClasses": null,

      /**
       * Enable or disable automatic column width calculation. This can be disabled
       * as an optimisation (it takes some time to calculate the widths) if the
       * tables widths are passed in using `columns`.
       *  @type boolean
       *  @default true
       *
       *  @dtopt Features
       *  @name DataTable.defaults.autoWidth
       *
       *  @example
       *    $(document).ready( function () {
       *      $('#example').dataTable( {
       *        "autoWidth": false
       *      } );
       *    } );
       */
      "bAutoWidth": true,

      /**
       * Deferred rendering can provide DataTables with a huge speed boost when you
       * are using an Ajax or JS data source for the table. This option, when set to
       * true, will cause DataTables to defer the creation of the table elements for
       * each row until they are needed for a draw - saving a significant amount of
       * time.
       *  @type boolean
       *  @default false
       *
       *  @dtopt Features
       *  @name DataTable.defaults.deferRender
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "ajax": "sources/arrays.txt",
       *        "deferRender": true
       *      } );
       *    } );
       */
      "bDeferRender": false,

      /**
       * Replace a DataTable which matches the given selector and replace it with
       * one which has the properties of the new initialisation object passed. If no
       * table matches the selector, then the new DataTable will be constructed as
       * per normal.
       *  @type boolean
       *  @default false
       *
       *  @dtopt Options
       *  @name DataTable.defaults.destroy
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "srollY": "200px",
       *        "paginate": false
       *      } );
       *
       *      // Some time later....
       *      $('#example').dataTable( {
       *        "filter": false,
       *        "destroy": true
       *      } );
       *    } );
       */
      "bDestroy": false,

      /**
       * Enable or disable filtering of data. Filtering in DataTables is "smart" in
       * that it allows the end user to input multiple words (space separated) and
       * will match a row containing those words, even if not in the order that was
       * specified (this allow matching across multiple columns). Note that if you
       * wish to use filtering in DataTables this must remain 'true' - to remove the
       * default filtering input box and retain filtering abilities, please use
       * {@link DataTable.defaults.dom}.
       *  @type boolean
       *  @default true
       *
       *  @dtopt Features
       *  @name DataTable.defaults.searching
       *
       *  @example
       *    $(document).ready( function () {
       *      $('#example').dataTable( {
       *        "searching": false
       *      } );
       *    } );
       */
      "bFilter": true,

      /**
       * Enable or disable the table information display. This shows information
       * about the data that is currently visible on the page, including information
       * about filtered data if that action is being performed.
       *  @type boolean
       *  @default true
       *
       *  @dtopt Features
       *  @name DataTable.defaults.info
       *
       *  @example
       *    $(document).ready( function () {
       *      $('#example').dataTable( {
       *        "info": false
       *      } );
       *    } );
       */
      "bInfo": true,

      /**
       * Enable jQuery UI ThemeRoller support (required as ThemeRoller requires some
       * slightly different and additional mark-up from what DataTables has
       * traditionally used).
       *  @type boolean
       *  @default false
       *
       *  @dtopt Features
       *  @name DataTable.defaults.jQueryUI
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "jQueryUI": true
       *      } );
       *    } );
       */
      "bJQueryUI": false,

      /**
       * Allows the end user to select the size of a formatted page from a select
       * menu (sizes are 10, 25, 50 and 100). Requires pagination (`paginate`).
       *  @type boolean
       *  @default true
       *
       *  @dtopt Features
       *  @name DataTable.defaults.lengthChange
       *
       *  @example
       *    $(document).ready( function () {
       *      $('#example').dataTable( {
       *        "lengthChange": false
       *      } );
       *    } );
       */
      "bLengthChange": true,

      /**
       * Enable or disable pagination.
       *  @type boolean
       *  @default true
       *
       *  @dtopt Features
       *  @name DataTable.defaults.paging
       *
       *  @example
       *    $(document).ready( function () {
       *      $('#example').dataTable( {
       *        "paging": false
       *      } );
       *    } );
       */
      "bPaginate": true,

      /**
       * Enable or disable the display of a 'processing' indicator when the table is
       * being processed (e.g. a sort). This is particularly useful for tables with
       * large amounts of data where it can take a noticeable amount of time to sort
       * the entries.
       *  @type boolean
       *  @default false
       *
       *  @dtopt Features
       *  @name DataTable.defaults.processing
       *
       *  @example
       *    $(document).ready( function () {
       *      $('#example').dataTable( {
       *        "processing": true
       *      } );
       *    } );
       */
      "bProcessing": false,

      /**
       * Retrieve the DataTables object for the given selector. Note that if the
       * table has already been initialised, this parameter will cause DataTables
       * to simply return the object that has already been set up - it will not take
       * account of any changes you might have made to the initialisation object
       * passed to DataTables (setting this parameter to true is an acknowledgement
       * that you understand this). `destroy` can be used to reinitialise a table if
       * you need.
       *  @type boolean
       *  @default false
       *
       *  @dtopt Options
       *  @name DataTable.defaults.retrieve
       *
       *  @example
       *    $(document).ready( function() {
       *      initTable();
       *      tableActions();
       *    } );
       *
       *    function initTable ()
       *    {
       *      return $('#example').dataTable( {
       *        "scrollY": "200px",
       *        "paginate": false,
       *        "retrieve": true
       *      } );
       *    }
       *
       *    function tableActions ()
       *    {
       *      var table = initTable();
       *      // perform API operations with oTable
       *    }
       */
      "bRetrieve": false,

      /**
       * When vertical (y) scrolling is enabled, DataTables will force the height of
       * the table's viewport to the given height at all times (useful for layout).
       * However, this can look odd when filtering data down to a small data set,
       * and the footer is left "floating" further down. This parameter (when
       * enabled) will cause DataTables to collapse the table's viewport down when
       * the result set will fit within the given Y height.
       *  @type boolean
       *  @default false
       *
       *  @dtopt Options
       *  @name DataTable.defaults.scrollCollapse
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "scrollY": "200",
       *        "scrollCollapse": true
       *      } );
       *    } );
       */
      "bScrollCollapse": false,

      /**
       * Configure DataTables to use server-side processing. Note that the
       * `ajax` parameter must also be given in order to give DataTables a
       * source to obtain the required data for each draw.
       *  @type boolean
       *  @default false
       *
       *  @dtopt Features
       *  @dtopt Server-side
       *  @name DataTable.defaults.serverSide
       *
       *  @example
       *    $(document).ready( function () {
       *      $('#example').dataTable( {
       *        "serverSide": true,
       *        "ajax": "xhr.php"
       *      } );
       *    } );
       */
      "bServerSide": false,

      /**
       * Enable or disable sorting of columns. Sorting of individual columns can be
       * disabled by the `sortable` option for each column.
       *  @type boolean
       *  @default true
       *
       *  @dtopt Features
       *  @name DataTable.defaults.ordering
       *
       *  @example
       *    $(document).ready( function () {
       *      $('#example').dataTable( {
       *        "ordering": false
       *      } );
       *    } );
       */
      "bSort": true,

      /**
       * Enable or display DataTables' ability to sort multiple columns at the
       * same time (activated by shift-click by the user).
       *  @type boolean
       *  @default true
       *
       *  @dtopt Options
       *  @name DataTable.defaults.orderMulti
       *
       *  @example
       *    // Disable multiple column sorting ability
       *    $(document).ready( function () {
       *      $('#example').dataTable( {
       *        "orderMulti": false
       *      } );
       *    } );
       */
      "bSortMulti": true,

      /**
       * Allows control over whether DataTables should use the top (true) unique
       * cell that is found for a single column, or the bottom (false - default).
       * This is useful when using complex headers.
       *  @type boolean
       *  @default false
       *
       *  @dtopt Options
       *  @name DataTable.defaults.orderCellsTop
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "orderCellsTop": true
       *      } );
       *    } );
       */
      "bSortCellsTop": false,

      /**
       * Enable or disable the addition of the classes `sorting\_1`, `sorting\_2` and
       * `sorting\_3` to the columns which are currently being sorted on. This is
       * presented as a feature switch as it can increase processing time (while
       * classes are removed and added) so for large data sets you might want to
       * turn this off.
       *  @type boolean
       *  @default true
       *
       *  @dtopt Features
       *  @name DataTable.defaults.orderClasses
       *
       *  @example
       *    $(document).ready( function () {
       *      $('#example').dataTable( {
       *        "orderClasses": false
       *      } );
       *    } );
       */
      "bSortClasses": true,

      /**
       * Enable or disable state saving. When enabled HTML5 `localStorage` will be
       * used to save table display information such as pagination information,
       * display length, filtering and sorting. As such when the end user reloads
       * the page the display display will match what thy had previously set up.
       *
       * Due to the use of `localStorage` the default state saving is not supported
       * in IE6 or 7. If state saving is required in those browsers, use
       * `stateSaveCallback` to provide a storage solution such as cookies.
       *  @type boolean
       *  @default false
       *
       *  @dtopt Features
       *  @name DataTable.defaults.stateSave
       *
       *  @example
       *    $(document).ready( function () {
       *      $('#example').dataTable( {
       *        "stateSave": true
       *      } );
       *    } );
       */
      "bStateSave": false,

      /**
       * This function is called when a TR element is created (and all TD child
       * elements have been inserted), or registered if using a DOM source, allowing
       * manipulation of the TR element (adding classes etc).
       *  @type function
       *  @param {node} row "TR" element for the current row
       *  @param {array} data Raw data array for this row
       *  @param {int} dataIndex The index of this row in the internal aoData array
       *
       *  @dtopt Callbacks
       *  @name DataTable.defaults.createdRow
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "createdRow": function( row, data, dataIndex ) {
       *          // Bold the grade for all 'A' grade browsers
       *          if ( data[4] == "A" )
       *          {
       *            $('td:eq(4)', row).html( '<b>A</b>' );
       *          }
       *        }
       *      } );
       *    } );
       */
      "fnCreatedRow": null,

      /**
       * This function is called on every 'draw' event, and allows you to
       * dynamically modify any aspect you want about the created DOM.
       *  @type function
       *  @param {object} settings DataTables settings object
       *
       *  @dtopt Callbacks
       *  @name DataTable.defaults.drawCallback
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "drawCallback": function( settings ) {
       *          alert( 'DataTables has redrawn the table' );
       *        }
       *      } );
       *    } );
       */
      "fnDrawCallback": null,

      /**
       * Identical to fnHeaderCallback() but for the table footer this function
       * allows you to modify the table footer on every 'draw' event.
       *  @type function
       *  @param {node} foot "TR" element for the footer
       *  @param {array} data Full table data (as derived from the original HTML)
       *  @param {int} start Index for the current display starting point in the
       *    display array
       *  @param {int} end Index for the current display ending point in the
       *    display array
       *  @param {array int} display Index array to translate the visual position
       *    to the full data array
       *
       *  @dtopt Callbacks
       *  @name DataTable.defaults.footerCallback
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "footerCallback": function( tfoot, data, start, end, display ) {
       *          tfoot.getElementsByTagName('th')[0].innerHTML = "Starting index is "+start;
       *        }
       *      } );
       *    } )
       */
      "fnFooterCallback": null,

      /**
       * When rendering large numbers in the information element for the table
       * (i.e. "Showing 1 to 10 of 57 entries") DataTables will render large numbers
       * to have a comma separator for the 'thousands' units (e.g. 1 million is
       * rendered as "1,000,000") to help readability for the end user. This
       * function will override the default method DataTables uses.
       *  @type function
       *  @member
       *  @param {int} toFormat number to be formatted
       *  @returns {string} formatted string for DataTables to show the number
       *
       *  @dtopt Callbacks
       *  @name DataTable.defaults.formatNumber
       *
       *  @example
       *    // Format a number using a single quote for the separator (note that
       *    // this can also be done with the language.thousands option)
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "formatNumber": function ( toFormat ) {
       *          return toFormat.toString().replace(
       *            /\B(?=(\d{3})+(?!\d))/g, "'"
       *          );
       *        };
       *      } );
       *    } );
       */
      "fnFormatNumber": function fnFormatNumber(toFormat) {
        return toFormat.toString().replace(/\B(?=(\d{3})+(?!\d))/g, this.oLanguage.sThousands);
      },

      /**
       * This function is called on every 'draw' event, and allows you to
       * dynamically modify the header row. This can be used to calculate and
       * display useful information about the table.
       *  @type function
       *  @param {node} head "TR" element for the header
       *  @param {array} data Full table data (as derived from the original HTML)
       *  @param {int} start Index for the current display starting point in the
       *    display array
       *  @param {int} end Index for the current display ending point in the
       *    display array
       *  @param {array int} display Index array to translate the visual position
       *    to the full data array
       *
       *  @dtopt Callbacks
       *  @name DataTable.defaults.headerCallback
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "fheaderCallback": function( head, data, start, end, display ) {
       *          head.getElementsByTagName('th')[0].innerHTML = "Displaying "+(end-start)+" records";
       *        }
       *      } );
       *    } )
       */
      "fnHeaderCallback": null,

      /**
       * The information element can be used to convey information about the current
       * state of the table. Although the internationalisation options presented by
       * DataTables are quite capable of dealing with most customisations, there may
       * be times where you wish to customise the string further. This callback
       * allows you to do exactly that.
       *  @type function
       *  @param {object} oSettings DataTables settings object
       *  @param {int} start Starting position in data for the draw
       *  @param {int} end End position in data for the draw
       *  @param {int} max Total number of rows in the table (regardless of
       *    filtering)
       *  @param {int} total Total number of rows in the data set, after filtering
       *  @param {string} pre The string that DataTables has formatted using it's
       *    own rules
       *  @returns {string} The string to be displayed in the information element.
       *
       *  @dtopt Callbacks
       *  @name DataTable.defaults.infoCallback
       *
       *  @example
       *    $('#example').dataTable( {
       *      "infoCallback": function( settings, start, end, max, total, pre ) {
       *        return start +" to "+ end;
       *      }
       *    } );
       */
      "fnInfoCallback": null,

      /**
       * Called when the table has been initialised. Normally DataTables will
       * initialise sequentially and there will be no need for this function,
       * however, this does not hold true when using external language information
       * since that is obtained using an async XHR call.
       *  @type function
       *  @param {object} settings DataTables settings object
       *  @param {object} json The JSON object request from the server - only
       *    present if client-side Ajax sourced data is used
       *
       *  @dtopt Callbacks
       *  @name DataTable.defaults.initComplete
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "initComplete": function(settings, json) {
       *          alert( 'DataTables has finished its initialisation.' );
       *        }
       *      } );
       *    } )
       */
      "fnInitComplete": null,

      /**
       * Called at the very start of each table draw and can be used to cancel the
       * draw by returning false, any other return (including undefined) results in
       * the full draw occurring).
       *  @type function
       *  @param {object} settings DataTables settings object
       *  @returns {boolean} False will cancel the draw, anything else (including no
       *    return) will allow it to complete.
       *
       *  @dtopt Callbacks
       *  @name DataTable.defaults.preDrawCallback
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "preDrawCallback": function( settings ) {
       *          if ( $('#test').val() == 1 ) {
       *            return false;
       *          }
       *        }
       *      } );
       *    } );
       */
      "fnPreDrawCallback": null,

      /**
       * This function allows you to 'post process' each row after it have been
       * generated for each table draw, but before it is rendered on screen. This
       * function might be used for setting the row class name etc.
       *  @type function
       *  @param {node} row "TR" element for the current row
       *  @param {array} data Raw data array for this row
       *  @param {int} displayIndex The display index for the current table draw
       *  @param {int} displayIndexFull The index of the data in the full list of
       *    rows (after filtering)
       *
       *  @dtopt Callbacks
       *  @name DataTable.defaults.rowCallback
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "rowCallback": function( row, data, displayIndex, displayIndexFull ) {
       *          // Bold the grade for all 'A' grade browsers
       *          if ( data[4] == "A" ) {
       *            $('td:eq(4)', row).html( '<b>A</b>' );
       *          }
       *        }
       *      } );
       *    } );
       */
      "fnRowCallback": null,

      /**
       * __Deprecated__ The functionality provided by this parameter has now been
       * superseded by that provided through `ajax`, which should be used instead.
       *
       * This parameter allows you to override the default function which obtains
       * the data from the server so something more suitable for your application.
       * For example you could use POST data, or pull information from a Gears or
       * AIR database.
       *  @type function
       *  @member
       *  @param {string} source HTTP source to obtain the data from (`ajax`)
       *  @param {array} data A key/value pair object containing the data to send
       *    to the server
       *  @param {function} callback to be called on completion of the data get
       *    process that will draw the data on the page.
       *  @param {object} settings DataTables settings object
       *
       *  @dtopt Callbacks
       *  @dtopt Server-side
       *  @name DataTable.defaults.serverData
       *
       *  @deprecated 1.10. Please use `ajax` for this functionality now.
       */
      "fnServerData": null,

      /**
       * __Deprecated__ The functionality provided by this parameter has now been
       * superseded by that provided through `ajax`, which should be used instead.
       *
       *  It is often useful to send extra data to the server when making an Ajax
       * request - for example custom filtering information, and this callback
       * function makes it trivial to send extra information to the server. The
       * passed in parameter is the data set that has been constructed by
       * DataTables, and you can add to this or modify it as you require.
       *  @type function
       *  @param {array} data Data array (array of objects which are name/value
       *    pairs) that has been constructed by DataTables and will be sent to the
       *    server. In the case of Ajax sourced data with server-side processing
       *    this will be an empty array, for server-side processing there will be a
       *    significant number of parameters!
       *  @returns {undefined} Ensure that you modify the data array passed in,
       *    as this is passed by reference.
       *
       *  @dtopt Callbacks
       *  @dtopt Server-side
       *  @name DataTable.defaults.serverParams
       *
       *  @deprecated 1.10. Please use `ajax` for this functionality now.
       */
      "fnServerParams": null,

      /**
       * Load the table state. With this function you can define from where, and how, the
       * state of a table is loaded. By default DataTables will load from `localStorage`
       * but you might wish to use a server-side database or cookies.
       *  @type function
       *  @member
       *  @param {object} settings DataTables settings object
       *  @return {object} The DataTables state object to be loaded
       *
       *  @dtopt Callbacks
       *  @name DataTable.defaults.stateLoadCallback
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "stateSave": true,
       *        "stateLoadCallback": function (settings) {
       *          var o;
       *
       *          // Send an Ajax request to the server to get the data. Note that
       *          // this is a synchronous request.
       *          $.ajax( {
       *            "url": "/state_load",
       *            "async": false,
       *            "dataType": "json",
       *            "success": function (json) {
       *              o = json;
       *            }
       *          } );
       *
       *          return o;
       *        }
       *      } );
       *    } );
       */
      "fnStateLoadCallback": function fnStateLoadCallback(settings) {
        try {
          return JSON.parse((settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem('DataTables_' + settings.sInstance + '_' + location.pathname));
        } catch (e) {}
      },

      /**
       * Callback which allows modification of the saved state prior to loading that state.
       * This callback is called when the table is loading state from the stored data, but
       * prior to the settings object being modified by the saved state. Note that for
       * plug-in authors, you should use the `stateLoadParams` event to load parameters for
       * a plug-in.
       *  @type function
       *  @param {object} settings DataTables settings object
       *  @param {object} data The state object that is to be loaded
       *
       *  @dtopt Callbacks
       *  @name DataTable.defaults.stateLoadParams
       *
       *  @example
       *    // Remove a saved filter, so filtering is never loaded
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "stateSave": true,
       *        "stateLoadParams": function (settings, data) {
       *          data.oSearch.sSearch = "";
       *        }
       *      } );
       *    } );
       *
       *  @example
       *    // Disallow state loading by returning false
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "stateSave": true,
       *        "stateLoadParams": function (settings, data) {
       *          return false;
       *        }
       *      } );
       *    } );
       */
      "fnStateLoadParams": null,

      /**
       * Callback that is called when the state has been loaded from the state saving method
       * and the DataTables settings object has been modified as a result of the loaded state.
       *  @type function
       *  @param {object} settings DataTables settings object
       *  @param {object} data The state object that was loaded
       *
       *  @dtopt Callbacks
       *  @name DataTable.defaults.stateLoaded
       *
       *  @example
       *    // Show an alert with the filtering value that was saved
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "stateSave": true,
       *        "stateLoaded": function (settings, data) {
       *          alert( 'Saved filter was: '+data.oSearch.sSearch );
       *        }
       *      } );
       *    } );
       */
      "fnStateLoaded": null,

      /**
       * Save the table state. This function allows you to define where and how the state
       * information for the table is stored By default DataTables will use `localStorage`
       * but you might wish to use a server-side database or cookies.
       *  @type function
       *  @member
       *  @param {object} settings DataTables settings object
       *  @param {object} data The state object to be saved
       *
       *  @dtopt Callbacks
       *  @name DataTable.defaults.stateSaveCallback
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "stateSave": true,
       *        "stateSaveCallback": function (settings, data) {
       *          // Send an Ajax request to the server with the state object
       *          $.ajax( {
       *            "url": "/state_save",
       *            "data": data,
       *            "dataType": "json",
       *            "method": "POST"
       *            "success": function () {}
       *          } );
       *        }
       *      } );
       *    } );
       */
      "fnStateSaveCallback": function fnStateSaveCallback(settings, data) {
        try {
          (settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem('DataTables_' + settings.sInstance + '_' + location.pathname, JSON.stringify(data));
        } catch (e) {}
      },

      /**
       * Callback which allows modification of the state to be saved. Called when the table
       * has changed state a new state save is required. This method allows modification of
       * the state saving object prior to actually doing the save, including addition or
       * other state properties or modification. Note that for plug-in authors, you should
       * use the `stateSaveParams` event to save parameters for a plug-in.
       *  @type function
       *  @param {object} settings DataTables settings object
       *  @param {object} data The state object to be saved
       *
       *  @dtopt Callbacks
       *  @name DataTable.defaults.stateSaveParams
       *
       *  @example
       *    // Remove a saved filter, so filtering is never saved
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "stateSave": true,
       *        "stateSaveParams": function (settings, data) {
       *          data.oSearch.sSearch = "";
       *        }
       *      } );
       *    } );
       */
      "fnStateSaveParams": null,

      /**
       * Duration for which the saved state information is considered valid. After this period
       * has elapsed the state will be returned to the default.
       * Value is given in seconds.
       *  @type int
       *  @default 7200 <i>(2 hours)</i>
       *
       *  @dtopt Options
       *  @name DataTable.defaults.stateDuration
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "stateDuration": 60*60*24; // 1 day
       *      } );
       *    } )
       */
      "iStateDuration": 7200,

      /**
       * When enabled DataTables will not make a request to the server for the first
       * page draw - rather it will use the data already on the page (no sorting etc
       * will be applied to it), thus saving on an XHR at load time. `deferLoading`
       * is used to indicate that deferred loading is required, but it is also used
       * to tell DataTables how many records there are in the full table (allowing
       * the information element and pagination to be displayed correctly). In the case
       * where a filtering is applied to the table on initial load, this can be
       * indicated by giving the parameter as an array, where the first element is
       * the number of records available after filtering and the second element is the
       * number of records without filtering (allowing the table information element
       * to be shown correctly).
       *  @type int | array
       *  @default null
       *
       *  @dtopt Options
       *  @name DataTable.defaults.deferLoading
       *
       *  @example
       *    // 57 records available in the table, no filtering applied
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "serverSide": true,
       *        "ajax": "scripts/server_processing.php",
       *        "deferLoading": 57
       *      } );
       *    } );
       *
       *  @example
       *    // 57 records after filtering, 100 without filtering (an initial filter applied)
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "serverSide": true,
       *        "ajax": "scripts/server_processing.php",
       *        "deferLoading": [ 57, 100 ],
       *        "search": {
       *          "search": "my_filter"
       *        }
       *      } );
       *    } );
       */
      "iDeferLoading": null,

      /**
       * Number of rows to display on a single page when using pagination. If
       * feature enabled (`lengthChange`) then the end user will be able to override
       * this to a custom setting using a pop-up menu.
       *  @type int
       *  @default 10
       *
       *  @dtopt Options
       *  @name DataTable.defaults.pageLength
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "pageLength": 50
       *      } );
       *    } )
       */
      "iDisplayLength": 10,

      /**
       * Define the starting point for data display when using DataTables with
       * pagination. Note that this parameter is the number of records, rather than
       * the page number, so if you have 10 records per page and want to start on
       * the third page, it should be "20".
       *  @type int
       *  @default 0
       *
       *  @dtopt Options
       *  @name DataTable.defaults.displayStart
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "displayStart": 20
       *      } );
       *    } )
       */
      "iDisplayStart": 0,

      /**
       * By default DataTables allows keyboard navigation of the table (sorting, paging,
       * and filtering) by adding a `tabindex` attribute to the required elements. This
       * allows you to tab through the controls and press the enter key to activate them.
       * The tabindex is default 0, meaning that the tab follows the flow of the document.
       * You can overrule this using this parameter if you wish. Use a value of -1 to
       * disable built-in keyboard navigation.
       *  @type int
       *  @default 0
       *
       *  @dtopt Options
       *  @name DataTable.defaults.tabIndex
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "tabIndex": 1
       *      } );
       *    } );
       */
      "iTabIndex": 0,

      /**
       * Classes that DataTables assigns to the various components and features
       * that it adds to the HTML table. This allows classes to be configured
       * during initialisation in addition to through the static
       * {@link DataTable.ext.oStdClasses} object).
       *  @namespace
       *  @name DataTable.defaults.classes
       */
      "oClasses": {},

      /**
       * All strings that DataTables uses in the user interface that it creates
       * are defined in this object, allowing you to modified them individually or
       * completely replace them all as required.
       *  @namespace
       *  @name DataTable.defaults.language
       */
      "oLanguage": {
        /**
         * Strings that are used for WAI-ARIA labels and controls only (these are not
         * actually visible on the page, but will be read by screenreaders, and thus
         * must be internationalised as well).
         *  @namespace
         *  @name DataTable.defaults.language.aria
         */
        "oAria": {
          /**
           * ARIA label that is added to the table headers when the column may be
           * sorted ascending by activing the column (click or return when focused).
           * Note that the column header is prefixed to this string.
           *  @type string
           *  @default : activate to sort column ascending
           *
           *  @dtopt Language
           *  @name DataTable.defaults.language.aria.sortAscending
           *
           *  @example
           *    $(document).ready( function() {
           *      $('#example').dataTable( {
           *        "language": {
           *          "aria": {
           *            "sortAscending": " - click/return to sort ascending"
           *          }
           *        }
           *      } );
           *    } );
           */
          "sSortAscending": ": activate to sort column ascending",

          /**
           * ARIA label that is added to the table headers when the column may be
           * sorted descending by activing the column (click or return when focused).
           * Note that the column header is prefixed to this string.
           *  @type string
           *  @default : activate to sort column ascending
           *
           *  @dtopt Language
           *  @name DataTable.defaults.language.aria.sortDescending
           *
           *  @example
           *    $(document).ready( function() {
           *      $('#example').dataTable( {
           *        "language": {
           *          "aria": {
           *            "sortDescending": " - click/return to sort descending"
           *          }
           *        }
           *      } );
           *    } );
           */
          "sSortDescending": ": activate to sort column descending"
        },

        /**
         * Pagination string used by DataTables for the built-in pagination
         * control types.
         *  @namespace
         *  @name DataTable.defaults.language.paginate
         */
        "oPaginate": {
          /**
           * Text to use when using the 'full_numbers' type of pagination for the
           * button to take the user to the first page.
           *  @type string
           *  @default First
           *
           *  @dtopt Language
           *  @name DataTable.defaults.language.paginate.first
           *
           *  @example
           *    $(document).ready( function() {
           *      $('#example').dataTable( {
           *        "language": {
           *          "paginate": {
           *            "first": "First page"
           *          }
           *        }
           *      } );
           *    } );
           */
          "sFirst": "First",

          /**
           * Text to use when using the 'full_numbers' type of pagination for the
           * button to take the user to the last page.
           *  @type string
           *  @default Last
           *
           *  @dtopt Language
           *  @name DataTable.defaults.language.paginate.last
           *
           *  @example
           *    $(document).ready( function() {
           *      $('#example').dataTable( {
           *        "language": {
           *          "paginate": {
           *            "last": "Last page"
           *          }
           *        }
           *      } );
           *    } );
           */
          "sLast": "Last",

          /**
           * Text to use for the 'next' pagination button (to take the user to the
           * next page).
           *  @type string
           *  @default Next
           *
           *  @dtopt Language
           *  @name DataTable.defaults.language.paginate.next
           *
           *  @example
           *    $(document).ready( function() {
           *      $('#example').dataTable( {
           *        "language": {
           *          "paginate": {
           *            "next": "Next page"
           *          }
           *        }
           *      } );
           *    } );
           */
          "sNext": "Next",

          /**
           * Text to use for the 'previous' pagination button (to take the user to
           * the previous page).
           *  @type string
           *  @default Previous
           *
           *  @dtopt Language
           *  @name DataTable.defaults.language.paginate.previous
           *
           *  @example
           *    $(document).ready( function() {
           *      $('#example').dataTable( {
           *        "language": {
           *          "paginate": {
           *            "previous": "Previous page"
           *          }
           *        }
           *      } );
           *    } );
           */
          "sPrevious": "Previous"
        },

        /**
         * This string is shown in preference to `zeroRecords` when the table is
         * empty of data (regardless of filtering). Note that this is an optional
         * parameter - if it is not given, the value of `zeroRecords` will be used
         * instead (either the default or given value).
         *  @type string
         *  @default No data available in table
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.emptyTable
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "emptyTable": "No data available in table"
         *        }
         *      } );
         *    } );
         */
        "sEmptyTable": "No data available in table",

        /**
         * This string gives information to the end user about the information
         * that is current on display on the page. The following tokens can be
         * used in the string and will be dynamically replaced as the table
         * display updates. This tokens can be placed anywhere in the string, or
         * removed as needed by the language requires:
         *
         * * `\_START\_` - Display index of the first record on the current page
         * * `\_END\_` - Display index of the last record on the current page
         * * `\_TOTAL\_` - Number of records in the table after filtering
         * * `\_MAX\_` - Number of records in the table without filtering
         * * `\_PAGE\_` - Current page number
         * * `\_PAGES\_` - Total number of pages of data in the table
         *
         *  @type string
         *  @default Showing _START_ to _END_ of _TOTAL_ entries
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.info
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "info": "Showing page _PAGE_ of _PAGES_"
         *        }
         *      } );
         *    } );
         */
        "sInfo": "Showing _START_ to _END_ of _TOTAL_ entries",

        /**
         * Display information string for when the table is empty. Typically the
         * format of this string should match `info`.
         *  @type string
         *  @default Showing 0 to 0 of 0 entries
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.infoEmpty
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "infoEmpty": "No entries to show"
         *        }
         *      } );
         *    } );
         */
        "sInfoEmpty": "Showing 0 to 0 of 0 entries",

        /**
         * When a user filters the information in a table, this string is appended
         * to the information (`info`) to give an idea of how strong the filtering
         * is. The variable _MAX_ is dynamically updated.
         *  @type string
         *  @default (filtered from _MAX_ total entries)
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.infoFiltered
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "infoFiltered": " - filtering from _MAX_ records"
         *        }
         *      } );
         *    } );
         */
        "sInfoFiltered": "(filtered from _MAX_ total entries)",

        /**
         * If can be useful to append extra information to the info string at times,
         * and this variable does exactly that. This information will be appended to
         * the `info` (`infoEmpty` and `infoFiltered` in whatever combination they are
         * being used) at all times.
         *  @type string
         *  @default <i>Empty string</i>
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.infoPostFix
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "infoPostFix": "All records shown are derived from real information."
         *        }
         *      } );
         *    } );
         */
        "sInfoPostFix": "",

        /**
         * This decimal place operator is a little different from the other
         * language options since DataTables doesn't output floating point
         * numbers, so it won't ever use this for display of a number. Rather,
         * what this parameter does is modify the sort methods of the table so
         * that numbers which are in a format which has a character other than
         * a period (`.`) as a decimal place will be sorted numerically.
         *
         * Note that numbers with different decimal places cannot be shown in
         * the same table and still be sortable, the table must be consistent.
         * However, multiple different tables on the page can use different
         * decimal place characters.
         *  @type string
         *  @default 
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.decimal
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "decimal": ","
         *          "thousands": "."
         *        }
         *      } );
         *    } );
         */
        "sDecimal": "",

        /**
         * DataTables has a build in number formatter (`formatNumber`) which is
         * used to format large numbers that are used in the table information.
         * By default a comma is used, but this can be trivially changed to any
         * character you wish with this parameter.
         *  @type string
         *  @default ,
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.thousands
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "thousands": "'"
         *        }
         *      } );
         *    } );
         */
        "sThousands": ",",

        /**
         * Detail the action that will be taken when the drop down menu for the
         * pagination length option is changed. The '_MENU_' variable is replaced
         * with a default select list of 10, 25, 50 and 100, and can be replaced
         * with a custom select box if required.
         *  @type string
         *  @default Show _MENU_ entries
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.lengthMenu
         *
         *  @example
         *    // Language change only
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "lengthMenu": "Display _MENU_ records"
         *        }
         *      } );
         *    } );
         *
         *  @example
         *    // Language and options change
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "lengthMenu": 'Display <select>'+
         *            '<option value="10">10</option>'+
         *            '<option value="20">20</option>'+
         *            '<option value="30">30</option>'+
         *            '<option value="40">40</option>'+
         *            '<option value="50">50</option>'+
         *            '<option value="-1">All</option>'+
         *            '</select> records'
         *        }
         *      } );
         *    } );
         */
        "sLengthMenu": "Show _MENU_ entries",

        /**
         * When using Ajax sourced data and during the first draw when DataTables is
         * gathering the data, this message is shown in an empty row in the table to
         * indicate to the end user the the data is being loaded. Note that this
         * parameter is not used when loading data by server-side processing, just
         * Ajax sourced data with client-side processing.
         *  @type string
         *  @default Loading...
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.loadingRecords
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "loadingRecords": "Please wait - loading..."
         *        }
         *      } );
         *    } );
         */
        "sLoadingRecords": "Loading...",

        /**
         * Text which is displayed when the table is processing a user action
         * (usually a sort command or similar).
         *  @type string
         *  @default Processing...
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.processing
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "processing": "DataTables is currently busy"
         *        }
         *      } );
         *    } );
         */
        "sProcessing": "Processing...",

        /**
         * Details the actions that will be taken when the user types into the
         * filtering input text box. The variable "_INPUT_", if used in the string,
         * is replaced with the HTML text box for the filtering input allowing
         * control over where it appears in the string. If "_INPUT_" is not given
         * then the input box is appended to the string automatically.
         *  @type string
         *  @default Search:
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.search
         *
         *  @example
         *    // Input text box will be appended at the end automatically
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "search": "Filter records:"
         *        }
         *      } );
         *    } );
         *
         *  @example
         *    // Specify where the filter should appear
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "search": "Apply filter _INPUT_ to table"
         *        }
         *      } );
         *    } );
         */
        "sSearch": "Search:",

        /**
         * Assign a `placeholder` attribute to the search `input` element
         *  @type string
         *  @default 
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.searchPlaceholder
         */
        "sSearchPlaceholder": "",

        /**
         * All of the language information can be stored in a file on the
         * server-side, which DataTables will look up if this parameter is passed.
         * It must store the URL of the language file, which is in a JSON format,
         * and the object has the same properties as the oLanguage object in the
         * initialiser object (i.e. the above parameters). Please refer to one of
         * the example language files to see how this works in action.
         *  @type string
         *  @default <i>Empty string - i.e. disabled</i>
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.url
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "url": "http://www.sprymedia.co.uk/dataTables/lang.txt"
         *        }
         *      } );
         *    } );
         */
        "sUrl": "",

        /**
         * Text shown inside the table records when the is no information to be
         * displayed after filtering. `emptyTable` is shown when there is simply no
         * information in the table at all (regardless of filtering).
         *  @type string
         *  @default No matching records found
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.zeroRecords
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "zeroRecords": "No records to display"
         *        }
         *      } );
         *    } );
         */
        "sZeroRecords": "No matching records found"
      },

      /**
       * This parameter allows you to have define the global filtering state at
       * initialisation time. As an object the `search` parameter must be
       * defined, but all other parameters are optional. When `regex` is true,
       * the search string will be treated as a regular expression, when false
       * (default) it will be treated as a straight string. When `smart`
       * DataTables will use it's smart filtering methods (to word match at
       * any point in the data), when false this will not be done.
       *  @namespace
       *  @extends DataTable.models.oSearch
       *
       *  @dtopt Options
       *  @name DataTable.defaults.search
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "search": {"search": "Initial search"}
       *      } );
       *    } )
       */
      "oSearch": $.extend({}, _DataTable.models.oSearch),

      /**
       * __Deprecated__ The functionality provided by this parameter has now been
       * superseded by that provided through `ajax`, which should be used instead.
       *
       * By default DataTables will look for the property `data` (or `aaData` for
       * compatibility with DataTables 1.9-) when obtaining data from an Ajax
       * source or for server-side processing - this parameter allows that
       * property to be changed. You can use Javascript dotted object notation to
       * get a data source for multiple levels of nesting.
       *  @type string
       *  @default data
       *
       *  @dtopt Options
       *  @dtopt Server-side
       *  @name DataTable.defaults.ajaxDataProp
       *
       *  @deprecated 1.10. Please use `ajax` for this functionality now.
       */
      "sAjaxDataProp": "data",

      /**
       * __Deprecated__ The functionality provided by this parameter has now been
       * superseded by that provided through `ajax`, which should be used instead.
       *
       * You can instruct DataTables to load data from an external
       * source using this parameter (use aData if you want to pass data in you
       * already have). Simply provide a url a JSON object can be obtained from.
       *  @type string
       *  @default null
       *
       *  @dtopt Options
       *  @dtopt Server-side
       *  @name DataTable.defaults.ajaxSource
       *
       *  @deprecated 1.10. Please use `ajax` for this functionality now.
       */
      "sAjaxSource": null,

      /**
       * This initialisation variable allows you to specify exactly where in the
       * DOM you want DataTables to inject the various controls it adds to the page
       * (for example you might want the pagination controls at the top of the
       * table). DIV elements (with or without a custom class) can also be added to
       * aid styling. The follow syntax is used:
       *   <ul>
       *     <li>The following options are allowed:
       *       <ul>
       *         <li>'l' - Length changing</li>
       *         <li>'f' - Filtering input</li>
       *         <li>'t' - The table!</li>
       *         <li>'i' - Information</li>
       *         <li>'p' - Pagination</li>
       *         <li>'r' - pRocessing</li>
       *       </ul>
       *     </li>
       *     <li>The following constants are allowed:
       *       <ul>
       *         <li>'H' - jQueryUI theme "header" classes ('fg-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix')</li>
       *         <li>'F' - jQueryUI theme "footer" classes ('fg-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix')</li>
       *       </ul>
       *     </li>
       *     <li>The following syntax is expected:
       *       <ul>
       *         <li>'&lt;' and '&gt;' - div elements</li>
       *         <li>'&lt;"class" and '&gt;' - div with a class</li>
       *         <li>'&lt;"#id" and '&gt;' - div with an ID</li>
       *       </ul>
       *     </li>
       *     <li>Examples:
       *       <ul>
       *         <li>'&lt;"wrapper"flipt&gt;'</li>
       *         <li>'&lt;lf&lt;t&gt;ip&gt;'</li>
       *       </ul>
       *     </li>
       *   </ul>
       *  @type string
       *  @default lfrtip <i>(when `jQueryUI` is false)</i> <b>or</b>
       *    <"H"lfr>t<"F"ip> <i>(when `jQueryUI` is true)</i>
       *
       *  @dtopt Options
       *  @name DataTable.defaults.dom
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "dom": '&lt;"top"i&gt;rt&lt;"bottom"flp&gt;&lt;"clear"&gt;'
       *      } );
       *    } );
       */
      "sDom": "lfrtip",

      /**
       * Search delay option. This will throttle full table searches that use the
       * DataTables provided search input element (it does not effect calls to
       * `dt-api search()`, providing a delay before the search is made.
       *  @type integer
       *  @default 0
       *
       *  @dtopt Options
       *  @name DataTable.defaults.searchDelay
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "searchDelay": 200
       *      } );
       *    } )
       */
      "searchDelay": null,

      /**
       * DataTables features four different built-in options for the buttons to
       * display for pagination control:
       *
       * * `simple` - 'Previous' and 'Next' buttons only
       * * 'simple_numbers` - 'Previous' and 'Next' buttons, plus page numbers
       * * `full` - 'First', 'Previous', 'Next' and 'Last' buttons
       * * `full_numbers` - 'First', 'Previous', 'Next' and 'Last' buttons, plus
       *   page numbers
       *  
       * Further methods can be added using {@link DataTable.ext.oPagination}.
       *  @type string
       *  @default simple_numbers
       *
       *  @dtopt Options
       *  @name DataTable.defaults.pagingType
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "pagingType": "full_numbers"
       *      } );
       *    } )
       */
      "sPaginationType": "simple_numbers",

      /**
       * Enable horizontal scrolling. When a table is too wide to fit into a
       * certain layout, or you have a large number of columns in the table, you
       * can enable x-scrolling to show the table in a viewport, which can be
       * scrolled. This property can be `true` which will allow the table to
       * scroll horizontally when needed, or any CSS unit, or a number (in which
       * case it will be treated as a pixel measurement). Setting as simply `true`
       * is recommended.
       *  @type boolean|string
       *  @default <i>blank string - i.e. disabled</i>
       *
       *  @dtopt Features
       *  @name DataTable.defaults.scrollX
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "scrollX": true,
       *        "scrollCollapse": true
       *      } );
       *    } );
       */
      "sScrollX": "",

      /**
       * This property can be used to force a DataTable to use more width than it
       * might otherwise do when x-scrolling is enabled. For example if you have a
       * table which requires to be well spaced, this parameter is useful for
       * "over-sizing" the table, and thus forcing scrolling. This property can by
       * any CSS unit, or a number (in which case it will be treated as a pixel
       * measurement).
       *  @type string
       *  @default <i>blank string - i.e. disabled</i>
       *
       *  @dtopt Options
       *  @name DataTable.defaults.scrollXInner
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "scrollX": "100%",
       *        "scrollXInner": "110%"
       *      } );
       *    } );
       */
      "sScrollXInner": "",

      /**
       * Enable vertical scrolling. Vertical scrolling will constrain the DataTable
       * to the given height, and enable scrolling for any data which overflows the
       * current viewport. This can be used as an alternative to paging to display
       * a lot of data in a small area (although paging and scrolling can both be
       * enabled at the same time). This property can be any CSS unit, or a number
       * (in which case it will be treated as a pixel measurement).
       *  @type string
       *  @default <i>blank string - i.e. disabled</i>
       *
       *  @dtopt Features
       *  @name DataTable.defaults.scrollY
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "scrollY": "200px",
       *        "paginate": false
       *      } );
       *    } );
       */
      "sScrollY": "",

      /**
       * __Deprecated__ The functionality provided by this parameter has now been
       * superseded by that provided through `ajax`, which should be used instead.
       *
       * Set the HTTP method that is used to make the Ajax call for server-side
       * processing or Ajax sourced data.
       *  @type string
       *  @default GET
       *
       *  @dtopt Options
       *  @dtopt Server-side
       *  @name DataTable.defaults.serverMethod
       *
       *  @deprecated 1.10. Please use `ajax` for this functionality now.
       */
      "sServerMethod": "GET",

      /**
       * DataTables makes use of renderers when displaying HTML elements for
       * a table. These renderers can be added or modified by plug-ins to
       * generate suitable mark-up for a site. For example the Bootstrap
       * integration plug-in for DataTables uses a paging button renderer to
       * display pagination buttons in the mark-up required by Bootstrap.
       *
       * For further information about the renderers available see
       * DataTable.ext.renderer
       *  @type string|object
       *  @default null
       *
       *  @name DataTable.defaults.renderer
       *
       */
      "renderer": null
    };

    _fnHungarianMap(_DataTable.defaults);
    /*
     * Developer note - See note in model.defaults.js about the use of Hungarian
     * notation and camel case.
     */

    /**
     * Column options that can be given to DataTables at initialisation time.
     *  @namespace
     */


    _DataTable.defaults.column = {
      /**
       * Define which column(s) an order will occur on for this column. This
       * allows a column's ordering to take multiple columns into account when
       * doing a sort or use the data from a different column. For example first
       * name / last name columns make sense to do a multi-column sort over the
       * two columns.
       *  @type array|int
       *  @default null <i>Takes the value of the column index automatically</i>
       *
       *  @name DataTable.defaults.column.orderData
       *  @dtopt Columns
       *
       *  @example
       *    // Using `columnDefs`
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "columnDefs": [
       *          { "orderData": [ 0, 1 ], "targets": [ 0 ] },
       *          { "orderData": [ 1, 0 ], "targets": [ 1 ] },
       *          { "orderData": 2, "targets": [ 2 ] }
       *        ]
       *      } );
       *    } );
       *
       *  @example
       *    // Using `columns`
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "columns": [
       *          { "orderData": [ 0, 1 ] },
       *          { "orderData": [ 1, 0 ] },
       *          { "orderData": 2 },
       *          null,
       *          null
       *        ]
       *      } );
       *    } );
       */
      "aDataSort": null,
      "iDataSort": -1,

      /**
       * You can control the default ordering direction, and even alter the
       * behaviour of the sort handler (i.e. only allow ascending ordering etc)
       * using this parameter.
       *  @type array
       *  @default [ 'asc', 'desc' ]
       *
       *  @name DataTable.defaults.column.orderSequence
       *  @dtopt Columns
       *
       *  @example
       *    // Using `columnDefs`
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "columnDefs": [
       *          { "orderSequence": [ "asc" ], "targets": [ 1 ] },
       *          { "orderSequence": [ "desc", "asc", "asc" ], "targets": [ 2 ] },
       *          { "orderSequence": [ "desc" ], "targets": [ 3 ] }
       *        ]
       *      } );
       *    } );
       *
       *  @example
       *    // Using `columns`
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "columns": [
       *          null,
       *          { "orderSequence": [ "asc" ] },
       *          { "orderSequence": [ "desc", "asc", "asc" ] },
       *          { "orderSequence": [ "desc" ] },
       *          null
       *        ]
       *      } );
       *    } );
       */
      "asSorting": ['asc', 'desc'],

      /**
       * Enable or disable filtering on the data in this column.
       *  @type boolean
       *  @default true
       *
       *  @name DataTable.defaults.column.searchable
       *  @dtopt Columns
       *
       *  @example
       *    // Using `columnDefs`
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "columnDefs": [
       *          { "searchable": false, "targets": [ 0 ] }
       *        ] } );
       *    } );
       *
       *  @example
       *    // Using `columns`
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "columns": [
       *          { "searchable": false },
       *          null,
       *          null,
       *          null,
       *          null
       *        ] } );
       *    } );
       */
      "bSearchable": true,

      /**
       * Enable or disable ordering on this column.
       *  @type boolean
       *  @default true
       *
       *  @name DataTable.defaults.column.orderable
       *  @dtopt Columns
       *
       *  @example
       *    // Using `columnDefs`
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "columnDefs": [
       *          { "orderable": false, "targets": [ 0 ] }
       *        ] } );
       *    } );
       *
       *  @example
       *    // Using `columns`
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "columns": [
       *          { "orderable": false },
       *          null,
       *          null,
       *          null,
       *          null
       *        ] } );
       *    } );
       */
      "bSortable": true,

      /**
       * Enable or disable the display of this column.
       *  @type boolean
       *  @default true
       *
       *  @name DataTable.defaults.column.visible
       *  @dtopt Columns
       *
       *  @example
       *    // Using `columnDefs`
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "columnDefs": [
       *          { "visible": false, "targets": [ 0 ] }
       *        ] } );
       *    } );
       *
       *  @example
       *    // Using `columns`
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "columns": [
       *          { "visible": false },
       *          null,
       *          null,
       *          null,
       *          null
       *        ] } );
       *    } );
       */
      "bVisible": true,

      /**
       * Developer definable function that is called whenever a cell is created (Ajax source,
       * etc) or processed for input (DOM source). This can be used as a compliment to mRender
       * allowing you to modify the DOM element (add background colour for example) when the
       * element is available.
       *  @type function
       *  @param {element} td The TD node that has been created
       *  @param {*} cellData The Data for the cell
       *  @param {array|object} rowData The data for the whole row
       *  @param {int} row The row index for the aoData data store
       *  @param {int} col The column index for aoColumns
       *
       *  @name DataTable.defaults.column.createdCell
       *  @dtopt Columns
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "columnDefs": [ {
       *          "targets": [3],
       *          "createdCell": function (td, cellData, rowData, row, col) {
       *            if ( cellData == "1.7" ) {
       *              $(td).css('color', 'blue')
       *            }
       *          }
       *        } ]
       *      });
       *    } );
       */
      "fnCreatedCell": null,

      /**
       * This parameter has been replaced by `data` in DataTables to ensure naming
       * consistency. `dataProp` can still be used, as there is backwards
       * compatibility in DataTables for this option, but it is strongly
       * recommended that you use `data` in preference to `dataProp`.
       *  @name DataTable.defaults.column.dataProp
       */

      /**
       * This property can be used to read data from any data source property,
       * including deeply nested objects / properties. `data` can be given in a
       * number of different ways which effect its behaviour:
       *
       * * `integer` - treated as an array index for the data source. This is the
       *   default that DataTables uses (incrementally increased for each column).
       * * `string` - read an object property from the data source. There are
       *   three 'special' options that can be used in the string to alter how
       *   DataTables reads the data from the source object:
       *    * `.` - Dotted Javascript notation. Just as you use a `.` in
       *      Javascript to read from nested objects, so to can the options
       *      specified in `data`. For example: `browser.version` or
       *      `browser.name`. If your object parameter name contains a period, use
       *      `\\` to escape it - i.e. `first\\.name`.
       *    * `[]` - Array notation. DataTables can automatically combine data
       *      from and array source, joining the data with the characters provided
       *      between the two brackets. For example: `name[, ]` would provide a
       *      comma-space separated list from the source array. If no characters
       *      are provided between the brackets, the original array source is
       *      returned.
       *    * `()` - Function notation. Adding `()` to the end of a parameter will
       *      execute a function of the name given. For example: `browser()` for a
       *      simple function on the data source, `browser.version()` for a
       *      function in a nested property or even `browser().version` to get an
       *      object property if the function called returns an object. Note that
       *      function notation is recommended for use in `render` rather than
       *      `data` as it is much simpler to use as a renderer.
       * * `null` - use the original data source for the row rather than plucking
       *   data directly from it. This action has effects on two other
       *   initialisation options:
       *    * `defaultContent` - When null is given as the `data` option and
       *      `defaultContent` is specified for the column, the value defined by
       *      `defaultContent` will be used for the cell.
       *    * `render` - When null is used for the `data` option and the `render`
       *      option is specified for the column, the whole data source for the
       *      row is used for the renderer.
       * * `function` - the function given will be executed whenever DataTables
       *   needs to set or get the data for a cell in the column. The function
       *   takes three parameters:
       *    * Parameters:
       *      * `{array|object}` The data source for the row
       *      * `{string}` The type call data requested - this will be 'set' when
       *        setting data or 'filter', 'display', 'type', 'sort' or undefined
       *        when gathering data. Note that when `undefined` is given for the
       *        type DataTables expects to get the raw data for the object back<
       *      * `{*}` Data to set when the second parameter is 'set'.
       *    * Return:
       *      * The return value from the function is not required when 'set' is
       *        the type of call, but otherwise the return is what will be used
       *        for the data requested.
       *
       * Note that `data` is a getter and setter option. If you just require
       * formatting of data for output, you will likely want to use `render` which
       * is simply a getter and thus simpler to use.
       *
       * Note that prior to DataTables 1.9.2 `data` was called `mDataProp`. The
       * name change reflects the flexibility of this property and is consistent
       * with the naming of mRender. If 'mDataProp' is given, then it will still
       * be used by DataTables, as it automatically maps the old name to the new
       * if required.
       *
       *  @type string|int|function|null
       *  @default null <i>Use automatically calculated column index</i>
       *
       *  @name DataTable.defaults.column.data
       *  @dtopt Columns
       *
       *  @example
       *    // Read table data from objects
       *    // JSON structure for each row:
       *    //   {
       *    //      "engine": {value},
       *    //      "browser": {value},
       *    //      "platform": {value},
       *    //      "version": {value},
       *    //      "grade": {value}
       *    //   }
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "ajaxSource": "sources/objects.txt",
       *        "columns": [
       *          { "data": "engine" },
       *          { "data": "browser" },
       *          { "data": "platform" },
       *          { "data": "version" },
       *          { "data": "grade" }
       *        ]
       *      } );
       *    } );
       *
       *  @example
       *    // Read information from deeply nested objects
       *    // JSON structure for each row:
       *    //   {
       *    //      "engine": {value},
       *    //      "browser": {value},
       *    //      "platform": {
       *    //         "inner": {value}
       *    //      },
       *    //      "details": [
       *    //         {value}, {value}
       *    //      ]
       *    //   }
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "ajaxSource": "sources/deep.txt",
       *        "columns": [
       *          { "data": "engine" },
       *          { "data": "browser" },
       *          { "data": "platform.inner" },
       *          { "data": "platform.details.0" },
       *          { "data": "platform.details.1" }
       *        ]
       *      } );
       *    } );
       *
       *  @example
       *    // Using `data` as a function to provide different information for
       *    // sorting, filtering and display. In this case, currency (price)
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "columnDefs": [ {
       *          "targets": [ 0 ],
       *          "data": function ( source, type, val ) {
       *            if (type === 'set') {
       *              source.price = val;
       *              // Store the computed dislay and filter values for efficiency
       *              source.price_display = val=="" ? "" : "$"+numberFormat(val);
       *              source.price_filter  = val=="" ? "" : "$"+numberFormat(val)+" "+val;
       *              return;
       *            }
       *            else if (type === 'display') {
       *              return source.price_display;
       *            }
       *            else if (type === 'filter') {
       *              return source.price_filter;
       *            }
       *            // 'sort', 'type' and undefined all just use the integer
       *            return source.price;
       *          }
       *        } ]
       *      } );
       *    } );
       *
       *  @example
       *    // Using default content
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "columnDefs": [ {
       *          "targets": [ 0 ],
       *          "data": null,
       *          "defaultContent": "Click to edit"
       *        } ]
       *      } );
       *    } );
       *
       *  @example
       *    // Using array notation - outputting a list from an array
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "columnDefs": [ {
       *          "targets": [ 0 ],
       *          "data": "name[, ]"
       *        } ]
       *      } );
       *    } );
       *
       */
      "mData": null,

      /**
       * This property is the rendering partner to `data` and it is suggested that
       * when you want to manipulate data for display (including filtering,
       * sorting etc) without altering the underlying data for the table, use this
       * property. `render` can be considered to be the the read only companion to
       * `data` which is read / write (then as such more complex). Like `data`
       * this option can be given in a number of different ways to effect its
       * behaviour:
       *
       * * `integer` - treated as an array index for the data source. This is the
       *   default that DataTables uses (incrementally increased for each column).
       * * `string` - read an object property from the data source. There are
       *   three 'special' options that can be used in the string to alter how
       *   DataTables reads the data from the source object:
       *    * `.` - Dotted Javascript notation. Just as you use a `.` in
       *      Javascript to read from nested objects, so to can the options
       *      specified in `data`. For example: `browser.version` or
       *      `browser.name`. If your object parameter name contains a period, use
       *      `\\` to escape it - i.e. `first\\.name`.
       *    * `[]` - Array notation. DataTables can automatically combine data
       *      from and array source, joining the data with the characters provided
       *      between the two brackets. For example: `name[, ]` would provide a
       *      comma-space separated list from the source array. If no characters
       *      are provided between the brackets, the original array source is
       *      returned.
       *    * `()` - Function notation. Adding `()` to the end of a parameter will
       *      execute a function of the name given. For example: `browser()` for a
       *      simple function on the data source, `browser.version()` for a
       *      function in a nested property or even `browser().version` to get an
       *      object property if the function called returns an object.
       * * `object` - use different data for the different data types requested by
       *   DataTables ('filter', 'display', 'type' or 'sort'). The property names
       *   of the object is the data type the property refers to and the value can
       *   defined using an integer, string or function using the same rules as
       *   `render` normally does. Note that an `_` option _must_ be specified.
       *   This is the default value to use if you haven't specified a value for
       *   the data type requested by DataTables.
       * * `function` - the function given will be executed whenever DataTables
       *   needs to set or get the data for a cell in the column. The function
       *   takes three parameters:
       *    * Parameters:
       *      * {array|object} The data source for the row (based on `data`)
       *      * {string} The type call data requested - this will be 'filter',
       *        'display', 'type' or 'sort'.
       *      * {array|object} The full data source for the row (not based on
       *        `data`)
       *    * Return:
       *      * The return value from the function is what will be used for the
       *        data requested.
       *
       *  @type string|int|function|object|null
       *  @default null Use the data source value.
       *
       *  @name DataTable.defaults.column.render
       *  @dtopt Columns
       *
       *  @example
       *    // Create a comma separated list from an array of objects
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "ajaxSource": "sources/deep.txt",
       *        "columns": [
       *          { "data": "engine" },
       *          { "data": "browser" },
       *          {
       *            "data": "platform",
       *            "render": "[, ].name"
       *          }
       *        ]
       *      } );
       *    } );
       *
       *  @example
       *    // Execute a function to obtain data
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "columnDefs": [ {
       *          "targets": [ 0 ],
       *          "data": null, // Use the full data source object for the renderer's source
       *          "render": "browserName()"
       *        } ]
       *      } );
       *    } );
       *
       *  @example
       *    // As an object, extracting different data for the different types
       *    // This would be used with a data source such as:
       *    //   { "phone": 5552368, "phone_filter": "5552368 555-2368", "phone_display": "555-2368" }
       *    // Here the `phone` integer is used for sorting and type detection, while `phone_filter`
       *    // (which has both forms) is used for filtering for if a user inputs either format, while
       *    // the formatted phone number is the one that is shown in the table.
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "columnDefs": [ {
       *          "targets": [ 0 ],
       *          "data": null, // Use the full data source object for the renderer's source
       *          "render": {
       *            "_": "phone",
       *            "filter": "phone_filter",
       *            "display": "phone_display"
       *          }
       *        } ]
       *      } );
       *    } );
       *
       *  @example
       *    // Use as a function to create a link from the data source
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "columnDefs": [ {
       *          "targets": [ 0 ],
       *          "data": "download_link",
       *          "render": function ( data, type, full ) {
       *            return '<a href="'+data+'">Download</a>';
       *          }
       *        } ]
       *      } );
       *    } );
       */
      "mRender": null,

      /**
       * Change the cell type created for the column - either TD cells or TH cells. This
       * can be useful as TH cells have semantic meaning in the table body, allowing them
       * to act as a header for a row (you may wish to add scope='row' to the TH elements).
       *  @type string
       *  @default td
       *
       *  @name DataTable.defaults.column.cellType
       *  @dtopt Columns
       *
       *  @example
       *    // Make the first column use TH cells
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "columnDefs": [ {
       *          "targets": [ 0 ],
       *          "cellType": "th"
       *        } ]
       *      } );
       *    } );
       */
      "sCellType": "td",

      /**
       * Class to give to each cell in this column.
       *  @type string
       *  @default <i>Empty string</i>
       *
       *  @name DataTable.defaults.column.class
       *  @dtopt Columns
       *
       *  @example
       *    // Using `columnDefs`
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "columnDefs": [
       *          { "class": "my_class", "targets": [ 0 ] }
       *        ]
       *      } );
       *    } );
       *
       *  @example
       *    // Using `columns`
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "columns": [
       *          { "class": "my_class" },
       *          null,
       *          null,
       *          null,
       *          null
       *        ]
       *      } );
       *    } );
       */
      "sClass": "",

      /**
       * When DataTables calculates the column widths to assign to each column,
       * it finds the longest string in each column and then constructs a
       * temporary table and reads the widths from that. The problem with this
       * is that "mmm" is much wider then "iiii", but the latter is a longer
       * string - thus the calculation can go wrong (doing it properly and putting
       * it into an DOM object and measuring that is horribly(!) slow). Thus as
       * a "work around" we provide this option. It will append its value to the
       * text that is found to be the longest string for the column - i.e. padding.
       * Generally you shouldn't need this!
       *  @type string
       *  @default <i>Empty string<i>
       *
       *  @name DataTable.defaults.column.contentPadding
       *  @dtopt Columns
       *
       *  @example
       *    // Using `columns`
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "columns": [
       *          null,
       *          null,
       *          null,
       *          {
       *            "contentPadding": "mmm"
       *          }
       *        ]
       *      } );
       *    } );
       */
      "sContentPadding": "",

      /**
       * Allows a default value to be given for a column's data, and will be used
       * whenever a null data source is encountered (this can be because `data`
       * is set to null, or because the data source itself is null).
       *  @type string
       *  @default null
       *
       *  @name DataTable.defaults.column.defaultContent
       *  @dtopt Columns
       *
       *  @example
       *    // Using `columnDefs`
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "columnDefs": [
       *          {
       *            "data": null,
       *            "defaultContent": "Edit",
       *            "targets": [ -1 ]
       *          }
       *        ]
       *      } );
       *    } );
       *
       *  @example
       *    // Using `columns`
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "columns": [
       *          null,
       *          null,
       *          null,
       *          {
       *            "data": null,
       *            "defaultContent": "Edit"
       *          }
       *        ]
       *      } );
       *    } );
       */
      "sDefaultContent": null,

      /**
       * This parameter is only used in DataTables' server-side processing. It can
       * be exceptionally useful to know what columns are being displayed on the
       * client side, and to map these to database fields. When defined, the names
       * also allow DataTables to reorder information from the server if it comes
       * back in an unexpected order (i.e. if you switch your columns around on the
       * client-side, your server-side code does not also need updating).
       *  @type string
       *  @default <i>Empty string</i>
       *
       *  @name DataTable.defaults.column.name
       *  @dtopt Columns
       *
       *  @example
       *    // Using `columnDefs`
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "columnDefs": [
       *          { "name": "engine", "targets": [ 0 ] },
       *          { "name": "browser", "targets": [ 1 ] },
       *          { "name": "platform", "targets": [ 2 ] },
       *          { "name": "version", "targets": [ 3 ] },
       *          { "name": "grade", "targets": [ 4 ] }
       *        ]
       *      } );
       *    } );
       *
       *  @example
       *    // Using `columns`
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "columns": [
       *          { "name": "engine" },
       *          { "name": "browser" },
       *          { "name": "platform" },
       *          { "name": "version" },
       *          { "name": "grade" }
       *        ]
       *      } );
       *    } );
       */
      "sName": "",

      /**
       * Defines a data source type for the ordering which can be used to read
       * real-time information from the table (updating the internally cached
       * version) prior to ordering. This allows ordering to occur on user
       * editable elements such as form inputs.
       *  @type string
       *  @default std
       *
       *  @name DataTable.defaults.column.orderDataType
       *  @dtopt Columns
       *
       *  @example
       *    // Using `columnDefs`
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "columnDefs": [
       *          { "orderDataType": "dom-text", "targets": [ 2, 3 ] },
       *          { "type": "numeric", "targets": [ 3 ] },
       *          { "orderDataType": "dom-select", "targets": [ 4 ] },
       *          { "orderDataType": "dom-checkbox", "targets": [ 5 ] }
       *        ]
       *      } );
       *    } );
       *
       *  @example
       *    // Using `columns`
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "columns": [
       *          null,
       *          null,
       *          { "orderDataType": "dom-text" },
       *          { "orderDataType": "dom-text", "type": "numeric" },
       *          { "orderDataType": "dom-select" },
       *          { "orderDataType": "dom-checkbox" }
       *        ]
       *      } );
       *    } );
       */
      "sSortDataType": "std",

      /**
       * The title of this column.
       *  @type string
       *  @default null <i>Derived from the 'TH' value for this column in the
       *    original HTML table.</i>
       *
       *  @name DataTable.defaults.column.title
       *  @dtopt Columns
       *
       *  @example
       *    // Using `columnDefs`
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "columnDefs": [
       *          { "title": "My column title", "targets": [ 0 ] }
       *        ]
       *      } );
       *    } );
       *
       *  @example
       *    // Using `columns`
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "columns": [
       *          { "title": "My column title" },
       *          null,
       *          null,
       *          null,
       *          null
       *        ]
       *      } );
       *    } );
       */
      "sTitle": null,

      /**
       * The type allows you to specify how the data for this column will be
       * ordered. Four types (string, numeric, date and html (which will strip
       * HTML tags before ordering)) are currently available. Note that only date
       * formats understood by Javascript's Date() object will be accepted as type
       * date. For example: "Mar 26, 2008 5:03 PM". May take the values: 'string',
       * 'numeric', 'date' or 'html' (by default). Further types can be adding
       * through plug-ins.
       *  @type string
       *  @default null <i>Auto-detected from raw data</i>
       *
       *  @name DataTable.defaults.column.type
       *  @dtopt Columns
       *
       *  @example
       *    // Using `columnDefs`
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "columnDefs": [
       *          { "type": "html", "targets": [ 0 ] }
       *        ]
       *      } );
       *    } );
       *
       *  @example
       *    // Using `columns`
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "columns": [
       *          { "type": "html" },
       *          null,
       *          null,
       *          null,
       *          null
       *        ]
       *      } );
       *    } );
       */
      "sType": null,

      /**
       * Defining the width of the column, this parameter may take any CSS value
       * (3em, 20px etc). DataTables applies 'smart' widths to columns which have not
       * been given a specific width through this interface ensuring that the table
       * remains readable.
       *  @type string
       *  @default null <i>Automatic</i>
       *
       *  @name DataTable.defaults.column.width
       *  @dtopt Columns
       *
       *  @example
       *    // Using `columnDefs`
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "columnDefs": [
       *          { "width": "20%", "targets": [ 0 ] }
       *        ]
       *      } );
       *    } );
       *
       *  @example
       *    // Using `columns`
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "columns": [
       *          { "width": "20%" },
       *          null,
       *          null,
       *          null,
       *          null
       *        ]
       *      } );
       *    } );
       */
      "sWidth": null
    };

    _fnHungarianMap(_DataTable.defaults.column);
    /**
     * DataTables settings object - this holds all the information needed for a
     * given table, including configuration, data and current application of the
     * table options. DataTables does not have a single instance for each DataTable
     * with the settings attached to that instance, but rather instances of the
     * DataTable "class" are created on-the-fly as needed (typically by a
     * $().dataTable() call) and the settings object is then applied to that
     * instance.
     *
     * Note that this object is related to {@link DataTable.defaults} but this
     * one is the internal data store for DataTables's cache of columns. It should
     * NOT be manipulated outside of DataTables. Any configuration should be done
     * through the initialisation options.
     *  @namespace
     *  @todo Really should attach the settings object to individual instances so we
     *    don't need to create new instances on each $().dataTable() call (if the
     *    table already exists). It would also save passing oSettings around and
     *    into every single function. However, this is a very significant
     *    architecture change for DataTables and will almost certainly break
     *    backwards compatibility with older installations. This is something that
     *    will be done in 2.0.
     */


    _DataTable.models.oSettings = {
      /**
       * Primary features of DataTables and their enablement state.
       *  @namespace
       */
      "oFeatures": {
        /**
         * Flag to say if DataTables should automatically try to calculate the
         * optimum table and columns widths (true) or not (false).
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type boolean
         */
        "bAutoWidth": null,

        /**
         * Delay the creation of TR and TD elements until they are actually
         * needed by a driven page draw. This can give a significant speed
         * increase for Ajax source and Javascript source data, but makes no
         * difference at all fro DOM and server-side processing tables.
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type boolean
         */
        "bDeferRender": null,

        /**
         * Enable filtering on the table or not. Note that if this is disabled
         * then there is no filtering at all on the table, including fnFilter.
         * To just remove the filtering input use sDom and remove the 'f' option.
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type boolean
         */
        "bFilter": null,

        /**
         * Table information element (the 'Showing x of y records' div) enable
         * flag.
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type boolean
         */
        "bInfo": null,

        /**
         * Present a user control allowing the end user to change the page size
         * when pagination is enabled.
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type boolean
         */
        "bLengthChange": null,

        /**
         * Pagination enabled or not. Note that if this is disabled then length
         * changing must also be disabled.
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type boolean
         */
        "bPaginate": null,

        /**
         * Processing indicator enable flag whenever DataTables is enacting a
         * user request - typically an Ajax request for server-side processing.
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type boolean
         */
        "bProcessing": null,

        /**
         * Server-side processing enabled flag - when enabled DataTables will
         * get all data from the server for every draw - there is no filtering,
         * sorting or paging done on the client-side.
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type boolean
         */
        "bServerSide": null,

        /**
         * Sorting enablement flag.
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type boolean
         */
        "bSort": null,

        /**
         * Multi-column sorting
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type boolean
         */
        "bSortMulti": null,

        /**
         * Apply a class to the columns which are being sorted to provide a
         * visual highlight or not. This can slow things down when enabled since
         * there is a lot of DOM interaction.
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type boolean
         */
        "bSortClasses": null,

        /**
         * State saving enablement flag.
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type boolean
         */
        "bStateSave": null
      },

      /**
       * Scrolling settings for a table.
       *  @namespace
       */
      "oScroll": {
        /**
         * When the table is shorter in height than sScrollY, collapse the
         * table container down to the height of the table (when true).
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type boolean
         */
        "bCollapse": null,

        /**
         * Width of the scrollbar for the web-browser's platform. Calculated
         * during table initialisation.
         *  @type int
         *  @default 0
         */
        "iBarWidth": 0,

        /**
         * Viewport width for horizontal scrolling. Horizontal scrolling is
         * disabled if an empty string.
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type string
         */
        "sX": null,

        /**
         * Width to expand the table to when using x-scrolling. Typically you
         * should not need to use this.
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type string
         *  @deprecated
         */
        "sXInner": null,

        /**
         * Viewport height for vertical scrolling. Vertical scrolling is disabled
         * if an empty string.
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type string
         */
        "sY": null
      },

      /**
       * Language information for the table.
       *  @namespace
       *  @extends DataTable.defaults.oLanguage
       */
      "oLanguage": {
        /**
         * Information callback function. See
         * {@link DataTable.defaults.fnInfoCallback}
         *  @type function
         *  @default null
         */
        "fnInfoCallback": null
      },

      /**
       * Browser support parameters
       *  @namespace
       */
      "oBrowser": {
        /**
         * Indicate if the browser incorrectly calculates width:100% inside a
         * scrolling element (IE6/7)
         *  @type boolean
         *  @default false
         */
        "bScrollOversize": false,

        /**
         * Determine if the vertical scrollbar is on the right or left of the
         * scrolling container - needed for rtl language layout, although not
         * all browsers move the scrollbar (Safari).
         *  @type boolean
         *  @default false
         */
        "bScrollbarLeft": false
      },
      "ajax": null,

      /**
       * Array referencing the nodes which are used for the features. The
       * parameters of this object match what is allowed by sDom - i.e.
       *   <ul>
       *     <li>'l' - Length changing</li>
       *     <li>'f' - Filtering input</li>
       *     <li>'t' - The table!</li>
       *     <li>'i' - Information</li>
       *     <li>'p' - Pagination</li>
       *     <li>'r' - pRocessing</li>
       *   </ul>
       *  @type array
       *  @default []
       */
      "aanFeatures": [],

      /**
       * Store data information - see {@link DataTable.models.oRow} for detailed
       * information.
       *  @type array
       *  @default []
       */
      "aoData": [],

      /**
       * Array of indexes which are in the current display (after filtering etc)
       *  @type array
       *  @default []
       */
      "aiDisplay": [],

      /**
       * Array of indexes for display - no filtering
       *  @type array
       *  @default []
       */
      "aiDisplayMaster": [],

      /**
       * Store information about each column that is in use
       *  @type array
       *  @default []
       */
      "aoColumns": [],

      /**
       * Store information about the table's header
       *  @type array
       *  @default []
       */
      "aoHeader": [],

      /**
       * Store information about the table's footer
       *  @type array
       *  @default []
       */
      "aoFooter": [],

      /**
       * Store the applied global search information in case we want to force a
       * research or compare the old search to a new one.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @namespace
       *  @extends DataTable.models.oSearch
       */
      "oPreviousSearch": {},

      /**
       * Store the applied search for each column - see
       * {@link DataTable.models.oSearch} for the format that is used for the
       * filtering information for each column.
       *  @type array
       *  @default []
       */
      "aoPreSearchCols": [],

      /**
       * Sorting that is applied to the table. Note that the inner arrays are
       * used in the following manner:
       * <ul>
       *   <li>Index 0 - column number</li>
       *   <li>Index 1 - current sorting direction</li>
       * </ul>
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type array
       *  @todo These inner arrays should really be objects
       */
      "aaSorting": null,

      /**
       * Sorting that is always applied to the table (i.e. prefixed in front of
       * aaSorting).
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type array
       *  @default []
       */
      "aaSortingFixed": [],

      /**
       * Classes to use for the striping of a table.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type array
       *  @default []
       */
      "asStripeClasses": null,

      /**
       * If restoring a table - we should restore its striping classes as well
       *  @type array
       *  @default []
       */
      "asDestroyStripes": [],

      /**
       * If restoring a table - we should restore its width
       *  @type int
       *  @default 0
       */
      "sDestroyWidth": 0,

      /**
       * Callback functions array for every time a row is inserted (i.e. on a draw).
       *  @type array
       *  @default []
       */
      "aoRowCallback": [],

      /**
       * Callback functions for the header on each draw.
       *  @type array
       *  @default []
       */
      "aoHeaderCallback": [],

      /**
       * Callback function for the footer on each draw.
       *  @type array
       *  @default []
       */
      "aoFooterCallback": [],

      /**
       * Array of callback functions for draw callback functions
       *  @type array
       *  @default []
       */
      "aoDrawCallback": [],

      /**
       * Array of callback functions for row created function
       *  @type array
       *  @default []
       */
      "aoRowCreatedCallback": [],

      /**
       * Callback functions for just before the table is redrawn. A return of
       * false will be used to cancel the draw.
       *  @type array
       *  @default []
       */
      "aoPreDrawCallback": [],

      /**
       * Callback functions for when the table has been initialised.
       *  @type array
       *  @default []
       */
      "aoInitComplete": [],

      /**
       * Callbacks for modifying the settings to be stored for state saving, prior to
       * saving state.
       *  @type array
       *  @default []
       */
      "aoStateSaveParams": [],

      /**
       * Callbacks for modifying the settings that have been stored for state saving
       * prior to using the stored values to restore the state.
       *  @type array
       *  @default []
       */
      "aoStateLoadParams": [],

      /**
       * Callbacks for operating on the settings object once the saved state has been
       * loaded
       *  @type array
       *  @default []
       */
      "aoStateLoaded": [],

      /**
       * Cache the table ID for quick access
       *  @type string
       *  @default <i>Empty string</i>
       */
      "sTableId": "",

      /**
       * The TABLE node for the main table
       *  @type node
       *  @default null
       */
      "nTable": null,

      /**
       * Permanent ref to the thead element
       *  @type node
       *  @default null
       */
      "nTHead": null,

      /**
       * Permanent ref to the tfoot element - if it exists
       *  @type node
       *  @default null
       */
      "nTFoot": null,

      /**
       * Permanent ref to the tbody element
       *  @type node
       *  @default null
       */
      "nTBody": null,

      /**
       * Cache the wrapper node (contains all DataTables controlled elements)
       *  @type node
       *  @default null
       */
      "nTableWrapper": null,

      /**
       * Indicate if when using server-side processing the loading of data
       * should be deferred until the second draw.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       *  @default false
       */
      "bDeferLoading": false,

      /**
       * Indicate if all required information has been read in
       *  @type boolean
       *  @default false
       */
      "bInitialised": false,

      /**
       * Information about open rows. Each object in the array has the parameters
       * 'nTr' and 'nParent'
       *  @type array
       *  @default []
       */
      "aoOpenRows": [],

      /**
       * Dictate the positioning of DataTables' control elements - see
       * {@link DataTable.model.oInit.sDom}.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type string
       *  @default null
       */
      "sDom": null,

      /**
       * Search delay (in mS)
       *  @type integer
       *  @default null
       */
      "searchDelay": null,

      /**
       * Which type of pagination should be used.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type string
       *  @default two_button
       */
      "sPaginationType": "two_button",

      /**
       * The state duration (for `stateSave`) in seconds.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type int
       *  @default 0
       */
      "iStateDuration": 0,

      /**
       * Array of callback functions for state saving. Each array element is an
       * object with the following parameters:
       *   <ul>
       *     <li>function:fn - function to call. Takes two parameters, oSettings
       *       and the JSON string to save that has been thus far created. Returns
       *       a JSON string to be inserted into a json object
       *       (i.e. '"param": [ 0, 1, 2]')</li>
       *     <li>string:sName - name of callback</li>
       *   </ul>
       *  @type array
       *  @default []
       */
      "aoStateSave": [],

      /**
       * Array of callback functions for state loading. Each array element is an
       * object with the following parameters:
       *   <ul>
       *     <li>function:fn - function to call. Takes two parameters, oSettings
       *       and the object stored. May return false to cancel state loading</li>
       *     <li>string:sName - name of callback</li>
       *   </ul>
       *  @type array
       *  @default []
       */
      "aoStateLoad": [],

      /**
       * State that was saved. Useful for back reference
       *  @type object
       *  @default null
       */
      "oSavedState": null,

      /**
       * State that was loaded. Useful for back reference
       *  @type object
       *  @default null
       */
      "oLoadedState": null,

      /**
       * Source url for AJAX data for the table.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type string
       *  @default null
       */
      "sAjaxSource": null,

      /**
       * Property from a given object from which to read the table data from. This
       * can be an empty string (when not server-side processing), in which case
       * it is  assumed an an array is given directly.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type string
       */
      "sAjaxDataProp": null,

      /**
       * Note if draw should be blocked while getting data
       *  @type boolean
       *  @default true
       */
      "bAjaxDataGet": true,

      /**
       * The last jQuery XHR object that was used for server-side data gathering.
       * This can be used for working with the XHR information in one of the
       * callbacks
       *  @type object
       *  @default null
       */
      "jqXHR": null,

      /**
       * JSON returned from the server in the last Ajax request
       *  @type object
       *  @default undefined
       */
      "json": undefined,

      /**
       * Data submitted as part of the last Ajax request
       *  @type object
       *  @default undefined
       */
      "oAjaxData": undefined,

      /**
       * Function to get the server-side data.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type function
       */
      "fnServerData": null,

      /**
       * Functions which are called prior to sending an Ajax request so extra
       * parameters can easily be sent to the server
       *  @type array
       *  @default []
       */
      "aoServerParams": [],

      /**
       * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if
       * required).
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type string
       */
      "sServerMethod": null,

      /**
       * Format numbers for display.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type function
       */
      "fnFormatNumber": null,

      /**
       * List of options that can be used for the user selectable length menu.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type array
       *  @default []
       */
      "aLengthMenu": null,

      /**
       * Counter for the draws that the table does. Also used as a tracker for
       * server-side processing
       *  @type int
       *  @default 0
       */
      "iDraw": 0,

      /**
       * Indicate if a redraw is being done - useful for Ajax
       *  @type boolean
       *  @default false
       */
      "bDrawing": false,

      /**
       * Draw index (iDraw) of the last error when parsing the returned data
       *  @type int
       *  @default -1
       */
      "iDrawError": -1,

      /**
       * Paging display length
       *  @type int
       *  @default 10
       */
      "_iDisplayLength": 10,

      /**
       * Paging start point - aiDisplay index
       *  @type int
       *  @default 0
       */
      "_iDisplayStart": 0,

      /**
       * Server-side processing - number of records in the result set
       * (i.e. before filtering), Use fnRecordsTotal rather than
       * this property to get the value of the number of records, regardless of
       * the server-side processing setting.
       *  @type int
       *  @default 0
       *  @private
       */
      "_iRecordsTotal": 0,

      /**
       * Server-side processing - number of records in the current display set
       * (i.e. after filtering). Use fnRecordsDisplay rather than
       * this property to get the value of the number of records, regardless of
       * the server-side processing setting.
       *  @type boolean
       *  @default 0
       *  @private
       */
      "_iRecordsDisplay": 0,

      /**
       * Flag to indicate if jQuery UI marking and classes should be used.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bJUI": null,

      /**
       * The classes to use for the table
       *  @type object
       *  @default {}
       */
      "oClasses": {},

      /**
       * Flag attached to the settings object so you can check in the draw
       * callback if filtering has been done in the draw. Deprecated in favour of
       * events.
       *  @type boolean
       *  @default false
       *  @deprecated
       */
      "bFiltered": false,

      /**
       * Flag attached to the settings object so you can check in the draw
       * callback if sorting has been done in the draw. Deprecated in favour of
       * events.
       *  @type boolean
       *  @default false
       *  @deprecated
       */
      "bSorted": false,

      /**
       * Indicate that if multiple rows are in the header and there is more than
       * one unique cell per column, if the top one (true) or bottom one (false)
       * should be used for sorting / title by DataTables.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bSortCellsTop": null,

      /**
       * Initialisation object that is used for the table
       *  @type object
       *  @default null
       */
      "oInit": null,

      /**
       * Destroy callback functions - for plug-ins to attach themselves to the
       * destroy so they can clean up markup and events.
       *  @type array
       *  @default []
       */
      "aoDestroyCallback": [],

      /**
       * Get the number of records in the current record set, before filtering
       *  @type function
       */
      "fnRecordsTotal": function fnRecordsTotal() {
        return _fnDataSource(this) == 'ssp' ? this._iRecordsTotal * 1 : this.aiDisplayMaster.length;
      },

      /**
       * Get the number of records in the current record set, after filtering
       *  @type function
       */
      "fnRecordsDisplay": function fnRecordsDisplay() {
        return _fnDataSource(this) == 'ssp' ? this._iRecordsDisplay * 1 : this.aiDisplay.length;
      },

      /**
       * Get the display end point - aiDisplay index
       *  @type function
       */
      "fnDisplayEnd": function fnDisplayEnd() {
        var len = this._iDisplayLength,
            start = this._iDisplayStart,
            calc = start + len,
            records = this.aiDisplay.length,
            features = this.oFeatures,
            paginate = features.bPaginate;

        if (features.bServerSide) {
          return paginate === false || len === -1 ? start + records : Math.min(start + len, this._iRecordsDisplay);
        } else {
          return !paginate || calc > records || len === -1 ? records : calc;
        }
      },

      /**
       * The DataTables object for this table
       *  @type object
       *  @default null
       */
      "oInstance": null,

      /**
       * Unique identifier for each instance of the DataTables object. If there
       * is an ID on the table node, then it takes that value, otherwise an
       * incrementing internal counter is used.
       *  @type string
       *  @default null
       */
      "sInstance": null,

      /**
       * tabindex attribute value that is added to DataTables control elements, allowing
       * keyboard navigation of the table and its controls.
       */
      "iTabIndex": 0,

      /**
       * DIV container for the footer scrolling table if scrolling
       */
      "nScrollHead": null,

      /**
       * DIV container for the footer scrolling table if scrolling
       */
      "nScrollFoot": null,

      /**
       * Last applied sort
       *  @type array
       *  @default []
       */
      "aLastSort": [],

      /**
       * Stored plug-in instances
       *  @type object
       *  @default {}
       */
      "oPlugins": {}
    };
    /**
     * Extension object for DataTables that is used to provide all extension
     * options.
     *
     * Note that the `DataTable.ext` object is available through
     * `jQuery.fn.dataTable.ext` where it may be accessed and manipulated. It is
     * also aliased to `jQuery.fn.dataTableExt` for historic reasons.
     *  @namespace
     *  @extends DataTable.models.ext
     */

    /**
     * DataTables extensions
     * 
     * This namespace acts as a collection area for plug-ins that can be used to
     * extend DataTables capabilities. Indeed many of the build in methods
     * use this method to provide their own capabilities (sorting methods for
     * example).
     *
     * Note that this namespace is aliased to `jQuery.fn.dataTableExt` for legacy
     * reasons
     *
     *  @namespace
     */

    _DataTable.ext = _ext = {
      /**
       * Buttons. For use with the Buttons extension for DataTables. This is
       * defined here so other extensions can define buttons regardless of load
       * order. It is _not_ used by DataTables core.
       *
       *  @type object
       *  @default {}
       */
      buttons: {},

      /**
       * Element class names
       *
       *  @type object
       *  @default {}
       */
      classes: {},

      /**
       * Error reporting.
       * 
       * How should DataTables report an error. Can take the value 'alert',
       * 'throw', 'none' or a function.
       *
       *  @type string|function
       *  @default alert
       */
      errMode: "alert",

      /**
       * Feature plug-ins.
       * 
       * This is an array of objects which describe the feature plug-ins that are
       * available to DataTables. These feature plug-ins are then available for
       * use through the `dom` initialisation option.
       * 
       * Each feature plug-in is described by an object which must have the
       * following properties:
       * 
       * * `fnInit` - function that is used to initialise the plug-in,
       * * `cFeature` - a character so the feature can be enabled by the `dom`
       *   instillation option. This is case sensitive.
       *
       * The `fnInit` function has the following input parameters:
       *
       * 1. `{object}` DataTables settings object: see
       *    {@link DataTable.models.oSettings}
       *
       * And the following return is expected:
       * 
       * * {node|null} The element which contains your feature. Note that the
       *   return may also be void if your plug-in does not require to inject any
       *   DOM elements into DataTables control (`dom`) - for example this might
       *   be useful when developing a plug-in which allows table control via
       *   keyboard entry
       *
       *  @type array
       *
       *  @example
       *    $.fn.dataTable.ext.features.push( {
       *      "fnInit": function( oSettings ) {
       *        return new TableTools( { "oDTSettings": oSettings } );
       *      },
       *      "cFeature": "T"
       *    } );
       */
      feature: [],

      /**
       * Row searching.
       * 
       * This method of searching is complimentary to the default type based
       * searching, and a lot more comprehensive as it allows you complete control
       * over the searching logic. Each element in this array is a function
       * (parameters described below) that is called for every row in the table,
       * and your logic decides if it should be included in the searching data set
       * or not.
       *
       * Searching functions have the following input parameters:
       *
       * 1. `{object}` DataTables settings object: see
       *    {@link DataTable.models.oSettings}
       * 2. `{array|object}` Data for the row to be processed (same as the
       *    original format that was passed in as the data source, or an array
       *    from a DOM data source
       * 3. `{int}` Row index ({@link DataTable.models.oSettings.aoData}), which
       *    can be useful to retrieve the `TR` element if you need DOM interaction.
       *
       * And the following return is expected:
       *
       * * {boolean} Include the row in the searched result set (true) or not
       *   (false)
       *
       * Note that as with the main search ability in DataTables, technically this
       * is "filtering", since it is subtractive. However, for consistency in
       * naming we call it searching here.
       *
       *  @type array
       *  @default []
       *
       *  @example
       *    // The following example shows custom search being applied to the
       *    // fourth column (i.e. the data[3] index) based on two input values
       *    // from the end-user, matching the data in a certain range.
       *    $.fn.dataTable.ext.search.push(
       *      function( settings, data, dataIndex ) {
       *        var min = document.getElementById('min').value * 1;
       *        var max = document.getElementById('max').value * 1;
       *        var version = data[3] == "-" ? 0 : data[3]*1;
       *
       *        if ( min == "" && max == "" ) {
       *          return true;
       *        }
       *        else if ( min == "" && version < max ) {
       *          return true;
       *        }
       *        else if ( min < version && "" == max ) {
       *          return true;
       *        }
       *        else if ( min < version && version < max ) {
       *          return true;
       *        }
       *        return false;
       *      }
       *    );
       */
      search: [],

      /**
       * Selector extensions
       *
       * The `selector` option can be used to extend the options available for the
       * selector modifier options (`selector-modifier` object data type) that
       * each of the three built in selector types offer (row, column and cell +
       * their plural counterparts). For example the Select extension uses this
       * mechanism to provide an option to select only rows, columns and cells
       * that have been marked as selected by the end user (`{selected: true}`),
       * which can be used in conjunction with the existing built in selector
       * options.
       *
       * Each property is an array to which functions can be pushed. The functions
       * take three attributes:
       *
       * * Settings object for the host table
       * * Options object (`selector-modifier` object type)
       * * Array of selected item indexes
       *
       * The return is an array of the resulting item indexes after the custom
       * selector has been applied.
       *
       *  @type object
       */
      selector: {
        cell: [],
        column: [],
        row: []
      },

      /**
       * Internal functions, exposed for used in plug-ins.
       * 
       * Please note that you should not need to use the internal methods for
       * anything other than a plug-in (and even then, try to avoid if possible).
       * The internal function may change between releases.
       *
       *  @type object
       *  @default {}
       */
      internal: {},

      /**
       * Legacy configuration options. Enable and disable legacy options that
       * are available in DataTables.
       *
       *  @type object
       */
      legacy: {
        /**
         * Enable / disable DataTables 1.9 compatible server-side processing
         * requests
         *
         *  @type boolean
         *  @default null
         */
        ajax: null
      },

      /**
       * Pagination plug-in methods.
       * 
       * Each entry in this object is a function and defines which buttons should
       * be shown by the pagination rendering method that is used for the table:
       * {@link DataTable.ext.renderer.pageButton}. The renderer addresses how the
       * buttons are displayed in the document, while the functions here tell it
       * what buttons to display. This is done by returning an array of button
       * descriptions (what each button will do).
       *
       * Pagination types (the four built in options and any additional plug-in
       * options defined here) can be used through the `paginationType`
       * initialisation parameter.
       *
       * The functions defined take two parameters:
       *
       * 1. `{int} page` The current page index
       * 2. `{int} pages` The number of pages in the table
       *
       * Each function is expected to return an array where each element of the
       * array can be one of:
       *
       * * `first` - Jump to first page when activated
       * * `last` - Jump to last page when activated
       * * `previous` - Show previous page when activated
       * * `next` - Show next page when activated
       * * `{int}` - Show page of the index given
       * * `{array}` - A nested array containing the above elements to add a
       *   containing 'DIV' element (might be useful for styling).
       *
       * Note that DataTables v1.9- used this object slightly differently whereby
       * an object with two functions would be defined for each plug-in. That
       * ability is still supported by DataTables 1.10+ to provide backwards
       * compatibility, but this option of use is now decremented and no longer
       * documented in DataTables 1.10+.
       *
       *  @type object
       *  @default {}
       *
       *  @example
       *    // Show previous, next and current page buttons only
       *    $.fn.dataTableExt.oPagination.current = function ( page, pages ) {
       *      return [ 'previous', page, 'next' ];
       *    };
       */
      pager: {},
      renderer: {
        pageButton: {},
        header: {}
      },

      /**
       * Ordering plug-ins - custom data source
       * 
       * The extension options for ordering of data available here is complimentary
       * to the default type based ordering that DataTables typically uses. It
       * allows much greater control over the the data that is being used to
       * order a column, but is necessarily therefore more complex.
       * 
       * This type of ordering is useful if you want to do ordering based on data
       * live from the DOM (for example the contents of an 'input' element) rather
       * than just the static string that DataTables knows of.
       * 
       * The way these plug-ins work is that you create an array of the values you
       * wish to be ordering for the column in question and then return that
       * array. The data in the array much be in the index order of the rows in
       * the table (not the currently ordering order!). Which order data gathering
       * function is run here depends on the `dt-init columns.orderDataType`
       * parameter that is used for the column (if any).
       *
       * The functions defined take two parameters:
       *
       * 1. `{object}` DataTables settings object: see
       *    {@link DataTable.models.oSettings}
       * 2. `{int}` Target column index
       *
       * Each function is expected to return an array:
       *
       * * `{array}` Data for the column to be ordering upon
       *
       *  @type array
       *
       *  @example
       *    // Ordering using `input` node values
       *    $.fn.dataTable.ext.order['dom-text'] = function  ( settings, col )
       *    {
       *      return this.api().column( col, {order:'index'} ).nodes().map( function ( td, i ) {
       *        return $('input', td).val();
       *      } );
       *    }
       */
      order: {},

      /**
       * Type based plug-ins.
       *
       * Each column in DataTables has a type assigned to it, either by automatic
       * detection or by direct assignment using the `type` option for the column.
       * The type of a column will effect how it is ordering and search (plug-ins
       * can also make use of the column type if required).
       *
       * @namespace
       */
      type: {
        /**
         * Type detection functions.
         *
         * The functions defined in this object are used to automatically detect
         * a column's type, making initialisation of DataTables super easy, even
         * when complex data is in the table.
         *
         * The functions defined take two parameters:
         *
            *  1. `{*}` Data from the column cell to be analysed
            *  2. `{settings}` DataTables settings object. This can be used to
            *     perform context specific type detection - for example detection
            *     based on language settings such as using a comma for a decimal
            *     place. Generally speaking the options from the settings will not
            *     be required
         *
         * Each function is expected to return:
         *
         * * `{string|null}` Data type detected, or null if unknown (and thus
         *   pass it on to the other type detection functions.
         *
         *  @type array
         *
         *  @example
         *    // Currency type detection plug-in:
         *    $.fn.dataTable.ext.type.detect.push(
         *      function ( data, settings ) {
         *        // Check the numeric part
         *        if ( ! $.isNumeric( data.substring(1) ) ) {
         *          return null;
         *        }
         *
         *        // Check prefixed by currency
         *        if ( data.charAt(0) == '$' || data.charAt(0) == '&pound;' ) {
         *          return 'currency';
         *        }
         *        return null;
         *      }
         *    );
         */
        detect: [],

        /**
         * Type based search formatting.
         *
         * The type based searching functions can be used to pre-format the
         * data to be search on. For example, it can be used to strip HTML
         * tags or to de-format telephone numbers for numeric only searching.
         *
         * Note that is a search is not defined for a column of a given type,
         * no search formatting will be performed.
         * 
         * Pre-processing of searching data plug-ins - When you assign the sType
         * for a column (or have it automatically detected for you by DataTables
         * or a type detection plug-in), you will typically be using this for
         * custom sorting, but it can also be used to provide custom searching
         * by allowing you to pre-processing the data and returning the data in
         * the format that should be searched upon. This is done by adding
         * functions this object with a parameter name which matches the sType
         * for that target column. This is the corollary of <i>afnSortData</i>
         * for searching data.
         *
         * The functions defined take a single parameter:
         *
            *  1. `{*}` Data from the column cell to be prepared for searching
         *
         * Each function is expected to return:
         *
         * * `{string|null}` Formatted string that will be used for the searching.
         *
         *  @type object
         *  @default {}
         *
         *  @example
         *    $.fn.dataTable.ext.type.search['title-numeric'] = function ( d ) {
         *      return d.replace(/\n/g," ").replace( /<.*?>/g, "" );
         *    }
         */
        search: {},

        /**
         * Type based ordering.
         *
         * The column type tells DataTables what ordering to apply to the table
         * when a column is sorted upon. The order for each type that is defined,
         * is defined by the functions available in this object.
         *
         * Each ordering option can be described by three properties added to
         * this object:
         *
         * * `{type}-pre` - Pre-formatting function
         * * `{type}-asc` - Ascending order function
         * * `{type}-desc` - Descending order function
         *
         * All three can be used together, only `{type}-pre` or only
         * `{type}-asc` and `{type}-desc` together. It is generally recommended
         * that only `{type}-pre` is used, as this provides the optimal
         * implementation in terms of speed, although the others are provided
         * for compatibility with existing Javascript sort functions.
         *
         * `{type}-pre`: Functions defined take a single parameter:
         *
            *  1. `{*}` Data from the column cell to be prepared for ordering
         *
         * And return:
         *
         * * `{*}` Data to be sorted upon
         *
         * `{type}-asc` and `{type}-desc`: Functions are typical Javascript sort
         * functions, taking two parameters:
         *
            *  1. `{*}` Data to compare to the second parameter
            *  2. `{*}` Data to compare to the first parameter
         *
         * And returning:
         *
         * * `{*}` Ordering match: <0 if first parameter should be sorted lower
         *   than the second parameter, ===0 if the two parameters are equal and
         *   >0 if the first parameter should be sorted height than the second
         *   parameter.
         * 
         *  @type object
         *  @default {}
         *
         *  @example
         *    // Numeric ordering of formatted numbers with a pre-formatter
         *    $.extend( $.fn.dataTable.ext.type.order, {
         *      "string-pre": function(x) {
         *        a = (a === "-" || a === "") ? 0 : a.replace( /[^\d\-\.]/g, "" );
         *        return parseFloat( a );
         *      }
         *    } );
         *
         *  @example
         *    // Case-sensitive string ordering, with no pre-formatting method
         *    $.extend( $.fn.dataTable.ext.order, {
         *      "string-case-asc": function(x,y) {
         *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
         *      },
         *      "string-case-desc": function(x,y) {
         *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
         *      }
         *    } );
         */
        order: {}
      },

      /**
       * Unique DataTables instance counter
       *
       * @type int
       * @private
       */
      _unique: 0,
      //
      // Depreciated
      // The following properties are retained for backwards compatiblity only.
      // The should not be used in new projects and will be removed in a future
      // version
      //

      /**
       * Version check function.
       *  @type function
       *  @depreciated Since 1.10
       */
      fnVersionCheck: _DataTable.fnVersionCheck,

      /**
       * Index for what 'this' index API functions should use
       *  @type int
       *  @deprecated Since v1.10
       */
      iApiIndex: 0,

      /**
       * jQuery UI class container
       *  @type object
       *  @deprecated Since v1.10
       */
      oJUIClasses: {},

      /**
       * Software version
       *  @type string
       *  @deprecated Since v1.10
       */
      sVersion: _DataTable.version
    }; //
    // Backwards compatibility. Alias to pre 1.10 Hungarian notation counter parts
    //

    $.extend(_ext, {
      afnFiltering: _ext.search,
      aTypes: _ext.type.detect,
      ofnSearch: _ext.type.search,
      oSort: _ext.type.order,
      afnSortData: _ext.order,
      aoFeatures: _ext.feature,
      oApi: _ext.internal,
      oStdClasses: _ext.classes,
      oPagination: _ext.pager
    });
    $.extend(_DataTable.ext.classes, {
      "sTable": "dataTable",
      "sNoFooter": "no-footer",

      /* Paging buttons */
      "sPageButton": "paginate_button",
      "sPageButtonActive": "current",
      "sPageButtonDisabled": "disabled",

      /* Striping classes */
      "sStripeOdd": "odd",
      "sStripeEven": "even",

      /* Empty row */
      "sRowEmpty": "dataTables_empty",

      /* Features */
      "sWrapper": "dataTables_wrapper",
      "sFilter": "dataTables_filter",
      "sInfo": "dataTables_info",
      "sPaging": "dataTables_paginate paging_",

      /* Note that the type is postfixed */
      "sLength": "dataTables_length",
      "sProcessing": "dataTables_processing",

      /* Sorting */
      "sSortAsc": "sorting_asc",
      "sSortDesc": "sorting_desc",
      "sSortable": "sorting",

      /* Sortable in both directions */
      "sSortableAsc": "sorting_asc_disabled",
      "sSortableDesc": "sorting_desc_disabled",
      "sSortableNone": "sorting_disabled",
      "sSortColumn": "sorting_",

      /* Note that an int is postfixed for the sorting order */

      /* Filtering */
      "sFilterInput": "",

      /* Page length */
      "sLengthSelect": "",

      /* Scrolling */
      "sScrollWrapper": "dataTables_scroll",
      "sScrollHead": "dataTables_scrollHead",
      "sScrollHeadInner": "dataTables_scrollHeadInner",
      "sScrollBody": "dataTables_scrollBody",
      "sScrollFoot": "dataTables_scrollFoot",
      "sScrollFootInner": "dataTables_scrollFootInner",

      /* Misc */
      "sHeaderTH": "",
      "sFooterTH": "",
      // Deprecated
      "sSortJUIAsc": "",
      "sSortJUIDesc": "",
      "sSortJUI": "",
      "sSortJUIAscAllowed": "",
      "sSortJUIDescAllowed": "",
      "sSortJUIWrapper": "",
      "sSortIcon": "",
      "sJUIHeader": "",
      "sJUIFooter": ""
    });

    (function () {
      // Reused strings for better compression. Closure compiler appears to have a
      // weird edge case where it is trying to expand strings rather than use the
      // variable version. This results in about 200 bytes being added, for very
      // little preference benefit since it this run on script load only.
      var _empty = '';
      _empty = '';

      var _stateDefault = _empty + 'ui-state-default';

      var _sortIcon = _empty + 'css_right ui-icon ui-icon-';

      var _headerFooter = _empty + 'fg-toolbar ui-toolbar ui-widget-header ui-helper-clearfix';

      $.extend(_DataTable.ext.oJUIClasses, _DataTable.ext.classes, {
        /* Full numbers paging buttons */
        "sPageButton": "fg-button ui-button " + _stateDefault,
        "sPageButtonActive": "ui-state-disabled",
        "sPageButtonDisabled": "ui-state-disabled",

        /* Features */
        "sPaging": "dataTables_paginate fg-buttonset ui-buttonset fg-buttonset-multi " + "ui-buttonset-multi paging_",

        /* Note that the type is postfixed */

        /* Sorting */
        "sSortAsc": _stateDefault + " sorting_asc",
        "sSortDesc": _stateDefault + " sorting_desc",
        "sSortable": _stateDefault + " sorting",
        "sSortableAsc": _stateDefault + " sorting_asc_disabled",
        "sSortableDesc": _stateDefault + " sorting_desc_disabled",
        "sSortableNone": _stateDefault + " sorting_disabled",
        "sSortJUIAsc": _sortIcon + "triangle-1-n",
        "sSortJUIDesc": _sortIcon + "triangle-1-s",
        "sSortJUI": _sortIcon + "carat-2-n-s",
        "sSortJUIAscAllowed": _sortIcon + "carat-1-n",
        "sSortJUIDescAllowed": _sortIcon + "carat-1-s",
        "sSortJUIWrapper": "DataTables_sort_wrapper",
        "sSortIcon": "DataTables_sort_icon",

        /* Scrolling */
        "sScrollHead": "dataTables_scrollHead " + _stateDefault,
        "sScrollFoot": "dataTables_scrollFoot " + _stateDefault,

        /* Misc */
        "sHeaderTH": _stateDefault,
        "sFooterTH": _stateDefault,
        "sJUIHeader": _headerFooter + " ui-corner-tl ui-corner-tr",
        "sJUIFooter": _headerFooter + " ui-corner-bl ui-corner-br"
      });
    })();

    var extPagination = _DataTable.ext.pager;

    function _numbers(page, pages) {
      var numbers = [],
          buttons = extPagination.numbers_length,
          half = Math.floor(buttons / 2),
          i = 1;

      if (pages <= buttons) {
        numbers = _range(0, pages);
      } else if (page <= half) {
        numbers = _range(0, buttons - 2);
        numbers.push('ellipsis');
        numbers.push(pages - 1);
      } else if (page >= pages - 1 - half) {
        numbers = _range(pages - (buttons - 2), pages);
        numbers.splice(0, 0, 'ellipsis'); // no unshift in ie6

        numbers.splice(0, 0, 0);
      } else {
        numbers = _range(page - half + 2, page + half - 1);
        numbers.push('ellipsis');
        numbers.push(pages - 1);
        numbers.splice(0, 0, 'ellipsis');
        numbers.splice(0, 0, 0);
      }

      numbers.DT_el = 'span';
      return numbers;
    }

    $.extend(extPagination, {
      simple: function simple(page, pages) {
        return ['previous', 'next'];
      },
      full: function full(page, pages) {
        return ['first', 'previous', 'next', 'last'];
      },
      simple_numbers: function simple_numbers(page, pages) {
        return ['previous', _numbers(page, pages), 'next'];
      },
      full_numbers: function full_numbers(page, pages) {
        return ['first', 'previous', _numbers(page, pages), 'next', 'last'];
      },
      // For testing and plug-ins to use
      _numbers: _numbers,
      // Number of number buttons (including ellipsis) to show. _Must be odd!_
      numbers_length: 7
    });
    $.extend(true, _DataTable.ext.renderer, {
      pageButton: {
        _: function _(settings, host, idx, buttons, page, pages) {
          var classes = settings.oClasses;
          var lang = settings.oLanguage.oPaginate;
          var btnDisplay,
              btnClass,
              counter = 0;

          var attach = function attach(container, buttons) {
            var i, ien, node, button;

            var clickHandler = function clickHandler(e) {
              _fnPageChange(settings, e.data.action, true);
            };

            for (i = 0, ien = buttons.length; i < ien; i++) {
              button = buttons[i];

              if ($.isArray(button)) {
                var inner = $('<' + (button.DT_el || 'div') + '/>').appendTo(container);
                attach(inner, button);
              } else {
                btnDisplay = '';
                btnClass = '';

                switch (button) {
                  case 'ellipsis':
                    container.append('<span class="ellipsis">&#x2026;</span>');
                    break;

                  case 'first':
                    btnDisplay = lang.sFirst;
                    btnClass = button + (page > 0 ? '' : ' ' + classes.sPageButtonDisabled);
                    break;

                  case 'previous':
                    btnDisplay = lang.sPrevious;
                    btnClass = button + (page > 0 ? '' : ' ' + classes.sPageButtonDisabled);
                    break;

                  case 'next':
                    btnDisplay = lang.sNext;
                    btnClass = button + (page < pages - 1 ? '' : ' ' + classes.sPageButtonDisabled);
                    break;

                  case 'last':
                    btnDisplay = lang.sLast;
                    btnClass = button + (page < pages - 1 ? '' : ' ' + classes.sPageButtonDisabled);
                    break;

                  default:
                    btnDisplay = button + 1;
                    btnClass = page === button ? classes.sPageButtonActive : '';
                    break;
                }

                if (btnDisplay) {
                  node = $('<a>', {
                    'class': classes.sPageButton + ' ' + btnClass,
                    'aria-controls': settings.sTableId,
                    'data-dt-idx': counter,
                    'tabindex': settings.iTabIndex,
                    'id': idx === 0 && typeof button === 'string' ? settings.sTableId + '_' + button : null
                  }).html(btnDisplay).appendTo(container);

                  _fnBindAction(node, {
                    action: button
                  }, clickHandler);

                  counter++;
                }
              }
            }
          }; // IE9 throws an 'unknown error' if document.activeElement is used
          // inside an iframe or frame. Try / catch the error. Not good for
          // accessibility, but neither are frames.


          var activeEl;

          try {
            // Because this approach is destroying and recreating the paging
            // elements, focus is lost on the select button which is bad for
            // accessibility. So we want to restore focus once the draw has
            // completed
            activeEl = $(document.activeElement).data('dt-idx');
          } catch (e) {}

          attach($(host).empty(), buttons);

          if (activeEl) {
            $(host).find('[data-dt-idx=' + activeEl + ']').focus();
          }
        }
      }
    }); // Built in type detection. See model.ext.aTypes for information about
    // what is required from this methods.

    $.extend(_DataTable.ext.type.detect, [// Plain numbers - first since V8 detects some plain numbers as dates
    // e.g. Date.parse('55') (but not all, e.g. Date.parse('22')...).
    function (d, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _isNumber(d, decimal) ? 'num' + decimal : null;
    }, // Dates (only those recognised by the browser's Date.parse)
    function (d, settings) {
      // V8 will remove any unknown characters at the start and end of the
      // expression, leading to false matches such as `$245.12` or `10%` being
      // a valid date. See forum thread 18941 for detail.
      if (d && !(d instanceof Date) && (!_re_date_start.test(d) || !_re_date_end.test(d))) {
        return null;
      }

      var parsed = Date.parse(d);
      return parsed !== null && !isNaN(parsed) || _empty(d) ? 'date' : null;
    }, // Formatted numbers
    function (d, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _isNumber(d, decimal, true) ? 'num-fmt' + decimal : null;
    }, // HTML numeric
    function (d, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _htmlNumeric(d, decimal) ? 'html-num' + decimal : null;
    }, // HTML numeric, formatted
    function (d, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _htmlNumeric(d, decimal, true) ? 'html-num-fmt' + decimal : null;
    }, // HTML (this is strict checking - there must be html)
    function (d, settings) {
      return _empty(d) || typeof d === 'string' && d.indexOf('<') !== -1 ? 'html' : null;
    }]); // Filter formatting functions. See model.ext.ofnSearch for information about
    // what is required from these methods.
    // 
    // Note that additional search methods are added for the html numbers and
    // html formatted numbers by `_addNumericSort()` when we know what the decimal
    // place is

    $.extend(_DataTable.ext.type.search, {
      html: function html(data) {
        return _empty(data) ? data : typeof data === 'string' ? data.replace(_re_new_lines, " ").replace(_re_html, "") : '';
      },
      string: function string(data) {
        return _empty(data) ? data : typeof data === 'string' ? data.replace(_re_new_lines, " ") : data;
      }
    });

    var __numericReplace = function __numericReplace(d, decimalPlace, re1, re2) {
      if (d !== 0 && (!d || d === '-')) {
        return -Infinity;
      } // If a decimal place other than `.` is used, it needs to be given to the
      // function so we can detect it and replace with a `.` which is the only
      // decimal place Javascript recognises - it is not locale aware.


      if (decimalPlace) {
        d = _numToDecimal(d, decimalPlace);
      }

      if (d.replace) {
        if (re1) {
          d = d.replace(re1, '');
        }

        if (re2) {
          d = d.replace(re2, '');
        }
      }

      return d * 1;
    }; // Add the numeric 'deformatting' functions for sorting and search. This is done
    // in a function to provide an easy ability for the language options to add
    // additional methods if a non-period decimal place is used.


    function _addNumericSort(decimalPlace) {
      $.each({
        // Plain numbers
        "num": function num(d) {
          return __numericReplace(d, decimalPlace);
        },
        // Formatted numbers
        "num-fmt": function numFmt(d) {
          return __numericReplace(d, decimalPlace, _re_formatted_numeric);
        },
        // HTML numeric
        "html-num": function htmlNum(d) {
          return __numericReplace(d, decimalPlace, _re_html);
        },
        // HTML numeric, formatted
        "html-num-fmt": function htmlNumFmt(d) {
          return __numericReplace(d, decimalPlace, _re_html, _re_formatted_numeric);
        }
      }, function (key, fn) {
        // Add the ordering method
        _ext.type.order[key + decimalPlace + '-pre'] = fn; // For HTML types add a search formatter that will strip the HTML

        if (key.match(/^html\-/)) {
          _ext.type.search[key + decimalPlace] = _ext.type.search.html;
        }
      });
    } // Default sort methods


    $.extend(_ext.type.order, {
      // Dates
      "date-pre": function datePre(d) {
        return Date.parse(d) || 0;
      },
      // html
      "html-pre": function htmlPre(a) {
        return _empty(a) ? '' : a.replace ? a.replace(/<.*?>/g, "").toLowerCase() : a + '';
      },
      // string
      "string-pre": function stringPre(a) {
        // This is a little complex, but faster than always calling toString,
        // http://jsperf.com/tostring-v-check
        return _empty(a) ? '' : typeof a === 'string' ? a.toLowerCase() : !a.toString ? '' : a.toString();
      },
      // string-asc and -desc are retained only for compatibility with the old
      // sort methods
      "string-asc": function stringAsc(x, y) {
        return x < y ? -1 : x > y ? 1 : 0;
      },
      "string-desc": function stringDesc(x, y) {
        return x < y ? 1 : x > y ? -1 : 0;
      }
    }); // Numeric sorting types - order doesn't matter here

    _addNumericSort('');

    $.extend(true, _DataTable.ext.renderer, {
      header: {
        _: function _(settings, cell, column, classes) {
          // No additional mark-up required
          // Attach a sort listener to update on sort - note that using the
          // `DT` namespace will allow the event to be removed automatically
          // on destroy, while the `dt` namespaced event is the one we are
          // listening for
          $(settings.nTable).on('order.dt.DT', function (e, ctx, sorting, columns) {
            if (settings !== ctx) {
              // need to check this this is the host
              return; // table, not a nested one
            }

            var colIdx = column.idx;
            cell.removeClass(column.sSortingClass + ' ' + classes.sSortAsc + ' ' + classes.sSortDesc).addClass(columns[colIdx] == 'asc' ? classes.sSortAsc : columns[colIdx] == 'desc' ? classes.sSortDesc : column.sSortingClass);
          });
        },
        jqueryui: function jqueryui(settings, cell, column, classes) {
          $('<div/>').addClass(classes.sSortJUIWrapper).append(cell.contents()).append($('<span/>').addClass(classes.sSortIcon + ' ' + column.sSortingClassJUI)).appendTo(cell); // Attach a sort listener to update on sort

          $(settings.nTable).on('order.dt.DT', function (e, ctx, sorting, columns) {
            if (settings !== ctx) {
              return;
            }

            var colIdx = column.idx;
            cell.removeClass(classes.sSortAsc + " " + classes.sSortDesc).addClass(columns[colIdx] == 'asc' ? classes.sSortAsc : columns[colIdx] == 'desc' ? classes.sSortDesc : column.sSortingClass);
            cell.find('span.' + classes.sSortIcon).removeClass(classes.sSortJUIAsc + " " + classes.sSortJUIDesc + " " + classes.sSortJUI + " " + classes.sSortJUIAscAllowed + " " + classes.sSortJUIDescAllowed).addClass(columns[colIdx] == 'asc' ? classes.sSortJUIAsc : columns[colIdx] == 'desc' ? classes.sSortJUIDesc : column.sSortingClassJUI);
          });
        }
      }
    });
    /*
     * Public helper functions. These aren't used internally by DataTables, or
     * called by any of the options passed into DataTables, but they can be used
     * externally by developers working with DataTables. They are helper functions
     * to make working with DataTables a little bit easier.
     */

    /**
     * Helpers for `columns.render`.
     *
     * The options defined here can be used with the `columns.render` initialisation
     * option to provide a display renderer. The following functions are defined:
     *
     * * `number` - Will format numeric data (defined by `columns.data`) for
     *   display, retaining the original unformatted data for sorting and filtering.
     *   It takes 4 parameters:
     *   * `string` - Thousands grouping separator
     *   * `string` - Decimal point indicator
     *   * `integer` - Number of decimal points to show
     *   * `string` (optional) - Prefix.
     *
     * @example
     *   // Column definition using the number renderer
     *   {
     *     data: "salary",
     *     render: $.fn.dataTable.render.number( '\'', '.', 0, '$' )
     *   }
     *
     * @namespace
     */

    _DataTable.render = {
      number: function number(thousands, decimal, precision, prefix) {
        return {
          display: function display(d) {
            if (typeof d !== 'number' && typeof d !== 'string') {
              return d;
            }

            var negative = d < 0 ? '-' : '';
            d = Math.abs(parseFloat(d));
            var intPart = parseInt(d, 10);
            var floatPart = precision ? decimal + (d - intPart).toFixed(precision).substring(2) : '';
            return negative + (prefix || '') + intPart.toString().replace(/\B(?=(\d{3})+(?!\d))/g, thousands) + floatPart;
          }
        };
      }
    };
    /*
     * This is really a good bit rubbish this method of exposing the internal methods
     * publicly... - To be fixed in 2.0 using methods on the prototype
     */

    /**
     * Create a wrapper function for exporting an internal functions to an external API.
     *  @param {string} fn API function name
     *  @returns {function} wrapped function
     *  @memberof DataTable#internal
     */

    function _fnExternApiFunc(fn) {
      return function () {
        var args = [_fnSettingsFromNode(this[_DataTable.ext.iApiIndex])].concat(Array.prototype.slice.call(arguments));
        return _DataTable.ext.internal[fn].apply(this, args);
      };
    }
    /**
     * Reference to internal functions for use by plug-in developers. Note that
     * these methods are references to internal functions and are considered to be
     * private. If you use these methods, be aware that they are liable to change
     * between versions.
     *  @namespace
     */


    $.extend(_DataTable.ext.internal, {
      _fnExternApiFunc: _fnExternApiFunc,
      _fnBuildAjax: _fnBuildAjax,
      _fnAjaxUpdate: _fnAjaxUpdate,
      _fnAjaxParameters: _fnAjaxParameters,
      _fnAjaxUpdateDraw: _fnAjaxUpdateDraw,
      _fnAjaxDataSrc: _fnAjaxDataSrc,
      _fnAddColumn: _fnAddColumn,
      _fnColumnOptions: _fnColumnOptions,
      _fnAdjustColumnSizing: _fnAdjustColumnSizing,
      _fnVisibleToColumnIndex: _fnVisibleToColumnIndex,
      _fnColumnIndexToVisible: _fnColumnIndexToVisible,
      _fnVisbleColumns: _fnVisbleColumns,
      _fnGetColumns: _fnGetColumns,
      _fnColumnTypes: _fnColumnTypes,
      _fnApplyColumnDefs: _fnApplyColumnDefs,
      _fnHungarianMap: _fnHungarianMap,
      _fnCamelToHungarian: _fnCamelToHungarian,
      _fnLanguageCompat: _fnLanguageCompat,
      _fnBrowserDetect: _fnBrowserDetect,
      _fnAddData: _fnAddData,
      _fnAddTr: _fnAddTr,
      _fnNodeToDataIndex: _fnNodeToDataIndex,
      _fnNodeToColumnIndex: _fnNodeToColumnIndex,
      _fnGetCellData: _fnGetCellData,
      _fnSetCellData: _fnSetCellData,
      _fnSplitObjNotation: _fnSplitObjNotation,
      _fnGetObjectDataFn: _fnGetObjectDataFn,
      _fnSetObjectDataFn: _fnSetObjectDataFn,
      _fnGetDataMaster: _fnGetDataMaster,
      _fnClearTable: _fnClearTable,
      _fnDeleteIndex: _fnDeleteIndex,
      _fnInvalidate: _fnInvalidate,
      _fnGetRowElements: _fnGetRowElements,
      _fnCreateTr: _fnCreateTr,
      _fnBuildHead: _fnBuildHead,
      _fnDrawHead: _fnDrawHead,
      _fnDraw: _fnDraw,
      _fnReDraw: _fnReDraw,
      _fnAddOptionsHtml: _fnAddOptionsHtml,
      _fnDetectHeader: _fnDetectHeader,
      _fnGetUniqueThs: _fnGetUniqueThs,
      _fnFeatureHtmlFilter: _fnFeatureHtmlFilter,
      _fnFilterComplete: _fnFilterComplete,
      _fnFilterCustom: _fnFilterCustom,
      _fnFilterColumn: _fnFilterColumn,
      _fnFilter: _fnFilter,
      _fnFilterCreateSearch: _fnFilterCreateSearch,
      _fnEscapeRegex: _fnEscapeRegex,
      _fnFilterData: _fnFilterData,
      _fnFeatureHtmlInfo: _fnFeatureHtmlInfo,
      _fnUpdateInfo: _fnUpdateInfo,
      _fnInfoMacros: _fnInfoMacros,
      _fnInitialise: _fnInitialise,
      _fnInitComplete: _fnInitComplete,
      _fnLengthChange: _fnLengthChange,
      _fnFeatureHtmlLength: _fnFeatureHtmlLength,
      _fnFeatureHtmlPaginate: _fnFeatureHtmlPaginate,
      _fnPageChange: _fnPageChange,
      _fnFeatureHtmlProcessing: _fnFeatureHtmlProcessing,
      _fnProcessingDisplay: _fnProcessingDisplay,
      _fnFeatureHtmlTable: _fnFeatureHtmlTable,
      _fnScrollDraw: _fnScrollDraw,
      _fnApplyToChildren: _fnApplyToChildren,
      _fnCalculateColumnWidths: _fnCalculateColumnWidths,
      _fnThrottle: _fnThrottle,
      _fnConvertToWidth: _fnConvertToWidth,
      _fnScrollingWidthAdjust: _fnScrollingWidthAdjust,
      _fnGetWidestNode: _fnGetWidestNode,
      _fnGetMaxLenString: _fnGetMaxLenString,
      _fnStringToCss: _fnStringToCss,
      _fnScrollBarWidth: _fnScrollBarWidth,
      _fnSortFlatten: _fnSortFlatten,
      _fnSort: _fnSort,
      _fnSortAria: _fnSortAria,
      _fnSortListener: _fnSortListener,
      _fnSortAttachListener: _fnSortAttachListener,
      _fnSortingClasses: _fnSortingClasses,
      _fnSortData: _fnSortData,
      _fnSaveState: _fnSaveState,
      _fnLoadState: _fnLoadState,
      _fnSettingsFromNode: _fnSettingsFromNode,
      _fnLog: _fnLog,
      _fnMap: _fnMap,
      _fnBindAction: _fnBindAction,
      _fnCallbackReg: _fnCallbackReg,
      _fnCallbackFire: _fnCallbackFire,
      _fnLengthOverflow: _fnLengthOverflow,
      _fnRenderer: _fnRenderer,
      _fnDataSource: _fnDataSource,
      _fnRowAttributes: _fnRowAttributes,
      _fnCalculateEnd: function _fnCalculateEnd() {} // Used by a lot of plug-ins, but redundant
      // in 1.10, so this dead-end function is
      // added to prevent errors

    }); // jQuery access

    $.fn.dataTable = _DataTable; // Legacy aliases

    $.fn.dataTableSettings = _DataTable.settings;
    $.fn.dataTableExt = _DataTable.ext; // With a capital `D` we return a DataTables API instance rather than a
    // jQuery object

    $.fn.DataTable = function (opts) {
      return $(this).dataTable(opts).api();
    }; // All properties that are available to $.fn.dataTable should also be
    // available on $.fn.DataTable


    $.each(_DataTable, function (prop, val) {
      $.fn.DataTable[prop] = val;
    }); // Information about events fired by DataTables - for documentation.

    /**
     * Draw event, fired whenever the table is redrawn on the page, at the same
     * point as fnDrawCallback. This may be useful for binding events or
     * performing calculations when the table is altered at all.
     *  @name DataTable#draw.dt
     *  @event
     *  @param {event} e jQuery event object
     *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
     */

    /**
     * Search event, fired when the searching applied to the table (using the
     * built-in global search, or column filters) is altered.
     *  @name DataTable#search.dt
     *  @event
     *  @param {event} e jQuery event object
     *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
     */

    /**
     * Page change event, fired when the paging of the table is altered.
     *  @name DataTable#page.dt
     *  @event
     *  @param {event} e jQuery event object
     *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
     */

    /**
     * Order event, fired when the ordering applied to the table is altered.
     *  @name DataTable#order.dt
     *  @event
     *  @param {event} e jQuery event object
     *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
     */

    /**
     * DataTables initialisation complete event, fired when the table is fully
     * drawn, including Ajax data loaded, if Ajax data is required.
     *  @name DataTable#init.dt
     *  @event
     *  @param {event} e jQuery event object
     *  @param {object} oSettings DataTables settings object
     *  @param {object} json The JSON object request from the server - only
     *    present if client-side Ajax sourced data is used</li></ol>
     */

    /**
     * State save event, fired when the table has changed state a new state save
     * is required. This event allows modification of the state saving object
     * prior to actually doing the save, including addition or other state
     * properties (for plug-ins) or modification of a DataTables core property.
     *  @name DataTable#stateSaveParams.dt
     *  @event
     *  @param {event} e jQuery event object
     *  @param {object} oSettings DataTables settings object
     *  @param {object} json The state information to be saved
     */

    /**
     * State load event, fired when the table is loading state from the stored
     * data, but prior to the settings object being modified by the saved state
     * - allowing modification of the saved state is required or loading of
     * state for a plug-in.
     *  @name DataTable#stateLoadParams.dt
     *  @event
     *  @param {event} e jQuery event object
     *  @param {object} oSettings DataTables settings object
     *  @param {object} json The saved state information
     */

    /**
     * State loaded event, fired when state has been loaded from stored data and
     * the settings object has been modified by the loaded data.
     *  @name DataTable#stateLoaded.dt
     *  @event
     *  @param {event} e jQuery event object
     *  @param {object} oSettings DataTables settings object
     *  @param {object} json The saved state information
     */

    /**
     * Processing event, fired when DataTables is doing some kind of processing
     * (be it, order, searcg or anything else). It can be used to indicate to
     * the end user that there is something happening, or that something has
     * finished.
     *  @name DataTable#processing.dt
     *  @event
     *  @param {event} e jQuery event object
     *  @param {object} oSettings DataTables settings object
     *  @param {boolean} bShow Flag for if DataTables is doing processing or not
     */

    /**
     * Ajax (XHR) event, fired whenever an Ajax request is completed from a
     * request to made to the server for new data. This event is called before
     * DataTables processed the returned data, so it can also be used to pre-
     * process the data returned from the server, if needed.
     *
     * Note that this trigger is called in `fnServerData`, if you override
     * `fnServerData` and which to use this event, you need to trigger it in you
     * success function.
     *  @name DataTable#xhr.dt
     *  @event
     *  @param {event} e jQuery event object
     *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
     *  @param {object} json JSON returned from the server
     *
     *  @example
     *     // Use a custom property returned from the server in another DOM element
     *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {
     *       $('#status').html( json.status );
     *     } );
     *
     *  @example
     *     // Pre-process the data returned from the server
     *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {
     *       for ( var i=0, ien=json.aaData.length ; i<ien ; i++ ) {
     *         json.aaData[i].sum = json.aaData[i].one + json.aaData[i].two;
     *       }
     *       // Note no return - manipulate the data directly in the JSON object.
     *     } );
     */

    /**
     * Destroy event, fired when the DataTable is destroyed by calling fnDestroy
     * or passing the bDestroy:true parameter in the initialisation object. This
     * can be used to remove bound events, added DOM nodes, etc.
     *  @name DataTable#destroy.dt
     *  @event
     *  @param {event} e jQuery event object
     *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
     */

    /**
     * Page length change event, fired when number of records to show on each
     * page (the length) is changed.
     *  @name DataTable#length.dt
     *  @event
     *  @param {event} e jQuery event object
     *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
     *  @param {integer} len New length
     */

    /**
     * Column sizing has changed.
     *  @name DataTable#column-sizing.dt
     *  @event
     *  @param {event} e jQuery event object
     *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
     */

    /**
     * Column visibility has changed.
     *  @name DataTable#column-visibility.dt
     *  @event
     *  @param {event} e jQuery event object
     *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
     *  @param {int} column Column index
     *  @param {bool} vis `false` if column now hidden, or `true` if visible
     */

    return $.fn.dataTable;
  });
})(window, document);

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9kaXN0L2pxdWVyeS5qcyIsIndlYnBhY2s6Ly8vLi93ZWIvYXNzZXRzL2RhdGF0YWJsZXMvanF1ZXJ5LmRhdGFUYWJsZXMuanMiXSwibmFtZXMiOlsid2luZG93IiwiZG9jdW1lbnQiLCJ1bmRlZmluZWQiLCJmYWN0b3J5IiwiZGVmaW5lIiwiJCIsIkRhdGFUYWJsZSIsIl9leHQiLCJfQXBpIiwiX2FwaV9yZWdpc3RlciIsIl9hcGlfcmVnaXN0ZXJQbHVyYWwiLCJfcmVfZGljIiwiX3JlX25ld19saW5lcyIsIl9yZV9odG1sIiwiX3JlX2RhdGVfc3RhcnQiLCJfcmVfZGF0ZV9lbmQiLCJfcmVfZXNjYXBlX3JlZ2V4IiwiUmVnRXhwIiwiam9pbiIsIl9yZV9mb3JtYXR0ZWRfbnVtZXJpYyIsIl9lbXB0eSIsImQiLCJfaW50VmFsIiwicyIsImludGVnZXIiLCJwYXJzZUludCIsImlzTmFOIiwiaXNGaW5pdGUiLCJfbnVtVG9EZWNpbWFsIiwibnVtIiwiZGVjaW1hbFBvaW50IiwiX2ZuRXNjYXBlUmVnZXgiLCJyZXBsYWNlIiwiX2lzTnVtYmVyIiwiZm9ybWF0dGVkIiwic3RyVHlwZSIsInBhcnNlRmxvYXQiLCJfaXNIdG1sIiwiX2h0bWxOdW1lcmljIiwiaHRtbCIsIl9zdHJpcEh0bWwiLCJfcGx1Y2siLCJhIiwicHJvcCIsInByb3AyIiwib3V0IiwiaSIsImllbiIsImxlbmd0aCIsInB1c2giLCJfcGx1Y2tfb3JkZXIiLCJvcmRlciIsIl9yYW5nZSIsImxlbiIsInN0YXJ0IiwiZW5kIiwiX3JlbW92ZUVtcHR5IiwiX3VuaXF1ZSIsInNyYyIsInZhbCIsImoiLCJrIiwiYWdhaW4iLCJfZm5IdW5nYXJpYW5NYXAiLCJvIiwiaHVuZ2FyaWFuIiwibWF0Y2giLCJuZXdLZXkiLCJtYXAiLCJlYWNoIiwia2V5IiwiaW5kZXhPZiIsInRvTG93ZXJDYXNlIiwiX2h1bmdhcmlhbk1hcCIsIl9mbkNhbWVsVG9IdW5nYXJpYW4iLCJ1c2VyIiwiZm9yY2UiLCJodW5nYXJpYW5LZXkiLCJjaGFyQXQiLCJleHRlbmQiLCJfZm5MYW5ndWFnZUNvbXBhdCIsImxhbmciLCJkZWZhdWx0cyIsIm9MYW5ndWFnZSIsInplcm9SZWNvcmRzIiwic1plcm9SZWNvcmRzIiwic0VtcHR5VGFibGUiLCJfZm5NYXAiLCJzTG9hZGluZ1JlY29yZHMiLCJzSW5mb1Rob3VzYW5kcyIsInNUaG91c2FuZHMiLCJkZWNpbWFsIiwic0RlY2ltYWwiLCJfYWRkTnVtZXJpY1NvcnQiLCJfZm5Db21wYXRNYXAiLCJrbmV3Iiwib2xkIiwiX2ZuQ29tcGF0T3B0cyIsImluaXQiLCJzZWFyY2hDb2xzIiwiYW9TZWFyY2hDb2xzIiwibW9kZWxzIiwib1NlYXJjaCIsIl9mbkNvbXBhdENvbHMiLCJkYXRhU29ydCIsImFEYXRhU29ydCIsImlzQXJyYXkiLCJfZm5Ccm93c2VyRGV0ZWN0Iiwic2V0dGluZ3MiLCJicm93c2VyIiwib0Jyb3dzZXIiLCJuIiwiY3NzIiwicG9zaXRpb24iLCJ0b3AiLCJsZWZ0IiwiaGVpZ2h0Iiwid2lkdGgiLCJvdmVyZmxvdyIsImFwcGVuZCIsImFwcGVuZFRvIiwidGVzdCIsImZpbmQiLCJiU2Nyb2xsT3ZlcnNpemUiLCJvZmZzZXRXaWR0aCIsImJTY3JvbGxiYXJMZWZ0IiwiTWF0aCIsInJvdW5kIiwib2Zmc2V0IiwicmVtb3ZlIiwiX2ZuUmVkdWNlIiwidGhhdCIsImZuIiwiaW5jIiwidmFsdWUiLCJpc1NldCIsImhhc093blByb3BlcnR5IiwiX2ZuQWRkQ29sdW1uIiwib1NldHRpbmdzIiwiblRoIiwib0RlZmF1bHRzIiwiY29sdW1uIiwiaUNvbCIsImFvQ29sdW1ucyIsIm9Db2wiLCJvQ29sdW1uIiwiY3JlYXRlRWxlbWVudCIsInNUaXRsZSIsImlubmVySFRNTCIsIm1EYXRhIiwiaWR4IiwiYW9QcmVTZWFyY2hDb2xzIiwiX2ZuQ29sdW1uT3B0aW9ucyIsImRhdGEiLCJvT3B0aW9ucyIsIm9DbGFzc2VzIiwidGgiLCJzV2lkdGhPcmlnIiwiYXR0ciIsInQiLCJtRGF0YVByb3AiLCJzVHlwZSIsIl9zTWFudWFsVHlwZSIsImNsYXNzTmFtZSIsInNDbGFzcyIsImlEYXRhU29ydCIsIm1EYXRhU3JjIiwiX2ZuR2V0T2JqZWN0RGF0YUZuIiwibVJlbmRlciIsImF0dHJUZXN0IiwiX2JBdHRyU3JjIiwiaXNQbGFpbk9iamVjdCIsInNvcnQiLCJ0eXBlIiwiZmlsdGVyIiwiZm5HZXREYXRhIiwicm93RGF0YSIsIm1ldGEiLCJpbm5lckRhdGEiLCJmblNldERhdGEiLCJfZm5TZXRPYmplY3REYXRhRm4iLCJfcm93UmVhZE9iamVjdCIsIm9GZWF0dXJlcyIsImJTb3J0IiwiYlNvcnRhYmxlIiwiYWRkQ2xhc3MiLCJzU29ydGFibGVOb25lIiwiYkFzYyIsImluQXJyYXkiLCJhc1NvcnRpbmciLCJiRGVzYyIsInNTb3J0aW5nQ2xhc3MiLCJzU29ydGluZ0NsYXNzSlVJIiwic1NvcnRhYmxlQXNjIiwic1NvcnRKVUlBc2NBbGxvd2VkIiwic1NvcnRhYmxlRGVzYyIsInNTb3J0SlVJRGVzY0FsbG93ZWQiLCJzU29ydGFibGUiLCJzU29ydEpVSSIsIl9mbkFkanVzdENvbHVtblNpemluZyIsImJBdXRvV2lkdGgiLCJjb2x1bW5zIiwiX2ZuQ2FsY3VsYXRlQ29sdW1uV2lkdGhzIiwiaUxlbiIsInN0eWxlIiwic1dpZHRoIiwic2Nyb2xsIiwib1Njcm9sbCIsInNZIiwic1giLCJfZm5TY3JvbGxEcmF3IiwiX2ZuQ2FsbGJhY2tGaXJlIiwiX2ZuVmlzaWJsZVRvQ29sdW1uSW5kZXgiLCJpTWF0Y2giLCJhaVZpcyIsIl9mbkdldENvbHVtbnMiLCJfZm5Db2x1bW5JbmRleFRvVmlzaWJsZSIsImlQb3MiLCJfZm5WaXNibGVDb2x1bW5zIiwic1BhcmFtIiwiX2ZuQ29sdW1uVHlwZXMiLCJhb0RhdGEiLCJ0eXBlcyIsImV4dCIsImRldGVjdCIsImplbiIsImtlbiIsImNvbCIsImNlbGwiLCJkZXRlY3RlZFR5cGUiLCJjYWNoZSIsIl9mbkdldENlbGxEYXRhIiwiX2ZuQXBwbHlDb2x1bW5EZWZzIiwiYW9Db2xEZWZzIiwiYW9Db2xzIiwiakxlbiIsImtMZW4iLCJkZWYiLCJhVGFyZ2V0cyIsInRhcmdldHMiLCJoYXNDbGFzcyIsIl9mbkFkZERhdGEiLCJhRGF0YUluIiwiblRyIiwiYW5UZHMiLCJpUm93Iiwib0RhdGEiLCJvUm93IiwiX2FEYXRhIiwiblRkIiwic1RoaXNUeXBlIiwiX2ZuU2V0Q2VsbERhdGEiLCJhaURpc3BsYXlNYXN0ZXIiLCJiRGVmZXJSZW5kZXIiLCJfZm5DcmVhdGVUciIsIl9mbkFkZFRyIiwidHJzIiwicm93IiwiZWwiLCJfZm5HZXRSb3dFbGVtZW50cyIsImNlbGxzIiwiX2ZuTm9kZVRvRGF0YUluZGV4IiwiX0RUX1Jvd0luZGV4IiwiX2ZuTm9kZVRvQ29sdW1uSW5kZXgiLCJhbkNlbGxzIiwicm93SWR4IiwiY29sSWR4IiwiZHJhdyIsImlEcmF3IiwiZGVmYXVsdENvbnRlbnQiLCJzRGVmYXVsdENvbnRlbnQiLCJjZWxsRGF0YSIsImlEcmF3RXJyb3IiLCJfZm5Mb2ciLCJjYWxsIiwiX19yZUFycmF5IiwiX19yZUZuIiwiX2ZuU3BsaXRPYmpOb3RhdGlvbiIsInN0ciIsIm1Tb3VyY2UiLCJfIiwiZmV0Y2hEYXRhIiwiYXJyYXlOb3RhdGlvbiIsImZ1bmNOb3RhdGlvbiIsImlubmVyU3JjIiwic3BsaWNlIiwic3Vic3RyaW5nIiwic2V0RGF0YSIsImIiLCJhTGFzdCIsInNsaWNlIiwiX2ZuR2V0RGF0YU1hc3RlciIsIl9mbkNsZWFyVGFibGUiLCJhaURpc3BsYXkiLCJfZm5EZWxldGVJbmRleCIsImlUYXJnZXQiLCJpVGFyZ2V0SW5kZXgiLCJfZm5JbnZhbGlkYXRlIiwiY2VsbFdyaXRlIiwiY2hpbGROb2RlcyIsInJlbW92ZUNoaWxkIiwiZmlyc3RDaGlsZCIsIl9hU29ydERhdGEiLCJfYUZpbHRlckRhdGEiLCJjb2xzIiwiX2ZuUm93QXR0cmlidXRlcyIsInRkcyIsInRkIiwibmFtZSIsImNvbnRlbnRzIiwib2JqZWN0UmVhZCIsInNldHRlciIsImdldEF0dHJpYnV0ZSIsImNlbGxQcm9jZXNzIiwidHJpbSIsIl9zZXR0ZXIiLCJub2RlTmFtZSIsInRvVXBwZXJDYXNlIiwibmV4dFNpYmxpbmciLCJuVHJJbiIsInNDZWxsVHlwZSIsImJWaXNpYmxlIiwiYXBwZW5kQ2hpbGQiLCJwYXJlbnROb2RlIiwiZm5DcmVhdGVkQ2VsbCIsIm9JbnN0YW5jZSIsInNldEF0dHJpYnV0ZSIsInRyIiwiRFRfUm93SWQiLCJpZCIsIkRUX1Jvd0NsYXNzIiwic3BsaXQiLCJfX3Jvd2MiLCJjb25jYXQiLCJyZW1vdmVDbGFzcyIsIkRUX1Jvd0F0dHIiLCJEVF9Sb3dEYXRhIiwiX2ZuQnVpbGRIZWFkIiwidGhlYWQiLCJuVEhlYWQiLCJ0Zm9vdCIsIm5URm9vdCIsImNyZWF0ZUhlYWRlciIsImNsYXNzZXMiLCJpVGFiSW5kZXgiLCJzVGFibGVJZCIsIl9mblNvcnRBdHRhY2hMaXN0ZW5lciIsIl9mblJlbmRlcmVyIiwiX2ZuRGV0ZWN0SGVhZGVyIiwiYW9IZWFkZXIiLCJzSGVhZGVyVEgiLCJzRm9vdGVyVEgiLCJhb0Zvb3RlciIsIm5UZiIsIl9mbkRyYXdIZWFkIiwiYW9Tb3VyY2UiLCJiSW5jbHVkZUhpZGRlbiIsIm5Mb2NhbFRyIiwiYW9Mb2NhbCIsImFBcHBsaWVkIiwiaUNvbHVtbnMiLCJpUm93c3BhbiIsImlDb2xzcGFuIiwiX2ZuRHJhdyIsImFQcmVEcmF3IiwiX2ZuUHJvY2Vzc2luZ0Rpc3BsYXkiLCJhblJvd3MiLCJpUm93Q291bnQiLCJhc1N0cmlwZUNsYXNzZXMiLCJpU3RyaXBlcyIsImlPcGVuUm93cyIsImFvT3BlblJvd3MiLCJvTGFuZyIsImlJbml0RGlzcGxheVN0YXJ0IiwiYlNlcnZlclNpZGUiLCJfZm5EYXRhU291cmNlIiwiYkRyYXdpbmciLCJfaURpc3BsYXlTdGFydCIsImZuUmVjb3Jkc0Rpc3BsYXkiLCJpRGlzcGxheVN0YXJ0IiwiaURpc3BsYXlFbmQiLCJmbkRpc3BsYXlFbmQiLCJiRGVmZXJMb2FkaW5nIiwiYkRlc3Ryb3lpbmciLCJfZm5BamF4VXBkYXRlIiwiaVN0YXJ0IiwiaUVuZCIsImlEYXRhSW5kZXgiLCJuUm93Iiwic1N0cmlwZSIsIl9zUm93U3RyaXBlIiwic1plcm8iLCJmblJlY29yZHNUb3RhbCIsInNSb3dFbXB0eSIsImNoaWxkcmVuIiwiYm9keSIsIm5UQm9keSIsImRldGFjaCIsImJTb3J0ZWQiLCJiRmlsdGVyZWQiLCJfZm5SZURyYXciLCJob2xkUG9zaXRpb24iLCJmZWF0dXJlcyIsImJGaWx0ZXIiLCJfZm5Tb3J0IiwiX2ZuRmlsdGVyQ29tcGxldGUiLCJvUHJldmlvdXNTZWFyY2giLCJfZHJhd0hvbGQiLCJfZm5BZGRPcHRpb25zSHRtbCIsInRhYmxlIiwiblRhYmxlIiwiaG9sZGluZyIsImluc2VydEJlZm9yZSIsImluc2VydCIsInNXcmFwcGVyIiwic05vRm9vdGVyIiwibkhvbGRpbmciLCJuVGFibGVXcmFwcGVyIiwiblRhYmxlUmVpbnNlcnRCZWZvcmUiLCJhRG9tIiwic0RvbSIsImZlYXR1cmVOb2RlIiwiY09wdGlvbiIsIm5OZXdOb2RlIiwiY05leHQiLCJzQXR0ciIsInNKVUlIZWFkZXIiLCJzSlVJRm9vdGVyIiwiYVNwbGl0Iiwic3Vic3RyIiwicGFyZW50IiwiYlBhZ2luYXRlIiwiYkxlbmd0aENoYW5nZSIsIl9mbkZlYXR1cmVIdG1sTGVuZ3RoIiwiX2ZuRmVhdHVyZUh0bWxGaWx0ZXIiLCJiUHJvY2Vzc2luZyIsIl9mbkZlYXR1cmVIdG1sUHJvY2Vzc2luZyIsIl9mbkZlYXR1cmVIdG1sVGFibGUiLCJiSW5mbyIsIl9mbkZlYXR1cmVIdG1sSW5mbyIsIl9mbkZlYXR1cmVIdG1sUGFnaW5hdGUiLCJmZWF0dXJlIiwiYW9GZWF0dXJlcyIsImNGZWF0dXJlIiwiZm5Jbml0IiwiYWFuRmVhdHVyZXMiLCJyZXBsYWNlV2l0aCIsImFMYXlvdXQiLCJuVGhlYWQiLCJuVHJzIiwibkNlbGwiLCJsIiwiaUNvbFNoaWZ0ZWQiLCJpQ29sdW1uIiwiYlVuaXF1ZSIsImZuU2hpZnRDb2wiLCJfZm5HZXRVbmlxdWVUaHMiLCJuSGVhZGVyIiwiYVJldHVybiIsInVuaXF1ZSIsImJTb3J0Q2VsbHNUb3AiLCJfZm5CdWlsZEFqYXgiLCJ0bXAiLCJyYnJhY2tldCIsImFqYXhEYXRhIiwiYWpheCIsImluc3RhbmNlIiwiY2FsbGJhY2siLCJqc29uIiwianFYSFIiLCJuZXdEYXRhIiwiaXNGdW5jdGlvbiIsImJhc2VBamF4IiwiZXJyb3IiLCJzRXJyb3IiLCJzU2VydmVyTWV0aG9kIiwieGhyIiwidGhyb3duIiwicmV0IiwicmVhZHlTdGF0ZSIsIm9BamF4RGF0YSIsImZuU2VydmVyRGF0YSIsInNBamF4U291cmNlIiwidXJsIiwiYkFqYXhEYXRhR2V0IiwiX2ZuQWpheFBhcmFtZXRlcnMiLCJfZm5BamF4VXBkYXRlRHJhdyIsImNvbHVtbkNvdW50IiwicHJlU2VhcmNoIiwicHJlQ29sU2VhcmNoIiwiZGF0YVByb3AiLCJjb2x1bW5TZWFyY2giLCJfZm5Tb3J0RmxhdHRlbiIsImRpc3BsYXlTdGFydCIsImRpc3BsYXlMZW5ndGgiLCJfaURpc3BsYXlMZW5ndGgiLCJwYXJhbSIsInNlYXJjaCIsInNTZWFyY2giLCJyZWdleCIsImJSZWdleCIsInNOYW1lIiwic2VhcmNoYWJsZSIsImJTZWFyY2hhYmxlIiwib3JkZXJhYmxlIiwiZGlyIiwibGVnYWN5IiwiY29tcGF0IiwibW9kZXJuIiwiX2ZuQWpheERhdGFTcmMiLCJyZWNvcmRzVG90YWwiLCJyZWNvcmRzRmlsdGVyZWQiLCJfaVJlY29yZHNUb3RhbCIsIl9pUmVjb3Jkc0Rpc3BsYXkiLCJfYkluaXRDb21wbGV0ZSIsIl9mbkluaXRDb21wbGV0ZSIsImRhdGFTcmMiLCJzQWpheERhdGFQcm9wIiwiYWFEYXRhIiwidGFibGVJZCIsImxhbmd1YWdlIiwicHJldmlvdXNTZWFyY2giLCJpbnB1dCIsInNGaWx0ZXJJbnB1dCIsImYiLCJzRmlsdGVyIiwic2VhcmNoRm4iLCJiU21hcnQiLCJiQ2FzZUluc2Vuc2l0aXZlIiwic2VhcmNoRGVsYXkiLCJqcUZpbHRlciIsInNTZWFyY2hQbGFjZWhvbGRlciIsImJpbmQiLCJfZm5UaHJvdHRsZSIsImUiLCJrZXlDb2RlIiwib24iLCJldiIsImFjdGl2ZUVsZW1lbnQiLCJvSW5wdXQiLCJpRm9yY2UiLCJvUHJldlNlYXJjaCIsImFvUHJldlNlYXJjaCIsImZuU2F2ZUZpbHRlciIsIm9GaWx0ZXIiLCJmblJlZ2V4IiwiYkVzY2FwZVJlZ2V4IiwiX2ZuRmlsdGVyIiwiX2ZuRmlsdGVyQ29sdW1uIiwiX2ZuRmlsdGVyQ3VzdG9tIiwiZmlsdGVycyIsImRpc3BsYXlSb3dzIiwicm93cyIsImFwcGx5Iiwic2VhcmNoU3RyIiwic21hcnQiLCJjYXNlSW5zZW5zaXRpdmUiLCJkaXNwbGF5IiwicnBTZWFyY2giLCJfZm5GaWx0ZXJDcmVhdGVTZWFyY2giLCJwcmV2U2VhcmNoIiwiZGlzcGxheU1hc3RlciIsImludmFsaWRhdGVkIiwiX2ZuRmlsdGVyRGF0YSIsIl9zRmlsdGVyUm93Iiwid29yZCIsIm0iLCJzVmFsIiwiX19maWx0ZXJfZGl2IiwiX19maWx0ZXJfZGl2X3RleHRDb250ZW50IiwidGV4dENvbnRlbnQiLCJmaWx0ZXJEYXRhIiwiZm9tYXR0ZXJzIiwid2FzSW52YWxpZGF0ZWQiLCJ0b1N0cmluZyIsImlubmVyVGV4dCIsIl9mblNlYXJjaFRvQ2FtZWwiLCJvYmoiLCJfZm5TZWFyY2hUb0h1bmciLCJ0aWQiLCJub2RlcyIsInNJbmZvIiwiYW9EcmF3Q2FsbGJhY2siLCJfZm5VcGRhdGVJbmZvIiwibWF4IiwidG90YWwiLCJzSW5mb0VtcHR5Iiwic0luZm9GaWx0ZXJlZCIsInNJbmZvUG9zdEZpeCIsIl9mbkluZm9NYWNyb3MiLCJmbkluZm9DYWxsYmFjayIsImZvcm1hdHRlciIsImZuRm9ybWF0TnVtYmVyIiwidmlzIiwiYWxsIiwiY2VpbCIsIl9mbkluaXRpYWxpc2UiLCJpQWpheFN0YXJ0IiwiYkluaXRpYWxpc2VkIiwic2V0VGltZW91dCIsIl9mblN0cmluZ1RvQ3NzIiwiYURhdGEiLCJfZm5MZW5ndGhDaGFuZ2UiLCJfZm5MZW5ndGhPdmVyZmxvdyIsIm1lbnUiLCJhTGVuZ3RoTWVudSIsImQyIiwibGVuZ3RocyIsInNlbGVjdCIsInNMZW5ndGhTZWxlY3QiLCJPcHRpb24iLCJkaXYiLCJzTGVuZ3RoIiwic0xlbmd0aE1lbnUiLCJvdXRlckhUTUwiLCJzUGFnaW5hdGlvblR5cGUiLCJwbHVnaW4iLCJwYWdlciIsInJlZHJhdyIsIm5vZGUiLCJzUGFnaW5nIiwicCIsInZpc1JlY29yZHMiLCJwYWdlIiwicGFnZXMiLCJidXR0b25zIiwiZm5VcGRhdGUiLCJfZm5QYWdlQ2hhbmdlIiwiYWN0aW9uIiwicmVjb3JkcyIsImZsb29yIiwiY2hhbmdlZCIsInIiLCJzUHJvY2Vzc2luZyIsInNob3ciLCJzY3JvbGxYIiwic2Nyb2xsWSIsImNhcHRpb24iLCJjYXB0aW9uU2lkZSIsIl9jYXB0aW9uU2lkZSIsImhlYWRlckNsb25lIiwiY2xvbmVOb2RlIiwiZm9vdGVyQ2xvbmUiLCJmb290ZXIiLCJfZGl2Iiwic2l6ZSIsInJlbW92ZUF0dHIiLCJzY3JvbGxlciIsInNTY3JvbGxXcmFwcGVyIiwic1Njcm9sbEhlYWQiLCJib3JkZXIiLCJzU2Nyb2xsSGVhZElubmVyIiwic1hJbm5lciIsInNTY3JvbGxCb2R5Iiwic1Njcm9sbEZvb3QiLCJzU2Nyb2xsRm9vdElubmVyIiwic2Nyb2xsSGVhZCIsInNjcm9sbEJvZHkiLCJzY3JvbGxGb290Iiwic2Nyb2xsTGVmdCIsIm5TY3JvbGxIZWFkIiwiblNjcm9sbEJvZHkiLCJuU2Nyb2xsRm9vdCIsInNjcm9sbFhJbm5lciIsImJhcldpZHRoIiwiaUJhcldpZHRoIiwiZGl2SGVhZGVyIiwiZGl2SGVhZGVyU3R5bGUiLCJkaXZIZWFkZXJJbm5lciIsImRpdkhlYWRlcklubmVyU3R5bGUiLCJkaXZIZWFkZXJUYWJsZSIsImRpdkJvZHlFbCIsImRpdkJvZHkiLCJkaXZCb2R5U3R5bGUiLCJkaXZGb290ZXIiLCJkaXZGb290ZXJJbm5lciIsImRpdkZvb3RlclRhYmxlIiwiaGVhZGVyIiwidGFibGVFbCIsInRhYmxlU3R5bGUiLCJpZTY3IiwiaGVhZGVyVHJnRWxzIiwiZm9vdGVyVHJnRWxzIiwiaGVhZGVyU3JjRWxzIiwiZm9vdGVyU3JjRWxzIiwiaGVhZGVyQ29weSIsImZvb3RlckNvcHkiLCJoZWFkZXJXaWR0aHMiLCJmb290ZXJXaWR0aHMiLCJoZWFkZXJDb250ZW50IiwiY29ycmVjdGlvbiIsInNhbml0eVdpZHRoIiwiemVyb091dCIsIm5TaXplciIsInBhZGRpbmdUb3AiLCJwYWRkaW5nQm90dG9tIiwiYm9yZGVyVG9wV2lkdGgiLCJib3JkZXJCb3R0b21XaWR0aCIsImNsb25lIiwicHJlcGVuZFRvIiwiX2ZuQXBwbHlUb0NoaWxkcmVuIiwiYkNvbGxhcHNlIiwib2Zmc2V0SGVpZ2h0Iiwib3V0ZXJXaWR0aCIsIm5Ub1NpemUiLCJzY3JvbGxIZWlnaHQiLCJpRXh0cmEiLCJpT3V0ZXJXaWR0aCIsImJTY3JvbGxpbmciLCJjbGllbnRIZWlnaHQiLCJwYWRkaW5nIiwic2Nyb2xsVG9wIiwiYW4xIiwiYW4yIiwiaW5kZXgiLCJuTm9kZTEiLCJuTm9kZTIiLCJub2RlVHlwZSIsIl9fcmVfaHRtbF9yZW1vdmUiLCJ2aXNpYmxlQ29sdW1ucyIsImhlYWRlckNlbGxzIiwidGFibGVXaWR0aEF0dHIiLCJ0YWJsZUNvbnRhaW5lciIsInVzZXJJbnB1dHMiLCJjb2x1bW5JZHgiLCJzdHlsZVdpZHRoIiwiX2ZuQ29udmVydFRvV2lkdGgiLCJlcSIsInRtcFRhYmxlIiwiX2ZuR2V0V2lkZXN0Tm9kZSIsInNDb250ZW50UGFkZGluZyIsIl9mblNjcm9sbGluZ1dpZHRoQWRqdXN0IiwiX3Jlc3pFdnQiLCJiaW5kUmVzaXplIiwic0luc3RhbmNlIiwiZnJlcSIsImZyZXF1ZW5jeSIsImxhc3QiLCJ0aW1lciIsIm5vdyIsIkRhdGUiLCJhcmdzIiwiYXJndW1lbnRzIiwiY2xlYXJUaW1lb3V0IiwiX2ZuR2V0TWF4TGVuU3RyaW5nIiwibWF4SWR4IiwiX2ZuU2Nyb2xsQmFyV2lkdGgiLCJfX3Njcm9sbGJhcldpZHRoIiwic2l6ZXIiLCJ2aXNpYmlsaXR5IiwiY2xpZW50V2lkdGgiLCJhU29ydCIsImFpT3JpZyIsInNyY0NvbCIsImZpeGVkIiwiYWFTb3J0aW5nRml4ZWQiLCJmaXhlZE9iaiIsIm5lc3RlZFNvcnQiLCJhZGQiLCJwcmUiLCJhYVNvcnRpbmciLCJwb3N0IiwiX2lkeCIsInNEYXRhVHlwZSIsIm9FeHRTb3J0Iiwib1NvcnQiLCJmb3JtYXR0ZXJzIiwic29ydENvbCIsIl9mblNvcnREYXRhIiwieCIsInkiLCJkYXRhQSIsImRhdGFCIiwiX2ZuU29ydEFyaWEiLCJsYWJlbCIsIm5leHRTb3J0Iiwib0FyaWEiLCJyZW1vdmVBdHRyaWJ1dGUiLCJzU29ydEFzY2VuZGluZyIsInNTb3J0RGVzY2VuZGluZyIsIl9mblNvcnRMaXN0ZW5lciIsInNvcnRpbmciLCJuZXh0U29ydElkeCIsIm5leHQiLCJiU29ydE11bHRpIiwic29ydElkeCIsImF0dGFjaFRvIiwiX2ZuQmluZEFjdGlvbiIsInNoaWZ0S2V5IiwiX2ZuU29ydGluZ0NsYXNzZXMiLCJvbGRTb3J0IiwiYUxhc3RTb3J0Iiwic29ydENsYXNzIiwic1NvcnRDb2x1bW4iLCJiU29ydENsYXNzZXMiLCJjdXN0b21Tb3J0Iiwic1NvcnREYXRhVHlwZSIsImN1c3RvbURhdGEiLCJfZm5TYXZlU3RhdGUiLCJiU3RhdGVTYXZlIiwic3RhdGUiLCJ0aW1lIiwidmlzaWJsZSIsIm9TYXZlZFN0YXRlIiwiZm5TdGF0ZVNhdmVDYWxsYmFjayIsIl9mbkxvYWRTdGF0ZSIsIm9Jbml0IiwiZm5TdGF0ZUxvYWRDYWxsYmFjayIsImFiU3RhdGVMb2FkIiwiZHVyYXRpb24iLCJpU3RhdGVEdXJhdGlvbiIsIm9Mb2FkZWRTdGF0ZSIsIl9mblNldHRpbmdzRnJvbU5vZGUiLCJsZXZlbCIsIm1zZyIsInRuIiwic0Vyck1vZGUiLCJlcnJNb2RlIiwiYWxlcnQiLCJFcnJvciIsImNvbnNvbGUiLCJsb2ciLCJtYXBwZWROYW1lIiwiX2ZuRXh0ZW5kIiwiZXh0ZW5kZXIiLCJicmVha1JlZnMiLCJibHVyIiwid2hpY2giLCJwcmV2ZW50RGVmYXVsdCIsIl9mbkNhbGxiYWNrUmVnIiwic1N0b3JlIiwiY2FsbGJhY2tBcnIiLCJldmVudE5hbWUiLCJyZXZlcnNlIiwiRXZlbnQiLCJ0cmlnZ2VyIiwicmVzdWx0IiwicmVuZGVyZXIiLCJob3N0Iiwib3B0aW9ucyIsInNTZWxlY3RvciIsIm9PcHRzIiwiYXBpIiwidHJhZGl0aW9uYWwiLCJpQXBpSW5kZXgiLCJmbkFkZERhdGEiLCJmbGF0dGVuIiwidG9BcnJheSIsImZuQWRqdXN0Q29sdW1uU2l6aW5nIiwiYlJlZHJhdyIsImFkanVzdCIsImZuQ2xlYXJUYWJsZSIsImNsZWFyIiwiZm5DbG9zZSIsImNoaWxkIiwiaGlkZSIsImZuRGVsZXRlUm93IiwidGFyZ2V0IiwiZm5EZXN0cm95IiwiZGVzdHJveSIsImZuRHJhdyIsImNvbXBsZXRlIiwiZm5GaWx0ZXIiLCJzSW5wdXQiLCJiU2hvd0dsb2JhbCIsImZuR2V0Tm9kZXMiLCJmbkdldFBvc2l0aW9uIiwiY29sdW1uVmlzaWJsZSIsImZuSXNPcGVuIiwiaXNTaG93biIsImZuT3BlbiIsIm1IdG1sIiwiZm5QYWdlQ2hhbmdlIiwibUFjdGlvbiIsImZuU2V0Q29sdW1uVmlzIiwiYlNob3ciLCJmblNldHRpbmdzIiwiZm5Tb3J0IiwiYWFTb3J0IiwiZm5Tb3J0TGlzdGVuZXIiLCJuTm9kZSIsImZuQ2FsbGJhY2siLCJsaXN0ZW5lciIsIm1Sb3ciLCJiQWN0aW9uIiwiZm5WZXJzaW9uQ2hlY2siLCJfdGhhdCIsImVtcHR5SW5pdCIsIm9BcGkiLCJpbnRlcm5hbCIsIl9mbkV4dGVybkFwaUZ1bmMiLCJzSWQiLCJiSW5pdEhhbmRlZE9mZiIsIiR0aGlzIiwiYWxsU2V0dGluZ3MiLCJiUmV0cmlldmUiLCJiRGVzdHJveSIsImRhdGFUYWJsZSIsImlEaXNwbGF5TGVuZ3RoIiwiZm5EcmF3Q2FsbGJhY2siLCJmblNlcnZlclBhcmFtcyIsImZuU3RhdGVTYXZlUGFyYW1zIiwiZm5TdGF0ZUxvYWRQYXJhbXMiLCJmblN0YXRlTG9hZGVkIiwiZm5Sb3dDYWxsYmFjayIsImZuQ3JlYXRlZFJvdyIsImZuSGVhZGVyQ2FsbGJhY2siLCJmbkZvb3RlckNhbGxiYWNrIiwiZm5Jbml0Q29tcGxldGUiLCJmblByZURyYXdDYWxsYmFjayIsImJKUXVlcnlVSSIsIm9KVUlDbGFzc2VzIiwic1RhYmxlIiwiaURlZmVyTG9hZGluZyIsInNVcmwiLCJkYXRhVHlwZSIsInN1Y2Nlc3MiLCJzU3RyaXBlT2RkIiwic1N0cmlwZUV2ZW4iLCJzdHJpcGVDbGFzc2VzIiwicm93T25lIiwiYXNEZXN0cm95U3RyaXBlcyIsImFuVGhzIiwiYW9Db2x1bW5zSW5pdCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiYW9Db2x1bW5EZWZzIiwib0RlZiIsInNvcnRlZENvbHVtbnMiLCJjYXB0aW9ucyIsInRib2R5IiwiX19hcGlTdHJ1Y3QiLCJfX2FycmF5UHJvdG8iLCJBcnJheSIsInByb3RvdHlwZSIsIl90b1NldHRpbmdzIiwibWl4ZWQiLCJqcSIsInRhYmxlcyIsImNvbnRleHQiLCJjdHhTZXR0aW5ncyIsInNlbGVjdG9yIiwib3B0cyIsIkFwaSIsImFueSIsImN0eCIsIml0ZXJhdG9yIiwiYWx3YXlzTmV3IiwiaXRlbXMiLCJpdGVtIiwiYXBpSW5zdCIsIl9zZWxlY3Rvcl9yb3dfaW5kZXhlcyIsImFwaVNlbGVjdG9yIiwibGFzdEluZGV4T2YiLCJwbHVjayIsInBvcCIsInJlZHVjZSIsInJlZHVjZVJpZ2h0Iiwic2hpZnQiLCJ0byQiLCJ0b0pRdWVyeSIsInVuc2hpZnQiLCJzY29wZSIsIl9fZHRfd3JhcHBlciIsInN0cnVjdCIsImlubmVyIiwibWV0aG9kU2NvcGluZyIsInN0cnVjIiwibWV0aG9kRXh0IiwicHJvcEV4dCIsInJlZ2lzdGVyIiwiaGVpciIsIm1ldGhvZCIsInJlZ2lzdGVyUGx1cmFsIiwicGx1cmFsTmFtZSIsInNpbmd1bGFyTmFtZSIsIl9fdGFibGVfc2VsZWN0b3IiLCJyZXNldFBhZ2luZyIsImluZm8iLCJfX3JlbG9hZCIsIm9uZSIsIl9zZWxlY3Rvcl9ydW4iLCJzZWxlY3RGbiIsInJlcyIsInNlbGVjdG9yVHlwZSIsIl9zZWxlY3Rvcl9vcHRzIiwiX3NlbGVjdG9yX2ZpcnN0IiwiaW5zdCIsImRpc3BsYXlGaWx0ZXJlZCIsIl9fcm93X3NlbGVjdG9yIiwicnVuIiwic2VsIiwic2VsSW50IiwidGhhdElkeCIsImRpc3BsYXlJbmRleCIsIm5ld1Jvd3MiLCJtb2RSb3dzIiwiX19kZXRhaWxzX2FkZCIsImtsYXNzIiwiYWRkUm93IiwiY3JlYXRlZCIsImNvbFNwYW4iLCJfZGV0YWlscyIsIl9kZXRhaWxzU2hvdyIsImluc2VydEFmdGVyIiwiX19kZXRhaWxzX3JlbW92ZSIsIl9fZGV0YWlsc19kaXNwbGF5IiwiX19kZXRhaWxzX2V2ZW50cyIsIm5hbWVzcGFjZSIsImRyYXdFdmVudCIsImNvbHZpc0V2ZW50IiwiZGVzdHJveUV2ZW50Iiwib2ZmIiwiX2VtcCIsIl9jaGlsZF9vYmoiLCJfY2hpbGRfbXRoIiwiX19yZV9jb2x1bW5fc2VsZWN0b3IiLCJfX2NvbHVtbkRhdGEiLCJyMSIsInIyIiwiX19jb2x1bW5fc2VsZWN0b3IiLCJuYW1lcyIsInZpc0NvbHVtbnMiLCJfX3NldENvbHVtblZpcyIsInJlY2FsYyIsImNhbGMiLCJfX2NlbGxfc2VsZWN0b3IiLCJhbGxDZWxscyIsImZuU2VsZWN0b3IiLCJyb3dTZWxlY3RvciIsImNvbHVtblNlbGVjdG9yIiwiY2FzZUluc2VuIiwidmVyc2lvbkNoZWNrIiwidmVyc2lvbiIsImFUaGlzIiwiYVRoYXQiLCJpVGhpcyIsImlUaGF0IiwiaXNEYXRhVGFibGUiLCJmbklzRGF0YVRhYmxlIiwiZ2V0IiwiaXMiLCJoZWFkIiwiZm9vdCIsImZuVGFibGVzIiwidXRpbCIsInRocm90dGxlIiwiZXNjYXBlUmVnZXgiLCJjYW1lbFRvSHVuZ2FyaWFuIiwianFSb3dzIiwib3JpZyIsImpxVGFibGUiLCJqcVRib2R5IiwianFXcmFwcGVyIiwidW5iaW5kIiwiYkpVSSIsInNTb3J0SWNvbiIsIndyYXBwZXIiLCJzU29ydEpVSVdyYXBwZXIiLCJzRGVzdHJveVdpZHRoIiwiaWR4MiIsInRva2VuIiwicGx1cmFsIiwicmVzb2x2ZWQiLCJ0b0Zvcm1hdCIsIkpTT04iLCJwYXJzZSIsInNlc3Npb25TdG9yYWdlIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImxvY2F0aW9uIiwicGF0aG5hbWUiLCJzZXRJdGVtIiwic3RyaW5naWZ5IiwicGFnaW5hdGUiLCJtaW4iLCJwYWdlQnV0dG9uIiwic1ZlcnNpb24iLCJhZm5GaWx0ZXJpbmciLCJhVHlwZXMiLCJvZm5TZWFyY2giLCJhZm5Tb3J0RGF0YSIsIm9TdGRDbGFzc2VzIiwib1BhZ2luYXRpb24iLCJfc3RhdGVEZWZhdWx0IiwiX3NvcnRJY29uIiwiX2hlYWRlckZvb3RlciIsImV4dFBhZ2luYXRpb24iLCJfbnVtYmVycyIsIm51bWJlcnMiLCJudW1iZXJzX2xlbmd0aCIsImhhbGYiLCJEVF9lbCIsInNpbXBsZSIsImZ1bGwiLCJzaW1wbGVfbnVtYmVycyIsImZ1bGxfbnVtYmVycyIsIm9QYWdpbmF0ZSIsImJ0bkRpc3BsYXkiLCJidG5DbGFzcyIsImNvdW50ZXIiLCJhdHRhY2giLCJjb250YWluZXIiLCJidXR0b24iLCJjbGlja0hhbmRsZXIiLCJzRmlyc3QiLCJzUGFnZUJ1dHRvbkRpc2FibGVkIiwic1ByZXZpb3VzIiwic05leHQiLCJzTGFzdCIsInNQYWdlQnV0dG9uQWN0aXZlIiwic1BhZ2VCdXR0b24iLCJhY3RpdmVFbCIsImVtcHR5IiwiZm9jdXMiLCJwYXJzZWQiLCJzdHJpbmciLCJfX251bWVyaWNSZXBsYWNlIiwiZGVjaW1hbFBsYWNlIiwicmUxIiwicmUyIiwiSW5maW5pdHkiLCJzU29ydEFzYyIsInNTb3J0RGVzYyIsImpxdWVyeXVpIiwic1NvcnRKVUlBc2MiLCJzU29ydEpVSURlc2MiLCJyZW5kZXIiLCJudW1iZXIiLCJ0aG91c2FuZHMiLCJwcmVjaXNpb24iLCJwcmVmaXgiLCJuZWdhdGl2ZSIsImFicyIsImludFBhcnQiLCJmbG9hdFBhcnQiLCJ0b0ZpeGVkIiwiX2ZuQ2FsY3VsYXRlRW5kIiwiZGF0YVRhYmxlU2V0dGluZ3MiLCJkYXRhVGFibGVFeHQiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtEQUEwQyxnQ0FBZ0M7QUFDMUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnRUFBd0Qsa0JBQWtCO0FBQzFFO0FBQ0EseURBQWlELGNBQWM7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUF5QyxpQ0FBaUM7QUFDMUUsd0hBQWdILG1CQUFtQixFQUFFO0FBQ3JJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7OztBQUdBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE1BQU0sS0FBMEI7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxZQUFZOztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUYsb0JBQW9COztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLFNBQVM7QUFDbEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLFlBQVk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsU0FBUztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBLGdCQUFnQixJQUFJOztBQUVwQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLHlCQUF5QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRLDZCQUE2QjtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsZ0NBQWdDLE1BQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsZUFBZTs7QUFFZixTQUFTOztBQUVUO0FBQ0EsUUFBUSxpQ0FBaUM7QUFDekMsUUFBUSxvQkFBb0I7QUFDNUIsUUFBUSxzQ0FBc0M7QUFDOUMsUUFBUTtBQUNSLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhLEVBQUU7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDREQUE0RDs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0EseUNBQXlDOztBQUV6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnRUFBZ0U7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qzs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsVUFBVTtBQUMzRSxzQ0FBc0MsMkJBQTJCO0FBQ2pFO0FBQ0EsZ0NBQWdDLE1BQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxVQUFVLFVBQVU7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsVUFBVSxjQUFjO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsWUFBWSx1RUFBdUU7QUFDbkY7QUFDQTtBQUNBLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsU0FBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLDJEQUEyRDs7QUFFM0Q7QUFDQTtBQUNBLG9GQUFvRjs7QUFFcEY7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxpREFBaUQ7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsVUFBVSx3Q0FBd0M7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTs7QUFFQSxDQUFDOzs7O0FBSUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUEsUUFBUSxHQUFHO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUEsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakIsMEJBQTBCLHdCQUF3Qjs7QUFFbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsMENBQTBDO0FBQzFDLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxjQUFjO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0NBQXdDLHNDQUFzQztBQUM5RSxvQ0FBb0MsdUNBQXVDO0FBQzNFLG9DQUFvQyxzQ0FBc0M7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ04sS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQztBQUNwQyxxQ0FBcUM7QUFDckMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7Ozs7O0FBS0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsYUFBYTtBQUNwQyxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxnQkFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLE9BQU87QUFDZjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxnQkFBZ0I7QUFDbEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7O0FBRVg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLGNBQWM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNB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QUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUM7OztBQUdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0RBQStEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxPQUFPOztBQUVmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLFFBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnQkFBZ0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGlEQUFpRCwwQkFBMEI7QUFDM0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtB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QVUsa0JBQWtCO0FBQzVCLFdBQVcsa0JBQWtCO0FBQzdCLGNBQWM7QUFDZCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFFBQVEsbUJBQW1CO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsaUNBQWlDO0FBQ2pDO0FBQ0E7O0FBRUEsSUFBSTtBQUNKOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxLQUFLO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQ0FBcUM7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsS0FBSztBQUNMOztBQUVBLFdBQVc7QUFDWCxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEIsZ0RBQWdEO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcseUJBQXlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQSxjQUFjLHNEQUFzRDtBQUNwRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBLGNBQWMsbUNBQW1DO0FBQ2pELGVBQWUsNkRBQTZEO0FBQzVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLLElBQTBDO0FBQy9DLENBQUMsaUNBQWtCLEVBQUUsbUNBQUU7QUFDdkI7QUFDQSxFQUFFO0FBQUEsb0dBQUU7QUFDSjs7Ozs7QUFLQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0FBQytILEVBQUYsQ0FBSzlILFNBQUwsR0FBaUIsVUFBV3U2QixJQUFYLEVBQWtCO0FBQ2xDLGFBQU94NkIsQ0FBQyxDQUFDLElBQUQsQ0FBRCxDQUFRNDNCLFNBQVIsQ0FBbUI0QyxJQUFuQixFQUEwQm5HLEdBQTFCLEVBQVA7QUFDQSxLQUZELENBeDRjb0MsQ0E0NGNwQztBQUNBOzs7QUFDQXIwQixLQUFDLENBQUNnRSxJQUFGLENBQVEvRCxVQUFSLEVBQW1CLFVBQVdxQyxJQUFYLEVBQWlCZ0IsR0FBakIsRUFBdUI7QUFDekN0RCxPQUFDLENBQUMrSCxFQUFGLENBQUs5SCxTQUFMLENBQWdCcUMsSUFBaEIsSUFBeUJnQixHQUF6QjtBQUNBLEtBRkQsRUE5NGNvQyxDQW01Y3BDOztBQUNBOzs7Ozs7Ozs7O0FBVUE7Ozs7Ozs7OztBQVNBOzs7Ozs7OztBQVFBOzs7Ozs7OztBQVFBOzs7Ozs7Ozs7OztBQVdBOzs7Ozs7Ozs7Ozs7QUFZQTs7Ozs7Ozs7Ozs7O0FBWUE7Ozs7Ozs7Ozs7QUFVQTs7Ozs7Ozs7Ozs7O0FBWUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUErQkE7Ozs7Ozs7Ozs7QUFVQTs7Ozs7Ozs7OztBQVVBOzs7Ozs7OztBQVFBOzs7Ozs7Ozs7O0FBVUEsV0FBT3RELENBQUMsQ0FBQytILEVBQUYsQ0FBSzZ2QixTQUFaO0FBQ0EsR0F2a2RBLENBQUQ7QUF5a2RDLENBM2tkc0IsRUEya2RyQmo0QixNQTNrZHFCLEVBMmtkYkMsUUEza2RhLENBQXZCLEMiLCJmaWxlIjoianF1ZXJ5LmRhdGFUYWJsZXMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9idWlsZC9cIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi93ZWIvYXNzZXRzL2RhdGF0YWJsZXMvanF1ZXJ5LmRhdGFUYWJsZXMuanNcIik7XG4iLCIvKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjMuMy4xXG4gKiBodHRwczovL2pxdWVyeS5jb20vXG4gKlxuICogSW5jbHVkZXMgU2l6emxlLmpzXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxOC0wMS0yMFQxNzoyNFpcbiAqL1xuKCBmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIGB3aW5kb3dgXG5cdFx0Ly8gaXMgcHJlc2VudCwgZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeS5cblx0XHQvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxuXHRcdC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzLlxuXHRcdC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgYHdpbmRvd2AuXG5cdFx0Ly8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xuXHRcdC8vIFNlZSB0aWNrZXQgIzE0NTQ5IGZvciBtb3JlIGluZm8uXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xuXHRcdFx0ZmFjdG9yeSggZ2xvYmFsLCB0cnVlICkgOlxuXHRcdFx0ZnVuY3Rpb24oIHcgKSB7XG5cdFx0XHRcdGlmICggIXcuZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWN0b3J5KCB3ICk7XG5cdFx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGZhY3RvcnkoIGdsb2JhbCApO1xuXHR9XG5cbi8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG59ICkoIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiggd2luZG93LCBub0dsb2JhbCApIHtcblxuLy8gRWRnZSA8PSAxMiAtIDEzKywgRmlyZWZveCA8PTE4IC0gNDUrLCBJRSAxMCAtIDExLCBTYWZhcmkgNS4xIC0gOSssIGlPUyA2IC0gOS4xXG4vLyB0aHJvdyBleGNlcHRpb25zIHdoZW4gbm9uLXN0cmljdCBjb2RlIChlLmcuLCBBU1AuTkVUIDQuNSkgYWNjZXNzZXMgc3RyaWN0IG1vZGVcbi8vIGFyZ3VtZW50cy5jYWxsZWUuY2FsbGVyICh0cmFjLTEzMzM1KS4gQnV0IGFzIG9mIGpRdWVyeSAzLjAgKDIwMTYpLCBzdHJpY3QgbW9kZSBzaG91bGQgYmUgY29tbW9uXG4vLyBlbm91Z2ggdGhhdCBhbGwgc3VjaCBhdHRlbXB0cyBhcmUgZ3VhcmRlZCBpbiBhIHRyeSBibG9jay5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYXJyID0gW107XG5cbnZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuXG52YXIgc2xpY2UgPSBhcnIuc2xpY2U7XG5cbnZhciBjb25jYXQgPSBhcnIuY29uY2F0O1xuXG52YXIgcHVzaCA9IGFyci5wdXNoO1xuXG52YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xuXG52YXIgY2xhc3MydHlwZSA9IHt9O1xuXG52YXIgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xuXG52YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGZuVG9TdHJpbmcgPSBoYXNPd24udG9TdHJpbmc7XG5cbnZhciBPYmplY3RGdW5jdGlvblN0cmluZyA9IGZuVG9TdHJpbmcuY2FsbCggT2JqZWN0ICk7XG5cbnZhciBzdXBwb3J0ID0ge307XG5cbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gaXNGdW5jdGlvbiggb2JqICkge1xuXG4gICAgICAvLyBTdXBwb3J0OiBDaHJvbWUgPD01NywgRmlyZWZveCA8PTUyXG4gICAgICAvLyBJbiBzb21lIGJyb3dzZXJzLCB0eXBlb2YgcmV0dXJucyBcImZ1bmN0aW9uXCIgZm9yIEhUTUwgPG9iamVjdD4gZWxlbWVudHNcbiAgICAgIC8vIChpLmUuLCBgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib2JqZWN0XCIgKSA9PT0gXCJmdW5jdGlvblwiYCkuXG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRvIGNsYXNzaWZ5ICphbnkqIERPTSBub2RlIGFzIGEgZnVuY3Rpb24uXG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBvYmoubm9kZVR5cGUgIT09IFwibnVtYmVyXCI7XG4gIH07XG5cblxudmFyIGlzV2luZG93ID0gZnVuY3Rpb24gaXNXaW5kb3coIG9iaiApIHtcblx0XHRyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xuXHR9O1xuXG5cblxuXG5cdHZhciBwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzID0ge1xuXHRcdHR5cGU6IHRydWUsXG5cdFx0c3JjOiB0cnVlLFxuXHRcdG5vTW9kdWxlOiB0cnVlXG5cdH07XG5cblx0ZnVuY3Rpb24gRE9NRXZhbCggY29kZSwgZG9jLCBub2RlICkge1xuXHRcdGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcblxuXHRcdHZhciBpLFxuXHRcdFx0c2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoIFwic2NyaXB0XCIgKTtcblxuXHRcdHNjcmlwdC50ZXh0ID0gY29kZTtcblx0XHRpZiAoIG5vZGUgKSB7XG5cdFx0XHRmb3IgKCBpIGluIHByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMgKSB7XG5cdFx0XHRcdGlmICggbm9kZVsgaSBdICkge1xuXHRcdFx0XHRcdHNjcmlwdFsgaSBdID0gbm9kZVsgaSBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGRvYy5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHQgKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcblx0fVxuXG5cbmZ1bmN0aW9uIHRvVHlwZSggb2JqICkge1xuXHRpZiAoIG9iaiA9PSBudWxsICkge1xuXHRcdHJldHVybiBvYmogKyBcIlwiO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5IChmdW5jdGlvbmlzaCBSZWdFeHApXG5cdHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiA/XG5cdFx0Y2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbCggb2JqICkgXSB8fCBcIm9iamVjdFwiIDpcblx0XHR0eXBlb2Ygb2JqO1xufVxuLyogZ2xvYmFsIFN5bWJvbCAqL1xuLy8gRGVmaW5pbmcgdGhpcyBnbG9iYWwgaW4gLmVzbGludHJjLmpzb24gd291bGQgY3JlYXRlIGEgZGFuZ2VyIG9mIHVzaW5nIHRoZSBnbG9iYWxcbi8vIHVuZ3VhcmRlZCBpbiBhbm90aGVyIHBsYWNlLCBpdCBzZWVtcyBzYWZlciB0byBkZWZpbmUgZ2xvYmFsIG9ubHkgZm9yIHRoaXMgbW9kdWxlXG5cblxuXG52YXJcblx0dmVyc2lvbiA9IFwiMy4zLjFcIixcblxuXHQvLyBEZWZpbmUgYSBsb2NhbCBjb3B5IG9mIGpRdWVyeVxuXHRqUXVlcnkgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cblx0XHQvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcblx0XHQvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxuXHRcdHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB3ZSB0cmltIEJPTSBhbmQgTkJTUFxuXHRydHJpbSA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZztcblxualF1ZXJ5LmZuID0galF1ZXJ5LnByb3RvdHlwZSA9IHtcblxuXHQvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXG5cdGpxdWVyeTogdmVyc2lvbixcblxuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LFxuXG5cdC8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhIGpRdWVyeSBvYmplY3QgaXMgMFxuXHRsZW5ndGg6IDAsXG5cblx0dG9BcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIE50aCBlbGVtZW50IGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0IE9SXG5cdC8vIEdldCB0aGUgd2hvbGUgbWF0Y2hlZCBlbGVtZW50IHNldCBhcyBhIGNsZWFuIGFycmF5XG5cdGdldDogZnVuY3Rpb24oIG51bSApIHtcblxuXHRcdC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGluIGEgY2xlYW4gYXJyYXlcblx0XHRpZiAoIG51bSA9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4ganVzdCB0aGUgb25lIGVsZW1lbnQgZnJvbSB0aGUgc2V0XG5cdFx0cmV0dXJuIG51bSA8IDAgPyB0aGlzWyBudW0gKyB0aGlzLmxlbmd0aCBdIDogdGhpc1sgbnVtIF07XG5cdH0sXG5cblx0Ly8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xuXHQvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcblx0cHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cblx0XHQvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxuXHRcdHZhciByZXQgPSBqUXVlcnkubWVyZ2UoIHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMgKTtcblxuXHRcdC8vIEFkZCB0aGUgb2xkIG9iamVjdCBvbnRvIHRoZSBzdGFjayAoYXMgYSByZWZlcmVuY2UpXG5cdFx0cmV0LnByZXZPYmplY3QgPSB0aGlzO1xuXG5cdFx0Ly8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG5cdGVhY2g6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmVhY2goIHRoaXMsIGNhbGxiYWNrICk7XG5cdH0sXG5cblx0bWFwOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkubWFwKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0c2xpY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggc2xpY2UuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApICk7XG5cdH0sXG5cblx0Zmlyc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAwICk7XG5cdH0sXG5cblx0bGFzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIC0xICk7XG5cdH0sXG5cblx0ZXE6IGZ1bmN0aW9uKCBpICkge1xuXHRcdHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdGogPSAraSArICggaSA8IDAgPyBsZW4gOiAwICk7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqID49IDAgJiYgaiA8IGxlbiA/IFsgdGhpc1sgaiBdIF0gOiBbXSApO1xuXHR9LFxuXG5cdGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCk7XG5cdH0sXG5cblx0Ly8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuXHQvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cblx0cHVzaDogcHVzaCxcblx0c29ydDogYXJyLnNvcnQsXG5cdHNwbGljZTogYXJyLnNwbGljZVxufTtcblxualF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcblx0dmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgMCBdIHx8IHt9LFxuXHRcdGkgPSAxLFxuXHRcdGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0ZGVlcCA9IGZhbHNlO1xuXG5cdC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cblx0aWYgKCB0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRkZWVwID0gdGFyZ2V0O1xuXG5cdFx0Ly8gU2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgaSBdIHx8IHt9O1xuXHRcdGkrKztcblx0fVxuXG5cdC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWlzRnVuY3Rpb24oIHRhcmdldCApICkge1xuXHRcdHRhcmdldCA9IHt9O1xuXHR9XG5cblx0Ly8gRXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG5cdGlmICggaSA9PT0gbGVuZ3RoICkge1xuXHRcdHRhcmdldCA9IHRoaXM7XG5cdFx0aS0tO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cblx0XHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG5cdFx0aWYgKCAoIG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSApICE9IG51bGwgKSB7XG5cblx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0c3JjID0gdGFyZ2V0WyBuYW1lIF07XG5cdFx0XHRcdGNvcHkgPSBvcHRpb25zWyBuYW1lIF07XG5cblx0XHRcdFx0Ly8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxuXHRcdFx0XHRpZiAoIHRhcmdldCA9PT0gY29weSApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRpZiAoIGRlZXAgJiYgY29weSAmJiAoIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb3B5ICkgfHxcblx0XHRcdFx0XHQoIGNvcHlJc0FycmF5ID0gQXJyYXkuaXNBcnJheSggY29weSApICkgKSApIHtcblxuXHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgKSB7XG5cdFx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgQXJyYXkuaXNBcnJheSggc3JjICkgPyBzcmMgOiBbXTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggc3JjICkgPyBzcmMgOiB7fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGpRdWVyeS5leHRlbmQoIGRlZXAsIGNsb25lLCBjb3B5ICk7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb3B5ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBjb3B5O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3Rcblx0cmV0dXJuIHRhcmdldDtcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBVbmlxdWUgZm9yIGVhY2ggY29weSBvZiBqUXVlcnkgb24gdGhlIHBhZ2Vcblx0ZXhwYW5kbzogXCJqUXVlcnlcIiArICggdmVyc2lvbiArIE1hdGgucmFuZG9tKCkgKS5yZXBsYWNlKCAvXFxEL2csIFwiXCIgKSxcblxuXHQvLyBBc3N1bWUgalF1ZXJ5IGlzIHJlYWR5IHdpdGhvdXQgdGhlIHJlYWR5IG1vZHVsZVxuXHRpc1JlYWR5OiB0cnVlLFxuXG5cdGVycm9yOiBmdW5jdGlvbiggbXNnICkge1xuXHRcdHRocm93IG5ldyBFcnJvciggbXNnICk7XG5cdH0sXG5cblx0bm9vcDogZnVuY3Rpb24oKSB7fSxcblxuXHRpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBwcm90bywgQ3RvcjtcblxuXHRcdC8vIERldGVjdCBvYnZpb3VzIG5lZ2F0aXZlc1xuXHRcdC8vIFVzZSB0b1N0cmluZyBpbnN0ZWFkIG9mIGpRdWVyeS50eXBlIHRvIGNhdGNoIGhvc3Qgb2JqZWN0c1xuXHRcdGlmICggIW9iaiB8fCB0b1N0cmluZy5jYWxsKCBvYmogKSAhPT0gXCJbb2JqZWN0IE9iamVjdF1cIiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRwcm90byA9IGdldFByb3RvKCBvYmogKTtcblxuXHRcdC8vIE9iamVjdHMgd2l0aCBubyBwcm90b3R5cGUgKGUuZy4sIGBPYmplY3QuY3JlYXRlKCBudWxsIClgKSBhcmUgcGxhaW5cblx0XHRpZiAoICFwcm90byApIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIE9iamVjdHMgd2l0aCBwcm90b3R5cGUgYXJlIHBsYWluIGlmZiB0aGV5IHdlcmUgY29uc3RydWN0ZWQgYnkgYSBnbG9iYWwgT2JqZWN0IGZ1bmN0aW9uXG5cdFx0Q3RvciA9IGhhc093bi5jYWxsKCBwcm90bywgXCJjb25zdHJ1Y3RvclwiICkgJiYgcHJvdG8uY29uc3RydWN0b3I7XG5cdFx0cmV0dXJuIHR5cGVvZiBDdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgZm5Ub1N0cmluZy5jYWxsKCBDdG9yICkgPT09IE9iamVjdEZ1bmN0aW9uU3RyaW5nO1xuXHR9LFxuXG5cdGlzRW1wdHlPYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cblx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXNsaW50L2VzbGludC9pc3N1ZXMvNjEyNVxuXHRcdHZhciBuYW1lO1xuXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIGdsb2JhbCBjb250ZXh0XG5cdGdsb2JhbEV2YWw6IGZ1bmN0aW9uKCBjb2RlICkge1xuXHRcdERPTUV2YWwoIGNvZGUgKTtcblx0fSxcblxuXHRlYWNoOiBmdW5jdGlvbiggb2JqLCBjYWxsYmFjayApIHtcblx0XHR2YXIgbGVuZ3RoLCBpID0gMDtcblxuXHRcdGlmICggaXNBcnJheUxpa2UoIG9iaiApICkge1xuXHRcdFx0bGVuZ3RoID0gb2JqLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIG9iaiApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb2JqO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seVxuXHR0cmltOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRyZXR1cm4gdGV4dCA9PSBudWxsID9cblx0XHRcdFwiXCIgOlxuXHRcdFx0KCB0ZXh0ICsgXCJcIiApLnJlcGxhY2UoIHJ0cmltLCBcIlwiICk7XG5cdH0sXG5cblx0Ly8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYWtlQXJyYXk6IGZ1bmN0aW9uKCBhcnIsIHJlc3VsdHMgKSB7XG5cdFx0dmFyIHJldCA9IHJlc3VsdHMgfHwgW107XG5cblx0XHRpZiAoIGFyciAhPSBudWxsICkge1xuXHRcdFx0aWYgKCBpc0FycmF5TGlrZSggT2JqZWN0KCBhcnIgKSApICkge1xuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHJldCxcblx0XHRcdFx0XHR0eXBlb2YgYXJyID09PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRbIGFyciBdIDogYXJyXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmNhbGwoIHJldCwgYXJyICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHRpbkFycmF5OiBmdW5jdGlvbiggZWxlbSwgYXJyLCBpICkge1xuXHRcdHJldHVybiBhcnIgPT0gbnVsbCA/IC0xIDogaW5kZXhPZi5jYWxsKCBhcnIsIGVsZW0sIGkgKTtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRtZXJnZTogZnVuY3Rpb24oIGZpcnN0LCBzZWNvbmQgKSB7XG5cdFx0dmFyIGxlbiA9ICtzZWNvbmQubGVuZ3RoLFxuXHRcdFx0aiA9IDAsXG5cdFx0XHRpID0gZmlyc3QubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRmaXJzdFsgaSsrIF0gPSBzZWNvbmRbIGogXTtcblx0XHR9XG5cblx0XHRmaXJzdC5sZW5ndGggPSBpO1xuXG5cdFx0cmV0dXJuIGZpcnN0O1xuXHR9LFxuXG5cdGdyZXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGludmVydCApIHtcblx0XHR2YXIgY2FsbGJhY2tJbnZlcnNlLFxuXHRcdFx0bWF0Y2hlcyA9IFtdLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGgsXG5cdFx0XHRjYWxsYmFja0V4cGVjdCA9ICFpbnZlcnQ7XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgb25seSBzYXZpbmcgdGhlIGl0ZW1zXG5cdFx0Ly8gdGhhdCBwYXNzIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb25cblx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdGNhbGxiYWNrSW52ZXJzZSA9ICFjYWxsYmFjayggZWxlbXNbIGkgXSwgaSApO1xuXHRcdFx0aWYgKCBjYWxsYmFja0ludmVyc2UgIT09IGNhbGxiYWNrRXhwZWN0ICkge1xuXHRcdFx0XHRtYXRjaGVzLnB1c2goIGVsZW1zWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0Y2hlcztcblx0fSxcblxuXHQvLyBhcmcgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBhcmcgKSB7XG5cdFx0dmFyIGxlbmd0aCwgdmFsdWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdHJldCA9IFtdO1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIHRyYW5zbGF0aW5nIGVhY2ggb2YgdGhlIGl0ZW1zIHRvIHRoZWlyIG5ldyB2YWx1ZXNcblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBlbGVtcyApICkge1xuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gR28gdGhyb3VnaCBldmVyeSBrZXkgb24gdGhlIG9iamVjdCxcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBlbGVtcyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRcdHJldHVybiBjb25jYXQuYXBwbHkoIFtdLCByZXQgKTtcblx0fSxcblxuXHQvLyBBIGdsb2JhbCBHVUlEIGNvdW50ZXIgZm9yIG9iamVjdHNcblx0Z3VpZDogMSxcblxuXHQvLyBqUXVlcnkuc3VwcG9ydCBpcyBub3QgdXNlZCBpbiBDb3JlIGJ1dCBvdGhlciBwcm9qZWN0cyBhdHRhY2ggdGhlaXJcblx0Ly8gcHJvcGVydGllcyB0byBpdCBzbyBpdCBuZWVkcyB0byBleGlzdC5cblx0c3VwcG9ydDogc3VwcG9ydFxufSApO1xuXG5pZiAoIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0alF1ZXJ5LmZuWyBTeW1ib2wuaXRlcmF0b3IgXSA9IGFyclsgU3ltYm9sLml0ZXJhdG9yIF07XG59XG5cbi8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxualF1ZXJ5LmVhY2goIFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvciBTeW1ib2xcIi5zcGxpdCggXCIgXCIgKSxcbmZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRjbGFzczJ0eXBlWyBcIltvYmplY3QgXCIgKyBuYW1lICsgXCJdXCIgXSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbn0gKTtcblxuZnVuY3Rpb24gaXNBcnJheUxpa2UoIG9iaiApIHtcblxuXHQvLyBTdXBwb3J0OiByZWFsIGlPUyA4LjIgb25seSAobm90IHJlcHJvZHVjaWJsZSBpbiBzaW11bGF0b3IpXG5cdC8vIGBpbmAgY2hlY2sgdXNlZCB0byBwcmV2ZW50IEpJVCBlcnJvciAoZ2gtMjE0NSlcblx0Ly8gaGFzT3duIGlzbid0IHVzZWQgaGVyZSBkdWUgdG8gZmFsc2UgbmVnYXRpdmVzXG5cdC8vIHJlZ2FyZGluZyBOb2RlbGlzdCBsZW5ndGggaW4gSUVcblx0dmFyIGxlbmd0aCA9ICEhb2JqICYmIFwibGVuZ3RoXCIgaW4gb2JqICYmIG9iai5sZW5ndGgsXG5cdFx0dHlwZSA9IHRvVHlwZSggb2JqICk7XG5cblx0aWYgKCBpc0Z1bmN0aW9uKCBvYmogKSB8fCBpc1dpbmRvdyggb2JqICkgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHR5cGUgPT09IFwiYXJyYXlcIiB8fCBsZW5ndGggPT09IDAgfHxcblx0XHR0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiICYmIGxlbmd0aCA+IDAgJiYgKCBsZW5ndGggLSAxICkgaW4gb2JqO1xufVxudmFyIFNpenpsZSA9XG4vKiFcbiAqIFNpenpsZSBDU1MgU2VsZWN0b3IgRW5naW5lIHYyLjMuM1xuICogaHR0cHM6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTYtMDgtMDhcbiAqL1xuKGZ1bmN0aW9uKCB3aW5kb3cgKSB7XG5cbnZhciBpLFxuXHRzdXBwb3J0LFxuXHRFeHByLFxuXHRnZXRUZXh0LFxuXHRpc1hNTCxcblx0dG9rZW5pemUsXG5cdGNvbXBpbGUsXG5cdHNlbGVjdCxcblx0b3V0ZXJtb3N0Q29udGV4dCxcblx0c29ydElucHV0LFxuXHRoYXNEdXBsaWNhdGUsXG5cblx0Ly8gTG9jYWwgZG9jdW1lbnQgdmFyc1xuXHRzZXREb2N1bWVudCxcblx0ZG9jdW1lbnQsXG5cdGRvY0VsZW0sXG5cdGRvY3VtZW50SXNIVE1MLFxuXHRyYnVnZ3lRU0EsXG5cdHJidWdneU1hdGNoZXMsXG5cdG1hdGNoZXMsXG5cdGNvbnRhaW5zLFxuXG5cdC8vIEluc3RhbmNlLXNwZWNpZmljIGRhdGFcblx0ZXhwYW5kbyA9IFwic2l6emxlXCIgKyAxICogbmV3IERhdGUoKSxcblx0cHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxuXHRkaXJydW5zID0gMCxcblx0ZG9uZSA9IDAsXG5cdGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHR0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0Y29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdC8vIEluc3RhbmNlIG1ldGhvZHNcblx0aGFzT3duID0gKHt9KS5oYXNPd25Qcm9wZXJ0eSxcblx0YXJyID0gW10sXG5cdHBvcCA9IGFyci5wb3AsXG5cdHB1c2hfbmF0aXZlID0gYXJyLnB1c2gsXG5cdHB1c2ggPSBhcnIucHVzaCxcblx0c2xpY2UgPSBhcnIuc2xpY2UsXG5cdC8vIFVzZSBhIHN0cmlwcGVkLWRvd24gaW5kZXhPZiBhcyBpdCdzIGZhc3RlciB0aGFuIG5hdGl2ZVxuXHQvLyBodHRwczovL2pzcGVyZi5jb20vdGhvci1pbmRleG9mLXZzLWZvci81XG5cdGluZGV4T2YgPSBmdW5jdGlvbiggbGlzdCwgZWxlbSApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRsZW4gPSBsaXN0Lmxlbmd0aDtcblx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGlmICggbGlzdFtpXSA9PT0gZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAtMTtcblx0fSxcblxuXHRib29sZWFucyA9IFwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcIixcblxuXHQvLyBSZWd1bGFyIGV4cHJlc3Npb25zXG5cblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI3doaXRlc3BhY2Vcblx0d2hpdGVzcGFjZSA9IFwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIixcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjdmFsdWUtZGVmLWlkZW50aWZpZXJcblx0aWRlbnRpZmllciA9IFwiKD86XFxcXFxcXFwufFtcXFxcdy1dfFteXFwwLVxcXFx4YTBdKStcIixcblxuXHQvLyBBdHRyaWJ1dGUgc2VsZWN0b3JzOiBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcblx0YXR0cmlidXRlcyA9IFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XCIgKyB3aGl0ZXNwYWNlICtcblx0XHQvLyBPcGVyYXRvciAoY2FwdHVyZSAyKVxuXHRcdFwiKihbKl4kfCF+XT89KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gXCJBdHRyaWJ1dGUgdmFsdWVzIG11c3QgYmUgQ1NTIGlkZW50aWZpZXJzIFtjYXB0dXJlIDVdIG9yIHN0cmluZ3MgW2NhcHR1cmUgMyBvciBjYXB0dXJlIDRdXCJcblx0XHRcIiooPzonKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCJ8KFwiICsgaWRlbnRpZmllciArIFwiKSl8KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XCIqXFxcXF1cIixcblxuXHRwc2V1ZG9zID0gXCI6KFwiICsgaWRlbnRpZmllciArIFwiKSg/OlxcXFwoKFwiICtcblx0XHQvLyBUbyByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWxlY3RvcnMgbmVlZGluZyB0b2tlbml6ZSBpbiB0aGUgcHJlRmlsdGVyLCBwcmVmZXIgYXJndW1lbnRzOlxuXHRcdC8vIDEuIHF1b3RlZCAoY2FwdHVyZSAzOyBjYXB0dXJlIDQgb3IgY2FwdHVyZSA1KVxuXHRcdFwiKCcoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcIil8XCIgK1xuXHRcdC8vIDIuIHNpbXBsZSAoY2FwdHVyZSA2KVxuXHRcdFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKClbXFxcXF1dfFwiICsgYXR0cmlidXRlcyArIFwiKSopfFwiICtcblx0XHQvLyAzLiBhbnl0aGluZyBlbHNlIChjYXB0dXJlIDIpXG5cdFx0XCIuKlwiICtcblx0XHRcIilcXFxcKXwpXCIsXG5cblx0Ly8gTGVhZGluZyBhbmQgbm9uLWVzY2FwZWQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgY2FwdHVyaW5nIHNvbWUgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycyBwcmVjZWRpbmcgdGhlIGxhdHRlclxuXHRyd2hpdGVzcGFjZSA9IG5ldyBSZWdFeHAoIHdoaXRlc3BhY2UgKyBcIitcIiwgXCJnXCIgKSxcblx0cnRyaW0gPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgKyB3aGl0ZXNwYWNlICsgXCIrJFwiLCBcImdcIiApLFxuXG5cdHJjb21tYSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKixcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXHRyY29tYmluYXRvcnMgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiooWz4rfl18XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblxuXHRyYXR0cmlidXRlUXVvdGVzID0gbmV3IFJlZ0V4cCggXCI9XCIgKyB3aGl0ZXNwYWNlICsgXCIqKFteXFxcXF0nXFxcIl0qPylcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcXVwiLCBcImdcIiApLFxuXG5cdHJwc2V1ZG8gPSBuZXcgUmVnRXhwKCBwc2V1ZG9zICksXG5cdHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBpZGVudGlmaWVyICsgXCIkXCIgKSxcblxuXHRtYXRjaEV4cHIgPSB7XG5cdFx0XCJJRFwiOiBuZXcgUmVnRXhwKCBcIl4jKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJDTEFTU1wiOiBuZXcgUmVnRXhwKCBcIl5cXFxcLihcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiVEFHXCI6IG5ldyBSZWdFeHAoIFwiXihcIiArIGlkZW50aWZpZXIgKyBcInxbKl0pXCIgKSxcblx0XHRcIkFUVFJcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBhdHRyaWJ1dGVzICksXG5cdFx0XCJQU0VVRE9cIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBwc2V1ZG9zICksXG5cdFx0XCJDSElMRFwiOiBuZXcgUmVnRXhwKCBcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86KFsrLV18KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooXFxcXGQrKXwpKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfClcIiwgXCJpXCIgKSxcblx0XHRcImJvb2xcIjogbmV3IFJlZ0V4cCggXCJeKD86XCIgKyBib29sZWFucyArIFwiKSRcIiwgXCJpXCIgKSxcblx0XHQvLyBGb3IgdXNlIGluIGxpYnJhcmllcyBpbXBsZW1lbnRpbmcgLmlzKClcblx0XHQvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXG5cdFx0XCJuZWVkc0NvbnRleHRcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICtcblx0XHRcdHdoaXRlc3BhY2UgKyBcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIgKVxuXHR9LFxuXG5cdHJpbnB1dHMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyaGVhZGVyID0gL15oXFxkJC9pLFxuXG5cdHJuYXRpdmUgPSAvXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFxuXG5cdC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xuXHRycXVpY2tFeHByID0gL14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sXG5cblx0cnNpYmxpbmcgPSAvWyt+XS8sXG5cblx0Ly8gQ1NTIGVzY2FwZXNcblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xuXHRydW5lc2NhcGUgPSBuZXcgUmVnRXhwKCBcIlxcXFxcXFxcKFtcXFxcZGEtZl17MSw2fVwiICsgd2hpdGVzcGFjZSArIFwiP3woXCIgKyB3aGl0ZXNwYWNlICsgXCIpfC4pXCIsIFwiaWdcIiApLFxuXHRmdW5lc2NhcGUgPSBmdW5jdGlvbiggXywgZXNjYXBlZCwgZXNjYXBlZFdoaXRlc3BhY2UgKSB7XG5cdFx0dmFyIGhpZ2ggPSBcIjB4XCIgKyBlc2NhcGVkIC0gMHgxMDAwMDtcblx0XHQvLyBOYU4gbWVhbnMgbm9uLWNvZGVwb2ludFxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjRcblx0XHQvLyBXb3JrYXJvdW5kIGVycm9uZW91cyBudW1lcmljIGludGVycHJldGF0aW9uIG9mICtcIjB4XCJcblx0XHRyZXR1cm4gaGlnaCAhPT0gaGlnaCB8fCBlc2NhcGVkV2hpdGVzcGFjZSA/XG5cdFx0XHRlc2NhcGVkIDpcblx0XHRcdGhpZ2ggPCAwID9cblx0XHRcdFx0Ly8gQk1QIGNvZGVwb2ludFxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoICsgMHgxMDAwMCApIDpcblx0XHRcdFx0Ly8gU3VwcGxlbWVudGFsIFBsYW5lIGNvZGVwb2ludCAoc3Vycm9nYXRlIHBhaXIpXG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCApO1xuXHR9LFxuXG5cdC8vIENTUyBzdHJpbmcvaWRlbnRpZmllciBzZXJpYWxpemF0aW9uXG5cdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jY29tbW9uLXNlcmlhbGl6aW5nLWlkaW9tc1xuXHRyY3NzZXNjYXBlID0gLyhbXFwwLVxceDFmXFx4N2ZdfF4tP1xcZCl8Xi0kfFteXFwwLVxceDFmXFx4N2YtXFx1RkZGRlxcdy1dL2csXG5cdGZjc3Nlc2NhcGUgPSBmdW5jdGlvbiggY2gsIGFzQ29kZVBvaW50ICkge1xuXHRcdGlmICggYXNDb2RlUG9pbnQgKSB7XG5cblx0XHRcdC8vIFUrMDAwMCBOVUxMIGJlY29tZXMgVStGRkZEIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxuXHRcdFx0aWYgKCBjaCA9PT0gXCJcXDBcIiApIHtcblx0XHRcdFx0cmV0dXJuIFwiXFx1RkZGRFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb250cm9sIGNoYXJhY3RlcnMgYW5kIChkZXBlbmRlbnQgdXBvbiBwb3NpdGlvbikgbnVtYmVycyBnZXQgZXNjYXBlZCBhcyBjb2RlIHBvaW50c1xuXHRcdFx0cmV0dXJuIGNoLnNsaWNlKCAwLCAtMSApICsgXCJcXFxcXCIgKyBjaC5jaGFyQ29kZUF0KCBjaC5sZW5ndGggLSAxICkudG9TdHJpbmcoIDE2ICkgKyBcIiBcIjtcblx0XHR9XG5cblx0XHQvLyBPdGhlciBwb3RlbnRpYWxseS1zcGVjaWFsIEFTQ0lJIGNoYXJhY3RlcnMgZ2V0IGJhY2tzbGFzaC1lc2NhcGVkXG5cdFx0cmV0dXJuIFwiXFxcXFwiICsgY2g7XG5cdH0sXG5cblx0Ly8gVXNlZCBmb3IgaWZyYW1lc1xuXHQvLyBTZWUgc2V0RG9jdW1lbnQoKVxuXHQvLyBSZW1vdmluZyB0aGUgZnVuY3Rpb24gd3JhcHBlciBjYXVzZXMgYSBcIlBlcm1pc3Npb24gRGVuaWVkXCJcblx0Ly8gZXJyb3IgaW4gSUVcblx0dW5sb2FkSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXHRcdHNldERvY3VtZW50KCk7XG5cdH0sXG5cblx0ZGlzYWJsZWRBbmNlc3RvciA9IGFkZENvbWJpbmF0b3IoXG5cdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gdHJ1ZSAmJiAoXCJmb3JtXCIgaW4gZWxlbSB8fCBcImxhYmVsXCIgaW4gZWxlbSk7XG5cdFx0fSxcblx0XHR7IGRpcjogXCJwYXJlbnROb2RlXCIsIG5leHQ6IFwibGVnZW5kXCIgfVxuXHQpO1xuXG4vLyBPcHRpbWl6ZSBmb3IgcHVzaC5hcHBseSggXywgTm9kZUxpc3QgKVxudHJ5IHtcblx0cHVzaC5hcHBseShcblx0XHQoYXJyID0gc2xpY2UuY2FsbCggcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMgKSksXG5cdFx0cHJlZmVycmVkRG9jLmNoaWxkTm9kZXNcblx0KTtcblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjBcblx0Ly8gRGV0ZWN0IHNpbGVudGx5IGZhaWxpbmcgcHVzaC5hcHBseVxuXHRhcnJbIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzLmxlbmd0aCBdLm5vZGVUeXBlO1xufSBjYXRjaCAoIGUgKSB7XG5cdHB1c2ggPSB7IGFwcGx5OiBhcnIubGVuZ3RoID9cblxuXHRcdC8vIExldmVyYWdlIHNsaWNlIGlmIHBvc3NpYmxlXG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0cHVzaF9uYXRpdmUuYXBwbHkoIHRhcmdldCwgc2xpY2UuY2FsbChlbHMpICk7XG5cdFx0fSA6XG5cblx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZCBkaXJlY3RseVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHZhciBqID0gdGFyZ2V0Lmxlbmd0aCxcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHQvLyBDYW4ndCB0cnVzdCBOb2RlTGlzdC5sZW5ndGhcblx0XHRcdHdoaWxlICggKHRhcmdldFtqKytdID0gZWxzW2krK10pICkge31cblx0XHRcdHRhcmdldC5sZW5ndGggPSBqIC0gMTtcblx0XHR9XG5cdH07XG59XG5cbmZ1bmN0aW9uIFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBtLCBpLCBlbGVtLCBuaWQsIG1hdGNoLCBncm91cHMsIG5ld1NlbGVjdG9yLFxuXHRcdG5ld0NvbnRleHQgPSBjb250ZXh0ICYmIGNvbnRleHQub3duZXJEb2N1bWVudCxcblxuXHRcdC8vIG5vZGVUeXBlIGRlZmF1bHRzIHRvIDksIHNpbmNlIGNvbnRleHQgZGVmYXVsdHMgdG8gZG9jdW1lbnRcblx0XHRub2RlVHlwZSA9IGNvbnRleHQgPyBjb250ZXh0Lm5vZGVUeXBlIDogOTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBSZXR1cm4gZWFybHkgZnJvbSBjYWxscyB3aXRoIGludmFsaWQgc2VsZWN0b3Igb3IgY29udGV4dFxuXHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiB8fCAhc2VsZWN0b3IgfHxcblx0XHRub2RlVHlwZSAhPT0gMSAmJiBub2RlVHlwZSAhPT0gOSAmJiBub2RlVHlwZSAhPT0gMTEgKSB7XG5cblx0XHRyZXR1cm4gcmVzdWx0cztcblx0fVxuXG5cdC8vIFRyeSB0byBzaG9ydGN1dCBmaW5kIG9wZXJhdGlvbnMgKGFzIG9wcG9zZWQgdG8gZmlsdGVycykgaW4gSFRNTCBkb2N1bWVudHNcblx0aWYgKCAhc2VlZCApIHtcblxuXHRcdGlmICggKCBjb250ZXh0ID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBwcmVmZXJyZWREb2MgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHRcdH1cblx0XHRjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuXHRcdGlmICggZG9jdW1lbnRJc0hUTUwgKSB7XG5cblx0XHRcdC8vIElmIHRoZSBzZWxlY3RvciBpcyBzdWZmaWNpZW50bHkgc2ltcGxlLCB0cnkgdXNpbmcgYSBcImdldCpCeSpcIiBET00gbWV0aG9kXG5cdFx0XHQvLyAoZXhjZXB0aW5nIERvY3VtZW50RnJhZ21lbnQgY29udGV4dCwgd2hlcmUgdGhlIG1ldGhvZHMgZG9uJ3QgZXhpc3QpXG5cdFx0XHRpZiAoIG5vZGVUeXBlICE9PSAxMSAmJiAobWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICkpICkge1xuXG5cdFx0XHRcdC8vIElEIHNlbGVjdG9yXG5cdFx0XHRcdGlmICggKG0gPSBtYXRjaFsxXSkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb2N1bWVudCBjb250ZXh0XG5cdFx0XHRcdFx0aWYgKCBub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdFx0aWYgKCBlbGVtLmlkID09PSBtICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEVsZW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0aWYgKCBuZXdDb250ZXh0ICYmIChlbGVtID0gbmV3Q29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApKSAmJlxuXHRcdFx0XHRcdFx0XHRjb250YWlucyggY29udGV4dCwgZWxlbSApICYmXG5cdFx0XHRcdFx0XHRcdGVsZW0uaWQgPT09IG0gKSB7XG5cblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUeXBlIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzJdICkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHNlbGVjdG9yICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0XHQvLyBDbGFzcyBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCAobSA9IG1hdGNoWzNdKSAmJiBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiZcblx0XHRcdFx0XHRjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIG0gKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRha2UgYWR2YW50YWdlIG9mIHF1ZXJ5U2VsZWN0b3JBbGxcblx0XHRcdGlmICggc3VwcG9ydC5xc2EgJiZcblx0XHRcdFx0IWNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXSAmJlxuXHRcdFx0XHQoIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoIHNlbGVjdG9yICkpICkge1xuXG5cdFx0XHRcdGlmICggbm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdFx0bmV3Q29udGV4dCA9IGNvbnRleHQ7XG5cdFx0XHRcdFx0bmV3U2VsZWN0b3IgPSBzZWxlY3RvcjtcblxuXHRcdFx0XHQvLyBxU0EgbG9va3Mgb3V0c2lkZSBFbGVtZW50IGNvbnRleHQsIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnRcblx0XHRcdFx0Ly8gVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoaXMgd29ya2Fyb3VuZCB0ZWNobmlxdWVcblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgb2JqZWN0IGVsZW1lbnRzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnRleHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHRcdC8vIENhcHR1cmUgdGhlIGNvbnRleHQgSUQsIHNldHRpbmcgaXQgZmlyc3QgaWYgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0aWYgKCAobmlkID0gY29udGV4dC5nZXRBdHRyaWJ1dGUoIFwiaWRcIiApKSApIHtcblx0XHRcdFx0XHRcdG5pZCA9IG5pZC5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnRleHQuc2V0QXR0cmlidXRlKCBcImlkXCIsIChuaWQgPSBleHBhbmRvKSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZWZpeCBldmVyeSBzZWxlY3RvciBpbiB0aGUgbGlzdFxuXHRcdFx0XHRcdGdyb3VwcyA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdFx0XHRcdGkgPSBncm91cHMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0Z3JvdXBzW2ldID0gXCIjXCIgKyBuaWQgKyBcIiBcIiArIHRvU2VsZWN0b3IoIGdyb3Vwc1tpXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKCBcIixcIiApO1xuXG5cdFx0XHRcdFx0Ly8gRXhwYW5kIGNvbnRleHQgZm9yIHNpYmxpbmcgc2VsZWN0b3JzXG5cdFx0XHRcdFx0bmV3Q29udGV4dCA9IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8XG5cdFx0XHRcdFx0XHRjb250ZXh0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBuZXdTZWxlY3RvciApIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cyxcblx0XHRcdFx0XHRcdFx0bmV3Q29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCBuZXdTZWxlY3RvciApXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fSBjYXRjaCAoIHFzYUVycm9yICkge1xuXHRcdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0XHRpZiAoIG5pZCA9PT0gZXhwYW5kbyApIHtcblx0XHRcdFx0XHRcdFx0Y29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoIFwiaWRcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFsbCBvdGhlcnNcblx0cmV0dXJuIHNlbGVjdCggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGtleS12YWx1ZSBjYWNoZXMgb2YgbGltaXRlZCBzaXplXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oc3RyaW5nLCBvYmplY3QpfSBSZXR1cm5zIHRoZSBPYmplY3QgZGF0YSBhZnRlciBzdG9yaW5nIGl0IG9uIGl0c2VsZiB3aXRoXG4gKlx0cHJvcGVydHkgbmFtZSB0aGUgKHNwYWNlLXN1ZmZpeGVkKSBzdHJpbmcgYW5kIChpZiB0aGUgY2FjaGUgaXMgbGFyZ2VyIHRoYW4gRXhwci5jYWNoZUxlbmd0aClcbiAqXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuXHR2YXIga2V5cyA9IFtdO1xuXG5cdGZ1bmN0aW9uIGNhY2hlKCBrZXksIHZhbHVlICkge1xuXHRcdC8vIFVzZSAoa2V5ICsgXCIgXCIpIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIG5hdGl2ZSBwcm90b3R5cGUgcHJvcGVydGllcyAoc2VlIElzc3VlICMxNTcpXG5cdFx0aWYgKCBrZXlzLnB1c2goIGtleSArIFwiIFwiICkgPiBFeHByLmNhY2hlTGVuZ3RoICkge1xuXHRcdFx0Ly8gT25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBlbnRyaWVzXG5cdFx0XHRkZWxldGUgY2FjaGVbIGtleXMuc2hpZnQoKSBdO1xuXHRcdH1cblx0XHRyZXR1cm4gKGNhY2hlWyBrZXkgKyBcIiBcIiBdID0gdmFsdWUpO1xuXHR9XG5cdHJldHVybiBjYWNoZTtcbn1cblxuLyoqXG4gKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IFNpenpsZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcmtcbiAqL1xuZnVuY3Rpb24gbWFya0Z1bmN0aW9uKCBmbiApIHtcblx0Zm5bIGV4cGFuZG8gXSA9IHRydWU7XG5cdHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHRlc3RpbmcgdXNpbmcgYW4gZWxlbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gUGFzc2VkIHRoZSBjcmVhdGVkIGVsZW1lbnQgYW5kIHJldHVybnMgYSBib29sZWFuIHJlc3VsdFxuICovXG5mdW5jdGlvbiBhc3NlcnQoIGZuICkge1xuXHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIik7XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gISFmbiggZWwgKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBmaW5hbGx5IHtcblx0XHQvLyBSZW1vdmUgZnJvbSBpdHMgcGFyZW50IGJ5IGRlZmF1bHRcblx0XHRpZiAoIGVsLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBlbCApO1xuXHRcdH1cblx0XHQvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuXHRcdGVsID0gbnVsbDtcblx0fVxufVxuXG4vKipcbiAqIEFkZHMgdGhlIHNhbWUgaGFuZGxlciBmb3IgYWxsIG9mIHRoZSBzcGVjaWZpZWQgYXR0cnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRycyBQaXBlLXNlcGFyYXRlZCBsaXN0IG9mIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgYXBwbGllZFxuICovXG5mdW5jdGlvbiBhZGRIYW5kbGUoIGF0dHJzLCBoYW5kbGVyICkge1xuXHR2YXIgYXJyID0gYXR0cnMuc3BsaXQoXCJ8XCIpLFxuXHRcdGkgPSBhcnIubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdEV4cHIuYXR0ckhhbmRsZVsgYXJyW2ldIF0gPSBoYW5kbGVyO1xuXHR9XG59XG5cbi8qKlxuICogQ2hlY2tzIGRvY3VtZW50IG9yZGVyIG9mIHR3byBzaWJsaW5nc1xuICogQHBhcmFtIHtFbGVtZW50fSBhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgbGVzcyB0aGFuIDAgaWYgYSBwcmVjZWRlcyBiLCBncmVhdGVyIHRoYW4gMCBpZiBhIGZvbGxvd3MgYlxuICovXG5mdW5jdGlvbiBzaWJsaW5nQ2hlY2soIGEsIGIgKSB7XG5cdHZhciBjdXIgPSBiICYmIGEsXG5cdFx0ZGlmZiA9IGN1ciAmJiBhLm5vZGVUeXBlID09PSAxICYmIGIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdGEuc291cmNlSW5kZXggLSBiLnNvdXJjZUluZGV4O1xuXG5cdC8vIFVzZSBJRSBzb3VyY2VJbmRleCBpZiBhdmFpbGFibGUgb24gYm90aCBub2Rlc1xuXHRpZiAoIGRpZmYgKSB7XG5cdFx0cmV0dXJuIGRpZmY7XG5cdH1cblxuXHQvLyBDaGVjayBpZiBiIGZvbGxvd3MgYVxuXHRpZiAoIGN1ciApIHtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIubmV4dFNpYmxpbmcpICkge1xuXHRcdFx0aWYgKCBjdXIgPT09IGIgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gYSA/IDEgOiAtMTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGlucHV0IHR5cGVzXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnB1dFBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgYnV0dG9uc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnV0dG9uUHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIChuYW1lID09PSBcImlucHV0XCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIikgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgOmVuYWJsZWQvOmRpc2FibGVkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2FibGVkIHRydWUgZm9yIDpkaXNhYmxlZDsgZmFsc2UgZm9yIDplbmFibGVkXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURpc2FibGVkUHNldWRvKCBkaXNhYmxlZCApIHtcblxuXHQvLyBLbm93biA6ZGlzYWJsZWQgZmFsc2UgcG9zaXRpdmVzOiBmaWVsZHNldFtkaXNhYmxlZF0gPiBsZWdlbmQ6bnRoLW9mLXR5cGUobisyKSA6Y2FuLWRpc2FibGVcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gT25seSBjZXJ0YWluIGVsZW1lbnRzIGNhbiBtYXRjaCA6ZW5hYmxlZCBvciA6ZGlzYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1lbmFibGVkXG5cdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZGlzYWJsZWRcblx0XHRpZiAoIFwiZm9ybVwiIGluIGVsZW0gKSB7XG5cblx0XHRcdC8vIENoZWNrIGZvciBpbmhlcml0ZWQgZGlzYWJsZWRuZXNzIG9uIHJlbGV2YW50IG5vbi1kaXNhYmxlZCBlbGVtZW50czpcblx0XHRcdC8vICogbGlzdGVkIGZvcm0tYXNzb2NpYXRlZCBlbGVtZW50cyBpbiBhIGRpc2FibGVkIGZpZWxkc2V0XG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY2F0ZWdvcnktbGlzdGVkXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1mZS1kaXNhYmxlZFxuXHRcdFx0Ly8gKiBvcHRpb24gZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtb3B0aW9uLWRpc2FibGVkXG5cdFx0XHQvLyBBbGwgc3VjaCBlbGVtZW50cyBoYXZlIGEgXCJmb3JtXCIgcHJvcGVydHkuXG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSAmJiBlbGVtLmRpc2FibGVkID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHQvLyBPcHRpb24gZWxlbWVudHMgZGVmZXIgdG8gYSBwYXJlbnQgb3B0Z3JvdXAgaWYgcHJlc2VudFxuXHRcdFx0XHRpZiAoIFwibGFiZWxcIiBpbiBlbGVtICkge1xuXHRcdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLnBhcmVudE5vZGUuZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDExXG5cdFx0XHRcdC8vIFVzZSB0aGUgaXNEaXNhYmxlZCBzaG9ydGN1dCBwcm9wZXJ0eSB0byBjaGVjayBmb3IgZGlzYWJsZWQgZmllbGRzZXQgYW5jZXN0b3JzXG5cdFx0XHRcdHJldHVybiBlbGVtLmlzRGlzYWJsZWQgPT09IGRpc2FibGVkIHx8XG5cblx0XHRcdFx0XHQvLyBXaGVyZSB0aGVyZSBpcyBubyBpc0Rpc2FibGVkLCBjaGVjayBtYW51YWxseVxuXHRcdFx0XHRcdC8qIGpzaGludCAtVzAxOCAqL1xuXHRcdFx0XHRcdGVsZW0uaXNEaXNhYmxlZCAhPT0gIWRpc2FibGVkICYmXG5cdFx0XHRcdFx0XHRkaXNhYmxlZEFuY2VzdG9yKCBlbGVtICkgPT09IGRpc2FibGVkO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cblx0XHQvLyBUcnkgdG8gd2lubm93IG91dCBlbGVtZW50cyB0aGF0IGNhbid0IGJlIGRpc2FibGVkIGJlZm9yZSB0cnVzdGluZyB0aGUgZGlzYWJsZWQgcHJvcGVydHkuXG5cdFx0Ly8gU29tZSB2aWN0aW1zIGdldCBjYXVnaHQgaW4gb3VyIG5ldCAobGFiZWwsIGxlZ2VuZCwgbWVudSwgdHJhY2spLCBidXQgaXQgc2hvdWxkbid0XG5cdFx0Ly8gZXZlbiBleGlzdCBvbiB0aGVtLCBsZXQgYWxvbmUgaGF2ZSBhIGJvb2xlYW4gdmFsdWUuXG5cdFx0fSBlbHNlIGlmICggXCJsYWJlbFwiIGluIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gUmVtYWluaW5nIGVsZW1lbnRzIGFyZSBuZWl0aGVyIDplbmFibGVkIG5vciA6ZGlzYWJsZWRcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBwb3NpdGlvbmFsc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZm4gKSB7XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIGFyZ3VtZW50ICkge1xuXHRcdGFyZ3VtZW50ID0gK2FyZ3VtZW50O1xuXHRcdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHR2YXIgaixcblx0XHRcdFx0bWF0Y2hJbmRleGVzID0gZm4oIFtdLCBzZWVkLmxlbmd0aCwgYXJndW1lbnQgKSxcblx0XHRcdFx0aSA9IG1hdGNoSW5kZXhlcy5sZW5ndGg7XG5cblx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIGZvdW5kIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhlc1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggc2VlZFsgKGogPSBtYXRjaEluZGV4ZXNbaV0pIF0gKSB7XG5cdFx0XHRcdFx0c2VlZFtqXSA9ICEobWF0Y2hlc1tqXSA9IHNlZWRbal0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIENoZWNrcyBhIG5vZGUgZm9yIHZhbGlkaXR5IGFzIGEgU2l6emxlIGNvbnRleHRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3Q9fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7RWxlbWVudHxPYmplY3R8Qm9vbGVhbn0gVGhlIGlucHV0IG5vZGUgaWYgYWNjZXB0YWJsZSwgb3RoZXJ3aXNlIGEgZmFsc3kgdmFsdWVcbiAqL1xuZnVuY3Rpb24gdGVzdENvbnRleHQoIGNvbnRleHQgKSB7XG5cdHJldHVybiBjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnRleHQ7XG59XG5cbi8vIEV4cG9zZSBzdXBwb3J0IHZhcnMgZm9yIGNvbnZlbmllbmNlXG5zdXBwb3J0ID0gU2l6emxlLnN1cHBvcnQgPSB7fTtcblxuLyoqXG4gKiBEZXRlY3RzIFhNTCBub2Rlc1xuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbSBBbiBlbGVtZW50IG9yIGEgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmZiBlbGVtIGlzIGEgbm9uLUhUTUwgWE1MIG5vZGVcbiAqL1xuaXNYTUwgPSBTaXp6bGUuaXNYTUwgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0Ly8gZG9jdW1lbnRFbGVtZW50IGlzIHZlcmlmaWVkIGZvciBjYXNlcyB3aGVyZSBpdCBkb2Vzbid0IHlldCBleGlzdFxuXHQvLyAoc3VjaCBhcyBsb2FkaW5nIGlmcmFtZXMgaW4gSUUgLSAjNDgzMylcblx0dmFyIGRvY3VtZW50RWxlbWVudCA9IGVsZW0gJiYgKGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtKS5kb2N1bWVudEVsZW1lbnQ7XG5cdHJldHVybiBkb2N1bWVudEVsZW1lbnQgPyBkb2N1bWVudEVsZW1lbnQubm9kZU5hbWUgIT09IFwiSFRNTFwiIDogZmFsc2U7XG59O1xuXG4vKipcbiAqIFNldHMgZG9jdW1lbnQtcmVsYXRlZCB2YXJpYWJsZXMgb25jZSBiYXNlZCBvbiB0aGUgY3VycmVudCBkb2N1bWVudFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gW2RvY10gQW4gZWxlbWVudCBvciBkb2N1bWVudCBvYmplY3QgdG8gdXNlIHRvIHNldCB0aGUgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqL1xuc2V0RG9jdW1lbnQgPSBTaXp6bGUuc2V0RG9jdW1lbnQgPSBmdW5jdGlvbiggbm9kZSApIHtcblx0dmFyIGhhc0NvbXBhcmUsIHN1YldpbmRvdyxcblx0XHRkb2MgPSBub2RlID8gbm9kZS5vd25lckRvY3VtZW50IHx8IG5vZGUgOiBwcmVmZXJyZWREb2M7XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGlmIGRvYyBpcyBpbnZhbGlkIG9yIGFscmVhZHkgc2VsZWN0ZWRcblx0aWYgKCBkb2MgPT09IGRvY3VtZW50IHx8IGRvYy5ub2RlVHlwZSAhPT0gOSB8fCAhZG9jLmRvY3VtZW50RWxlbWVudCApIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQ7XG5cdH1cblxuXHQvLyBVcGRhdGUgZ2xvYmFsIHZhcmlhYmxlc1xuXHRkb2N1bWVudCA9IGRvYztcblx0ZG9jRWxlbSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblx0ZG9jdW1lbnRJc0hUTUwgPSAhaXNYTUwoIGRvY3VtZW50ICk7XG5cblx0Ly8gU3VwcG9ydDogSUUgOS0xMSwgRWRnZVxuXHQvLyBBY2Nlc3NpbmcgaWZyYW1lIGRvY3VtZW50cyBhZnRlciB1bmxvYWQgdGhyb3dzIFwicGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvcnMgKGpRdWVyeSAjMTM5MzYpXG5cdGlmICggcHJlZmVycmVkRG9jICE9PSBkb2N1bWVudCAmJlxuXHRcdChzdWJXaW5kb3cgPSBkb2N1bWVudC5kZWZhdWx0VmlldykgJiYgc3ViV2luZG93LnRvcCAhPT0gc3ViV2luZG93ICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgMTEsIEVkZ2Vcblx0XHRpZiAoIHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0c3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwidW5sb2FkXCIsIHVubG9hZEhhbmRsZXIsIGZhbHNlICk7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTAgb25seVxuXHRcdH0gZWxzZSBpZiAoIHN1YldpbmRvdy5hdHRhY2hFdmVudCApIHtcblx0XHRcdHN1YldpbmRvdy5hdHRhY2hFdmVudCggXCJvbnVubG9hZFwiLCB1bmxvYWRIYW5kbGVyICk7XG5cdFx0fVxuXHR9XG5cblx0LyogQXR0cmlidXRlc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gU3VwcG9ydDogSUU8OFxuXHQvLyBWZXJpZnkgdGhhdCBnZXRBdHRyaWJ1dGUgcmVhbGx5IHJldHVybnMgYXR0cmlidXRlcyBhbmQgbm90IHByb3BlcnRpZXNcblx0Ly8gKGV4Y2VwdGluZyBJRTggYm9vbGVhbnMpXG5cdHN1cHBvcnQuYXR0cmlidXRlcyA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZWwuY2xhc3NOYW1lID0gXCJpXCI7XG5cdFx0cmV0dXJuICFlbC5nZXRBdHRyaWJ1dGUoXCJjbGFzc05hbWVcIik7XG5cdH0pO1xuXG5cdC8qIGdldEVsZW1lbnQocylCeSpcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSByZXR1cm5zIG9ubHkgZWxlbWVudHNcblx0c3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZWwuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoXCJcIikgKTtcblx0XHRyZXR1cm4gIWVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKS5sZW5ndGg7XG5cdH0pO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDlcblx0c3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICk7XG5cblx0Ly8gU3VwcG9ydDogSUU8MTBcblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudEJ5SWQgcmV0dXJucyBlbGVtZW50cyBieSBuYW1lXG5cdC8vIFRoZSBicm9rZW4gZ2V0RWxlbWVudEJ5SWQgbWV0aG9kcyBkb24ndCBwaWNrIHVwIHByb2dyYW1tYXRpY2FsbHktc2V0IG5hbWVzLFxuXHQvLyBzbyB1c2UgYSByb3VuZGFib3V0IGdldEVsZW1lbnRzQnlOYW1lIHRlc3Rcblx0c3VwcG9ydC5nZXRCeUlkID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmlkID0gZXhwYW5kbztcblx0XHRyZXR1cm4gIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lIHx8ICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSggZXhwYW5kbyApLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gSUQgZmlsdGVyIGFuZCBmaW5kXG5cdGlmICggc3VwcG9ydC5nZXRCeUlkICkge1xuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwiaWRcIikgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRFeHByLmZpbmRbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblx0XHRcdFx0cmV0dXJuIGVsZW0gPyBbIGVsZW0gXSA6IFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9ICBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBcInVuZGVmaW5lZFwiICYmXG5cdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdHJldHVybiBub2RlICYmIG5vZGUudmFsdWUgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDYgLSA3IG9ubHlcblx0XHQvLyBnZXRFbGVtZW50QnlJZCBpcyBub3QgcmVsaWFibGUgYXMgYSBmaW5kIHNob3J0Y3V0XG5cdFx0RXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgbm9kZSwgaSwgZWxlbXMsXG5cdFx0XHRcdFx0ZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtICkge1xuXG5cdFx0XHRcdFx0Ly8gVmVyaWZ5IHRoZSBpZCBhdHRyaWJ1dGVcblx0XHRcdFx0XHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdFx0aWYgKCBub2RlICYmIG5vZGUudmFsdWUgPT09IGlkICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIFsgZWxlbSBdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEZhbGwgYmFjayBvbiBnZXRFbGVtZW50c0J5TmFtZVxuXHRcdFx0XHRcdGVsZW1zID0gY29udGV4dC5nZXRFbGVtZW50c0J5TmFtZSggaWQgKTtcblx0XHRcdFx0XHRpID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbXNbaSsrXSkgKSB7XG5cdFx0XHRcdFx0XHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdFx0XHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBbIGVsZW0gXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cdC8vIFRhZ1xuXHRFeHByLmZpbmRbXCJUQUdcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID9cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBEb2N1bWVudEZyYWdtZW50IG5vZGVzIGRvbid0IGhhdmUgZ0VCVE5cblx0XHRcdH0gZWxzZSBpZiAoIHN1cHBvcnQucXNhICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgKTtcblx0XHRcdH1cblx0XHR9IDpcblxuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0dG1wID0gW10sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHQvLyBCeSBoYXBweSBjb2luY2lkZW5jZSwgYSAoYnJva2VuKSBnRUJUTiBhcHBlYXJzIG9uIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgdG9vXG5cdFx0XHRcdHJlc3VsdHMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRmlsdGVyIG91dCBwb3NzaWJsZSBjb21tZW50c1xuXHRcdFx0aWYgKCB0YWcgPT09IFwiKlwiICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHR0bXAucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0bXA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHR9O1xuXG5cdC8vIENsYXNzXG5cdEV4cHIuZmluZFtcIkNMQVNTXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGZ1bmN0aW9uKCBjbGFzc05hbWUsIGNvbnRleHQgKSB7XG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggY2xhc3NOYW1lICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIFFTQS9tYXRjaGVzU2VsZWN0b3Jcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFFTQSBhbmQgbWF0Y2hlc1NlbGVjdG9yIHN1cHBvcnRcblxuXHQvLyBtYXRjaGVzU2VsZWN0b3IoOmFjdGl2ZSkgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKElFOS9PcGVyYSAxMS41KVxuXHRyYnVnZ3lNYXRjaGVzID0gW107XG5cblx0Ly8gcVNhKDpmb2N1cykgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKENocm9tZSAyMSlcblx0Ly8gV2UgYWxsb3cgdGhpcyBiZWNhdXNlIG9mIGEgYnVnIGluIElFOC85IHRoYXQgdGhyb3dzIGFuIGVycm9yXG5cdC8vIHdoZW5ldmVyIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBpcyBhY2Nlc3NlZCBvbiBhbiBpZnJhbWVcblx0Ly8gU28sIHdlIGFsbG93IDpmb2N1cyB0byBwYXNzIHRocm91Z2ggUVNBIGFsbCB0aGUgdGltZSB0byBhdm9pZCB0aGUgSUUgZXJyb3Jcblx0Ly8gU2VlIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM3OFxuXHRyYnVnZ3lRU0EgPSBbXTtcblxuXHRpZiAoIChzdXBwb3J0LnFzYSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCApKSApIHtcblx0XHQvLyBCdWlsZCBRU0EgcmVnZXhcblx0XHQvLyBSZWdleCBzdHJhdGVneSBhZG9wdGVkIGZyb20gRGllZ28gUGVyaW5pXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdC8vIFNlbGVjdCBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIG9uIHB1cnBvc2Vcblx0XHRcdC8vIFRoaXMgaXMgdG8gdGVzdCBJRSdzIHRyZWF0bWVudCBvZiBub3QgZXhwbGljaXRseVxuXHRcdFx0Ly8gc2V0dGluZyBhIGJvb2xlYW4gY29udGVudCBhdHRyaWJ1dGUsXG5cdFx0XHQvLyBzaW5jZSBpdHMgcHJlc2VuY2Ugc2hvdWxkIGJlIGVub3VnaFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMzU5XG5cdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmlubmVySFRNTCA9IFwiPGEgaWQ9J1wiICsgZXhwYW5kbyArIFwiJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgaWQ9J1wiICsgZXhwYW5kbyArIFwiLVxcclxcXFwnIG1zYWxsb3djYXB0dXJlPScnPlwiICtcblx0XHRcdFx0XCI8b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTgsIE9wZXJhIDExLTEyLjE2XG5cdFx0XHQvLyBOb3RoaW5nIHNob3VsZCBiZSBzZWxlY3RlZCB3aGVuIGVtcHR5IHN0cmluZ3MgZm9sbG93IF49IG9yICQ9IG9yICo9XG5cdFx0XHQvLyBUaGUgdGVzdCBhdHRyaWJ1dGUgbXVzdCBiZSB1bmtub3duIGluIE9wZXJhIGJ1dCBcInNhZmVcIiBmb3IgV2luUlRcblx0XHRcdC8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvaGg0NjUzODguYXNweCNhdHRyaWJ1dGVfc2VjdGlvblxuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW21zYWxsb3djYXB0dXJlXj0nJ11cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJbKl4kXT1cIiArIHdoaXRlc3BhY2UgKyBcIiooPzonJ3xcXFwiXFxcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBhbmQgXCJ2YWx1ZVwiIGFyZSBub3QgdHJlYXRlZCBjb3JyZWN0bHlcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbc2VsZWN0ZWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooPzp2YWx1ZXxcIiArIGJvb2xlYW5zICsgXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lPDI5LCBBbmRyb2lkPDQuNCwgU2FmYXJpPDcuMCssIGlPUzw3LjArLCBQaGFudG9tSlM8MS45LjgrXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIltpZH49XCIgKyBleHBhbmRvICsgXCItXVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIn49XCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBXZWJraXQvT3BlcmEgLSA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIHNlbGVjdGVkIG9wdGlvbiBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmNoZWNrZWRcIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIjpjaGVja2VkXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCssIGlPUyA4K1xuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNjg1MVxuXHRcdFx0Ly8gSW4tcGFnZSBgc2VsZWN0b3IjaWQgc2libGluZy1jb21iaW5hdG9yIHNlbGVjdG9yYCBmYWlsc1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJhI1wiICsgZXhwYW5kbyArIFwiKypcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIuIy4rWyt+XVwiKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JycgZGlzYWJsZWQ9J2Rpc2FibGVkJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgZGlzYWJsZWQ9J2Rpc2FibGVkJz48b3B0aW9uLz48L3NlbGVjdD5cIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogV2luZG93cyA4IE5hdGl2ZSBBcHBzXG5cdFx0XHQvLyBUaGUgdHlwZSBhbmQgbmFtZSBhdHRyaWJ1dGVzIGFyZSByZXN0cmljdGVkIGR1cmluZyAuaW5uZXJIVE1MIGFzc2lnbm1lbnRcblx0XHRcdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcblx0XHRcdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwiaGlkZGVuXCIgKTtcblx0XHRcdGVsLmFwcGVuZENoaWxkKCBpbnB1dCApLnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwiRFwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gRW5mb3JjZSBjYXNlLXNlbnNpdGl2aXR5IG9mIG5hbWUgYXR0cmlidXRlXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbmFtZT1kXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIm5hbWVcIiArIHdoaXRlc3BhY2UgKyBcIipbKl4kfCF+XT89XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRkYgMy41IC0gOmVuYWJsZWQvOmRpc2FibGVkIGFuZCBoaWRkZW4gZWxlbWVudHMgKGhpZGRlbiBlbGVtZW50cyBhcmUgc3RpbGwgZW5hYmxlZClcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZW5hYmxlZFwiKS5sZW5ndGggIT09IDIgKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU5LTExK1xuXHRcdFx0Ly8gSUUncyA6ZGlzYWJsZWQgc2VsZWN0b3IgZG9lcyBub3QgcGljayB1cCB0aGUgY2hpbGRyZW4gb2YgZGlzYWJsZWQgZmllbGRzZXRzXG5cdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmRpc2FibGVkID0gdHJ1ZTtcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIjpkaXNhYmxlZFwiKS5sZW5ndGggIT09IDIgKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3BlcmEgMTAtMTEgZG9lcyBub3QgdGhyb3cgb24gcG9zdC1jb21tYSBpbnZhbGlkIHBzZXVkb3Ncblx0XHRcdGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCIqLDp4XCIpO1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIsLio6XCIpO1xuXHRcdH0pO1xuXHR9XG5cblx0aWYgKCAoc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgPSBybmF0aXZlLnRlc3QoIChtYXRjaGVzID0gZG9jRWxlbS5tYXRjaGVzIHx8XG5cdFx0ZG9jRWxlbS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ub01hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubXNNYXRjaGVzU2VsZWN0b3IpICkpICkge1xuXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdC8vIENoZWNrIHRvIHNlZSBpZiBpdCdzIHBvc3NpYmxlIHRvIGRvIG1hdGNoZXNTZWxlY3RvclxuXHRcdFx0Ly8gb24gYSBkaXNjb25uZWN0ZWQgbm9kZSAoSUUgOSlcblx0XHRcdHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggPSBtYXRjaGVzLmNhbGwoIGVsLCBcIipcIiApO1xuXG5cdFx0XHQvLyBUaGlzIHNob3VsZCBmYWlsIHdpdGggYW4gZXhjZXB0aW9uXG5cdFx0XHQvLyBHZWNrbyBkb2VzIG5vdCBlcnJvciwgcmV0dXJucyBmYWxzZSBpbnN0ZWFkXG5cdFx0XHRtYXRjaGVzLmNhbGwoIGVsLCBcIltzIT0nJ106eFwiICk7XG5cdFx0XHRyYnVnZ3lNYXRjaGVzLnB1c2goIFwiIT1cIiwgcHNldWRvcyApO1xuXHRcdH0pO1xuXHR9XG5cblx0cmJ1Z2d5UVNBID0gcmJ1Z2d5UVNBLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lRU0Euam9pbihcInxcIikgKTtcblx0cmJ1Z2d5TWF0Y2hlcyA9IHJidWdneU1hdGNoZXMubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneU1hdGNoZXMuam9pbihcInxcIikgKTtcblxuXHQvKiBDb250YWluc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cdGhhc0NvbXBhcmUgPSBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29tcGFyZURvY3VtZW50UG9zaXRpb24gKTtcblxuXHQvLyBFbGVtZW50IGNvbnRhaW5zIGFub3RoZXJcblx0Ly8gUHVycG9zZWZ1bGx5IHNlbGYtZXhjbHVzaXZlXG5cdC8vIEFzIGluLCBhbiBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gaXRzZWxmXG5cdGNvbnRhaW5zID0gaGFzQ29tcGFyZSB8fCBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29udGFpbnMgKSA/XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHR2YXIgYWRvd24gPSBhLm5vZGVUeXBlID09PSA5ID8gYS5kb2N1bWVudEVsZW1lbnQgOiBhLFxuXHRcdFx0XHRidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcblx0XHRcdHJldHVybiBhID09PSBidXAgfHwgISEoIGJ1cCAmJiBidXAubm9kZVR5cGUgPT09IDEgJiYgKFxuXHRcdFx0XHRhZG93bi5jb250YWlucyA/XG5cdFx0XHRcdFx0YWRvd24uY29udGFpbnMoIGJ1cCApIDpcblx0XHRcdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGJ1cCApICYgMTZcblx0XHRcdCkpO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0aWYgKCBiICkge1xuXHRcdFx0XHR3aGlsZSAoIChiID0gYi5wYXJlbnROb2RlKSApIHtcblx0XHRcdFx0XHRpZiAoIGIgPT09IGEgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdC8qIFNvcnRpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIERvY3VtZW50IG9yZGVyIHNvcnRpbmdcblx0c29ydE9yZGVyID0gaGFzQ29tcGFyZSA/XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXG5cdFx0Ly8gRmxhZyBmb3IgZHVwbGljYXRlIHJlbW92YWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0Ly8gU29ydCBvbiBtZXRob2QgZXhpc3RlbmNlIGlmIG9ubHkgb25lIGlucHV0IGhhcyBjb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuXHRcdHZhciBjb21wYXJlID0gIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gLSAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtcblx0XHRpZiAoIGNvbXBhcmUgKSB7XG5cdFx0XHRyZXR1cm4gY29tcGFyZTtcblx0XHR9XG5cblx0XHQvLyBDYWxjdWxhdGUgcG9zaXRpb24gaWYgYm90aCBpbnB1dHMgYmVsb25nIHRvIHRoZSBzYW1lIGRvY3VtZW50XG5cdFx0Y29tcGFyZSA9ICggYS5vd25lckRvY3VtZW50IHx8IGEgKSA9PT0gKCBiLm93bmVyRG9jdW1lbnQgfHwgYiApID9cblx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGIgKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSB3ZSBrbm93IHRoZXkgYXJlIGRpc2Nvbm5lY3RlZFxuXHRcdFx0MTtcblxuXHRcdC8vIERpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdGlmICggY29tcGFyZSAmIDEgfHxcblx0XHRcdCghc3VwcG9ydC5zb3J0RGV0YWNoZWQgJiYgYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYSApID09PSBjb21wYXJlKSApIHtcblxuXHRcdFx0Ly8gQ2hvb3NlIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgaXMgcmVsYXRlZCB0byBvdXIgcHJlZmVycmVkIGRvY3VtZW50XG5cdFx0XHRpZiAoIGEgPT09IGRvY3VtZW50IHx8IGEub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYSkgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHRcdGlmICggYiA9PT0gZG9jdW1lbnQgfHwgYi5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBiKSApIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1haW50YWluIG9yaWdpbmFsIG9yZGVyXG5cdFx0XHRyZXR1cm4gc29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcblx0fSA6XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdC8vIEV4aXQgZWFybHkgaWYgdGhlIG5vZGVzIGFyZSBpZGVudGljYWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0YXVwID0gYS5wYXJlbnROb2RlLFxuXHRcdFx0YnVwID0gYi5wYXJlbnROb2RlLFxuXHRcdFx0YXAgPSBbIGEgXSxcblx0XHRcdGJwID0gWyBiIF07XG5cblx0XHQvLyBQYXJlbnRsZXNzIG5vZGVzIGFyZSBlaXRoZXIgZG9jdW1lbnRzIG9yIGRpc2Nvbm5lY3RlZFxuXHRcdGlmICggIWF1cCB8fCAhYnVwICkge1xuXHRcdFx0cmV0dXJuIGEgPT09IGRvY3VtZW50ID8gLTEgOlxuXHRcdFx0XHRiID09PSBkb2N1bWVudCA/IDEgOlxuXHRcdFx0XHRhdXAgPyAtMSA6XG5cdFx0XHRcdGJ1cCA/IDEgOlxuXHRcdFx0XHRzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cblx0XHQvLyBJZiB0aGUgbm9kZXMgYXJlIHNpYmxpbmdzLCB3ZSBjYW4gZG8gYSBxdWljayBjaGVja1xuXHRcdH0gZWxzZSBpZiAoIGF1cCA9PT0gYnVwICkge1xuXHRcdFx0cmV0dXJuIHNpYmxpbmdDaGVjayggYSwgYiApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSB3ZSBuZWVkIGZ1bGwgbGlzdHMgb2YgdGhlaXIgYW5jZXN0b3JzIGZvciBjb21wYXJpc29uXG5cdFx0Y3VyID0gYTtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRhcC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cdFx0Y3VyID0gYjtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRicC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cblx0XHQvLyBXYWxrIGRvd24gdGhlIHRyZWUgbG9va2luZyBmb3IgYSBkaXNjcmVwYW5jeVxuXHRcdHdoaWxlICggYXBbaV0gPT09IGJwW2ldICkge1xuXHRcdFx0aSsrO1xuXHRcdH1cblxuXHRcdHJldHVybiBpID9cblx0XHRcdC8vIERvIGEgc2libGluZyBjaGVjayBpZiB0aGUgbm9kZXMgaGF2ZSBhIGNvbW1vbiBhbmNlc3RvclxuXHRcdFx0c2libGluZ0NoZWNrKCBhcFtpXSwgYnBbaV0gKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSBub2RlcyBpbiBvdXIgZG9jdW1lbnQgc29ydCBmaXJzdFxuXHRcdFx0YXBbaV0gPT09IHByZWZlcnJlZERvYyA/IC0xIDpcblx0XHRcdGJwW2ldID09PSBwcmVmZXJyZWREb2MgPyAxIDpcblx0XHRcdDA7XG5cdH07XG5cblx0cmV0dXJuIGRvY3VtZW50O1xufTtcblxuU2l6emxlLm1hdGNoZXMgPSBmdW5jdGlvbiggZXhwciwgZWxlbWVudHMgKSB7XG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIG51bGwsIG51bGwsIGVsZW1lbnRzICk7XG59O1xuXG5TaXp6bGUubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24oIGVsZW0sIGV4cHIgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdC8vIE1ha2Ugc3VyZSB0aGF0IGF0dHJpYnV0ZSBzZWxlY3RvcnMgYXJlIHF1b3RlZFxuXHRleHByID0gZXhwci5yZXBsYWNlKCByYXR0cmlidXRlUXVvdGVzLCBcIj0nJDEnXVwiICk7XG5cblx0aWYgKCBzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciAmJiBkb2N1bWVudElzSFRNTCAmJlxuXHRcdCFjb21waWxlckNhY2hlWyBleHByICsgXCIgXCIgXSAmJlxuXHRcdCggIXJidWdneU1hdGNoZXMgfHwgIXJidWdneU1hdGNoZXMudGVzdCggZXhwciApICkgJiZcblx0XHQoICFyYnVnZ3lRU0EgICAgIHx8ICFyYnVnZ3lRU0EudGVzdCggZXhwciApICkgKSB7XG5cblx0XHR0cnkge1xuXHRcdFx0dmFyIHJldCA9IG1hdGNoZXMuY2FsbCggZWxlbSwgZXhwciApO1xuXG5cdFx0XHQvLyBJRSA5J3MgbWF0Y2hlc1NlbGVjdG9yIHJldHVybnMgZmFsc2Ugb24gZGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0XHRpZiAoIHJldCB8fCBzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoIHx8XG5cdFx0XHRcdFx0Ly8gQXMgd2VsbCwgZGlzY29ubmVjdGVkIG5vZGVzIGFyZSBzYWlkIHRvIGJlIGluIGEgZG9jdW1lbnRcblx0XHRcdFx0XHQvLyBmcmFnbWVudCBpbiBJRSA5XG5cdFx0XHRcdFx0ZWxlbS5kb2N1bWVudCAmJiBlbGVtLmRvY3VtZW50Lm5vZGVUeXBlICE9PSAxMSApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7fVxuXHR9XG5cblx0cmV0dXJuIFNpenpsZSggZXhwciwgZG9jdW1lbnQsIG51bGwsIFsgZWxlbSBdICkubGVuZ3RoID4gMDtcbn07XG5cblNpenpsZS5jb250YWlucyA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGVtICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0ICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdH1cblx0cmV0dXJuIGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICk7XG59O1xuXG5TaXp6bGUuYXR0ciA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHR2YXIgZm4gPSBFeHByLmF0dHJIYW5kbGVbIG5hbWUudG9Mb3dlckNhc2UoKSBdLFxuXHRcdC8vIERvbid0IGdldCBmb29sZWQgYnkgT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzIChqUXVlcnkgIzEzODA3KVxuXHRcdHZhbCA9IGZuICYmIGhhc093bi5jYWxsKCBFeHByLmF0dHJIYW5kbGUsIG5hbWUudG9Mb3dlckNhc2UoKSApID9cblx0XHRcdGZuKCBlbGVtLCBuYW1lLCAhZG9jdW1lbnRJc0hUTUwgKSA6XG5cdFx0XHR1bmRlZmluZWQ7XG5cblx0cmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkID9cblx0XHR2YWwgOlxuXHRcdHN1cHBvcnQuYXR0cmlidXRlcyB8fCAhZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKSA6XG5cdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0bnVsbDtcbn07XG5cblNpenpsZS5lc2NhcGUgPSBmdW5jdGlvbiggc2VsICkge1xuXHRyZXR1cm4gKHNlbCArIFwiXCIpLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcbn07XG5cblNpenpsZS5lcnJvciA9IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdHRocm93IG5ldyBFcnJvciggXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcIiArIG1zZyApO1xufTtcblxuLyoqXG4gKiBEb2N1bWVudCBzb3J0aW5nIGFuZCByZW1vdmluZyBkdXBsaWNhdGVzXG4gKiBAcGFyYW0ge0FycmF5TGlrZX0gcmVzdWx0c1xuICovXG5TaXp6bGUudW5pcXVlU29ydCA9IGZ1bmN0aW9uKCByZXN1bHRzICkge1xuXHR2YXIgZWxlbSxcblx0XHRkdXBsaWNhdGVzID0gW10sXG5cdFx0aiA9IDAsXG5cdFx0aSA9IDA7XG5cblx0Ly8gVW5sZXNzIHdlICprbm93KiB3ZSBjYW4gZGV0ZWN0IGR1cGxpY2F0ZXMsIGFzc3VtZSB0aGVpciBwcmVzZW5jZVxuXHRoYXNEdXBsaWNhdGUgPSAhc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzO1xuXHRzb3J0SW5wdXQgPSAhc3VwcG9ydC5zb3J0U3RhYmxlICYmIHJlc3VsdHMuc2xpY2UoIDAgKTtcblx0cmVzdWx0cy5zb3J0KCBzb3J0T3JkZXIgKTtcblxuXHRpZiAoIGhhc0R1cGxpY2F0ZSApIHtcblx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdGlmICggZWxlbSA9PT0gcmVzdWx0c1sgaSBdICkge1xuXHRcdFx0XHRqID0gZHVwbGljYXRlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0cmVzdWx0cy5zcGxpY2UoIGR1cGxpY2F0ZXNbIGogXSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENsZWFyIGlucHV0IGFmdGVyIHNvcnRpbmcgdG8gcmVsZWFzZSBvYmplY3RzXG5cdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L3NpenpsZS9wdWxsLzIyNVxuXHRzb3J0SW5wdXQgPSBudWxsO1xuXG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciByZXRyaWV2aW5nIHRoZSB0ZXh0IHZhbHVlIG9mIGFuIGFycmF5IG9mIERPTSBub2Rlc1xuICogQHBhcmFtIHtBcnJheXxFbGVtZW50fSBlbGVtXG4gKi9cbmdldFRleHQgPSBTaXp6bGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHR2YXIgbm9kZSxcblx0XHRyZXQgPSBcIlwiLFxuXHRcdGkgPSAwLFxuXHRcdG5vZGVUeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRpZiAoICFub2RlVHlwZSApIHtcblx0XHQvLyBJZiBubyBub2RlVHlwZSwgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheVxuXHRcdHdoaWxlICggKG5vZGUgPSBlbGVtW2krK10pICkge1xuXHRcdFx0Ly8gRG8gbm90IHRyYXZlcnNlIGNvbW1lbnQgbm9kZXNcblx0XHRcdHJldCArPSBnZXRUZXh0KCBub2RlICk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMSB8fCBub2RlVHlwZSA9PT0gOSB8fCBub2RlVHlwZSA9PT0gMTEgKSB7XG5cdFx0Ly8gVXNlIHRleHRDb250ZW50IGZvciBlbGVtZW50c1xuXHRcdC8vIGlubmVyVGV4dCB1c2FnZSByZW1vdmVkIGZvciBjb25zaXN0ZW5jeSBvZiBuZXcgbGluZXMgKGpRdWVyeSAjMTExNTMpXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS50ZXh0Q29udGVudCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLnRleHRDb250ZW50O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBUcmF2ZXJzZSBpdHMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRyZXQgKz0gZ2V0VGV4dCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDMgfHwgbm9kZVR5cGUgPT09IDQgKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZVZhbHVlO1xuXHR9XG5cdC8vIERvIG5vdCBpbmNsdWRlIGNvbW1lbnQgb3IgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBub2Rlc1xuXG5cdHJldHVybiByZXQ7XG59O1xuXG5FeHByID0gU2l6emxlLnNlbGVjdG9ycyA9IHtcblxuXHQvLyBDYW4gYmUgYWRqdXN0ZWQgYnkgdGhlIHVzZXJcblx0Y2FjaGVMZW5ndGg6IDUwLFxuXG5cdGNyZWF0ZVBzZXVkbzogbWFya0Z1bmN0aW9uLFxuXG5cdG1hdGNoOiBtYXRjaEV4cHIsXG5cblx0YXR0ckhhbmRsZToge30sXG5cblx0ZmluZDoge30sXG5cblx0cmVsYXRpdmU6IHtcblx0XHRcIj5cIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiIFwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIgfSxcblx0XHRcIitcIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCJ+XCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiIH1cblx0fSxcblxuXHRwcmVGaWx0ZXI6IHtcblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHQvLyBNb3ZlIHRoZSBnaXZlbiB2YWx1ZSB0byBtYXRjaFszXSB3aGV0aGVyIHF1b3RlZCBvciB1bnF1b3RlZFxuXHRcdFx0bWF0Y2hbM10gPSAoIG1hdGNoWzNdIHx8IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCIgKS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHRpZiAoIG1hdGNoWzJdID09PSBcIn49XCIgKSB7XG5cdFx0XHRcdG1hdGNoWzNdID0gXCIgXCIgKyBtYXRjaFszXSArIFwiIFwiO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDQgKTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHQvKiBtYXRjaGVzIGZyb20gbWF0Y2hFeHByW1wiQ0hJTERcIl1cblx0XHRcdFx0MSB0eXBlIChvbmx5fG50aHwuLi4pXG5cdFx0XHRcdDIgd2hhdCAoY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0MyBhcmd1bWVudCAoZXZlbnxvZGR8XFxkKnxcXGQqbihbKy1dXFxkKyk/fC4uLilcblx0XHRcdFx0NCB4bi1jb21wb25lbnQgb2YgeG4reSBhcmd1bWVudCAoWystXT9cXGQqbnwpXG5cdFx0XHRcdDUgc2lnbiBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NiB4IG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ3IHNpZ24gb2YgeS1jb21wb25lbnRcblx0XHRcdFx0OCB5IG9mIHktY29tcG9uZW50XG5cdFx0XHQqL1xuXHRcdFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRpZiAoIG1hdGNoWzFdLnNsaWNlKCAwLCAzICkgPT09IFwibnRoXCIgKSB7XG5cdFx0XHRcdC8vIG50aC0qIHJlcXVpcmVzIGFyZ3VtZW50XG5cdFx0XHRcdGlmICggIW1hdGNoWzNdICkge1xuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG51bWVyaWMgeCBhbmQgeSBwYXJhbWV0ZXJzIGZvciBFeHByLmZpbHRlci5DSElMRFxuXHRcdFx0XHQvLyByZW1lbWJlciB0aGF0IGZhbHNlL3RydWUgY2FzdCByZXNwZWN0aXZlbHkgdG8gMC8xXG5cdFx0XHRcdG1hdGNoWzRdID0gKyggbWF0Y2hbNF0gPyBtYXRjaFs1XSArIChtYXRjaFs2XSB8fCAxKSA6IDIgKiAoIG1hdGNoWzNdID09PSBcImV2ZW5cIiB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApICk7XG5cdFx0XHRcdG1hdGNoWzVdID0gKyggKCBtYXRjaFs3XSArIG1hdGNoWzhdICkgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKTtcblxuXHRcdFx0Ly8gb3RoZXIgdHlwZXMgcHJvaGliaXQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFszXSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdHZhciBleGNlc3MsXG5cdFx0XHRcdHVucXVvdGVkID0gIW1hdGNoWzZdICYmIG1hdGNoWzJdO1xuXG5cdFx0XHRpZiAoIG1hdGNoRXhwcltcIkNISUxEXCJdLnRlc3QoIG1hdGNoWzBdICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBY2NlcHQgcXVvdGVkIGFyZ3VtZW50cyBhcy1pc1xuXHRcdFx0aWYgKCBtYXRjaFszXSApIHtcblx0XHRcdFx0bWF0Y2hbMl0gPSBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTdHJpcCBleGNlc3MgY2hhcmFjdGVycyBmcm9tIHVucXVvdGVkIGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggdW5xdW90ZWQgJiYgcnBzZXVkby50ZXN0KCB1bnF1b3RlZCApICYmXG5cdFx0XHRcdC8vIEdldCBleGNlc3MgZnJvbSB0b2tlbml6ZSAocmVjdXJzaXZlbHkpXG5cdFx0XHRcdChleGNlc3MgPSB0b2tlbml6ZSggdW5xdW90ZWQsIHRydWUgKSkgJiZcblx0XHRcdFx0Ly8gYWR2YW5jZSB0byB0aGUgbmV4dCBjbG9zaW5nIHBhcmVudGhlc2lzXG5cdFx0XHRcdChleGNlc3MgPSB1bnF1b3RlZC5pbmRleE9mKCBcIilcIiwgdW5xdW90ZWQubGVuZ3RoIC0gZXhjZXNzICkgLSB1bnF1b3RlZC5sZW5ndGgpICkge1xuXG5cdFx0XHRcdC8vIGV4Y2VzcyBpcyBhIG5lZ2F0aXZlIGluZGV4XG5cdFx0XHRcdG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0XHRtYXRjaFsyXSA9IHVucXVvdGVkLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV0dXJuIG9ubHkgY2FwdHVyZXMgbmVlZGVkIGJ5IHRoZSBwc2V1ZG8gZmlsdGVyIG1ldGhvZCAodHlwZSBhbmQgYXJndW1lbnQpXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDMgKTtcblx0XHR9XG5cdH0sXG5cblx0ZmlsdGVyOiB7XG5cblx0XHRcIlRBR1wiOiBmdW5jdGlvbiggbm9kZU5hbWVTZWxlY3RvciApIHtcblx0XHRcdHZhciBub2RlTmFtZSA9IG5vZGVOYW1lU2VsZWN0b3IucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5vZGVOYW1lU2VsZWN0b3IgPT09IFwiKlwiID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9IDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZTtcblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDTEFTU1wiOiBmdW5jdGlvbiggY2xhc3NOYW1lICkge1xuXHRcdFx0dmFyIHBhdHRlcm4gPSBjbGFzc0NhY2hlWyBjbGFzc05hbWUgKyBcIiBcIiBdO1xuXG5cdFx0XHRyZXR1cm4gcGF0dGVybiB8fFxuXHRcdFx0XHQocGF0dGVybiA9IG5ldyBSZWdFeHAoIFwiKF58XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyBjbGFzc05hbWUgKyBcIihcIiArIHdoaXRlc3BhY2UgKyBcInwkKVwiICkpICYmXG5cdFx0XHRcdGNsYXNzQ2FjaGUoIGNsYXNzTmFtZSwgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhdHRlcm4udGVzdCggdHlwZW9mIGVsZW0uY2xhc3NOYW1lID09PSBcInN0cmluZ1wiICYmIGVsZW0uY2xhc3NOYW1lIHx8IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBlbGVtLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIgKTtcblx0XHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbmFtZSwgb3BlcmF0b3IsIGNoZWNrICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gU2l6emxlLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdFx0XHRpZiAoIHJlc3VsdCA9PSBudWxsICkge1xuXHRcdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCIhPVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIW9wZXJhdG9yICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVzdWx0ICs9IFwiXCI7XG5cblx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIj1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiE9XCIgPyByZXN1bHQgIT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJePVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPT09IDAgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIio9XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIkPVwiID8gY2hlY2sgJiYgcmVzdWx0LnNsaWNlKCAtY2hlY2subGVuZ3RoICkgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ+PVwiID8gKCBcIiBcIiArIHJlc3VsdC5yZXBsYWNlKCByd2hpdGVzcGFjZSwgXCIgXCIgKSArIFwiIFwiICkuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ8PVwiID8gcmVzdWx0ID09PSBjaGVjayB8fCByZXN1bHQuc2xpY2UoIDAsIGNoZWNrLmxlbmd0aCArIDEgKSA9PT0gY2hlY2sgKyBcIi1cIiA6XG5cdFx0XHRcdFx0ZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCB0eXBlLCB3aGF0LCBhcmd1bWVudCwgZmlyc3QsIGxhc3QgKSB7XG5cdFx0XHR2YXIgc2ltcGxlID0gdHlwZS5zbGljZSggMCwgMyApICE9PSBcIm50aFwiLFxuXHRcdFx0XHRmb3J3YXJkID0gdHlwZS5zbGljZSggLTQgKSAhPT0gXCJsYXN0XCIsXG5cdFx0XHRcdG9mVHlwZSA9IHdoYXQgPT09IFwib2YtdHlwZVwiO1xuXG5cdFx0XHRyZXR1cm4gZmlyc3QgPT09IDEgJiYgbGFzdCA9PT0gMCA/XG5cblx0XHRcdFx0Ly8gU2hvcnRjdXQgZm9yIDpudGgtKihuKVxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gISFlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRcdH0gOlxuXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGNhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSwgbm9kZSwgbm9kZUluZGV4LCBzdGFydCxcblx0XHRcdFx0XHRcdGRpciA9IHNpbXBsZSAhPT0gZm9yd2FyZCA/IFwibmV4dFNpYmxpbmdcIiA6IFwicHJldmlvdXNTaWJsaW5nXCIsXG5cdFx0XHRcdFx0XHRwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGUsXG5cdFx0XHRcdFx0XHRuYW1lID0gb2ZUeXBlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdFx0XHRcdHVzZUNhY2hlID0gIXhtbCAmJiAhb2ZUeXBlLFxuXHRcdFx0XHRcdFx0ZGlmZiA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIDooZmlyc3R8bGFzdHxvbmx5KS0oY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0XHRcdGlmICggc2ltcGxlICkge1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIGRpciApIHtcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gbm9kZVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0Ly8gUmV2ZXJzZSBkaXJlY3Rpb24gZm9yIDpvbmx5LSogKGlmIHdlIGhhdmVuJ3QgeWV0IGRvbmUgc28pXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnQgPSBkaXIgPSB0eXBlID09PSBcIm9ubHlcIiAmJiAhc3RhcnQgJiYgXCJuZXh0U2libGluZ1wiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzdGFydCA9IFsgZm9yd2FyZCA/IHBhcmVudC5maXJzdENoaWxkIDogcGFyZW50Lmxhc3RDaGlsZCBdO1xuXG5cdFx0XHRcdFx0XHQvLyBub24teG1sIDpudGgtY2hpbGQoLi4uKSBzdG9yZXMgY2FjaGUgZGF0YSBvbiBgcGFyZW50YFxuXHRcdFx0XHRcdFx0aWYgKCBmb3J3YXJkICYmIHVzZUNhY2hlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFNlZWsgYGVsZW1gIGZyb20gYSBwcmV2aW91c2x5LWNhY2hlZCBpbmRleFxuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0bm9kZSA9IHBhcmVudDtcblx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleCAmJiBjYWNoZVsgMiBdO1xuXHRcdFx0XHRcdFx0XHRub2RlID0gbm9kZUluZGV4ICYmIHBhcmVudC5jaGlsZE5vZGVzWyBub2RlSW5kZXggXTtcblxuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gRmFsbGJhY2sgdG8gc2Vla2luZyBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFdoZW4gZm91bmQsIGNhY2hlIGluZGV4ZXMgb24gYHBhcmVudGAgYW5kIGJyZWFrXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlLm5vZGVUeXBlID09PSAxICYmICsrZGlmZiAmJiBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgbm9kZUluZGV4LCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gVXNlIHByZXZpb3VzbHktY2FjaGVkIGVsZW1lbnQgaW5kZXggaWYgYXZhaWxhYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleDtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIHhtbCA6bnRoLWNoaWxkKC4uLilcblx0XHRcdFx0XHRcdFx0Ly8gb3IgOm50aC1sYXN0LWNoaWxkKC4uLikgb3IgOm50aCgtbGFzdCk/LW9mLXR5cGUoLi4uKVxuXHRcdFx0XHRcdFx0XHRpZiAoIGRpZmYgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIFVzZSB0aGUgc2FtZSBsb29wIGFzIGFib3ZlIHRvIHNlZWsgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCsrZGlmZiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBDYWNoZSB0aGUgaW5kZXggb2YgZWFjaCBlbmNvdW50ZXJlZCBlbGVtZW50XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEluY29ycG9yYXRlIHRoZSBvZmZzZXQsIHRoZW4gY2hlY2sgYWdhaW5zdCBjeWNsZSBzaXplXG5cdFx0XHRcdFx0XHRkaWZmIC09IGxhc3Q7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZGlmZiA9PT0gZmlyc3QgfHwgKCBkaWZmICUgZmlyc3QgPT09IDAgJiYgZGlmZiAvIGZpcnN0ID49IDAgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBwc2V1ZG8sIGFyZ3VtZW50ICkge1xuXHRcdFx0Ly8gcHNldWRvLWNsYXNzIG5hbWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI3BzZXVkby1jbGFzc2VzXG5cdFx0XHQvLyBQcmlvcml0aXplIGJ5IGNhc2Ugc2Vuc2l0aXZpdHkgaW4gY2FzZSBjdXN0b20gcHNldWRvcyBhcmUgYWRkZWQgd2l0aCB1cHBlcmNhc2UgbGV0dGVyc1xuXHRcdFx0Ly8gUmVtZW1iZXIgdGhhdCBzZXRGaWx0ZXJzIGluaGVyaXRzIGZyb20gcHNldWRvc1xuXHRcdFx0dmFyIGFyZ3MsXG5cdFx0XHRcdGZuID0gRXhwci5wc2V1ZG9zWyBwc2V1ZG8gXSB8fCBFeHByLnNldEZpbHRlcnNbIHBzZXVkby50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcIiArIHBzZXVkbyApO1xuXG5cdFx0XHQvLyBUaGUgdXNlciBtYXkgdXNlIGNyZWF0ZVBzZXVkbyB0byBpbmRpY2F0ZSB0aGF0XG5cdFx0XHQvLyBhcmd1bWVudHMgYXJlIG5lZWRlZCB0byBjcmVhdGUgdGhlIGZpbHRlciBmdW5jdGlvblxuXHRcdFx0Ly8ganVzdCBhcyBTaXp6bGUgZG9lc1xuXHRcdFx0aWYgKCBmblsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRyZXR1cm4gZm4oIGFyZ3VtZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEJ1dCBtYWludGFpbiBzdXBwb3J0IGZvciBvbGQgc2lnbmF0dXJlc1xuXHRcdFx0aWYgKCBmbi5sZW5ndGggPiAxICkge1xuXHRcdFx0XHRhcmdzID0gWyBwc2V1ZG8sIHBzZXVkbywgXCJcIiwgYXJndW1lbnQgXTtcblx0XHRcdFx0cmV0dXJuIEV4cHIuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eSggcHNldWRvLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRcdFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0XHRcdFx0dmFyIGlkeCxcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZCA9IGZuKCBzZWVkLCBhcmd1bWVudCApLFxuXHRcdFx0XHRcdFx0XHRpID0gbWF0Y2hlZC5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWR4ID0gaW5kZXhPZiggc2VlZCwgbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0XHRzZWVkWyBpZHggXSA9ICEoIG1hdGNoZXNbIGlkeCBdID0gbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pIDpcblx0XHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmbiggZWxlbSwgMCwgYXJncyApO1xuXHRcdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmbjtcblx0XHR9XG5cdH0sXG5cblx0cHNldWRvczoge1xuXHRcdC8vIFBvdGVudGlhbGx5IGNvbXBsZXggcHNldWRvc1xuXHRcdFwibm90XCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHQvLyBUcmltIHRoZSBzZWxlY3RvciBwYXNzZWQgdG8gY29tcGlsZVxuXHRcdFx0Ly8gdG8gYXZvaWQgdHJlYXRpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmdcblx0XHRcdC8vIHNwYWNlcyBhcyBjb21iaW5hdG9yc1xuXHRcdFx0dmFyIGlucHV0ID0gW10sXG5cdFx0XHRcdHJlc3VsdHMgPSBbXSxcblx0XHRcdFx0bWF0Y2hlciA9IGNvbXBpbGUoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSApO1xuXG5cdFx0XHRyZXR1cm4gbWF0Y2hlclsgZXhwYW5kbyBdID9cblx0XHRcdFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQgPSBtYXRjaGVyKCBzZWVkLCBudWxsLCB4bWwsIFtdICksXG5cdFx0XHRcdFx0XHRpID0gc2VlZC5sZW5ndGg7XG5cblx0XHRcdFx0XHQvLyBNYXRjaCBlbGVtZW50cyB1bm1hdGNoZWQgYnkgYG1hdGNoZXJgXG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0c2VlZFtpXSA9ICEobWF0Y2hlc1tpXSA9IGVsZW0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSkgOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdGlucHV0WzBdID0gZWxlbTtcblx0XHRcdFx0XHRtYXRjaGVyKCBpbnB1dCwgbnVsbCwgeG1sLCByZXN1bHRzICk7XG5cdFx0XHRcdFx0Ly8gRG9uJ3Qga2VlcCB0aGUgZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdFx0XHRpbnB1dFswXSA9IG51bGw7XG5cdFx0XHRcdFx0cmV0dXJuICFyZXN1bHRzLnBvcCgpO1xuXHRcdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJoYXNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIFNpenpsZSggc2VsZWN0b3IsIGVsZW0gKS5sZW5ndGggPiAwO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiY29udGFpbnNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS50ZXh0Q29udGVudCB8fCBlbGVtLmlubmVyVGV4dCB8fCBnZXRUZXh0KCBlbGVtICkgKS5pbmRleE9mKCB0ZXh0ICkgPiAtMTtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHQvLyBcIldoZXRoZXIgYW4gZWxlbWVudCBpcyByZXByZXNlbnRlZCBieSBhIDpsYW5nKCkgc2VsZWN0b3Jcblx0XHQvLyBpcyBiYXNlZCBzb2xlbHkgb24gdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZVxuXHRcdC8vIGJlaW5nIGVxdWFsIHRvIHRoZSBpZGVudGlmaWVyIEMsXG5cdFx0Ly8gb3IgYmVnaW5uaW5nIHdpdGggdGhlIGlkZW50aWZpZXIgQyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBcIi1cIi5cblx0XHQvLyBUaGUgbWF0Y2hpbmcgb2YgQyBhZ2FpbnN0IHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWUgaXMgcGVyZm9ybWVkIGNhc2UtaW5zZW5zaXRpdmVseS5cblx0XHQvLyBUaGUgaWRlbnRpZmllciBDIGRvZXMgbm90IGhhdmUgdG8gYmUgYSB2YWxpZCBsYW5ndWFnZSBuYW1lLlwiXG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNsYW5nLXBzZXVkb1xuXHRcdFwibGFuZ1wiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBsYW5nICkge1xuXHRcdFx0Ly8gbGFuZyB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclxuXHRcdFx0aWYgKCAhcmlkZW50aWZpZXIudGVzdChsYW5nIHx8IFwiXCIpICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgbGFuZzogXCIgKyBsYW5nICk7XG5cdFx0XHR9XG5cdFx0XHRsYW5nID0gbGFuZy5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBlbGVtTGFuZztcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdGlmICggKGVsZW1MYW5nID0gZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0XHRcdFx0ZWxlbS5sYW5nIDpcblx0XHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKFwieG1sOmxhbmdcIikgfHwgZWxlbS5nZXRBdHRyaWJ1dGUoXCJsYW5nXCIpKSApIHtcblxuXHRcdFx0XHRcdFx0ZWxlbUxhbmcgPSBlbGVtTGFuZy50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW1MYW5nID09PSBsYW5nIHx8IGVsZW1MYW5nLmluZGV4T2YoIGxhbmcgKyBcIi1cIiApID09PSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSB3aGlsZSAoIChlbGVtID0gZWxlbS5wYXJlbnROb2RlKSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHQvLyBNaXNjZWxsYW5lb3VzXG5cdFx0XCJ0YXJnZXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaGFzaDtcblx0XHRcdHJldHVybiBoYXNoICYmIGhhc2guc2xpY2UoIDEgKSA9PT0gZWxlbS5pZDtcblx0XHR9LFxuXG5cdFx0XCJyb290XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY0VsZW07XG5cdFx0fSxcblxuXHRcdFwiZm9jdXNcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiAoIWRvY3VtZW50Lmhhc0ZvY3VzIHx8IGRvY3VtZW50Lmhhc0ZvY3VzKCkpICYmICEhKGVsZW0udHlwZSB8fCBlbGVtLmhyZWYgfHwgfmVsZW0udGFiSW5kZXgpO1xuXHRcdH0sXG5cblx0XHQvLyBCb29sZWFuIHByb3BlcnRpZXNcblx0XHRcImVuYWJsZWRcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGZhbHNlICksXG5cdFx0XCJkaXNhYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggdHJ1ZSApLFxuXG5cdFx0XCJjaGVja2VkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gSW4gQ1NTMywgOmNoZWNrZWQgc2hvdWxkIHJldHVybiBib3RoIGNoZWNrZWQgYW5kIHNlbGVjdGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0dmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIChub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmICEhZWxlbS5jaGVja2VkKSB8fCAobm9kZU5hbWUgPT09IFwib3B0aW9uXCIgJiYgISFlbGVtLnNlbGVjdGVkKTtcblx0XHR9LFxuXG5cdFx0XCJzZWxlY3RlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEFjY2Vzc2luZyB0aGlzIHByb3BlcnR5IG1ha2VzIHNlbGVjdGVkLWJ5LWRlZmF1bHRcblx0XHRcdC8vIG9wdGlvbnMgaW4gU2FmYXJpIHdvcmsgcHJvcGVybHlcblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRlbGVtLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW0uc2VsZWN0ZWQgPT09IHRydWU7XG5cdFx0fSxcblxuXHRcdC8vIENvbnRlbnRzXG5cdFx0XCJlbXB0eVwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jZW1wdHktcHNldWRvXG5cdFx0XHQvLyA6ZW1wdHkgaXMgbmVnYXRlZCBieSBlbGVtZW50ICgxKSBvciBjb250ZW50IG5vZGVzICh0ZXh0OiAzOyBjZGF0YTogNDsgZW50aXR5IHJlZjogNSksXG5cdFx0XHQvLyAgIGJ1dCBub3QgYnkgb3RoZXJzIChjb21tZW50OiA4OyBwcm9jZXNzaW5nIGluc3RydWN0aW9uOiA3OyBldGMuKVxuXHRcdFx0Ly8gbm9kZVR5cGUgPCA2IHdvcmtzIGJlY2F1c2UgYXR0cmlidXRlcyAoMikgZG8gbm90IGFwcGVhciBhcyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA8IDYgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0XCJwYXJlbnRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gIUV4cHIucHNldWRvc1tcImVtcHR5XCJdKCBlbGVtICk7XG5cdFx0fSxcblxuXHRcdC8vIEVsZW1lbnQvaW5wdXQgdHlwZXNcblx0XHRcImhlYWRlclwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaGVhZGVyLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJpbnB1dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaW5wdXRzLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJidXR0b25cIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSBcImJ1dHRvblwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCI7XG5cdFx0fSxcblxuXHRcdFwidGV4dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBhdHRyO1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICYmXG5cdFx0XHRcdGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCIgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRTw4XG5cdFx0XHRcdC8vIE5ldyBIVE1MNSBhdHRyaWJ1dGUgdmFsdWVzIChlLmcuLCBcInNlYXJjaFwiKSBhcHBlYXIgd2l0aCBlbGVtLnR5cGUgPT09IFwidGV4dFwiXG5cdFx0XHRcdCggKGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZShcInR5cGVcIikpID09IG51bGwgfHwgYXR0ci50b0xvd2VyQ2FzZSgpID09PSBcInRleHRcIiApO1xuXHRcdH0sXG5cblx0XHQvLyBQb3NpdGlvbi1pbi1jb2xsZWN0aW9uXG5cdFx0XCJmaXJzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFsgMCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJsYXN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIFsgbGVuZ3RoIC0gMSBdO1xuXHRcdH0pLFxuXG5cdFx0XCJlcVwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHRyZXR1cm4gWyBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50IF07XG5cdFx0fSksXG5cblx0XHRcImV2ZW5cIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcIm9kZFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMTtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwibHRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyAtLWkgPj0gMDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJndFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7ICsraSA8IGxlbmd0aDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pXG5cdH1cbn07XG5cbkV4cHIucHNldWRvc1tcIm50aFwiXSA9IEV4cHIucHNldWRvc1tcImVxXCJdO1xuXG4vLyBBZGQgYnV0dG9uL2lucHV0IHR5cGUgcHNldWRvc1xuZm9yICggaSBpbiB7IHJhZGlvOiB0cnVlLCBjaGVja2JveDogdHJ1ZSwgZmlsZTogdHJ1ZSwgcGFzc3dvcmQ6IHRydWUsIGltYWdlOiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlSW5wdXRQc2V1ZG8oIGkgKTtcbn1cbmZvciAoIGkgaW4geyBzdWJtaXQ6IHRydWUsIHJlc2V0OiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlQnV0dG9uUHNldWRvKCBpICk7XG59XG5cbi8vIEVhc3kgQVBJIGZvciBjcmVhdGluZyBuZXcgc2V0RmlsdGVyc1xuZnVuY3Rpb24gc2V0RmlsdGVycygpIHt9XG5zZXRGaWx0ZXJzLnByb3RvdHlwZSA9IEV4cHIuZmlsdGVycyA9IEV4cHIucHNldWRvcztcbkV4cHIuc2V0RmlsdGVycyA9IG5ldyBzZXRGaWx0ZXJzKCk7XG5cbnRva2VuaXplID0gU2l6emxlLnRva2VuaXplID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBwYXJzZU9ubHkgKSB7XG5cdHZhciBtYXRjaGVkLCBtYXRjaCwgdG9rZW5zLCB0eXBlLFxuXHRcdHNvRmFyLCBncm91cHMsIHByZUZpbHRlcnMsXG5cdFx0Y2FjaGVkID0gdG9rZW5DYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggY2FjaGVkICkge1xuXHRcdHJldHVybiBwYXJzZU9ubHkgPyAwIDogY2FjaGVkLnNsaWNlKCAwICk7XG5cdH1cblxuXHRzb0ZhciA9IHNlbGVjdG9yO1xuXHRncm91cHMgPSBbXTtcblx0cHJlRmlsdGVycyA9IEV4cHIucHJlRmlsdGVyO1xuXG5cdHdoaWxlICggc29GYXIgKSB7XG5cblx0XHQvLyBDb21tYSBhbmQgZmlyc3QgcnVuXG5cdFx0aWYgKCAhbWF0Y2hlZCB8fCAobWF0Y2ggPSByY29tbWEuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRpZiAoIG1hdGNoICkge1xuXHRcdFx0XHQvLyBEb24ndCBjb25zdW1lIHRyYWlsaW5nIGNvbW1hcyBhcyB2YWxpZFxuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaFswXS5sZW5ndGggKSB8fCBzb0Zhcjtcblx0XHRcdH1cblx0XHRcdGdyb3Vwcy5wdXNoKCAodG9rZW5zID0gW10pICk7XG5cdFx0fVxuXG5cdFx0bWF0Y2hlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gQ29tYmluYXRvcnNcblx0XHRpZiAoIChtYXRjaCA9IHJjb21iaW5hdG9ycy5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0dG9rZW5zLnB1c2goe1xuXHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0Ly8gQ2FzdCBkZXNjZW5kYW50IGNvbWJpbmF0b3JzIHRvIHNwYWNlXG5cdFx0XHRcdHR5cGU6IG1hdGNoWzBdLnJlcGxhY2UoIHJ0cmltLCBcIiBcIiApXG5cdFx0XHR9KTtcblx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmlsdGVyc1xuXHRcdGZvciAoIHR5cGUgaW4gRXhwci5maWx0ZXIgKSB7XG5cdFx0XHRpZiAoIChtYXRjaCA9IG1hdGNoRXhwclsgdHlwZSBdLmV4ZWMoIHNvRmFyICkpICYmICghcHJlRmlsdGVyc1sgdHlwZSBdIHx8XG5cdFx0XHRcdChtYXRjaCA9IHByZUZpbHRlcnNbIHR5cGUgXSggbWF0Y2ggKSkpICkge1xuXHRcdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdFx0dG9rZW5zLnB1c2goe1xuXHRcdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdFx0bWF0Y2hlczogbWF0Y2hcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCAhbWF0Y2hlZCApIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBpbnZhbGlkIGV4Y2Vzc1xuXHQvLyBpZiB3ZSdyZSBqdXN0IHBhcnNpbmdcblx0Ly8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvciBvciByZXR1cm4gdG9rZW5zXG5cdHJldHVybiBwYXJzZU9ubHkgP1xuXHRcdHNvRmFyLmxlbmd0aCA6XG5cdFx0c29GYXIgP1xuXHRcdFx0U2l6emxlLmVycm9yKCBzZWxlY3RvciApIDpcblx0XHRcdC8vIENhY2hlIHRoZSB0b2tlbnNcblx0XHRcdHRva2VuQ2FjaGUoIHNlbGVjdG9yLCBncm91cHMgKS5zbGljZSggMCApO1xufTtcblxuZnVuY3Rpb24gdG9TZWxlY3RvciggdG9rZW5zICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRzZWxlY3RvciA9IFwiXCI7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdHNlbGVjdG9yICs9IHRva2Vuc1tpXS52YWx1ZTtcblx0fVxuXHRyZXR1cm4gc2VsZWN0b3I7XG59XG5cbmZ1bmN0aW9uIGFkZENvbWJpbmF0b3IoIG1hdGNoZXIsIGNvbWJpbmF0b3IsIGJhc2UgKSB7XG5cdHZhciBkaXIgPSBjb21iaW5hdG9yLmRpcixcblx0XHRza2lwID0gY29tYmluYXRvci5uZXh0LFxuXHRcdGtleSA9IHNraXAgfHwgZGlyLFxuXHRcdGNoZWNrTm9uRWxlbWVudHMgPSBiYXNlICYmIGtleSA9PT0gXCJwYXJlbnROb2RlXCIsXG5cdFx0ZG9uZU5hbWUgPSBkb25lKys7XG5cblx0cmV0dXJuIGNvbWJpbmF0b3IuZmlyc3QgP1xuXHRcdC8vIENoZWNrIGFnYWluc3QgY2xvc2VzdCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9IDpcblxuXHRcdC8vIENoZWNrIGFnYWluc3QgYWxsIGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50c1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgb2xkQ2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLFxuXHRcdFx0XHRuZXdDYWNoZSA9IFsgZGlycnVucywgZG9uZU5hbWUgXTtcblxuXHRcdFx0Ly8gV2UgY2FuJ3Qgc2V0IGFyYml0cmFyeSBkYXRhIG9uIFhNTCBub2Rlcywgc28gdGhleSBkb24ndCBiZW5lZml0IGZyb20gY29tYmluYXRvciBjYWNoaW5nXG5cdFx0XHRpZiAoIHhtbCApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBlbGVtWyBleHBhbmRvIF0gfHwgKGVsZW1bIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSB8fCAob3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHNraXAgJiYgc2tpcCA9PT0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICkge1xuXHRcdFx0XHRcdFx0XHRlbGVtID0gZWxlbVsgZGlyIF0gfHwgZWxlbTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIChvbGRDYWNoZSA9IHVuaXF1ZUNhY2hlWyBrZXkgXSkgJiZcblx0XHRcdFx0XHRcdFx0b2xkQ2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBvbGRDYWNoZVsgMSBdID09PSBkb25lTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBc3NpZ24gdG8gbmV3Q2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gKG5ld0NhY2hlWyAyIF0gPSBvbGRDYWNoZVsgMiBdKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFJldXNlIG5ld2NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIGtleSBdID0gbmV3Q2FjaGU7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQSBtYXRjaCBtZWFucyB3ZSdyZSBkb25lOyBhIGZhaWwgbWVhbnMgd2UgaGF2ZSB0byBrZWVwIGNoZWNraW5nXG5cdFx0XHRcdFx0XHRcdGlmICggKG5ld0NhY2hlWyAyIF0gPSBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xufVxuXG5mdW5jdGlvbiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSB7XG5cdHJldHVybiBtYXRjaGVycy5sZW5ndGggPiAxID9cblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIGkgPSBtYXRjaGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAhbWF0Y2hlcnNbaV0oIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSA6XG5cdFx0bWF0Y2hlcnNbMF07XG59XG5cbmZ1bmN0aW9uIG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yLCBjb250ZXh0cywgcmVzdWx0cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0U2l6emxlKCBzZWxlY3RvciwgY29udGV4dHNbaV0sIHJlc3VsdHMgKTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gY29uZGVuc2UoIHVubWF0Y2hlZCwgbWFwLCBmaWx0ZXIsIGNvbnRleHQsIHhtbCApIHtcblx0dmFyIGVsZW0sXG5cdFx0bmV3VW5tYXRjaGVkID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bGVuID0gdW5tYXRjaGVkLmxlbmd0aCxcblx0XHRtYXBwZWQgPSBtYXAgIT0gbnVsbDtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcblx0XHRcdGlmICggIWZpbHRlciB8fCBmaWx0ZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRuZXdVbm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRpZiAoIG1hcHBlZCApIHtcblx0XHRcdFx0XHRtYXAucHVzaCggaSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG5ld1VubWF0Y2hlZDtcbn1cblxuZnVuY3Rpb24gc2V0TWF0Y2hlciggcHJlRmlsdGVyLCBzZWxlY3RvciwgbWF0Y2hlciwgcG9zdEZpbHRlciwgcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICkge1xuXHRpZiAoIHBvc3RGaWx0ZXIgJiYgIXBvc3RGaWx0ZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmlsdGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbHRlciApO1xuXHR9XG5cdGlmICggcG9zdEZpbmRlciAmJiAhcG9zdEZpbmRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaW5kZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKTtcblx0fVxuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCByZXN1bHRzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0dmFyIHRlbXAsIGksIGVsZW0sXG5cdFx0XHRwcmVNYXAgPSBbXSxcblx0XHRcdHBvc3RNYXAgPSBbXSxcblx0XHRcdHByZWV4aXN0aW5nID0gcmVzdWx0cy5sZW5ndGgsXG5cblx0XHRcdC8vIEdldCBpbml0aWFsIGVsZW1lbnRzIGZyb20gc2VlZCBvciBjb250ZXh0XG5cdFx0XHRlbGVtcyA9IHNlZWQgfHwgbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IgfHwgXCIqXCIsIGNvbnRleHQubm9kZVR5cGUgPyBbIGNvbnRleHQgXSA6IGNvbnRleHQsIFtdICksXG5cblx0XHRcdC8vIFByZWZpbHRlciB0byBnZXQgbWF0Y2hlciBpbnB1dCwgcHJlc2VydmluZyBhIG1hcCBmb3Igc2VlZC1yZXN1bHRzIHN5bmNocm9uaXphdGlvblxuXHRcdFx0bWF0Y2hlckluID0gcHJlRmlsdGVyICYmICggc2VlZCB8fCAhc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGNvbmRlbnNlKCBlbGVtcywgcHJlTWFwLCBwcmVGaWx0ZXIsIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0ZWxlbXMsXG5cblx0XHRcdG1hdGNoZXJPdXQgPSBtYXRjaGVyID9cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIHBvc3RGaW5kZXIsIG9yIGZpbHRlcmVkIHNlZWQsIG9yIG5vbi1zZWVkIHBvc3RGaWx0ZXIgb3IgcHJlZXhpc3RpbmcgcmVzdWx0cyxcblx0XHRcdFx0cG9zdEZpbmRlciB8fCAoIHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyICkgP1xuXG5cdFx0XHRcdFx0Ly8gLi4uaW50ZXJtZWRpYXRlIHByb2Nlc3NpbmcgaXMgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0W10gOlxuXG5cdFx0XHRcdFx0Ly8gLi4ub3RoZXJ3aXNlIHVzZSByZXN1bHRzIGRpcmVjdGx5XG5cdFx0XHRcdFx0cmVzdWx0cyA6XG5cdFx0XHRcdG1hdGNoZXJJbjtcblxuXHRcdC8vIEZpbmQgcHJpbWFyeSBtYXRjaGVzXG5cdFx0aWYgKCBtYXRjaGVyICkge1xuXHRcdFx0bWF0Y2hlciggbWF0Y2hlckluLCBtYXRjaGVyT3V0LCBjb250ZXh0LCB4bWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwb3N0RmlsdGVyXG5cdFx0aWYgKCBwb3N0RmlsdGVyICkge1xuXHRcdFx0dGVtcCA9IGNvbmRlbnNlKCBtYXRjaGVyT3V0LCBwb3N0TWFwICk7XG5cdFx0XHRwb3N0RmlsdGVyKCB0ZW1wLCBbXSwgY29udGV4dCwgeG1sICk7XG5cblx0XHRcdC8vIFVuLW1hdGNoIGZhaWxpbmcgZWxlbWVudHMgYnkgbW92aW5nIHRoZW0gYmFjayB0byBtYXRjaGVySW5cblx0XHRcdGkgPSB0ZW1wLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIChlbGVtID0gdGVtcFtpXSkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlck91dFsgcG9zdE1hcFtpXSBdID0gIShtYXRjaGVySW5bIHBvc3RNYXBbaV0gXSA9IGVsZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyIHx8IHByZUZpbHRlciApIHtcblx0XHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRcdC8vIEdldCB0aGUgZmluYWwgbWF0Y2hlck91dCBieSBjb25kZW5zaW5nIHRoaXMgaW50ZXJtZWRpYXRlIGludG8gcG9zdEZpbmRlciBjb250ZXh0c1xuXHRcdFx0XHRcdHRlbXAgPSBbXTtcblx0XHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFJlc3RvcmUgbWF0Y2hlckluIHNpbmNlIGVsZW0gaXMgbm90IHlldCBhIGZpbmFsIG1hdGNoXG5cdFx0XHRcdFx0XHRcdHRlbXAucHVzaCggKG1hdGNoZXJJbltpXSA9IGVsZW0pICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIChtYXRjaGVyT3V0ID0gW10pLCB0ZW1wLCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE1vdmUgbWF0Y2hlZCBlbGVtZW50cyBmcm9tIHNlZWQgdG8gcmVzdWx0cyB0byBrZWVwIHRoZW0gc3luY2hyb25pemVkXG5cdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICYmXG5cdFx0XHRcdFx0XHQodGVtcCA9IHBvc3RGaW5kZXIgPyBpbmRleE9mKCBzZWVkLCBlbGVtICkgOiBwcmVNYXBbaV0pID4gLTEgKSB7XG5cblx0XHRcdFx0XHRcdHNlZWRbdGVtcF0gPSAhKHJlc3VsdHNbdGVtcF0gPSBlbGVtKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEFkZCBlbGVtZW50cyB0byByZXN1bHRzLCB0aHJvdWdoIHBvc3RGaW5kZXIgaWYgZGVmaW5lZFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyT3V0ID0gY29uZGVuc2UoXG5cdFx0XHRcdG1hdGNoZXJPdXQgPT09IHJlc3VsdHMgP1xuXHRcdFx0XHRcdG1hdGNoZXJPdXQuc3BsaWNlKCBwcmVleGlzdGluZywgbWF0Y2hlck91dC5sZW5ndGggKSA6XG5cdFx0XHRcdFx0bWF0Y2hlck91dFxuXHRcdFx0KTtcblx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgcmVzdWx0cywgbWF0Y2hlck91dCwgeG1sICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBtYXRjaGVyT3V0ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Ub2tlbnMoIHRva2VucyApIHtcblx0dmFyIGNoZWNrQ29udGV4dCwgbWF0Y2hlciwgaixcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdGxlYWRpbmdSZWxhdGl2ZSA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1swXS50eXBlIF0sXG5cdFx0aW1wbGljaXRSZWxhdGl2ZSA9IGxlYWRpbmdSZWxhdGl2ZSB8fCBFeHByLnJlbGF0aXZlW1wiIFwiXSxcblx0XHRpID0gbGVhZGluZ1JlbGF0aXZlID8gMSA6IDAsXG5cblx0XHQvLyBUaGUgZm91bmRhdGlvbmFsIG1hdGNoZXIgZW5zdXJlcyB0aGF0IGVsZW1lbnRzIGFyZSByZWFjaGFibGUgZnJvbSB0b3AtbGV2ZWwgY29udGV4dChzKVxuXHRcdG1hdGNoQ29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGNoZWNrQ29udGV4dDtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hBbnlDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZiggY2hlY2tDb250ZXh0LCBlbGVtICkgPiAtMTtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hlcnMgPSBbIGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgcmV0ID0gKCAhbGVhZGluZ1JlbGF0aXZlICYmICggeG1sIHx8IGNvbnRleHQgIT09IG91dGVybW9zdENvbnRleHQgKSApIHx8IChcblx0XHRcdFx0KGNoZWNrQ29udGV4dCA9IGNvbnRleHQpLm5vZGVUeXBlID9cblx0XHRcdFx0XHRtYXRjaENvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0XHRtYXRjaEFueUNvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApICk7XG5cdFx0XHQvLyBBdm9pZCBoYW5naW5nIG9udG8gZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdGNoZWNrQ29udGV4dCA9IG51bGw7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH0gXTtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoIChtYXRjaGVyID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2ldLnR5cGUgXSkgKSB7XG5cdFx0XHRtYXRjaGVycyA9IFsgYWRkQ29tYmluYXRvcihlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSwgbWF0Y2hlcikgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlciA9IEV4cHIuZmlsdGVyWyB0b2tlbnNbaV0udHlwZSBdLmFwcGx5KCBudWxsLCB0b2tlbnNbaV0ubWF0Y2hlcyApO1xuXG5cdFx0XHQvLyBSZXR1cm4gc3BlY2lhbCB1cG9uIHNlZWluZyBhIHBvc2l0aW9uYWwgbWF0Y2hlclxuXHRcdFx0aWYgKCBtYXRjaGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdC8vIEZpbmQgdGhlIG5leHQgcmVsYXRpdmUgb3BlcmF0b3IgKGlmIGFueSkgZm9yIHByb3BlciBoYW5kbGluZ1xuXHRcdFx0XHRqID0gKytpO1xuXHRcdFx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbIHRva2Vuc1tqXS50eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHNldE1hdGNoZXIoXG5cdFx0XHRcdFx0aSA+IDEgJiYgZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksXG5cdFx0XHRcdFx0aSA+IDEgJiYgdG9TZWxlY3Rvcihcblx0XHRcdFx0XHRcdC8vIElmIHRoZSBwcmVjZWRpbmcgdG9rZW4gd2FzIGEgZGVzY2VuZGFudCBjb21iaW5hdG9yLCBpbnNlcnQgYW4gaW1wbGljaXQgYW55LWVsZW1lbnQgYCpgXG5cdFx0XHRcdFx0XHR0b2tlbnMuc2xpY2UoIDAsIGkgLSAxICkuY29uY2F0KHsgdmFsdWU6IHRva2Vuc1sgaSAtIDIgXS50eXBlID09PSBcIiBcIiA/IFwiKlwiIDogXCJcIiB9KVxuXHRcdFx0XHRcdCkucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLFxuXHRcdFx0XHRcdG1hdGNoZXIsXG5cdFx0XHRcdFx0aSA8IGogJiYgbWF0Y2hlckZyb21Ub2tlbnMoIHRva2Vucy5zbGljZSggaSwgaiApICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiBtYXRjaGVyRnJvbVRva2VucyggKHRva2VucyA9IHRva2Vucy5zbGljZSggaiApKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgdG9TZWxlY3RvciggdG9rZW5zIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdG1hdGNoZXJzLnB1c2goIG1hdGNoZXIgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApIHtcblx0dmFyIGJ5U2V0ID0gc2V0TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRieUVsZW1lbnQgPSBlbGVtZW50TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRzdXBlck1hdGNoZXIgPSBmdW5jdGlvbiggc2VlZCwgY29udGV4dCwgeG1sLCByZXN1bHRzLCBvdXRlcm1vc3QgKSB7XG5cdFx0XHR2YXIgZWxlbSwgaiwgbWF0Y2hlcixcblx0XHRcdFx0bWF0Y2hlZENvdW50ID0gMCxcblx0XHRcdFx0aSA9IFwiMFwiLFxuXHRcdFx0XHR1bm1hdGNoZWQgPSBzZWVkICYmIFtdLFxuXHRcdFx0XHRzZXRNYXRjaGVkID0gW10sXG5cdFx0XHRcdGNvbnRleHRCYWNrdXAgPSBvdXRlcm1vc3RDb250ZXh0LFxuXHRcdFx0XHQvLyBXZSBtdXN0IGFsd2F5cyBoYXZlIGVpdGhlciBzZWVkIGVsZW1lbnRzIG9yIG91dGVybW9zdCBjb250ZXh0XG5cdFx0XHRcdGVsZW1zID0gc2VlZCB8fCBieUVsZW1lbnQgJiYgRXhwci5maW5kW1wiVEFHXCJdKCBcIipcIiwgb3V0ZXJtb3N0ICksXG5cdFx0XHRcdC8vIFVzZSBpbnRlZ2VyIGRpcnJ1bnMgaWZmIHRoaXMgaXMgdGhlIG91dGVybW9zdCBtYXRjaGVyXG5cdFx0XHRcdGRpcnJ1bnNVbmlxdWUgPSAoZGlycnVucyArPSBjb250ZXh0QmFja3VwID09IG51bGwgPyAxIDogTWF0aC5yYW5kb20oKSB8fCAwLjEpLFxuXHRcdFx0XHRsZW4gPSBlbGVtcy5sZW5ndGg7XG5cblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dCA9PT0gZG9jdW1lbnQgfHwgY29udGV4dCB8fCBvdXRlcm1vc3Q7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBlbGVtZW50cyBwYXNzaW5nIGVsZW1lbnRNYXRjaGVycyBkaXJlY3RseSB0byByZXN1bHRzXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTw5LCBTYWZhcmlcblx0XHRcdC8vIFRvbGVyYXRlIE5vZGVMaXN0IHByb3BlcnRpZXMgKElFOiBcImxlbmd0aFwiOyBTYWZhcmk6IDxudW1iZXI+KSBtYXRjaGluZyBlbGVtZW50cyBieSBpZFxuXHRcdFx0Zm9yICggOyBpICE9PSBsZW4gJiYgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGJ5RWxlbWVudCAmJiBlbGVtICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdGlmICggIWNvbnRleHQgJiYgZWxlbS5vd25lckRvY3VtZW50ICE9PSBkb2N1bWVudCApIHtcblx0XHRcdFx0XHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdFx0XHRcdFx0XHR4bWwgPSAhZG9jdW1lbnRJc0hUTUw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBlbGVtZW50TWF0Y2hlcnNbaisrXSkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQgfHwgZG9jdW1lbnQsIHhtbCkgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUcmFjayB1bm1hdGNoZWQgZWxlbWVudHMgZm9yIHNldCBmaWx0ZXJzXG5cdFx0XHRcdGlmICggYnlTZXQgKSB7XG5cdFx0XHRcdFx0Ly8gVGhleSB3aWxsIGhhdmUgZ29uZSB0aHJvdWdoIGFsbCBwb3NzaWJsZSBtYXRjaGVyc1xuXHRcdFx0XHRcdGlmICggKGVsZW0gPSAhbWF0Y2hlciAmJiBlbGVtKSApIHtcblx0XHRcdFx0XHRcdG1hdGNoZWRDb3VudC0tO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIExlbmd0aGVuIHRoZSBhcnJheSBmb3IgZXZlcnkgZWxlbWVudCwgbWF0Y2hlZCBvciBub3Rcblx0XHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBgaWAgaXMgbm93IHRoZSBjb3VudCBvZiBlbGVtZW50cyB2aXNpdGVkIGFib3ZlLCBhbmQgYWRkaW5nIGl0IHRvIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBtYWtlcyB0aGUgbGF0dGVyIG5vbm5lZ2F0aXZlLlxuXHRcdFx0bWF0Y2hlZENvdW50ICs9IGk7XG5cblx0XHRcdC8vIEFwcGx5IHNldCBmaWx0ZXJzIHRvIHVubWF0Y2hlZCBlbGVtZW50c1xuXHRcdFx0Ly8gTk9URTogVGhpcyBjYW4gYmUgc2tpcHBlZCBpZiB0aGVyZSBhcmUgbm8gdW5tYXRjaGVkIGVsZW1lbnRzIChpLmUuLCBgbWF0Y2hlZENvdW50YFxuXHRcdFx0Ly8gZXF1YWxzIGBpYCksIHVubGVzcyB3ZSBkaWRuJ3QgdmlzaXQgX2FueV8gZWxlbWVudHMgaW4gdGhlIGFib3ZlIGxvb3AgYmVjYXVzZSB3ZSBoYXZlXG5cdFx0XHQvLyBubyBlbGVtZW50IG1hdGNoZXJzIGFuZCBubyBzZWVkLlxuXHRcdFx0Ly8gSW5jcmVtZW50aW5nIGFuIGluaXRpYWxseS1zdHJpbmcgXCIwXCIgYGlgIGFsbG93cyBgaWAgdG8gcmVtYWluIGEgc3RyaW5nIG9ubHkgaW4gdGhhdFxuXHRcdFx0Ly8gY2FzZSwgd2hpY2ggd2lsbCByZXN1bHQgaW4gYSBcIjAwXCIgYG1hdGNoZWRDb3VudGAgdGhhdCBkaWZmZXJzIGZyb20gYGlgIGJ1dCBpcyBhbHNvXG5cdFx0XHQvLyBudW1lcmljYWxseSB6ZXJvLlxuXHRcdFx0aWYgKCBieVNldCAmJiBpICE9PSBtYXRjaGVkQ291bnQgKSB7XG5cdFx0XHRcdGogPSAwO1xuXHRcdFx0XHR3aGlsZSAoIChtYXRjaGVyID0gc2V0TWF0Y2hlcnNbaisrXSkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlciggdW5tYXRjaGVkLCBzZXRNYXRjaGVkLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHQvLyBSZWludGVncmF0ZSBlbGVtZW50IG1hdGNoZXMgdG8gZWxpbWluYXRlIHRoZSBuZWVkIGZvciBzb3J0aW5nXG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkQ291bnQgPiAwICkge1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggISh1bm1hdGNoZWRbaV0gfHwgc2V0TWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c2V0TWF0Y2hlZFtpXSA9IHBvcC5jYWxsKCByZXN1bHRzICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBEaXNjYXJkIGluZGV4IHBsYWNlaG9sZGVyIHZhbHVlcyB0byBnZXQgb25seSBhY3R1YWwgbWF0Y2hlc1xuXHRcdFx0XHRcdHNldE1hdGNoZWQgPSBjb25kZW5zZSggc2V0TWF0Y2hlZCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQWRkIG1hdGNoZXMgdG8gcmVzdWx0c1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZXRNYXRjaGVkICk7XG5cblx0XHRcdFx0Ly8gU2VlZGxlc3Mgc2V0IG1hdGNoZXMgc3VjY2VlZGluZyBtdWx0aXBsZSBzdWNjZXNzZnVsIG1hdGNoZXJzIHN0aXB1bGF0ZSBzb3J0aW5nXG5cdFx0XHRcdGlmICggb3V0ZXJtb3N0ICYmICFzZWVkICYmIHNldE1hdGNoZWQubGVuZ3RoID4gMCAmJlxuXHRcdFx0XHRcdCggbWF0Y2hlZENvdW50ICsgc2V0TWF0Y2hlcnMubGVuZ3RoICkgPiAxICkge1xuXG5cdFx0XHRcdFx0U2l6emxlLnVuaXF1ZVNvcnQoIHJlc3VsdHMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdmVycmlkZSBtYW5pcHVsYXRpb24gb2YgZ2xvYmFscyBieSBuZXN0ZWQgbWF0Y2hlcnNcblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHRCYWNrdXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB1bm1hdGNoZWQ7XG5cdFx0fTtcblxuXHRyZXR1cm4gYnlTZXQgP1xuXHRcdG1hcmtGdW5jdGlvbiggc3VwZXJNYXRjaGVyICkgOlxuXHRcdHN1cGVyTWF0Y2hlcjtcbn1cblxuY29tcGlsZSA9IFNpenpsZS5jb21waWxlID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBtYXRjaCAvKiBJbnRlcm5hbCBVc2UgT25seSAqLyApIHtcblx0dmFyIGksXG5cdFx0c2V0TWF0Y2hlcnMgPSBbXSxcblx0XHRlbGVtZW50TWF0Y2hlcnMgPSBbXSxcblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCAhY2FjaGVkICkge1xuXHRcdC8vIEdlbmVyYXRlIGEgZnVuY3Rpb24gb2YgcmVjdXJzaXZlIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIHRvIGNoZWNrIGVhY2ggZWxlbWVudFxuXHRcdGlmICggIW1hdGNoICkge1xuXHRcdFx0bWF0Y2ggPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHR9XG5cdFx0aSA9IG1hdGNoLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGNhY2hlZCA9IG1hdGNoZXJGcm9tVG9rZW5zKCBtYXRjaFtpXSApO1xuXHRcdFx0aWYgKCBjYWNoZWRbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0c2V0TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtZW50TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FjaGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZSggc2VsZWN0b3IsIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApICk7XG5cblx0XHQvLyBTYXZlIHNlbGVjdG9yIGFuZCB0b2tlbml6YXRpb25cblx0XHRjYWNoZWQuc2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0fVxuXHRyZXR1cm4gY2FjaGVkO1xufTtcblxuLyoqXG4gKiBBIGxvdy1sZXZlbCBzZWxlY3Rpb24gZnVuY3Rpb24gdGhhdCB3b3JrcyB3aXRoIFNpenpsZSdzIGNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb25zXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc2VsZWN0b3IgQSBzZWxlY3RvciBvciBhIHByZS1jb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uIGJ1aWx0IHdpdGggU2l6emxlLmNvbXBpbGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGV4dFxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdHNdXG4gKiBAcGFyYW0ge0FycmF5fSBbc2VlZF0gQSBzZXQgb2YgZWxlbWVudHMgdG8gbWF0Y2ggYWdhaW5zdFxuICovXG5zZWxlY3QgPSBTaXp6bGUuc2VsZWN0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgaSwgdG9rZW5zLCB0b2tlbiwgdHlwZSwgZmluZCxcblx0XHRjb21waWxlZCA9IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICYmIHNlbGVjdG9yLFxuXHRcdG1hdGNoID0gIXNlZWQgJiYgdG9rZW5pemUoIChzZWxlY3RvciA9IGNvbXBpbGVkLnNlbGVjdG9yIHx8IHNlbGVjdG9yKSApO1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFRyeSB0byBtaW5pbWl6ZSBvcGVyYXRpb25zIGlmIHRoZXJlIGlzIG9ubHkgb25lIHNlbGVjdG9yIGluIHRoZSBsaXN0IGFuZCBubyBzZWVkXG5cdC8vICh0aGUgbGF0dGVyIG9mIHdoaWNoIGd1YXJhbnRlZXMgdXMgY29udGV4dClcblx0aWYgKCBtYXRjaC5sZW5ndGggPT09IDEgKSB7XG5cblx0XHQvLyBSZWR1Y2UgY29udGV4dCBpZiB0aGUgbGVhZGluZyBjb21wb3VuZCBzZWxlY3RvciBpcyBhbiBJRFxuXHRcdHRva2VucyA9IG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAgKTtcblx0XHRpZiAoIHRva2Vucy5sZW5ndGggPiAyICYmICh0b2tlbiA9IHRva2Vuc1swXSkudHlwZSA9PT0gXCJJRFwiICYmXG5cdFx0XHRcdGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiYgZG9jdW1lbnRJc0hUTUwgJiYgRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzFdLnR5cGUgXSApIHtcblxuXHRcdFx0Y29udGV4dCA9ICggRXhwci5maW5kW1wiSURcIl0oIHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSksIGNvbnRleHQgKSB8fCBbXSApWzBdO1xuXHRcdFx0aWYgKCAhY29udGV4dCApIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdC8vIFByZWNvbXBpbGVkIG1hdGNoZXJzIHdpbGwgc3RpbGwgdmVyaWZ5IGFuY2VzdHJ5LCBzbyBzdGVwIHVwIGEgbGV2ZWxcblx0XHRcdH0gZWxzZSBpZiAoIGNvbXBpbGVkICkge1xuXHRcdFx0XHRjb250ZXh0ID0gY29udGV4dC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXG5cdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKCB0b2tlbnMuc2hpZnQoKS52YWx1ZS5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGZXRjaCBhIHNlZWQgc2V0IGZvciByaWdodC10by1sZWZ0IG1hdGNoaW5nXG5cdFx0aSA9IG1hdGNoRXhwcltcIm5lZWRzQ29udGV4dFwiXS50ZXN0KCBzZWxlY3RvciApID8gMCA6IHRva2Vucy5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0b2tlbiA9IHRva2Vuc1tpXTtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgd2UgaGl0IGEgY29tYmluYXRvclxuXHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyAodHlwZSA9IHRva2VuLnR5cGUpIF0gKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAoZmluZCA9IEV4cHIuZmluZFsgdHlwZSBdKSApIHtcblx0XHRcdFx0Ly8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzXG5cdFx0XHRcdGlmICggKHNlZWQgPSBmaW5kKFxuXHRcdFx0XHRcdHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSxcblx0XHRcdFx0XHRyc2libGluZy50ZXN0KCB0b2tlbnNbMF0udHlwZSApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdFx0XHRcdCkpICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgc2VlZCBpcyBlbXB0eSBvciBubyB0b2tlbnMgcmVtYWluLCB3ZSBjYW4gcmV0dXJuIGVhcmx5XG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdHNlbGVjdG9yID0gc2VlZC5sZW5ndGggJiYgdG9TZWxlY3RvciggdG9rZW5zICk7XG5cdFx0XHRcdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZWVkICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENvbXBpbGUgYW5kIGV4ZWN1dGUgYSBmaWx0ZXJpbmcgZnVuY3Rpb24gaWYgb25lIGlzIG5vdCBwcm92aWRlZFxuXHQvLyBQcm92aWRlIGBtYXRjaGAgdG8gYXZvaWQgcmV0b2tlbml6YXRpb24gaWYgd2UgbW9kaWZpZWQgdGhlIHNlbGVjdG9yIGFib3ZlXG5cdCggY29tcGlsZWQgfHwgY29tcGlsZSggc2VsZWN0b3IsIG1hdGNoICkgKShcblx0XHRzZWVkLFxuXHRcdGNvbnRleHQsXG5cdFx0IWRvY3VtZW50SXNIVE1MLFxuXHRcdHJlc3VsdHMsXG5cdFx0IWNvbnRleHQgfHwgcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHQpO1xuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8vIE9uZS10aW1lIGFzc2lnbm1lbnRzXG5cbi8vIFNvcnQgc3RhYmlsaXR5XG5zdXBwb3J0LnNvcnRTdGFibGUgPSBleHBhbmRvLnNwbGl0KFwiXCIpLnNvcnQoIHNvcnRPcmRlciApLmpvaW4oXCJcIikgPT09IGV4cGFuZG87XG5cbi8vIFN1cHBvcnQ6IENocm9tZSAxNC0zNStcbi8vIEFsd2F5cyBhc3N1bWUgZHVwbGljYXRlcyBpZiB0aGV5IGFyZW4ndCBwYXNzZWQgdG8gdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25cbnN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcyA9ICEhaGFzRHVwbGljYXRlO1xuXG4vLyBJbml0aWFsaXplIGFnYWluc3QgdGhlIGRlZmF1bHQgZG9jdW1lbnRcbnNldERvY3VtZW50KCk7XG5cbi8vIFN1cHBvcnQ6IFdlYmtpdDw1MzcuMzIgLSBTYWZhcmkgNi4wLjMvQ2hyb21lIDI1IChmaXhlZCBpbiBDaHJvbWUgMjcpXG4vLyBEZXRhY2hlZCBub2RlcyBjb25mb3VuZGluZ2x5IGZvbGxvdyAqZWFjaCBvdGhlcipcbnN1cHBvcnQuc29ydERldGFjaGVkID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0Ly8gU2hvdWxkIHJldHVybiAxLCBidXQgcmV0dXJucyA0IChmb2xsb3dpbmcpXG5cdHJldHVybiBlbC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZpZWxkc2V0XCIpICkgJiAxO1xufSk7XG5cbi8vIFN1cHBvcnQ6IElFPDhcbi8vIFByZXZlbnQgYXR0cmlidXRlL3Byb3BlcnR5IFwiaW50ZXJwb2xhdGlvblwiXG4vLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM2NDI5JTI4VlMuODUlMjkuYXNweFxuaWYgKCAhYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0ZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScjJz48L2E+XCI7XG5cdHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcImhyZWZcIikgPT09IFwiI1wiIDtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidHlwZXxocmVmfGhlaWdodHx3aWR0aFwiLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0eXBlXCIgPyAxIDogMiApO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBkZWZhdWx0VmFsdWUgaW4gcGxhY2Ugb2YgZ2V0QXR0cmlidXRlKFwidmFsdWVcIilcbmlmICggIXN1cHBvcnQuYXR0cmlidXRlcyB8fCAhYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0ZWwuaW5uZXJIVE1MID0gXCI8aW5wdXQvPlwiO1xuXHRlbC5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiLCBcIlwiICk7XG5cdHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IFwiXCI7XG59KSApIHtcblx0YWRkSGFuZGxlKCBcInZhbHVlXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLmRlZmF1bHRWYWx1ZTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZ2V0QXR0cmlidXRlTm9kZSB0byBmZXRjaCBib29sZWFucyB3aGVuIGdldEF0dHJpYnV0ZSBsaWVzXG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRyZXR1cm4gZWwuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIikgPT0gbnVsbDtcbn0pICkge1xuXHRhZGRIYW5kbGUoIGJvb2xlYW5zLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHZhbDtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtWyBuYW1lIF0gPT09IHRydWUgPyBuYW1lLnRvTG93ZXJDYXNlKCkgOlxuXHRcdFx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKSkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0bnVsbDtcblx0XHR9XG5cdH0pO1xufVxuXG5yZXR1cm4gU2l6emxlO1xuXG59KSggd2luZG93ICk7XG5cblxuXG5qUXVlcnkuZmluZCA9IFNpenpsZTtcbmpRdWVyeS5leHByID0gU2l6emxlLnNlbGVjdG9ycztcblxuLy8gRGVwcmVjYXRlZFxualF1ZXJ5LmV4cHJbIFwiOlwiIF0gPSBqUXVlcnkuZXhwci5wc2V1ZG9zO1xualF1ZXJ5LnVuaXF1ZVNvcnQgPSBqUXVlcnkudW5pcXVlID0gU2l6emxlLnVuaXF1ZVNvcnQ7XG5qUXVlcnkudGV4dCA9IFNpenpsZS5nZXRUZXh0O1xualF1ZXJ5LmlzWE1MRG9jID0gU2l6emxlLmlzWE1MO1xualF1ZXJ5LmNvbnRhaW5zID0gU2l6emxlLmNvbnRhaW5zO1xualF1ZXJ5LmVzY2FwZVNlbGVjdG9yID0gU2l6emxlLmVzY2FwZTtcblxuXG5cblxudmFyIGRpciA9IGZ1bmN0aW9uKCBlbGVtLCBkaXIsIHVudGlsICkge1xuXHR2YXIgbWF0Y2hlZCA9IFtdLFxuXHRcdHRydW5jYXRlID0gdW50aWwgIT09IHVuZGVmaW5lZDtcblxuXHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgJiYgZWxlbS5ub2RlVHlwZSAhPT0gOSApIHtcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRpZiAoIHRydW5jYXRlICYmIGpRdWVyeSggZWxlbSApLmlzKCB1bnRpbCApICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdG1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxudmFyIHNpYmxpbmdzID0gZnVuY3Rpb24oIG4sIGVsZW0gKSB7XG5cdHZhciBtYXRjaGVkID0gW107XG5cblx0Zm9yICggOyBuOyBuID0gbi5uZXh0U2libGluZyApIHtcblx0XHRpZiAoIG4ubm9kZVR5cGUgPT09IDEgJiYgbiAhPT0gZWxlbSApIHtcblx0XHRcdG1hdGNoZWQucHVzaCggbiApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgcm5lZWRzQ29udGV4dCA9IGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dDtcblxuXG5cbmZ1bmN0aW9uIG5vZGVOYW1lKCBlbGVtLCBuYW1lICkge1xuXG4gIHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG59O1xudmFyIHJzaW5nbGVUYWcgPSAoIC9ePChbYS16XVteXFwvXFwwPjpcXHgyMFxcdFxcclxcblxcZl0qKVtcXHgyMFxcdFxcclxcblxcZl0qXFwvPz4oPzo8XFwvXFwxPnwpJC9pICk7XG5cblxuXG4vLyBJbXBsZW1lbnQgdGhlIGlkZW50aWNhbCBmdW5jdGlvbmFsaXR5IGZvciBmaWx0ZXIgYW5kIG5vdFxuZnVuY3Rpb24gd2lubm93KCBlbGVtZW50cywgcXVhbGlmaWVyLCBub3QgKSB7XG5cdGlmICggaXNGdW5jdGlvbiggcXVhbGlmaWVyICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gISFxdWFsaWZpZXIuY2FsbCggZWxlbSwgaSwgZWxlbSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gU2luZ2xlIGVsZW1lbnRcblx0aWYgKCBxdWFsaWZpZXIubm9kZVR5cGUgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBlbGVtID09PSBxdWFsaWZpZXIgKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEFycmF5bGlrZSBvZiBlbGVtZW50cyAoalF1ZXJ5LCBhcmd1bWVudHMsIEFycmF5KVxuXHRpZiAoIHR5cGVvZiBxdWFsaWZpZXIgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBpbmRleE9mLmNhbGwoIHF1YWxpZmllciwgZWxlbSApID4gLTEgKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEZpbHRlcmVkIGRpcmVjdGx5IGZvciBib3RoIHNpbXBsZSBhbmQgY29tcGxleCBzZWxlY3RvcnNcblx0cmV0dXJuIGpRdWVyeS5maWx0ZXIoIHF1YWxpZmllciwgZWxlbWVudHMsIG5vdCApO1xufVxuXG5qUXVlcnkuZmlsdGVyID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1zLCBub3QgKSB7XG5cdHZhciBlbGVtID0gZWxlbXNbIDAgXTtcblxuXHRpZiAoIG5vdCApIHtcblx0XHRleHByID0gXCI6bm90KFwiICsgZXhwciArIFwiKVwiO1xuXHR9XG5cblx0aWYgKCBlbGVtcy5sZW5ndGggPT09IDEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBlbGVtLCBleHByICkgPyBbIGVsZW0gXSA6IFtdO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXMoIGV4cHIsIGpRdWVyeS5ncmVwKCBlbGVtcywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDE7XG5cdH0gKSApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmaW5kOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGksIHJldCxcblx0XHRcdGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5KCBzZWxlY3RvciApLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHNlbGZbIGkgXSwgdGhpcyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICkgKTtcblx0XHR9XG5cblx0XHRyZXQgPSB0aGlzLnB1c2hTdGFjayggW10gKTtcblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRqUXVlcnkuZmluZCggc2VsZWN0b3IsIHNlbGZbIGkgXSwgcmV0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGxlbiA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggcmV0ICkgOiByZXQ7XG5cdH0sXG5cdGZpbHRlcjogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgZmFsc2UgKSApO1xuXHR9LFxuXHRub3Q6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIHRydWUgKSApO1xuXHR9LFxuXHRpczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiAhIXdpbm5vdyhcblx0XHRcdHRoaXMsXG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBwb3NpdGlvbmFsL3JlbGF0aXZlIHNlbGVjdG9yLCBjaGVjayBtZW1iZXJzaGlwIGluIHRoZSByZXR1cm5lZCBzZXRcblx0XHRcdC8vIHNvICQoXCJwOmZpcnN0XCIpLmlzKFwicDpsYXN0XCIpIHdvbid0IHJldHVybiB0cnVlIGZvciBhIGRvYyB3aXRoIHR3byBcInBcIi5cblx0XHRcdHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiAmJiBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICkgP1xuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9yICkgOlxuXHRcdFx0XHRzZWxlY3RvciB8fCBbXSxcblx0XHRcdGZhbHNlXG5cdFx0KS5sZW5ndGg7XG5cdH1cbn0gKTtcblxuXG4vLyBJbml0aWFsaXplIGEgalF1ZXJ5IG9iamVjdFxuXG5cbi8vIEEgY2VudHJhbCByZWZlcmVuY2UgdG8gdGhlIHJvb3QgalF1ZXJ5KGRvY3VtZW50KVxudmFyIHJvb3RqUXVlcnksXG5cblx0Ly8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3Ncblx0Ly8gUHJpb3JpdGl6ZSAjaWQgb3ZlciA8dGFnPiB0byBhdm9pZCBYU1MgdmlhIGxvY2F0aW9uLmhhc2ggKCM5NTIxKVxuXHQvLyBTdHJpY3QgSFRNTCByZWNvZ25pdGlvbiAoIzExMjkwOiBtdXN0IHN0YXJ0IHdpdGggPClcblx0Ly8gU2hvcnRjdXQgc2ltcGxlICNpZCBjYXNlIGZvciBzcGVlZFxuXHRycXVpY2tFeHByID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKykpJC8sXG5cblx0aW5pdCA9IGpRdWVyeS5mbi5pbml0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByb290ICkge1xuXHRcdHZhciBtYXRjaCwgZWxlbTtcblxuXHRcdC8vIEhBTkRMRTogJChcIlwiKSwgJChudWxsKSwgJCh1bmRlZmluZWQpLCAkKGZhbHNlKVxuXHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gTWV0aG9kIGluaXQoKSBhY2NlcHRzIGFuIGFsdGVybmF0ZSByb290alF1ZXJ5XG5cdFx0Ly8gc28gbWlncmF0ZSBjYW4gc3VwcG9ydCBqUXVlcnkuc3ViIChnaC0yMTAxKVxuXHRcdHJvb3QgPSByb290IHx8IHJvb3RqUXVlcnk7XG5cblx0XHQvLyBIYW5kbGUgSFRNTCBzdHJpbmdzXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRpZiAoIHNlbGVjdG9yWyAwIF0gPT09IFwiPFwiICYmXG5cdFx0XHRcdHNlbGVjdG9yWyBzZWxlY3Rvci5sZW5ndGggLSAxIF0gPT09IFwiPlwiICYmXG5cdFx0XHRcdHNlbGVjdG9yLmxlbmd0aCA+PSAzICkge1xuXG5cdFx0XHRcdC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXG5cdFx0XHRcdG1hdGNoID0gWyBudWxsLCBzZWxlY3RvciwgbnVsbCBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWF0Y2ggaHRtbCBvciBtYWtlIHN1cmUgbm8gY29udGV4dCBpcyBzcGVjaWZpZWQgZm9yICNpZFxuXHRcdFx0aWYgKCBtYXRjaCAmJiAoIG1hdGNoWyAxIF0gfHwgIWNvbnRleHQgKSApIHtcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCkgLT4gJChhcnJheSlcblx0XHRcdFx0aWYgKCBtYXRjaFsgMSBdICkge1xuXHRcdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFsgMCBdIDogY29udGV4dDtcblxuXHRcdFx0XHRcdC8vIE9wdGlvbiB0byBydW4gc2NyaXB0cyBpcyB0cnVlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRcdC8vIEludGVudGlvbmFsbHkgbGV0IHRoZSBlcnJvciBiZSB0aHJvd24gaWYgcGFyc2VIVE1MIGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLCBqUXVlcnkucGFyc2VIVE1MKFxuXHRcdFx0XHRcdFx0bWF0Y2hbIDEgXSxcblx0XHRcdFx0XHRcdGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQsXG5cdFx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdFx0KSApO1xuXG5cdFx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwsIHByb3BzKVxuXHRcdFx0XHRcdGlmICggcnNpbmdsZVRhZy50ZXN0KCBtYXRjaFsgMSBdICkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvbnRleHQgKSApIHtcblx0XHRcdFx0XHRcdGZvciAoIG1hdGNoIGluIGNvbnRleHQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUHJvcGVydGllcyBvZiBjb250ZXh0IGFyZSBjYWxsZWQgYXMgbWV0aG9kcyBpZiBwb3NzaWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHRoaXNbIG1hdGNoIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzWyBtYXRjaCBdKCBjb250ZXh0WyBtYXRjaCBdICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIG90aGVyd2lzZSBzZXQgYXMgYXR0cmlidXRlc1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuYXR0ciggbWF0Y2gsIGNvbnRleHRbIG1hdGNoIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJCgjaWQpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBtYXRjaFsgMiBdICk7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIEluamVjdCB0aGUgZWxlbWVudCBkaXJlY3RseSBpbnRvIHRoZSBqUXVlcnkgb2JqZWN0XG5cdFx0XHRcdFx0XHR0aGlzWyAwIF0gPSBlbGVtO1xuXHRcdFx0XHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgJCguLi4pKVxuXHRcdFx0fSBlbHNlIGlmICggIWNvbnRleHQgfHwgY29udGV4dC5qcXVlcnkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGNvbnRleHQgfHwgcm9vdCApLmZpbmQoIHNlbGVjdG9yICk7XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCBjb250ZXh0KVxuXHRcdFx0Ly8gKHdoaWNoIGlzIGp1c3QgZXF1aXZhbGVudCB0bzogJChjb250ZXh0KS5maW5kKGV4cHIpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3RvciggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHQvLyBIQU5ETEU6ICQoRE9NRWxlbWVudClcblx0XHR9IGVsc2UgaWYgKCBzZWxlY3Rvci5ub2RlVHlwZSApIHtcblx0XHRcdHRoaXNbIDAgXSA9IHNlbGVjdG9yO1xuXHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHQvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXG5cdFx0Ly8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XG5cdFx0fSBlbHNlIGlmICggaXNGdW5jdGlvbiggc2VsZWN0b3IgKSApIHtcblx0XHRcdHJldHVybiByb290LnJlYWR5ICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRyb290LnJlYWR5KCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBFeGVjdXRlIGltbWVkaWF0ZWx5IGlmIHJlYWR5IGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdHNlbGVjdG9yKCBqUXVlcnkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IsIHRoaXMgKTtcblx0fTtcblxuLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxuaW5pdC5wcm90b3R5cGUgPSBqUXVlcnkuZm47XG5cbi8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2VcbnJvb3RqUXVlcnkgPSBqUXVlcnkoIGRvY3VtZW50ICk7XG5cblxudmFyIHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxuXG5cdC8vIE1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0XG5cdGd1YXJhbnRlZWRVbmlxdWUgPSB7XG5cdFx0Y2hpbGRyZW46IHRydWUsXG5cdFx0Y29udGVudHM6IHRydWUsXG5cdFx0bmV4dDogdHJ1ZSxcblx0XHRwcmV2OiB0cnVlXG5cdH07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aGFzOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdHZhciB0YXJnZXRzID0galF1ZXJ5KCB0YXJnZXQsIHRoaXMgKSxcblx0XHRcdGwgPSB0YXJnZXRzLmxlbmd0aDtcblxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCB0aGlzLCB0YXJnZXRzWyBpIF0gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRjbG9zZXN0OiBmdW5jdGlvbiggc2VsZWN0b3JzLCBjb250ZXh0ICkge1xuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aCxcblx0XHRcdG1hdGNoZWQgPSBbXSxcblx0XHRcdHRhcmdldHMgPSB0eXBlb2Ygc2VsZWN0b3JzICE9PSBcInN0cmluZ1wiICYmIGpRdWVyeSggc2VsZWN0b3JzICk7XG5cblx0XHQvLyBQb3NpdGlvbmFsIHNlbGVjdG9ycyBuZXZlciBtYXRjaCwgc2luY2UgdGhlcmUncyBubyBfc2VsZWN0aW9uXyBjb250ZXh0XG5cdFx0aWYgKCAhcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvcnMgKSApIHtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zm9yICggY3VyID0gdGhpc1sgaSBdOyBjdXIgJiYgY3VyICE9PSBjb250ZXh0OyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblxuXHRcdFx0XHRcdC8vIEFsd2F5cyBza2lwIGRvY3VtZW50IGZyYWdtZW50c1xuXHRcdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlIDwgMTEgJiYgKCB0YXJnZXRzID9cblx0XHRcdFx0XHRcdHRhcmdldHMuaW5kZXgoIGN1ciApID4gLTEgOlxuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBTaXp6bGVcblx0XHRcdFx0XHRcdGN1ci5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGN1ciwgc2VsZWN0b3JzICkgKSApIHtcblxuXHRcdFx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKSA6IG1hdGNoZWQgKTtcblx0fSxcblxuXHQvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgd2l0aGluIHRoZSBzZXRcblx0aW5kZXg6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gTm8gYXJndW1lbnQsIHJldHVybiBpbmRleCBpbiBwYXJlbnRcblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuICggdGhpc1sgMCBdICYmIHRoaXNbIDAgXS5wYXJlbnROb2RlICkgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xuXHRcdH1cblxuXHRcdC8vIEluZGV4IGluIHNlbGVjdG9yXG5cdFx0aWYgKCB0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBpbmRleE9mLmNhbGwoIGpRdWVyeSggZWxlbSApLCB0aGlzWyAwIF0gKTtcblx0XHR9XG5cblx0XHQvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcblx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCB0aGlzLFxuXG5cdFx0XHQvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcblx0XHRcdGVsZW0uanF1ZXJ5ID8gZWxlbVsgMCBdIDogZWxlbVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKFxuXHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoXG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcy5nZXQoKSwgalF1ZXJ5KCBzZWxlY3RvciwgY29udGV4dCApIClcblx0XHRcdClcblx0XHQpO1xuXHR9LFxuXG5cdGFkZEJhY2s6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgP1xuXHRcdFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlciggc2VsZWN0b3IgKVxuXHRcdCk7XG5cdH1cbn0gKTtcblxuZnVuY3Rpb24gc2libGluZyggY3VyLCBkaXIgKSB7XG5cdHdoaWxlICggKCBjdXIgPSBjdXJbIGRpciBdICkgJiYgY3VyLm5vZGVUeXBlICE9PSAxICkge31cblx0cmV0dXJuIGN1cjtcbn1cblxualF1ZXJ5LmVhY2goIHtcblx0cGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XG5cdH0sXG5cdHBhcmVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiICk7XG5cdH0sXG5cdHBhcmVudHNVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiLCB1bnRpbCApO1xuXHR9LFxuXHRuZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXY6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0cHJldlVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0c2libGluZ3M6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggKCBlbGVtLnBhcmVudE5vZGUgfHwge30gKS5maXJzdENoaWxkLCBlbGVtICk7XG5cdH0sXG5cdGNoaWxkcmVuOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoIGVsZW0uZmlyc3RDaGlsZCApO1xuXHR9LFxuXHRjb250ZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgIGlmICggbm9kZU5hbWUoIGVsZW0sIFwiaWZyYW1lXCIgKSApIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtLmNvbnRlbnREb2N1bWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5LCBpT1MgNyBvbmx5LCBBbmRyb2lkIEJyb3dzZXIgPD00LjMgb25seVxuICAgICAgICAvLyBUcmVhdCB0aGUgdGVtcGxhdGUgZWxlbWVudCBhcyBhIHJlZ3VsYXIgb25lIGluIGJyb3dzZXJzIHRoYXRcbiAgICAgICAgLy8gZG9uJ3Qgc3VwcG9ydCBpdC5cbiAgICAgICAgaWYgKCBub2RlTmFtZSggZWxlbSwgXCJ0ZW1wbGF0ZVwiICkgKSB7XG4gICAgICAgICAgICBlbGVtID0gZWxlbS5jb250ZW50IHx8IGVsZW07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgZWxlbS5jaGlsZE5vZGVzICk7XG5cdH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBmbiApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggdW50aWwsIHNlbGVjdG9yICkge1xuXHRcdHZhciBtYXRjaGVkID0galF1ZXJ5Lm1hcCggdGhpcywgZm4sIHVudGlsICk7XG5cblx0XHRpZiAoIG5hbWUuc2xpY2UoIC01ICkgIT09IFwiVW50aWxcIiApIHtcblx0XHRcdHNlbGVjdG9yID0gdW50aWw7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3RvciAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRtYXRjaGVkID0galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIG1hdGNoZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGR1cGxpY2F0ZXNcblx0XHRcdGlmICggIWd1YXJhbnRlZWRVbmlxdWVbIG5hbWUgXSApIHtcblx0XHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV2ZXJzZSBvcmRlciBmb3IgcGFyZW50cyogYW5kIHByZXYtZGVyaXZhdGl2ZXNcblx0XHRcdGlmICggcnBhcmVudHNwcmV2LnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0bWF0Y2hlZC5yZXZlcnNlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkICk7XG5cdH07XG59ICk7XG52YXIgcm5vdGh0bWx3aGl0ZSA9ICggL1teXFx4MjBcXHRcXHJcXG5cXGZdKy9nICk7XG5cblxuXG4vLyBDb252ZXJ0IFN0cmluZy1mb3JtYXR0ZWQgb3B0aW9ucyBpbnRvIE9iamVjdC1mb3JtYXR0ZWQgb25lc1xuZnVuY3Rpb24gY3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIHtcblx0dmFyIG9iamVjdCA9IHt9O1xuXHRqUXVlcnkuZWFjaCggb3B0aW9ucy5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdLCBmdW5jdGlvbiggXywgZmxhZyApIHtcblx0XHRvYmplY3RbIGZsYWcgXSA9IHRydWU7XG5cdH0gKTtcblx0cmV0dXJuIG9iamVjdDtcbn1cblxuLypcbiAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICpcbiAqXHRvcHRpb25zOiBhbiBvcHRpb25hbCBsaXN0IG9mIHNwYWNlLXNlcGFyYXRlZCBvcHRpb25zIHRoYXQgd2lsbCBjaGFuZ2UgaG93XG4gKlx0XHRcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3RcbiAqXG4gKiBCeSBkZWZhdWx0IGEgY2FsbGJhY2sgbGlzdCB3aWxsIGFjdCBsaWtlIGFuIGV2ZW50IGNhbGxiYWNrIGxpc3QgYW5kIGNhbiBiZVxuICogXCJmaXJlZFwiIG11bHRpcGxlIHRpbWVzLlxuICpcbiAqIFBvc3NpYmxlIG9wdGlvbnM6XG4gKlxuICpcdG9uY2U6XHRcdFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHRtZW1vcnk6XHRcdFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxuICpcdFx0XHRcdFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXCJtZW1vcml6ZWRcIlxuICpcdFx0XHRcdFx0dmFsdWVzIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdHVuaXF1ZTpcdFx0XHR3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdClcbiAqXG4gKlx0c3RvcE9uRmFsc2U6XHRpbnRlcnJ1cHQgY2FsbGluZ3Mgd2hlbiBhIGNhbGxiYWNrIHJldHVybnMgZmFsc2VcbiAqXG4gKi9cbmpRdWVyeS5DYWxsYmFja3MgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHQvLyBDb252ZXJ0IG9wdGlvbnMgZnJvbSBTdHJpbmctZm9ybWF0dGVkIHRvIE9iamVjdC1mb3JtYXR0ZWQgaWYgbmVlZGVkXG5cdC8vICh3ZSBjaGVjayBpbiBjYWNoZSBmaXJzdClcblx0b3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiID9cblx0XHRjcmVhdGVPcHRpb25zKCBvcHRpb25zICkgOlxuXHRcdGpRdWVyeS5leHRlbmQoIHt9LCBvcHRpb25zICk7XG5cblx0dmFyIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IGlzIGN1cnJlbnRseSBmaXJpbmdcblx0XHRmaXJpbmcsXG5cblx0XHQvLyBMYXN0IGZpcmUgdmFsdWUgZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0c1xuXHRcdG1lbW9yeSxcblxuXHRcdC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXG5cdFx0ZmlyZWQsXG5cblx0XHQvLyBGbGFnIHRvIHByZXZlbnQgZmlyaW5nXG5cdFx0bG9ja2VkLFxuXG5cdFx0Ly8gQWN0dWFsIGNhbGxiYWNrIGxpc3Rcblx0XHRsaXN0ID0gW10sXG5cblx0XHQvLyBRdWV1ZSBvZiBleGVjdXRpb24gZGF0YSBmb3IgcmVwZWF0YWJsZSBsaXN0c1xuXHRcdHF1ZXVlID0gW10sXG5cblx0XHQvLyBJbmRleCBvZiBjdXJyZW50bHkgZmlyaW5nIGNhbGxiYWNrIChtb2RpZmllZCBieSBhZGQvcmVtb3ZlIGFzIG5lZWRlZClcblx0XHRmaXJpbmdJbmRleCA9IC0xLFxuXG5cdFx0Ly8gRmlyZSBjYWxsYmFja3Ncblx0XHRmaXJlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuZm9yY2Ugc2luZ2xlLWZpcmluZ1xuXHRcdFx0bG9ja2VkID0gbG9ja2VkIHx8IG9wdGlvbnMub25jZTtcblxuXHRcdFx0Ly8gRXhlY3V0ZSBjYWxsYmFja3MgZm9yIGFsbCBwZW5kaW5nIGV4ZWN1dGlvbnMsXG5cdFx0XHQvLyByZXNwZWN0aW5nIGZpcmluZ0luZGV4IG92ZXJyaWRlcyBhbmQgcnVudGltZSBjaGFuZ2VzXG5cdFx0XHRmaXJlZCA9IGZpcmluZyA9IHRydWU7XG5cdFx0XHRmb3IgKCA7IHF1ZXVlLmxlbmd0aDsgZmlyaW5nSW5kZXggPSAtMSApIHtcblx0XHRcdFx0bWVtb3J5ID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdFx0d2hpbGUgKCArK2ZpcmluZ0luZGV4IDwgbGlzdC5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHQvLyBSdW4gY2FsbGJhY2sgYW5kIGNoZWNrIGZvciBlYXJseSB0ZXJtaW5hdGlvblxuXHRcdFx0XHRcdGlmICggbGlzdFsgZmlyaW5nSW5kZXggXS5hcHBseSggbWVtb3J5WyAwIF0sIG1lbW9yeVsgMSBdICkgPT09IGZhbHNlICYmXG5cdFx0XHRcdFx0XHRvcHRpb25zLnN0b3BPbkZhbHNlICkge1xuXG5cdFx0XHRcdFx0XHQvLyBKdW1wIHRvIGVuZCBhbmQgZm9yZ2V0IHRoZSBkYXRhIHNvIC5hZGQgZG9lc24ndCByZS1maXJlXG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvcmdldCB0aGUgZGF0YSBpZiB3ZSdyZSBkb25lIHdpdGggaXRcblx0XHRcdGlmICggIW9wdGlvbnMubWVtb3J5ICkge1xuXHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0ZmlyaW5nID0gZmFsc2U7XG5cblx0XHRcdC8vIENsZWFuIHVwIGlmIHdlJ3JlIGRvbmUgZmlyaW5nIGZvciBnb29kXG5cdFx0XHRpZiAoIGxvY2tlZCApIHtcblxuXHRcdFx0XHQvLyBLZWVwIGFuIGVtcHR5IGxpc3QgaWYgd2UgaGF2ZSBkYXRhIGZvciBmdXR1cmUgYWRkIGNhbGxzXG5cdFx0XHRcdGlmICggbWVtb3J5ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIHRoaXMgb2JqZWN0IGlzIHNwZW50XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGlzdCA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gQWN0dWFsIENhbGxiYWNrcyBvYmplY3Rcblx0XHRzZWxmID0ge1xuXG5cdFx0XHQvLyBBZGQgYSBjYWxsYmFjayBvciBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIHRoZSBsaXN0XG5cdFx0XHRhZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBoYXZlIG1lbW9yeSBmcm9tIGEgcGFzdCBydW4sIHdlIHNob3VsZCBmaXJlIGFmdGVyIGFkZGluZ1xuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoIC0gMTtcblx0XHRcdFx0XHRcdHF1ZXVlLnB1c2goIG1lbW9yeSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdCggZnVuY3Rpb24gYWRkKCBhcmdzICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3MsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCAhb3B0aW9ucy51bmlxdWUgfHwgIXNlbGYuaGFzKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGxpc3QucHVzaCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBhcmcgJiYgYXJnLmxlbmd0aCAmJiB0b1R5cGUoIGFyZyApICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gSW5zcGVjdCByZWN1cnNpdmVseVxuXHRcdFx0XHRcdFx0XHRcdGFkZCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9ICkoIGFyZ3VtZW50cyApO1xuXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYSBjYWxsYmFjayBmcm9tIHRoZSBsaXN0XG5cdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZWFjaCggYXJndW1lbnRzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdHZhciBpbmRleDtcblx0XHRcdFx0XHR3aGlsZSAoICggaW5kZXggPSBqUXVlcnkuaW5BcnJheSggYXJnLCBsaXN0LCBpbmRleCApICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdGxpc3Quc3BsaWNlKCBpbmRleCwgMSApO1xuXG5cdFx0XHRcdFx0XHQvLyBIYW5kbGUgZmlyaW5nIGluZGV4ZXNcblx0XHRcdFx0XHRcdGlmICggaW5kZXggPD0gZmlyaW5nSW5kZXggKSB7XG5cdFx0XHRcdFx0XHRcdGZpcmluZ0luZGV4LS07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgYSBnaXZlbiBjYWxsYmFjayBpcyBpbiB0aGUgbGlzdC5cblx0XHRcdC8vIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCByZXR1cm4gd2hldGhlciBvciBub3QgbGlzdCBoYXMgY2FsbGJhY2tzIGF0dGFjaGVkLlxuXHRcdFx0aGFzOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdHJldHVybiBmbiA/XG5cdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGZuLCBsaXN0ICkgPiAtMSA6XG5cdFx0XHRcdFx0bGlzdC5sZW5ndGggPiAwO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGFsbCBjYWxsYmFja3MgZnJvbSB0aGUgbGlzdFxuXHRcdFx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZSBhbmQgLmFkZFxuXHRcdFx0Ly8gQWJvcnQgYW55IGN1cnJlbnQvcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHQvLyBDbGVhciBhbGwgY2FsbGJhY2tzIGFuZCB2YWx1ZXNcblx0XHRcdGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0ZGlzYWJsZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gIWxpc3Q7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlXG5cdFx0XHQvLyBBbHNvIGRpc2FibGUgLmFkZCB1bmxlc3Mgd2UgaGF2ZSBtZW1vcnkgKHNpbmNlIGl0IHdvdWxkIGhhdmUgbm8gZWZmZWN0KVxuXHRcdFx0Ly8gQWJvcnQgYW55IHBlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0bG9jazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGlmICggIW1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGxvY2tlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWxvY2tlZDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGFuZCBhcmd1bWVudHNcblx0XHRcdGZpcmVXaXRoOiBmdW5jdGlvbiggY29udGV4dCwgYXJncyApIHtcblx0XHRcdFx0aWYgKCAhbG9ja2VkICkge1xuXHRcdFx0XHRcdGFyZ3MgPSBhcmdzIHx8IFtdO1xuXHRcdFx0XHRcdGFyZ3MgPSBbIGNvbnRleHQsIGFyZ3Muc2xpY2UgPyBhcmdzLnNsaWNlKCkgOiBhcmdzIF07XG5cdFx0XHRcdFx0cXVldWUucHVzaCggYXJncyApO1xuXHRcdFx0XHRcdGlmICggIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCB0aGUgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYuZmlyZVdpdGgoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgdGhlIGNhbGxiYWNrcyBoYXZlIGFscmVhZHkgYmVlbiBjYWxsZWQgYXQgbGVhc3Qgb25jZVxuXHRcdFx0ZmlyZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFmaXJlZDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdHJldHVybiBzZWxmO1xufTtcblxuXG5mdW5jdGlvbiBJZGVudGl0eSggdiApIHtcblx0cmV0dXJuIHY7XG59XG5mdW5jdGlvbiBUaHJvd2VyKCBleCApIHtcblx0dGhyb3cgZXg7XG59XG5cbmZ1bmN0aW9uIGFkb3B0VmFsdWUoIHZhbHVlLCByZXNvbHZlLCByZWplY3QsIG5vVmFsdWUgKSB7XG5cdHZhciBtZXRob2Q7XG5cblx0dHJ5IHtcblxuXHRcdC8vIENoZWNrIGZvciBwcm9taXNlIGFzcGVjdCBmaXJzdCB0byBwcml2aWxlZ2Ugc3luY2hyb25vdXMgYmVoYXZpb3Jcblx0XHRpZiAoIHZhbHVlICYmIGlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUucHJvbWlzZSApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUgKS5kb25lKCByZXNvbHZlICkuZmFpbCggcmVqZWN0ICk7XG5cblx0XHQvLyBPdGhlciB0aGVuYWJsZXNcblx0XHR9IGVsc2UgaWYgKCB2YWx1ZSAmJiBpc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnRoZW4gKSApICkge1xuXHRcdFx0bWV0aG9kLmNhbGwoIHZhbHVlLCByZXNvbHZlLCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIG5vbi10aGVuYWJsZXNcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb250cm9sIGByZXNvbHZlYCBhcmd1bWVudHMgYnkgbGV0dGluZyBBcnJheSNzbGljZSBjYXN0IGJvb2xlYW4gYG5vVmFsdWVgIHRvIGludGVnZXI6XG5cdFx0XHQvLyAqIGZhbHNlOiBbIHZhbHVlIF0uc2xpY2UoIDAgKSA9PiByZXNvbHZlKCB2YWx1ZSApXG5cdFx0XHQvLyAqIHRydWU6IFsgdmFsdWUgXS5zbGljZSggMSApID0+IHJlc29sdmUoKVxuXHRcdFx0cmVzb2x2ZS5hcHBseSggdW5kZWZpbmVkLCBbIHZhbHVlIF0uc2xpY2UoIG5vVmFsdWUgKSApO1xuXHRcdH1cblxuXHQvLyBGb3IgUHJvbWlzZXMvQSssIGNvbnZlcnQgZXhjZXB0aW9ucyBpbnRvIHJlamVjdGlvbnNcblx0Ly8gU2luY2UgalF1ZXJ5LndoZW4gZG9lc24ndCB1bndyYXAgdGhlbmFibGVzLCB3ZSBjYW4gc2tpcCB0aGUgZXh0cmEgY2hlY2tzIGFwcGVhcmluZyBpblxuXHQvLyBEZWZlcnJlZCN0aGVuIHRvIGNvbmRpdGlvbmFsbHkgc3VwcHJlc3MgcmVqZWN0aW9uLlxuXHR9IGNhdGNoICggdmFsdWUgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCBvbmx5XG5cdFx0Ly8gU3RyaWN0IG1vZGUgZnVuY3Rpb25zIGludm9rZWQgd2l0aG91dCAuY2FsbC8uYXBwbHkgZ2V0IGdsb2JhbC1vYmplY3QgY29udGV4dFxuXHRcdHJlamVjdC5hcHBseSggdW5kZWZpbmVkLCBbIHZhbHVlIF0gKTtcblx0fVxufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0RGVmZXJyZWQ6IGZ1bmN0aW9uKCBmdW5jICkge1xuXHRcdHZhciB0dXBsZXMgPSBbXG5cblx0XHRcdFx0Ly8gYWN0aW9uLCBhZGQgbGlzdGVuZXIsIGNhbGxiYWNrcyxcblx0XHRcdFx0Ly8gLi4uIC50aGVuIGhhbmRsZXJzLCBhcmd1bWVudCBpbmRleCwgW2ZpbmFsIHN0YXRlXVxuXHRcdFx0XHRbIFwibm90aWZ5XCIsIFwicHJvZ3Jlc3NcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSwgMiBdLFxuXHRcdFx0XHRbIFwicmVzb2x2ZVwiLCBcImRvbmVcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIDAsIFwicmVzb2x2ZWRcIiBdLFxuXHRcdFx0XHRbIFwicmVqZWN0XCIsIFwiZmFpbFwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMSwgXCJyZWplY3RlZFwiIF1cblx0XHRcdF0sXG5cdFx0XHRzdGF0ZSA9IFwicGVuZGluZ1wiLFxuXHRcdFx0cHJvbWlzZSA9IHtcblx0XHRcdFx0c3RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0YWx3YXlzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5kb25lKCBhcmd1bWVudHMgKS5mYWlsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblx0XHRcdFx0XCJjYXRjaFwiOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHByb21pc2UudGhlbiggbnVsbCwgZm4gKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBLZWVwIHBpcGUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdHBpcGU6IGZ1bmN0aW9uKCAvKiBmbkRvbmUsIGZuRmFpbCwgZm5Qcm9ncmVzcyAqLyApIHtcblx0XHRcdFx0XHR2YXIgZm5zID0gYXJndW1lbnRzO1xuXG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIE1hcCB0dXBsZXMgKHByb2dyZXNzLCBkb25lLCBmYWlsKSB0byBhcmd1bWVudHMgKGRvbmUsIGZhaWwsIHByb2dyZXNzKVxuXHRcdFx0XHRcdFx0XHR2YXIgZm4gPSBpc0Z1bmN0aW9uKCBmbnNbIHR1cGxlWyA0IF0gXSApICYmIGZuc1sgdHVwbGVbIDQgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLnByb2dyZXNzKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLm5vdGlmeSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5kb25lKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlc29sdmUgfSlcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZmFpbChmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZWplY3QgfSlcblx0XHRcdFx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAxIF0gXSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkID0gZm4gJiYgZm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgJiYgaXNGdW5jdGlvbiggcmV0dXJuZWQucHJvbWlzZSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQucHJvbWlzZSgpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5wcm9ncmVzcyggbmV3RGVmZXIubm90aWZ5IClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmRvbmUoIG5ld0RlZmVyLnJlc29sdmUgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZmFpbCggbmV3RGVmZXIucmVqZWN0ICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXShcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm4gPyBbIHJldHVybmVkIF0gOiBhcmd1bWVudHNcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRmbnMgPSBudWxsO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRoZW46IGZ1bmN0aW9uKCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcyApIHtcblx0XHRcdFx0XHR2YXIgbWF4RGVwdGggPSAwO1xuXHRcdFx0XHRcdGZ1bmN0aW9uIHJlc29sdmUoIGRlcHRoLCBkZWZlcnJlZCwgaGFuZGxlciwgc3BlY2lhbCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkLCB0aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuM1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElnbm9yZSBkb3VibGUtcmVzb2x1dGlvbiBhdHRlbXB0c1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCA8IG1heERlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkID0gaGFuZGxlci5hcHBseSggdGhhdCwgYXJncyApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4xXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC00OFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCA9PT0gZGVmZXJyZWQucHJvbWlzZSgpICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCBcIlRoZW5hYmxlIHNlbGYtcmVzb2x1dGlvblwiICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb25zIDIuMy4zLjEsIDMuNVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTRcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTc1XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBSZXRyaWV2ZSBgdGhlbmAgb25seSBvbmNlXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGVuID0gcmV0dXJuZWQgJiZcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy40XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTY0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgY2hlY2sgb2JqZWN0cyBhbmQgZnVuY3Rpb25zIGZvciB0aGVuYWJpbGl0eVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoIHR5cGVvZiByZXR1cm5lZCA9PT0gXCJvYmplY3RcIiB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiByZXR1cm5lZCA9PT0gXCJmdW5jdGlvblwiICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQudGhlbjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGEgcmV0dXJuZWQgdGhlbmFibGVcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggdGhlbiApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFNwZWNpYWwgcHJvY2Vzc29ycyAobm90aWZ5KSBqdXN0IHdhaXQgZm9yIHJlc29sdXRpb25cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBhbHNvIGhvb2sgaW50byBwcm9ncmVzc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIGRpc3JlZ2FyZCBvbGRlciByZXNvbHV0aW9uIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1heERlcHRoKys7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGVuLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYWxsIG90aGVyIHJldHVybmVkIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IElkZW50aXR5ICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IFsgcmV0dXJuZWQgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFByb2Nlc3MgdGhlIHZhbHVlKHMpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmF1bHQgcHJvY2VzcyBpcyByZXNvbHZlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggc3BlY2lhbCB8fCBkZWZlcnJlZC5yZXNvbHZlV2l0aCApKCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgbm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGNhdGNoIGFuZCByZWplY3QgZXhjZXB0aW9uc1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MgPSBzcGVjaWFsID9cblx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgOlxuXHRcdFx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdygpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayggZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjQuMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTYxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIHBvc3QtcmVzb2x1dGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCArIDEgPj0gbWF4RGVwdGggKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBoYW5kbGVyICE9PSBUaHJvd2VyICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGF0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyBlIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjFcblx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTdcblx0XHRcdFx0XHRcdFx0Ly8gUmUtcmVzb2x2ZSBwcm9taXNlcyBpbW1lZGlhdGVseSB0byBkb2RnZSBmYWxzZSByZWplY3Rpb24gZnJvbVxuXHRcdFx0XHRcdFx0XHQvLyBzdWJzZXF1ZW50IGVycm9yc1xuXHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENhbGwgYW4gb3B0aW9uYWwgaG9vayB0byByZWNvcmQgdGhlIHN0YWNrLCBpbiBjYXNlIG9mIGV4Y2VwdGlvblxuXHRcdFx0XHRcdFx0XHRcdC8vIHNpbmNlIGl0J3Mgb3RoZXJ3aXNlIGxvc3Qgd2hlbiBleGVjdXRpb24gZ29lcyBhc3luY1xuXHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3Muc3RhY2tUcmFjZSA9IGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHByb2Nlc3MgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cblx0XHRcdFx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25Qcm9ncmVzcyApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUHJvZ3Jlc3MgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIubm90aWZ5V2l0aFxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAxIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvbkZ1bGZpbGxlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uRnVsZmlsbGVkIDpcblx0XHRcdFx0XHRcdFx0XHRcdElkZW50aXR5XG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMiBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25SZWplY3RlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUmVqZWN0ZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0VGhyb3dlclxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gR2V0IGEgcHJvbWlzZSBmb3IgdGhpcyBkZWZlcnJlZFxuXHRcdFx0XHQvLyBJZiBvYmogaXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGFzcGVjdCBpcyBhZGRlZCB0byB0aGUgb2JqZWN0XG5cdFx0XHRcdHByb21pc2U6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZCggb2JqLCBwcm9taXNlICkgOiBwcm9taXNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVmZXJyZWQgPSB7fTtcblxuXHRcdC8vIEFkZCBsaXN0LXNwZWNpZmljIG1ldGhvZHNcblx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHR1cGxlWyAyIF0sXG5cdFx0XHRcdHN0YXRlU3RyaW5nID0gdHVwbGVbIDUgXTtcblxuXHRcdFx0Ly8gcHJvbWlzZS5wcm9ncmVzcyA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmRvbmUgPSBsaXN0LmFkZFxuXHRcdFx0Ly8gcHJvbWlzZS5mYWlsID0gbGlzdC5hZGRcblx0XHRcdHByb21pc2VbIHR1cGxlWyAxIF0gXSA9IGxpc3QuYWRkO1xuXG5cdFx0XHQvLyBIYW5kbGUgc3RhdGVcblx0XHRcdGlmICggc3RhdGVTdHJpbmcgKSB7XG5cdFx0XHRcdGxpc3QuYWRkKFxuXHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVzb2x2ZWRcIiAoaS5lLiwgZnVsZmlsbGVkKVxuXHRcdFx0XHRcdFx0Ly8gc3RhdGUgPSBcInJlamVjdGVkXCJcblx0XHRcdFx0XHRcdHN0YXRlID0gc3RhdGVTdHJpbmc7XG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdC8vIHJlamVjdGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAyIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmRpc2FibGVcblx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZGlzYWJsZVxuXHRcdFx0XHRcdHR1cGxlc1sgMyAtIGkgXVsgMyBdLmRpc2FibGUsXG5cblx0XHRcdFx0XHQvLyBwcm9ncmVzc19jYWxsYmFja3MubG9ja1xuXHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAyIF0ubG9jayxcblxuXHRcdFx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmxvY2tcblx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMyBdLmxvY2tcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdGxpc3QuYWRkKCB0dXBsZVsgMyBdLmZpcmUgKTtcblxuXHRcdFx0Ly8gZGVmZXJyZWQubm90aWZ5ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLm5vdGlmeVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlc29sdmVXaXRoKC4uLikgfVxuXHRcdFx0Ly8gZGVmZXJyZWQucmVqZWN0ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlamVjdFdpdGgoLi4uKSB9XG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSggdGhpcyA9PT0gZGVmZXJyZWQgPyB1bmRlZmluZWQgOiB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnlXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0Ly8gZGVmZXJyZWQucmVzb2x2ZVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3RXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdID0gbGlzdC5maXJlV2l0aDtcblx0XHR9ICk7XG5cblx0XHQvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2Vcblx0XHRwcm9taXNlLnByb21pc2UoIGRlZmVycmVkICk7XG5cblx0XHQvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XG5cdFx0aWYgKCBmdW5jICkge1xuXHRcdFx0ZnVuYy5jYWxsKCBkZWZlcnJlZCwgZGVmZXJyZWQgKTtcblx0XHR9XG5cblx0XHQvLyBBbGwgZG9uZSFcblx0XHRyZXR1cm4gZGVmZXJyZWQ7XG5cdH0sXG5cblx0Ly8gRGVmZXJyZWQgaGVscGVyXG5cdHdoZW46IGZ1bmN0aW9uKCBzaW5nbGVWYWx1ZSApIHtcblx0XHR2YXJcblxuXHRcdFx0Ly8gY291bnQgb2YgdW5jb21wbGV0ZWQgc3Vib3JkaW5hdGVzXG5cdFx0XHRyZW1haW5pbmcgPSBhcmd1bWVudHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bnByb2Nlc3NlZCBhcmd1bWVudHNcblx0XHRcdGkgPSByZW1haW5pbmcsXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGZ1bGZpbGxtZW50IGRhdGFcblx0XHRcdHJlc29sdmVDb250ZXh0cyA9IEFycmF5KCBpICksXG5cdFx0XHRyZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cblx0XHRcdC8vIHRoZSBtYXN0ZXIgRGVmZXJyZWRcblx0XHRcdG1hc3RlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXG5cdFx0XHQvLyBzdWJvcmRpbmF0ZSBjYWxsYmFjayBmYWN0b3J5XG5cdFx0XHR1cGRhdGVGdW5jID0gZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZUNvbnRleHRzWyBpIF0gPSB0aGlzO1xuXHRcdFx0XHRcdHJlc29sdmVWYWx1ZXNbIGkgXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gc2xpY2UuY2FsbCggYXJndW1lbnRzICkgOiB2YWx1ZTtcblx0XHRcdFx0XHRpZiAoICEoIC0tcmVtYWluaW5nICkgKSB7XG5cdFx0XHRcdFx0XHRtYXN0ZXIucmVzb2x2ZVdpdGgoIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH07XG5cblx0XHQvLyBTaW5nbGUtIGFuZCBlbXB0eSBhcmd1bWVudHMgYXJlIGFkb3B0ZWQgbGlrZSBQcm9taXNlLnJlc29sdmVcblx0XHRpZiAoIHJlbWFpbmluZyA8PSAxICkge1xuXHRcdFx0YWRvcHRWYWx1ZSggc2luZ2xlVmFsdWUsIG1hc3Rlci5kb25lKCB1cGRhdGVGdW5jKCBpICkgKS5yZXNvbHZlLCBtYXN0ZXIucmVqZWN0LFxuXHRcdFx0XHQhcmVtYWluaW5nICk7XG5cblx0XHRcdC8vIFVzZSAudGhlbigpIHRvIHVud3JhcCBzZWNvbmRhcnkgdGhlbmFibGVzIChjZi4gZ2gtMzAwMClcblx0XHRcdGlmICggbWFzdGVyLnN0YXRlKCkgPT09IFwicGVuZGluZ1wiIHx8XG5cdFx0XHRcdGlzRnVuY3Rpb24oIHJlc29sdmVWYWx1ZXNbIGkgXSAmJiByZXNvbHZlVmFsdWVzWyBpIF0udGhlbiApICkge1xuXG5cdFx0XHRcdHJldHVybiBtYXN0ZXIudGhlbigpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE11bHRpcGxlIGFyZ3VtZW50cyBhcmUgYWdncmVnYXRlZCBsaWtlIFByb21pc2UuYWxsIGFycmF5IGVsZW1lbnRzXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCByZXNvbHZlVmFsdWVzWyBpIF0sIHVwZGF0ZUZ1bmMoIGkgKSwgbWFzdGVyLnJlamVjdCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBtYXN0ZXIucHJvbWlzZSgpO1xuXHR9XG59ICk7XG5cblxuLy8gVGhlc2UgdXN1YWxseSBpbmRpY2F0ZSBhIHByb2dyYW1tZXIgbWlzdGFrZSBkdXJpbmcgZGV2ZWxvcG1lbnQsXG4vLyB3YXJuIGFib3V0IHRoZW0gQVNBUCByYXRoZXIgdGhhbiBzd2FsbG93aW5nIHRoZW0gYnkgZGVmYXVsdC5cbnZhciByZXJyb3JOYW1lcyA9IC9eKEV2YWx8SW50ZXJuYWx8UmFuZ2V8UmVmZXJlbmNlfFN5bnRheHxUeXBlfFVSSSlFcnJvciQvO1xuXG5qUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayA9IGZ1bmN0aW9uKCBlcnJvciwgc3RhY2sgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgOCAtIDkgb25seVxuXHQvLyBDb25zb2xlIGV4aXN0cyB3aGVuIGRldiB0b29scyBhcmUgb3Blbiwgd2hpY2ggY2FuIGhhcHBlbiBhdCBhbnkgdGltZVxuXHRpZiAoIHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLndhcm4gJiYgZXJyb3IgJiYgcmVycm9yTmFtZXMudGVzdCggZXJyb3IubmFtZSApICkge1xuXHRcdHdpbmRvdy5jb25zb2xlLndhcm4oIFwialF1ZXJ5LkRlZmVycmVkIGV4Y2VwdGlvbjogXCIgKyBlcnJvci5tZXNzYWdlLCBlcnJvci5zdGFjaywgc3RhY2sgKTtcblx0fVxufTtcblxuXG5cblxualF1ZXJ5LnJlYWR5RXhjZXB0aW9uID0gZnVuY3Rpb24oIGVycm9yICkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gKTtcbn07XG5cblxuXG5cbi8vIFRoZSBkZWZlcnJlZCB1c2VkIG9uIERPTSByZWFkeVxudmFyIHJlYWR5TGlzdCA9IGpRdWVyeS5EZWZlcnJlZCgpO1xuXG5qUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiggZm4gKSB7XG5cblx0cmVhZHlMaXN0XG5cdFx0LnRoZW4oIGZuIClcblxuXHRcdC8vIFdyYXAgalF1ZXJ5LnJlYWR5RXhjZXB0aW9uIGluIGEgZnVuY3Rpb24gc28gdGhhdCB0aGUgbG9va3VwXG5cdFx0Ly8gaGFwcGVucyBhdCB0aGUgdGltZSBvZiBlcnJvciBoYW5kbGluZyBpbnN0ZWFkIG9mIGNhbGxiYWNrXG5cdFx0Ly8gcmVnaXN0cmF0aW9uLlxuXHRcdC5jYXRjaCggZnVuY3Rpb24oIGVycm9yICkge1xuXHRcdFx0alF1ZXJ5LnJlYWR5RXhjZXB0aW9uKCBlcnJvciApO1xuXHRcdH0gKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBJcyB0aGUgRE9NIHJlYWR5IHRvIGJlIHVzZWQ/IFNldCB0byB0cnVlIG9uY2UgaXQgb2NjdXJzLlxuXHRpc1JlYWR5OiBmYWxzZSxcblxuXHQvLyBBIGNvdW50ZXIgdG8gdHJhY2sgaG93IG1hbnkgaXRlbXMgdG8gd2FpdCBmb3IgYmVmb3JlXG5cdC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlICM2NzgxXG5cdHJlYWR5V2FpdDogMSxcblxuXHQvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XG5cdHJlYWR5OiBmdW5jdGlvbiggd2FpdCApIHtcblxuXHRcdC8vIEFib3J0IGlmIHRoZXJlIGFyZSBwZW5kaW5nIGhvbGRzIG9yIHdlJ3JlIGFscmVhZHkgcmVhZHlcblx0XHRpZiAoIHdhaXQgPT09IHRydWUgPyAtLWpRdWVyeS5yZWFkeVdhaXQgOiBqUXVlcnkuaXNSZWFkeSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZW1lbWJlciB0aGF0IHRoZSBET00gaXMgcmVhZHlcblx0XHRqUXVlcnkuaXNSZWFkeSA9IHRydWU7XG5cblx0XHQvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxuXHRcdGlmICggd2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZXJlIGFyZSBmdW5jdGlvbnMgYm91bmQsIHRvIGV4ZWN1dGVcblx0XHRyZWFkeUxpc3QucmVzb2x2ZVdpdGgoIGRvY3VtZW50LCBbIGpRdWVyeSBdICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LnJlYWR5LnRoZW4gPSByZWFkeUxpc3QudGhlbjtcblxuLy8gVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2RcbmZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcblx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xuXHRqUXVlcnkucmVhZHkoKTtcbn1cblxuLy8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWRcbi8vIGFmdGVyIHRoZSBicm93c2VyIGV2ZW50IGhhcyBhbHJlYWR5IG9jY3VycmVkLlxuLy8gU3VwcG9ydDogSUUgPD05IC0gMTAgb25seVxuLy8gT2xkZXIgSUUgc29tZXRpbWVzIHNpZ25hbHMgXCJpbnRlcmFjdGl2ZVwiIHRvbyBzb29uXG5pZiAoIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiB8fFxuXHQoIGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgKSApIHtcblxuXHQvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcblx0d2luZG93LnNldFRpbWVvdXQoIGpRdWVyeS5yZWFkeSApO1xuXG59IGVsc2Uge1xuXG5cdC8vIFVzZSB0aGUgaGFuZHkgZXZlbnQgY2FsbGJhY2tcblx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXG5cdC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG59XG5cblxuXG5cbi8vIE11bHRpZnVuY3Rpb25hbCBtZXRob2QgdG8gZ2V0IGFuZCBzZXQgdmFsdWVzIG9mIGEgY29sbGVjdGlvblxuLy8gVGhlIHZhbHVlL3MgY2FuIG9wdGlvbmFsbHkgYmUgZXhlY3V0ZWQgaWYgaXQncyBhIGZ1bmN0aW9uXG52YXIgYWNjZXNzID0gZnVuY3Rpb24oIGVsZW1zLCBmbiwga2V5LCB2YWx1ZSwgY2hhaW5hYmxlLCBlbXB0eUdldCwgcmF3ICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gZWxlbXMubGVuZ3RoLFxuXHRcdGJ1bGsgPSBrZXkgPT0gbnVsbDtcblxuXHQvLyBTZXRzIG1hbnkgdmFsdWVzXG5cdGlmICggdG9UeXBlKCBrZXkgKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXHRcdGZvciAoIGkgaW4ga2V5ICkge1xuXHRcdFx0YWNjZXNzKCBlbGVtcywgZm4sIGksIGtleVsgaSBdLCB0cnVlLCBlbXB0eUdldCwgcmF3ICk7XG5cdFx0fVxuXG5cdC8vIFNldHMgb25lIHZhbHVlXG5cdH0gZWxzZSBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblxuXHRcdGlmICggIWlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyYXcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICggYnVsayApIHtcblxuXHRcdFx0Ly8gQnVsayBvcGVyYXRpb25zIHJ1biBhZ2FpbnN0IHRoZSBlbnRpcmUgc2V0XG5cdFx0XHRpZiAoIHJhdyApIHtcblx0XHRcdFx0Zm4uY2FsbCggZWxlbXMsIHZhbHVlICk7XG5cdFx0XHRcdGZuID0gbnVsbDtcblxuXHRcdFx0Ly8gLi4uZXhjZXB0IHdoZW4gZXhlY3V0aW5nIGZ1bmN0aW9uIHZhbHVlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnVsayA9IGZuO1xuXHRcdFx0XHRmbiA9IGZ1bmN0aW9uKCBlbGVtLCBrZXksIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiBidWxrLmNhbGwoIGpRdWVyeSggZWxlbSApLCB2YWx1ZSApO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0Zm4oXG5cdFx0XHRcdFx0ZWxlbXNbIGkgXSwga2V5LCByYXcgP1xuXHRcdFx0XHRcdHZhbHVlIDpcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCBlbGVtc1sgaSBdLCBpLCBmbiggZWxlbXNbIGkgXSwga2V5ICkgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggY2hhaW5hYmxlICkge1xuXHRcdHJldHVybiBlbGVtcztcblx0fVxuXG5cdC8vIEdldHNcblx0aWYgKCBidWxrICkge1xuXHRcdHJldHVybiBmbi5jYWxsKCBlbGVtcyApO1xuXHR9XG5cblx0cmV0dXJuIGxlbiA/IGZuKCBlbGVtc1sgMCBdLCBrZXkgKSA6IGVtcHR5R2V0O1xufTtcblxuXG4vLyBNYXRjaGVzIGRhc2hlZCBzdHJpbmcgZm9yIGNhbWVsaXppbmdcbnZhciBybXNQcmVmaXggPSAvXi1tcy0vLFxuXHRyZGFzaEFscGhhID0gLy0oW2Etel0pL2c7XG5cbi8vIFVzZWQgYnkgY2FtZWxDYXNlIGFzIGNhbGxiYWNrIHRvIHJlcGxhY2UoKVxuZnVuY3Rpb24gZmNhbWVsQ2FzZSggYWxsLCBsZXR0ZXIgKSB7XG5cdHJldHVybiBsZXR0ZXIudG9VcHBlckNhc2UoKTtcbn1cblxuLy8gQ29udmVydCBkYXNoZWQgdG8gY2FtZWxDYXNlOyB1c2VkIGJ5IHRoZSBjc3MgYW5kIGRhdGEgbW9kdWxlc1xuLy8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxNVxuLy8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKCM5NTcyKVxuZnVuY3Rpb24gY2FtZWxDYXNlKCBzdHJpbmcgKSB7XG5cdHJldHVybiBzdHJpbmcucmVwbGFjZSggcm1zUHJlZml4LCBcIm1zLVwiICkucmVwbGFjZSggcmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSApO1xufVxudmFyIGFjY2VwdERhdGEgPSBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0Ly8gQWNjZXB0cyBvbmx5OlxuXHQvLyAgLSBOb2RlXG5cdC8vICAgIC0gTm9kZS5FTEVNRU5UX05PREVcblx0Ly8gICAgLSBOb2RlLkRPQ1VNRU5UX05PREVcblx0Ly8gIC0gT2JqZWN0XG5cdC8vICAgIC0gQW55XG5cdHJldHVybiBvd25lci5ub2RlVHlwZSA9PT0gMSB8fCBvd25lci5ub2RlVHlwZSA9PT0gOSB8fCAhKCArb3duZXIubm9kZVR5cGUgKTtcbn07XG5cblxuXG5cbmZ1bmN0aW9uIERhdGEoKSB7XG5cdHRoaXMuZXhwYW5kbyA9IGpRdWVyeS5leHBhbmRvICsgRGF0YS51aWQrKztcbn1cblxuRGF0YS51aWQgPSAxO1xuXG5EYXRhLnByb3RvdHlwZSA9IHtcblxuXHRjYWNoZTogZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdFx0Ly8gQ2hlY2sgaWYgdGhlIG93bmVyIG9iamVjdCBhbHJlYWR5IGhhcyBhIGNhY2hlXG5cdFx0dmFyIHZhbHVlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0Ly8gSWYgbm90LCBjcmVhdGUgb25lXG5cdFx0aWYgKCAhdmFsdWUgKSB7XG5cdFx0XHR2YWx1ZSA9IHt9O1xuXG5cdFx0XHQvLyBXZSBjYW4gYWNjZXB0IGRhdGEgZm9yIG5vbi1lbGVtZW50IG5vZGVzIGluIG1vZGVybiBicm93c2Vycyxcblx0XHRcdC8vIGJ1dCB3ZSBzaG91bGQgbm90LCBzZWUgIzgzMzUuXG5cdFx0XHQvLyBBbHdheXMgcmV0dXJuIGFuIGVtcHR5IG9iamVjdC5cblx0XHRcdGlmICggYWNjZXB0RGF0YSggb3duZXIgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBpdCBpcyBhIG5vZGUgdW5saWtlbHkgdG8gYmUgc3RyaW5naWZ5LWVkIG9yIGxvb3BlZCBvdmVyXG5cdFx0XHRcdC8vIHVzZSBwbGFpbiBhc3NpZ25tZW50XG5cdFx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdmFsdWU7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHNlY3VyZSBpdCBpbiBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5XG5cdFx0XHRcdC8vIGNvbmZpZ3VyYWJsZSBtdXN0IGJlIHRydWUgdG8gYWxsb3cgdGhlIHByb3BlcnR5IHRvIGJlXG5cdFx0XHRcdC8vIGRlbGV0ZWQgd2hlbiBkYXRhIGlzIHJlbW92ZWRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIG93bmVyLCB0aGlzLmV4cGFuZG8sIHtcblx0XHRcdFx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZTtcblx0fSxcblx0c2V0OiBmdW5jdGlvbiggb3duZXIsIGRhdGEsIHZhbHVlICkge1xuXHRcdHZhciBwcm9wLFxuXHRcdFx0Y2FjaGUgPSB0aGlzLmNhY2hlKCBvd25lciApO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCBrZXksIHZhbHVlIF0gYXJnc1xuXHRcdC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1Nylcblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Y2FjaGVbIGNhbWVsQ2FzZSggZGF0YSApIF0gPSB2YWx1ZTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwgeyBwcm9wZXJ0aWVzIH0gXSBhcmdzXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQ29weSB0aGUgcHJvcGVydGllcyBvbmUtYnktb25lIHRvIHRoZSBjYWNoZSBvYmplY3Rcblx0XHRcdGZvciAoIHByb3AgaW4gZGF0YSApIHtcblx0XHRcdFx0Y2FjaGVbIGNhbWVsQ2FzZSggcHJvcCApIF0gPSBkYXRhWyBwcm9wIF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjYWNoZTtcblx0fSxcblx0Z2V0OiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHRyZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcy5jYWNoZSggb3duZXIgKSA6XG5cblx0XHRcdC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1Nylcblx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSAmJiBvd25lclsgdGhpcy5leHBhbmRvIF1bIGNhbWVsQ2FzZSgga2V5ICkgXTtcblx0fSxcblx0YWNjZXNzOiBmdW5jdGlvbiggb3duZXIsIGtleSwgdmFsdWUgKSB7XG5cblx0XHQvLyBJbiBjYXNlcyB3aGVyZSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIE5vIGtleSB3YXMgc3BlY2lmaWVkXG5cdFx0Ly8gICAyLiBBIHN0cmluZyBrZXkgd2FzIHNwZWNpZmllZCwgYnV0IG5vIHZhbHVlIHByb3ZpZGVkXG5cdFx0Ly9cblx0XHQvLyBUYWtlIHRoZSBcInJlYWRcIiBwYXRoIGFuZCBhbGxvdyB0aGUgZ2V0IG1ldGhvZCB0byBkZXRlcm1pbmVcblx0XHQvLyB3aGljaCB2YWx1ZSB0byByZXR1cm4sIHJlc3BlY3RpdmVseSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIFRoZSBlbnRpcmUgY2FjaGUgb2JqZWN0XG5cdFx0Ly8gICAyLiBUaGUgZGF0YSBzdG9yZWQgYXQgdGhlIGtleVxuXHRcdC8vXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0XHQoICgga2V5ICYmIHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgKSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmdldCggb3duZXIsIGtleSApO1xuXHRcdH1cblxuXHRcdC8vIFdoZW4gdGhlIGtleSBpcyBub3QgYSBzdHJpbmcsIG9yIGJvdGggYSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly8gYXJlIHNwZWNpZmllZCwgc2V0IG9yIGV4dGVuZCAoZXhpc3Rpbmcgb2JqZWN0cykgd2l0aCBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIEFuIG9iamVjdCBvZiBwcm9wZXJ0aWVzXG5cdFx0Ly8gICAyLiBBIGtleSBhbmQgdmFsdWVcblx0XHQvL1xuXHRcdHRoaXMuc2V0KCBvd25lciwga2V5LCB2YWx1ZSApO1xuXG5cdFx0Ly8gU2luY2UgdGhlIFwic2V0XCIgcGF0aCBjYW4gaGF2ZSB0d28gcG9zc2libGUgZW50cnkgcG9pbnRzXG5cdFx0Ly8gcmV0dXJuIHRoZSBleHBlY3RlZCBkYXRhIGJhc2VkIG9uIHdoaWNoIHBhdGggd2FzIHRha2VuWypdXG5cdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IGtleTtcblx0fSxcblx0cmVtb3ZlOiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHR2YXIgaSxcblx0XHRcdGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0aWYgKCBjYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICgga2V5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBrZXlzXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGtleSApICkge1xuXG5cdFx0XHRcdC8vIElmIGtleSBpcyBhbiBhcnJheSBvZiBrZXlzLi4uXG5cdFx0XHRcdC8vIFdlIGFsd2F5cyBzZXQgY2FtZWxDYXNlIGtleXMsIHNvIHJlbW92ZSB0aGF0LlxuXHRcdFx0XHRrZXkgPSBrZXkubWFwKCBjYW1lbENhc2UgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGtleSA9IGNhbWVsQ2FzZSgga2V5ICk7XG5cblx0XHRcdFx0Ly8gSWYgYSBrZXkgd2l0aCB0aGUgc3BhY2VzIGV4aXN0cywgdXNlIGl0LlxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIGNyZWF0ZSBhbiBhcnJheSBieSBtYXRjaGluZyBub24td2hpdGVzcGFjZVxuXHRcdFx0XHRrZXkgPSBrZXkgaW4gY2FjaGUgP1xuXHRcdFx0XHRcdFsga2V5IF0gOlxuXHRcdFx0XHRcdCgga2V5Lm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10gKTtcblx0XHRcdH1cblxuXHRcdFx0aSA9IGtleS5sZW5ndGg7XG5cblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRkZWxldGUgY2FjaGVbIGtleVsgaSBdIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBleHBhbmRvIGlmIHRoZXJlJ3Mgbm8gbW9yZSBkYXRhXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fCBqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKSApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NVxuXHRcdFx0Ly8gV2Via2l0ICYgQmxpbmsgcGVyZm9ybWFuY2Ugc3VmZmVycyB3aGVuIGRlbGV0aW5nIHByb3BlcnRpZXNcblx0XHRcdC8vIGZyb20gRE9NIG5vZGVzLCBzbyBzZXQgdG8gdW5kZWZpbmVkIGluc3RlYWRcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM3ODYwNyAoYnVnIHJlc3RyaWN0ZWQpXG5cdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWxldGUgb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0aGFzRGF0YTogZnVuY3Rpb24oIG93bmVyICkge1xuXHRcdHZhciBjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRyZXR1cm4gY2FjaGUgIT09IHVuZGVmaW5lZCAmJiAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICk7XG5cdH1cbn07XG52YXIgZGF0YVByaXYgPSBuZXcgRGF0YSgpO1xuXG52YXIgZGF0YVVzZXIgPSBuZXcgRGF0YSgpO1xuXG5cblxuLy9cdEltcGxlbWVudGF0aW9uIFN1bW1hcnlcbi8vXG4vL1x0MS4gRW5mb3JjZSBBUEkgc3VyZmFjZSBhbmQgc2VtYW50aWMgY29tcGF0aWJpbGl0eSB3aXRoIDEuOS54IGJyYW5jaFxuLy9cdDIuIEltcHJvdmUgdGhlIG1vZHVsZSdzIG1haW50YWluYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgc3RvcmFnZVxuLy9cdFx0cGF0aHMgdG8gYSBzaW5nbGUgbWVjaGFuaXNtLlxuLy9cdDMuIFVzZSB0aGUgc2FtZSBzaW5nbGUgbWVjaGFuaXNtIHRvIHN1cHBvcnQgXCJwcml2YXRlXCIgYW5kIFwidXNlclwiIGRhdGEuXG4vL1x0NC4gX05ldmVyXyBleHBvc2UgXCJwcml2YXRlXCIgZGF0YSB0byB1c2VyIGNvZGUgKFRPRE86IERyb3AgX2RhdGEsIF9yZW1vdmVEYXRhKVxuLy9cdDUuIEF2b2lkIGV4cG9zaW5nIGltcGxlbWVudGF0aW9uIGRldGFpbHMgb24gdXNlciBvYmplY3RzIChlZy4gZXhwYW5kbyBwcm9wZXJ0aWVzKVxuLy9cdDYuIFByb3ZpZGUgYSBjbGVhciBwYXRoIGZvciBpbXBsZW1lbnRhdGlvbiB1cGdyYWRlIHRvIFdlYWtNYXAgaW4gMjAxNFxuXG52YXIgcmJyYWNlID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxuXHRybXVsdGlEYXNoID0gL1tBLVpdL2c7XG5cbmZ1bmN0aW9uIGdldERhdGEoIGRhdGEgKSB7XG5cdGlmICggZGF0YSA9PT0gXCJ0cnVlXCIgKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAoIGRhdGEgPT09IFwiZmFsc2VcIiApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRpZiAoIGRhdGEgPT09IFwibnVsbFwiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gT25seSBjb252ZXJ0IHRvIGEgbnVtYmVyIGlmIGl0IGRvZXNuJ3QgY2hhbmdlIHRoZSBzdHJpbmdcblx0aWYgKCBkYXRhID09PSArZGF0YSArIFwiXCIgKSB7XG5cdFx0cmV0dXJuICtkYXRhO1xuXHR9XG5cblx0aWYgKCByYnJhY2UudGVzdCggZGF0YSApICkge1xuXHRcdHJldHVybiBKU09OLnBhcnNlKCBkYXRhICk7XG5cdH1cblxuXHRyZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gZGF0YUF0dHIoIGVsZW0sIGtleSwgZGF0YSApIHtcblx0dmFyIG5hbWU7XG5cblx0Ly8gSWYgbm90aGluZyB3YXMgZm91bmQgaW50ZXJuYWxseSwgdHJ5IHRvIGZldGNoIGFueVxuXHQvLyBkYXRhIGZyb20gdGhlIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGVcblx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRuYW1lID0gXCJkYXRhLVwiICsga2V5LnJlcGxhY2UoIHJtdWx0aURhc2gsIFwiLSQmXCIgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdGRhdGEgPSBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApO1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRhdGEgPSBnZXREYXRhKCBkYXRhICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHt9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGRhdGEgc28gaXQgaXNuJ3QgY2hhbmdlZCBsYXRlclxuXHRcdFx0ZGF0YVVzZXIuc2V0KCBlbGVtLCBrZXksIGRhdGEgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGRhdGE7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aGFzRGF0YTogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmhhc0RhdGEoIGVsZW0gKSB8fCBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICk7XG5cdH0sXG5cblx0ZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFVc2VyLnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9LFxuXG5cdC8vIFRPRE86IE5vdyB0aGF0IGFsbCBjYWxscyB0byBfZGF0YSBhbmQgX3JlbW92ZURhdGEgaGF2ZSBiZWVuIHJlcGxhY2VkXG5cdC8vIHdpdGggZGlyZWN0IGNhbGxzIHRvIGRhdGFQcml2IG1ldGhvZHMsIHRoZXNlIGNhbiBiZSBkZXByZWNhdGVkLlxuXHRfZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdF9yZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRhdGE6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBpLCBuYW1lLCBkYXRhLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdGF0dHJzID0gZWxlbSAmJiBlbGVtLmF0dHJpYnV0ZXM7XG5cblx0XHQvLyBHZXRzIGFsbCB2YWx1ZXNcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB0aGlzLmxlbmd0aCApIHtcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSApO1xuXG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAhZGF0YVByaXYuZ2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiICkgKSB7XG5cdFx0XHRcdFx0aSA9IGF0dHJzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgMTEgb25seVxuXHRcdFx0XHRcdFx0Ly8gVGhlIGF0dHJzIGVsZW1lbnRzIGNhbiBiZSBudWxsICgjMTQ4OTQpXG5cdFx0XHRcdFx0XHRpZiAoIGF0dHJzWyBpIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG5hbWUgPSBhdHRyc1sgaSBdLm5hbWU7XG5cdFx0XHRcdFx0XHRcdGlmICggbmFtZS5pbmRleE9mKCBcImRhdGEtXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0XHRcdFx0XHRuYW1lID0gY2FtZWxDYXNlKCBuYW1lLnNsaWNlKCA1ICkgKTtcblx0XHRcdFx0XHRcdFx0XHRkYXRhQXR0ciggZWxlbSwgbmFtZSwgZGF0YVsgbmFtZSBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0cyBtdWx0aXBsZSB2YWx1ZXNcblx0XHRpZiAoIHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZGF0YTtcblxuXHRcdFx0Ly8gVGhlIGNhbGxpbmcgalF1ZXJ5IG9iamVjdCAoZWxlbWVudCBtYXRjaGVzKSBpcyBub3QgZW1wdHlcblx0XHRcdC8vIChhbmQgdGhlcmVmb3JlIGhhcyBhbiBlbGVtZW50IGFwcGVhcnMgYXQgdGhpc1sgMCBdKSBhbmQgdGhlXG5cdFx0XHQvLyBgdmFsdWVgIHBhcmFtZXRlciB3YXMgbm90IHVuZGVmaW5lZC4gQW4gZW1wdHkgalF1ZXJ5IG9iamVjdFxuXHRcdFx0Ly8gd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgZm9yIGVsZW0gPSB0aGlzWyAwIF0gd2hpY2ggd2lsbFxuXHRcdFx0Ly8gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFuIGF0dGVtcHQgdG8gcmVhZCBhIGRhdGEgY2FjaGUgaXMgbWFkZS5cblx0XHRcdGlmICggZWxlbSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gZ2V0IGRhdGEgZnJvbSB0aGUgY2FjaGVcblx0XHRcdFx0Ly8gVGhlIGtleSB3aWxsIGFsd2F5cyBiZSBjYW1lbENhc2VkIGluIERhdGFcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBcImRpc2NvdmVyXCIgdGhlIGRhdGEgaW5cblx0XHRcdFx0Ly8gSFRNTDUgY3VzdG9tIGRhdGEtKiBhdHRyc1xuXHRcdFx0XHRkYXRhID0gZGF0YUF0dHIoIGVsZW0sIGtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFdlIHRyaWVkIHJlYWxseSBoYXJkLCBidXQgdGhlIGRhdGEgZG9lc24ndCBleGlzdC5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgdGhlIGRhdGEuLi5cblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHN0b3JlIHRoZSBjYW1lbENhc2VkIGtleVxuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSwgdmFsdWUgKTtcblx0XHRcdH0gKTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEsIG51bGwsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGF0YVVzZXIucmVtb3ZlKCB0aGlzLCBrZXkgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgcXVldWU7XG5cblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHR0eXBlID0gKCB0eXBlIHx8IFwiZnhcIiApICsgXCJxdWV1ZVwiO1xuXHRcdFx0cXVldWUgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0Ly8gU3BlZWQgdXAgZGVxdWV1ZSBieSBnZXR0aW5nIG91dCBxdWlja2x5IGlmIHRoaXMgaXMganVzdCBhIGxvb2t1cFxuXHRcdFx0aWYgKCBkYXRhICkge1xuXHRcdFx0XHRpZiAoICFxdWV1ZSB8fCBBcnJheS5pc0FycmF5KCBkYXRhICkgKSB7XG5cdFx0XHRcdFx0cXVldWUgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIHR5cGUsIGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEgKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGRhdGEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHF1ZXVlIHx8IFtdO1xuXHRcdH1cblx0fSxcblxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIGVsZW0sIHR5cGUgKSxcblx0XHRcdHN0YXJ0TGVuZ3RoID0gcXVldWUubGVuZ3RoLFxuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpLFxuXHRcdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIHR5cGUgKSxcblx0XHRcdG5leHQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIGVsZW0sIHR5cGUgKTtcblx0XHRcdH07XG5cblx0XHQvLyBJZiB0aGUgZnggcXVldWUgaXMgZGVxdWV1ZWQsIGFsd2F5cyByZW1vdmUgdGhlIHByb2dyZXNzIHNlbnRpbmVsXG5cdFx0aWYgKCBmbiA9PT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRzdGFydExlbmd0aC0tO1xuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cblx0XHRcdC8vIEFkZCBhIHByb2dyZXNzIHNlbnRpbmVsIHRvIHByZXZlbnQgdGhlIGZ4IHF1ZXVlIGZyb20gYmVpbmdcblx0XHRcdC8vIGF1dG9tYXRpY2FsbHkgZGVxdWV1ZWRcblx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICkge1xuXHRcdFx0XHRxdWV1ZS51bnNoaWZ0KCBcImlucHJvZ3Jlc3NcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDbGVhciB1cCB0aGUgbGFzdCBxdWV1ZSBzdG9wIGZ1bmN0aW9uXG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdGZuLmNhbGwoIGVsZW0sIG5leHQsIGhvb2tzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhc3RhcnRMZW5ndGggJiYgaG9va3MgKSB7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIE5vdCBwdWJsaWMgLSBnZW5lcmF0ZSBhIHF1ZXVlSG9va3Mgb2JqZWN0LCBvciByZXR1cm4gdGhlIGN1cnJlbnQgb25lXG5cdF9xdWV1ZUhvb2tzOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR2YXIga2V5ID0gdHlwZSArIFwicXVldWVIb29rc1wiO1xuXHRcdHJldHVybiBkYXRhUHJpdi5nZXQoIGVsZW0sIGtleSApIHx8IGRhdGFQcml2LmFjY2VzcyggZWxlbSwga2V5LCB7XG5cdFx0XHRlbXB0eTogalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICkuYWRkKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBbIHR5cGUgKyBcInF1ZXVlXCIsIGtleSBdICk7XG5cdFx0XHR9IClcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHNldHRlciA9IDI7XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZGF0YSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gXCJmeFwiO1xuXHRcdFx0c2V0dGVyLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoIDwgc2V0dGVyICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5xdWV1ZSggdGhpc1sgMCBdLCB0eXBlICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzIDpcblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgZGF0YSApO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSBhIGhvb2tzIGZvciB0aGlzIHF1ZXVlXG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICYmIHF1ZXVlWyAwIF0gIT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0fSxcblx0ZGVxdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdH0gKTtcblx0fSxcblx0Y2xlYXJRdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHR9LFxuXG5cdC8vIEdldCBhIHByb21pc2UgcmVzb2x2ZWQgd2hlbiBxdWV1ZXMgb2YgYSBjZXJ0YWluIHR5cGVcblx0Ly8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXG5cdHByb21pc2U6IGZ1bmN0aW9uKCB0eXBlLCBvYmogKSB7XG5cdFx0dmFyIHRtcCxcblx0XHRcdGNvdW50ID0gMSxcblx0XHRcdGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRlbGVtZW50cyA9IHRoaXMsXG5cdFx0XHRpID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRyZXNvbHZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggISggLS1jb3VudCApICkge1xuXHRcdFx0XHRcdGRlZmVyLnJlc29sdmVXaXRoKCBlbGVtZW50cywgWyBlbGVtZW50cyBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b2JqID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG1wID0gZGF0YVByaXYuZ2V0KCBlbGVtZW50c1sgaSBdLCB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgKTtcblx0XHRcdGlmICggdG1wICYmIHRtcC5lbXB0eSApIHtcblx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0dG1wLmVtcHR5LmFkZCggcmVzb2x2ZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXNvbHZlKCk7XG5cdFx0cmV0dXJuIGRlZmVyLnByb21pc2UoIG9iaiApO1xuXHR9XG59ICk7XG52YXIgcG51bSA9ICggL1srLV0/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KS8gKS5zb3VyY2U7XG5cbnZhciByY3NzTnVtID0gbmV3IFJlZ0V4cCggXCJeKD86KFsrLV0pPXwpKFwiICsgcG51bSArIFwiKShbYS16JV0qKSRcIiwgXCJpXCIgKTtcblxuXG52YXIgY3NzRXhwYW5kID0gWyBcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiIF07XG5cbnZhciBpc0hpZGRlbldpdGhpblRyZWUgPSBmdW5jdGlvbiggZWxlbSwgZWwgKSB7XG5cblx0XHQvLyBpc0hpZGRlbldpdGhpblRyZWUgbWlnaHQgYmUgY2FsbGVkIGZyb20galF1ZXJ5I2ZpbHRlciBmdW5jdGlvbjtcblx0XHQvLyBpbiB0aGF0IGNhc2UsIGVsZW1lbnQgd2lsbCBiZSBzZWNvbmQgYXJndW1lbnRcblx0XHRlbGVtID0gZWwgfHwgZWxlbTtcblxuXHRcdC8vIElubGluZSBzdHlsZSB0cnVtcHMgYWxsXG5cdFx0cmV0dXJuIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIgfHxcblx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJlxuXG5cdFx0XHQvLyBPdGhlcndpc2UsIGNoZWNrIGNvbXB1dGVkIHN0eWxlXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDMgLSA0NVxuXHRcdFx0Ly8gRGlzY29ubmVjdGVkIGVsZW1lbnRzIGNhbiBoYXZlIGNvbXB1dGVkIGRpc3BsYXk6IG5vbmUsIHNvIGZpcnN0IGNvbmZpcm0gdGhhdCBlbGVtIGlzXG5cdFx0XHQvLyBpbiB0aGUgZG9jdW1lbnQuXG5cdFx0XHRqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApICYmXG5cblx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgPT09IFwibm9uZVwiO1xuXHR9O1xuXG52YXIgc3dhcCA9IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBjYWxsYmFjaywgYXJncyApIHtcblx0dmFyIHJldCwgbmFtZSxcblx0XHRvbGQgPSB7fTtcblxuXHQvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdG9sZFsgbmFtZSBdID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9wdGlvbnNbIG5hbWUgXTtcblx0fVxuXG5cdHJldCA9IGNhbGxiYWNrLmFwcGx5KCBlbGVtLCBhcmdzIHx8IFtdICk7XG5cblx0Ly8gUmV2ZXJ0IHRoZSBvbGQgdmFsdWVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvbGRbIG5hbWUgXTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuXG5cblxuXG5mdW5jdGlvbiBhZGp1c3RDU1MoIGVsZW0sIHByb3AsIHZhbHVlUGFydHMsIHR3ZWVuICkge1xuXHR2YXIgYWRqdXN0ZWQsIHNjYWxlLFxuXHRcdG1heEl0ZXJhdGlvbnMgPSAyMCxcblx0XHRjdXJyZW50VmFsdWUgPSB0d2VlbiA/XG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmN1cigpO1xuXHRcdFx0fSA6XG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AsIFwiXCIgKTtcblx0XHRcdH0sXG5cdFx0aW5pdGlhbCA9IGN1cnJlbnRWYWx1ZSgpLFxuXHRcdHVuaXQgPSB2YWx1ZVBhcnRzICYmIHZhbHVlUGFydHNbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKSxcblxuXHRcdC8vIFN0YXJ0aW5nIHZhbHVlIGNvbXB1dGF0aW9uIGlzIHJlcXVpcmVkIGZvciBwb3RlbnRpYWwgdW5pdCBtaXNtYXRjaGVzXG5cdFx0aW5pdGlhbEluVW5pdCA9ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdIHx8IHVuaXQgIT09IFwicHhcIiAmJiAraW5pdGlhbCApICYmXG5cdFx0XHRyY3NzTnVtLmV4ZWMoIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AgKSApO1xuXG5cdGlmICggaW5pdGlhbEluVW5pdCAmJiBpbml0aWFsSW5Vbml0WyAzIF0gIT09IHVuaXQgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NTRcblx0XHQvLyBIYWx2ZSB0aGUgaXRlcmF0aW9uIHRhcmdldCB2YWx1ZSB0byBwcmV2ZW50IGludGVyZmVyZW5jZSBmcm9tIENTUyB1cHBlciBib3VuZHMgKGdoLTIxNDQpXG5cdFx0aW5pdGlhbCA9IGluaXRpYWwgLyAyO1xuXG5cdFx0Ly8gVHJ1c3QgdW5pdHMgcmVwb3J0ZWQgYnkgalF1ZXJ5LmNzc1xuXHRcdHVuaXQgPSB1bml0IHx8IGluaXRpYWxJblVuaXRbIDMgXTtcblxuXHRcdC8vIEl0ZXJhdGl2ZWx5IGFwcHJveGltYXRlIGZyb20gYSBub256ZXJvIHN0YXJ0aW5nIHBvaW50XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsIHx8IDE7XG5cblx0XHR3aGlsZSAoIG1heEl0ZXJhdGlvbnMtLSApIHtcblxuXHRcdFx0Ly8gRXZhbHVhdGUgYW5kIHVwZGF0ZSBvdXIgYmVzdCBndWVzcyAoZG91YmxpbmcgZ3Vlc3NlcyB0aGF0IHplcm8gb3V0KS5cblx0XHRcdC8vIEZpbmlzaCBpZiB0aGUgc2NhbGUgZXF1YWxzIG9yIGNyb3NzZXMgMSAobWFraW5nIHRoZSBvbGQqbmV3IHByb2R1Y3Qgbm9uLXBvc2l0aXZlKS5cblx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblx0XHRcdGlmICggKCAxIC0gc2NhbGUgKSAqICggMSAtICggc2NhbGUgPSBjdXJyZW50VmFsdWUoKSAvIGluaXRpYWwgfHwgMC41ICkgKSA8PSAwICkge1xuXHRcdFx0XHRtYXhJdGVyYXRpb25zID0gMDtcblx0XHRcdH1cblx0XHRcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0IC8gc2NhbGU7XG5cblx0XHR9XG5cblx0XHRpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAqIDI7XG5cdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBpbml0aWFsSW5Vbml0ICsgdW5pdCApO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHdlIHVwZGF0ZSB0aGUgdHdlZW4gcHJvcGVydGllcyBsYXRlciBvblxuXHRcdHZhbHVlUGFydHMgPSB2YWx1ZVBhcnRzIHx8IFtdO1xuXHR9XG5cblx0aWYgKCB2YWx1ZVBhcnRzICkge1xuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbEluVW5pdCB8fCAraW5pdGlhbCB8fCAwO1xuXG5cdFx0Ly8gQXBwbHkgcmVsYXRpdmUgb2Zmc2V0ICgrPS8tPSkgaWYgc3BlY2lmaWVkXG5cdFx0YWRqdXN0ZWQgPSB2YWx1ZVBhcnRzWyAxIF0gP1xuXHRcdFx0aW5pdGlhbEluVW5pdCArICggdmFsdWVQYXJ0c1sgMSBdICsgMSApICogdmFsdWVQYXJ0c1sgMiBdIDpcblx0XHRcdCt2YWx1ZVBhcnRzWyAyIF07XG5cdFx0aWYgKCB0d2VlbiApIHtcblx0XHRcdHR3ZWVuLnVuaXQgPSB1bml0O1xuXHRcdFx0dHdlZW4uc3RhcnQgPSBpbml0aWFsSW5Vbml0O1xuXHRcdFx0dHdlZW4uZW5kID0gYWRqdXN0ZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBhZGp1c3RlZDtcbn1cblxuXG52YXIgZGVmYXVsdERpc3BsYXlNYXAgPSB7fTtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdERpc3BsYXkoIGVsZW0gKSB7XG5cdHZhciB0ZW1wLFxuXHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudCxcblx0XHRub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUsXG5cdFx0ZGlzcGxheSA9IGRlZmF1bHREaXNwbGF5TWFwWyBub2RlTmFtZSBdO1xuXG5cdGlmICggZGlzcGxheSApIHtcblx0XHRyZXR1cm4gZGlzcGxheTtcblx0fVxuXG5cdHRlbXAgPSBkb2MuYm9keS5hcHBlbmRDaGlsZCggZG9jLmNyZWF0ZUVsZW1lbnQoIG5vZGVOYW1lICkgKTtcblx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIHRlbXAsIFwiZGlzcGxheVwiICk7XG5cblx0dGVtcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCB0ZW1wICk7XG5cblx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRkaXNwbGF5ID0gXCJibG9ja1wiO1xuXHR9XG5cdGRlZmF1bHREaXNwbGF5TWFwWyBub2RlTmFtZSBdID0gZGlzcGxheTtcblxuXHRyZXR1cm4gZGlzcGxheTtcbn1cblxuZnVuY3Rpb24gc2hvd0hpZGUoIGVsZW1lbnRzLCBzaG93ICkge1xuXHR2YXIgZGlzcGxheSwgZWxlbSxcblx0XHR2YWx1ZXMgPSBbXSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoO1xuXG5cdC8vIERldGVybWluZSBuZXcgZGlzcGxheSB2YWx1ZSBmb3IgZWxlbWVudHMgdGhhdCBuZWVkIHRvIGNoYW5nZVxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGVsZW0gPSBlbGVtZW50c1sgaW5kZXggXTtcblx0XHRpZiAoICFlbGVtLnN0eWxlICkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0ZGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheTtcblx0XHRpZiAoIHNob3cgKSB7XG5cblx0XHRcdC8vIFNpbmNlIHdlIGZvcmNlIHZpc2liaWxpdHkgdXBvbiBjYXNjYWRlLWhpZGRlbiBlbGVtZW50cywgYW4gaW1tZWRpYXRlIChhbmQgc2xvdylcblx0XHRcdC8vIGNoZWNrIGlzIHJlcXVpcmVkIGluIHRoaXMgZmlyc3QgbG9vcCB1bmxlc3Mgd2UgaGF2ZSBhIG5vbmVtcHR5IGRpc3BsYXkgdmFsdWUgKGVpdGhlclxuXHRcdFx0Ly8gaW5saW5lIG9yIGFib3V0LXRvLWJlLXJlc3RvcmVkKVxuXHRcdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImRpc3BsYXlcIiApIHx8IG51bGw7XG5cdFx0XHRcdGlmICggIXZhbHVlc1sgaW5kZXggXSApIHtcblx0XHRcdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJiBpc0hpZGRlbldpdGhpblRyZWUoIGVsZW0gKSApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gZ2V0RGVmYXVsdERpc3BsYXkoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCBkaXNwbGF5ICE9PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gXCJub25lXCI7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgd2hhdCB3ZSdyZSBvdmVyd3JpdGluZ1xuXHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiZGlzcGxheVwiLCBkaXNwbGF5ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gU2V0IHRoZSBkaXNwbGF5IG9mIHRoZSBlbGVtZW50cyBpbiBhIHNlY29uZCBsb29wIHRvIGF2b2lkIGNvbnN0YW50IHJlZmxvd1xuXHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggdmFsdWVzWyBpbmRleCBdICE9IG51bGwgKSB7XG5cdFx0XHRlbGVtZW50c1sgaW5kZXggXS5zdHlsZS5kaXNwbGF5ID0gdmFsdWVzWyBpbmRleCBdO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50cztcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzaG93OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMsIHRydWUgKTtcblx0fSxcblx0aGlkZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzICk7XG5cdH0sXG5cdHRvZ2dsZTogZnVuY3Rpb24oIHN0YXRlICkge1xuXHRcdGlmICggdHlwZW9mIHN0YXRlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZSA/IHRoaXMuc2hvdygpIDogdGhpcy5oaWRlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGlzSGlkZGVuV2l0aGluVHJlZSggdGhpcyApICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5zaG93KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5oaWRlKCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG52YXIgcmNoZWNrYWJsZVR5cGUgPSAoIC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pICk7XG5cbnZhciBydGFnTmFtZSA9ICggLzwoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0rKS9pICk7XG5cbnZhciByc2NyaXB0VHlwZSA9ICggL14kfF5tb2R1bGUkfFxcLyg/OmphdmF8ZWNtYSlzY3JpcHQvaSApO1xuXG5cblxuLy8gV2UgaGF2ZSB0byBjbG9zZSB0aGVzZSB0YWdzIHRvIHN1cHBvcnQgWEhUTUwgKCMxMzIwMClcbnZhciB3cmFwTWFwID0ge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdG9wdGlvbjogWyAxLCBcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cIiwgXCI8L3NlbGVjdD5cIiBdLFxuXG5cdC8vIFhIVE1MIHBhcnNlcnMgZG8gbm90IG1hZ2ljYWxseSBpbnNlcnQgZWxlbWVudHMgaW4gdGhlXG5cdC8vIHNhbWUgd2F5IHRoYXQgdGFnIHNvdXAgcGFyc2VycyBkby4gU28gd2UgY2Fubm90IHNob3J0ZW5cblx0Ly8gdGhpcyBieSBvbWl0dGluZyA8dGJvZHk+IG9yIG90aGVyIHJlcXVpcmVkIGVsZW1lbnRzLlxuXHR0aGVhZDogWyAxLCBcIjx0YWJsZT5cIiwgXCI8L3RhYmxlPlwiIF0sXG5cdGNvbDogWyAyLCBcIjx0YWJsZT48Y29sZ3JvdXA+XCIsIFwiPC9jb2xncm91cD48L3RhYmxlPlwiIF0sXG5cdHRyOiBbIDIsIFwiPHRhYmxlPjx0Ym9keT5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCIgXSxcblx0dGQ6IFsgMywgXCI8dGFibGU+PHRib2R5Pjx0cj5cIiwgXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXG5cdF9kZWZhdWx0OiBbIDAsIFwiXCIsIFwiXCIgXVxufTtcblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbndyYXBNYXAub3B0Z3JvdXAgPSB3cmFwTWFwLm9wdGlvbjtcblxud3JhcE1hcC50Ym9keSA9IHdyYXBNYXAudGZvb3QgPSB3cmFwTWFwLmNvbGdyb3VwID0gd3JhcE1hcC5jYXB0aW9uID0gd3JhcE1hcC50aGVhZDtcbndyYXBNYXAudGggPSB3cmFwTWFwLnRkO1xuXG5cbmZ1bmN0aW9uIGdldEFsbCggY29udGV4dCwgdGFnICkge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0Ly8gVXNlIHR5cGVvZiB0byBhdm9pZCB6ZXJvLWFyZ3VtZW50IG1ldGhvZCBpbnZvY2F0aW9uIG9uIGhvc3Qgb2JqZWN0cyAoIzE1MTUxKVxuXHR2YXIgcmV0O1xuXG5cdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0cmV0ID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnIHx8IFwiKlwiICk7XG5cblx0fSBlbHNlIGlmICggdHlwZW9mIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRyZXQgPSBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyB8fCBcIipcIiApO1xuXG5cdH0gZWxzZSB7XG5cdFx0cmV0ID0gW107XG5cdH1cblxuXHRpZiAoIHRhZyA9PT0gdW5kZWZpbmVkIHx8IHRhZyAmJiBub2RlTmFtZSggY29udGV4dCwgdGFnICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5tZXJnZSggWyBjb250ZXh0IF0sIHJldCApO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn1cblxuXG4vLyBNYXJrIHNjcmlwdHMgYXMgaGF2aW5nIGFscmVhZHkgYmVlbiBldmFsdWF0ZWRcbmZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoIGVsZW1zLCByZWZFbGVtZW50cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGRhdGFQcml2LnNldChcblx0XHRcdGVsZW1zWyBpIF0sXG5cdFx0XHRcImdsb2JhbEV2YWxcIixcblx0XHRcdCFyZWZFbGVtZW50cyB8fCBkYXRhUHJpdi5nZXQoIHJlZkVsZW1lbnRzWyBpIF0sIFwiZ2xvYmFsRXZhbFwiIClcblx0XHQpO1xuXHR9XG59XG5cblxudmFyIHJodG1sID0gLzx8JiM/XFx3KzsvO1xuXG5mdW5jdGlvbiBidWlsZEZyYWdtZW50KCBlbGVtcywgY29udGV4dCwgc2NyaXB0cywgc2VsZWN0aW9uLCBpZ25vcmVkICkge1xuXHR2YXIgZWxlbSwgdG1wLCB0YWcsIHdyYXAsIGNvbnRhaW5zLCBqLFxuXHRcdGZyYWdtZW50ID0gY29udGV4dC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0bm9kZXMgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRlbGVtID0gZWxlbXNbIGkgXTtcblxuXHRcdGlmICggZWxlbSB8fCBlbGVtID09PSAwICkge1xuXG5cdFx0XHQvLyBBZGQgbm9kZXMgZGlyZWN0bHlcblx0XHRcdGlmICggdG9UeXBlKCBlbGVtICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgZWxlbS5ub2RlVHlwZSA/IFsgZWxlbSBdIDogZWxlbSApO1xuXG5cdFx0XHQvLyBDb252ZXJ0IG5vbi1odG1sIGludG8gYSB0ZXh0IG5vZGVcblx0XHRcdH0gZWxzZSBpZiAoICFyaHRtbC50ZXN0KCBlbGVtICkgKSB7XG5cdFx0XHRcdG5vZGVzLnB1c2goIGNvbnRleHQuY3JlYXRlVGV4dE5vZGUoIGVsZW0gKSApO1xuXG5cdFx0XHQvLyBDb252ZXJ0IGh0bWwgaW50byBET00gbm9kZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRtcCA9IHRtcCB8fCBmcmFnbWVudC5hcHBlbmRDaGlsZCggY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKTtcblxuXHRcdFx0XHQvLyBEZXNlcmlhbGl6ZSBhIHN0YW5kYXJkIHJlcHJlc2VudGF0aW9uXG5cdFx0XHRcdHRhZyA9ICggcnRhZ05hbWUuZXhlYyggZWxlbSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHR3cmFwID0gd3JhcE1hcFsgdGFnIF0gfHwgd3JhcE1hcC5fZGVmYXVsdDtcblx0XHRcdFx0dG1wLmlubmVySFRNTCA9IHdyYXBbIDEgXSArIGpRdWVyeS5odG1sUHJlZmlsdGVyKCBlbGVtICkgKyB3cmFwWyAyIF07XG5cblx0XHRcdFx0Ly8gRGVzY2VuZCB0aHJvdWdoIHdyYXBwZXJzIHRvIHRoZSByaWdodCBjb250ZW50XG5cdFx0XHRcdGogPSB3cmFwWyAwIF07XG5cdFx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRcdHRtcCA9IHRtcC5sYXN0Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCB0bXAuY2hpbGROb2RlcyApO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyXG5cdFx0XHRcdHRtcCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIHRoZSBjcmVhdGVkIG5vZGVzIGFyZSBvcnBoYW5lZCAoIzEyMzkyKVxuXHRcdFx0XHR0bXAudGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJlbW92ZSB3cmFwcGVyIGZyb20gZnJhZ21lbnRcblx0ZnJhZ21lbnQudGV4dENvbnRlbnQgPSBcIlwiO1xuXG5cdGkgPSAwO1xuXHR3aGlsZSAoICggZWxlbSA9IG5vZGVzWyBpKysgXSApICkge1xuXG5cdFx0Ly8gU2tpcCBlbGVtZW50cyBhbHJlYWR5IGluIHRoZSBjb250ZXh0IGNvbGxlY3Rpb24gKHRyYWMtNDA4Nylcblx0XHRpZiAoIHNlbGVjdGlvbiAmJiBqUXVlcnkuaW5BcnJheSggZWxlbSwgc2VsZWN0aW9uICkgPiAtMSApIHtcblx0XHRcdGlmICggaWdub3JlZCApIHtcblx0XHRcdFx0aWdub3JlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRjb250YWlucyA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cblx0XHQvLyBBcHBlbmQgdG8gZnJhZ21lbnRcblx0XHR0bXAgPSBnZXRBbGwoIGZyYWdtZW50LmFwcGVuZENoaWxkKCBlbGVtICksIFwic2NyaXB0XCIgKTtcblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRpZiAoIGNvbnRhaW5zICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggdG1wICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FwdHVyZSBleGVjdXRhYmxlc1xuXHRcdGlmICggc2NyaXB0cyApIHtcblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0bXBbIGorKyBdICkgKSB7XG5cdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggZWxlbS50eXBlIHx8IFwiXCIgKSApIHtcblx0XHRcdFx0XHRzY3JpcHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmcmFnbWVudDtcbn1cblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0ZGl2ID0gZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApLFxuXHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxuXHQvLyBDaGVjayBzdGF0ZSBsb3N0IGlmIHRoZSBuYW1lIGlzIHNldCAoIzExMjE3KVxuXHQvLyBTdXBwb3J0OiBXaW5kb3dzIFdlYiBBcHBzIChXV0EpXG5cdC8vIGBuYW1lYCBhbmQgYHR5cGVgIG11c3QgdXNlIC5zZXRBdHRyaWJ1dGUgZm9yIFdXQSAoIzE0OTAxKVxuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcInJhZGlvXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcImNoZWNrZWRcIiwgXCJjaGVja2VkXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJ0XCIgKTtcblxuXHRkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSBvbmx5XG5cdC8vIE9sZGVyIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xuXHRzdXBwb3J0LmNoZWNrQ2xvbmUgPSBkaXYuY2xvbmVOb2RlKCB0cnVlICkuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmNoZWNrZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXG5cdGRpdi5pbm5lckhUTUwgPSBcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIjtcblx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XG59ICkoKTtcbnZhciBkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblxuXG52YXJcblx0cmtleUV2ZW50ID0gL15rZXkvLFxuXHRybW91c2VFdmVudCA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudXxkcmFnfGRyb3ApfGNsaWNrLyxcblx0cnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkvO1xuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbi8vIFNlZSAjMTMzOTMgZm9yIG1vcmUgaW5mb1xuZnVuY3Rpb24gc2FmZUFjdGl2ZUVsZW1lbnQoKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cdH0gY2F0Y2ggKCBlcnIgKSB7IH1cbn1cblxuZnVuY3Rpb24gb24oIGVsZW0sIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIG9uZSApIHtcblx0dmFyIG9yaWdGbiwgdHlwZTtcblxuXHQvLyBUeXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcblx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyAoIHR5cGVzLU9iamVjdCwgc2VsZWN0b3IsIGRhdGEgKVxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLU9iamVjdCwgZGF0YSApXG5cdFx0XHRkYXRhID0gZGF0YSB8fCBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0b24oIGVsZW0sIHR5cGUsIHNlbGVjdG9yLCBkYXRhLCB0eXBlc1sgdHlwZSBdLCBvbmUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIGRhdGEgPT0gbnVsbCAmJiBmbiA9PSBudWxsICkge1xuXG5cdFx0Ly8gKCB0eXBlcywgZm4gKVxuXHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0ZGF0YSA9IHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKCBmbiA9PSBudWxsICkge1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBzZWxlY3RvciwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBkYXRhLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0fSBlbHNlIGlmICggIWZuICkge1xuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBvbmUgPT09IDEgKSB7XG5cdFx0b3JpZ0ZuID0gZm47XG5cdFx0Zm4gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xuXHRcdFx0alF1ZXJ5KCkub2ZmKCBldmVudCApO1xuXHRcdFx0cmV0dXJuIG9yaWdGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fTtcblxuXHRcdC8vIFVzZSBzYW1lIGd1aWQgc28gY2FsbGVyIGNhbiByZW1vdmUgdXNpbmcgb3JpZ0ZuXG5cdFx0Zm4uZ3VpZCA9IG9yaWdGbi5ndWlkIHx8ICggb3JpZ0ZuLmd1aWQgPSBqUXVlcnkuZ3VpZCsrICk7XG5cdH1cblx0cmV0dXJuIGVsZW0uZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgdHlwZXMsIGZuLCBkYXRhLCBzZWxlY3RvciApO1xuXHR9ICk7XG59XG5cbi8qXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBtYW5hZ2luZyBldmVudHMgLS0gbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuXG4gKiBQcm9wcyB0byBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkgZm9yIG1hbnkgb2YgdGhlIGlkZWFzLlxuICovXG5qUXVlcnkuZXZlbnQgPSB7XG5cblx0Z2xvYmFsOiB7fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgZGF0YSwgc2VsZWN0b3IgKSB7XG5cblx0XHR2YXIgaGFuZGxlT2JqSW4sIGV2ZW50SGFuZGxlLCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHQvLyBEb24ndCBhdHRhY2ggZXZlbnRzIHRvIG5vRGF0YSBvciB0ZXh0L2NvbW1lbnQgbm9kZXMgKGJ1dCBhbGxvdyBwbGFpbiBvYmplY3RzKVxuXHRcdGlmICggIWVsZW1EYXRhICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlclxuXHRcdGlmICggaGFuZGxlci5oYW5kbGVyICkge1xuXHRcdFx0aGFuZGxlT2JqSW4gPSBoYW5kbGVyO1xuXHRcdFx0aGFuZGxlciA9IGhhbmRsZU9iakluLmhhbmRsZXI7XG5cdFx0XHRzZWxlY3RvciA9IGhhbmRsZU9iakluLnNlbGVjdG9yO1xuXHRcdH1cblxuXHRcdC8vIEVuc3VyZSB0aGF0IGludmFsaWQgc2VsZWN0b3JzIHRocm93IGV4Y2VwdGlvbnMgYXQgYXR0YWNoIHRpbWVcblx0XHQvLyBFdmFsdWF0ZSBhZ2FpbnN0IGRvY3VtZW50RWxlbWVudCBpbiBjYXNlIGVsZW0gaXMgYSBub24tZWxlbWVudCBub2RlIChlLmcuLCBkb2N1bWVudClcblx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBkb2N1bWVudEVsZW1lbnQsIHNlbGVjdG9yICk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIGhhbmRsZXIgaGFzIGEgdW5pcXVlIElELCB1c2VkIHRvIGZpbmQvcmVtb3ZlIGl0IGxhdGVyXG5cdFx0aWYgKCAhaGFuZGxlci5ndWlkICkge1xuXHRcdFx0aGFuZGxlci5ndWlkID0galF1ZXJ5Lmd1aWQrKztcblx0XHR9XG5cblx0XHQvLyBJbml0IHRoZSBlbGVtZW50J3MgZXZlbnQgc3RydWN0dXJlIGFuZCBtYWluIGhhbmRsZXIsIGlmIHRoaXMgaXMgdGhlIGZpcnN0XG5cdFx0aWYgKCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyA9IHt9O1xuXHRcdH1cblx0XHRpZiAoICEoIGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlICkgKSB7XG5cdFx0XHRldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSA9IGZ1bmN0aW9uKCBlICkge1xuXG5cdFx0XHRcdC8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhIGpRdWVyeS5ldmVudC50cmlnZ2VyKCkgYW5kXG5cdFx0XHRcdC8vIHdoZW4gYW4gZXZlbnQgaXMgY2FsbGVkIGFmdGVyIGEgcGFnZSBoYXMgdW5sb2FkZWRcblx0XHRcdFx0cmV0dXJuIHR5cGVvZiBqUXVlcnkgIT09IFwidW5kZWZpbmVkXCIgJiYgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCAhPT0gZS50eXBlID9cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuZGlzcGF0Y2guYXBwbHkoIGVsZW0sIGFyZ3VtZW50cyApIDogdW5kZWZpbmVkO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBIYW5kbGUgbXVsdGlwbGUgZXZlbnRzIHNlcGFyYXRlZCBieSBhIHNwYWNlXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFRoZXJlICptdXN0KiBiZSBhIHR5cGUsIG5vIGF0dGFjaGluZyBuYW1lc3BhY2Utb25seSBoYW5kbGVyc1xuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIElmIHNlbGVjdG9yIGRlZmluZWQsIGRldGVybWluZSBzcGVjaWFsIGV2ZW50IGFwaSB0eXBlLCBvdGhlcndpc2UgZ2l2ZW4gdHlwZVxuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBVcGRhdGUgc3BlY2lhbCBiYXNlZCBvbiBuZXdseSByZXNldCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcblx0XHRcdGhhbmRsZU9iaiA9IGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0b3JpZ1R5cGU6IG9yaWdUeXBlLFxuXHRcdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0XHRoYW5kbGVyOiBoYW5kbGVyLFxuXHRcdFx0XHRndWlkOiBoYW5kbGVyLmd1aWQsXG5cdFx0XHRcdHNlbGVjdG9yOiBzZWxlY3Rvcixcblx0XHRcdFx0bmVlZHNDb250ZXh0OiBzZWxlY3RvciAmJiBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSxcblx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiIClcblx0XHRcdH0sIGhhbmRsZU9iakluICk7XG5cblx0XHRcdC8vIEluaXQgdGhlIGV2ZW50IGhhbmRsZXIgcXVldWUgaWYgd2UncmUgdGhlIGZpcnN0XG5cdFx0XHRpZiAoICEoIGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gKSApIHtcblx0XHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSA9IFtdO1xuXHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50ID0gMDtcblxuXHRcdFx0XHQvLyBPbmx5IHVzZSBhZGRFdmVudExpc3RlbmVyIGlmIHRoZSBzcGVjaWFsIGV2ZW50cyBoYW5kbGVyIHJldHVybnMgZmFsc2Vcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC5zZXR1cCB8fFxuXHRcdFx0XHRcdHNwZWNpYWwuc2V0dXAuY2FsbCggZWxlbSwgZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0uYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdFx0XHRcdGVsZW0uYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgZXZlbnRIYW5kbGUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzcGVjaWFsLmFkZCApIHtcblx0XHRcdFx0c3BlY2lhbC5hZGQuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cblx0XHRcdFx0aWYgKCAhaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlci5ndWlkID0gaGFuZGxlci5ndWlkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB0byB0aGUgZWxlbWVudCdzIGhhbmRsZXIgbGlzdCwgZGVsZWdhdGVzIGluIGZyb250XG5cdFx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQrKywgMCwgaGFuZGxlT2JqICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gS2VlcCB0cmFjayBvZiB3aGljaCBldmVudHMgaGF2ZSBldmVyIGJlZW4gdXNlZCwgZm9yIGV2ZW50IG9wdGltaXphdGlvblxuXHRcdFx0alF1ZXJ5LmV2ZW50Lmdsb2JhbFsgdHlwZSBdID0gdHJ1ZTtcblx0XHR9XG5cblx0fSxcblxuXHQvLyBEZXRhY2ggYW4gZXZlbnQgb3Igc2V0IG9mIGV2ZW50cyBmcm9tIGFuIGVsZW1lbnRcblx0cmVtb3ZlOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIHNlbGVjdG9yLCBtYXBwZWRUeXBlcyApIHtcblxuXHRcdHZhciBqLCBvcmlnQ291bnQsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICkgJiYgZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHRpZiAoICFlbGVtRGF0YSB8fCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBPbmNlIGZvciBlYWNoIHR5cGUubmFtZXNwYWNlIGluIHR5cGVzOyB0eXBlIG1heSBiZSBvbWl0dGVkXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSArIHR5cGVzWyB0IF0sIGhhbmRsZXIsIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSB8fCBbXTtcblx0XHRcdHRtcCA9IHRtcFsgMiBdICYmXG5cdFx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApO1xuXG5cdFx0XHQvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXG5cdFx0XHRvcmlnQ291bnQgPSBqID0gaGFuZGxlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBqIF07XG5cblx0XHRcdFx0aWYgKCAoIG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUgKSAmJlxuXHRcdFx0XHRcdCggIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCApICYmXG5cdFx0XHRcdFx0KCAhdG1wIHx8IHRtcC50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSAmJlxuXHRcdFx0XHRcdCggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHxcblx0XHRcdFx0XHRcdHNlbGVjdG9yID09PSBcIioqXCIgJiYgaGFuZGxlT2JqLnNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBqLCAxICk7XG5cblx0XHRcdFx0XHRpZiAoIGhhbmRsZU9iai5zZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzcGVjaWFsLnJlbW92ZSApIHtcblx0XHRcdFx0XHRcdHNwZWNpYWwucmVtb3ZlLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgZ2VuZXJpYyBldmVudCBoYW5kbGVyIGlmIHdlIHJlbW92ZWQgc29tZXRoaW5nIGFuZCBubyBtb3JlIGhhbmRsZXJzIGV4aXN0XG5cdFx0XHQvLyAoYXZvaWRzIHBvdGVudGlhbCBmb3IgZW5kbGVzcyByZWN1cnNpb24gZHVyaW5nIHJlbW92YWwgb2Ygc3BlY2lhbCBldmVudCBoYW5kbGVycylcblx0XHRcdGlmICggb3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdGlmICggIXNwZWNpYWwudGVhcmRvd24gfHxcblx0XHRcdFx0XHRzcGVjaWFsLnRlYXJkb3duLmNhbGwoIGVsZW0sIG5hbWVzcGFjZXMsIGVsZW1EYXRhLmhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgZXZlbnRzWyB0eXBlIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIGRhdGEgYW5kIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcblx0XHRpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBldmVudHMgKSApIHtcblx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJoYW5kbGUgZXZlbnRzXCIgKTtcblx0XHR9XG5cdH0sXG5cblx0ZGlzcGF0Y2g6IGZ1bmN0aW9uKCBuYXRpdmVFdmVudCApIHtcblxuXHRcdC8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxuXHRcdHZhciBldmVudCA9IGpRdWVyeS5ldmVudC5maXgoIG5hdGl2ZUV2ZW50ICk7XG5cblx0XHR2YXIgaSwgaiwgcmV0LCBtYXRjaGVkLCBoYW5kbGVPYmosIGhhbmRsZXJRdWV1ZSxcblx0XHRcdGFyZ3MgPSBuZXcgQXJyYXkoIGFyZ3VtZW50cy5sZW5ndGggKSxcblx0XHRcdGhhbmRsZXJzID0gKCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gfHwgW10sXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGV2ZW50LnR5cGUgXSB8fCB7fTtcblxuXHRcdC8vIFVzZSB0aGUgZml4LWVkIGpRdWVyeS5FdmVudCByYXRoZXIgdGhhbiB0aGUgKHJlYWQtb25seSkgbmF0aXZlIGV2ZW50XG5cdFx0YXJnc1sgMCBdID0gZXZlbnQ7XG5cblx0XHRmb3IgKCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdGFyZ3NbIGkgXSA9IGFyZ3VtZW50c1sgaSBdO1xuXHRcdH1cblxuXHRcdGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGhpcztcblxuXHRcdC8vIENhbGwgdGhlIHByZURpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZSwgYW5kIGxldCBpdCBiYWlsIGlmIGRlc2lyZWRcblx0XHRpZiAoIHNwZWNpYWwucHJlRGlzcGF0Y2ggJiYgc3BlY2lhbC5wcmVEaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgaGFuZGxlcnNcblx0XHRoYW5kbGVyUXVldWUgPSBqUXVlcnkuZXZlbnQuaGFuZGxlcnMuY2FsbCggdGhpcywgZXZlbnQsIGhhbmRsZXJzICk7XG5cblx0XHQvLyBSdW4gZGVsZWdhdGVzIGZpcnN0OyB0aGV5IG1heSB3YW50IHRvIHN0b3AgcHJvcGFnYXRpb24gYmVuZWF0aCB1c1xuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBtYXRjaGVkID0gaGFuZGxlclF1ZXVlWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0ZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcblxuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggaGFuZGxlT2JqID0gbWF0Y2hlZC5oYW5kbGVyc1sgaisrIF0gKSAmJlxuXHRcdFx0XHQhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0XHQvLyBUcmlnZ2VyZWQgZXZlbnQgbXVzdCBlaXRoZXIgMSkgaGF2ZSBubyBuYW1lc3BhY2UsIG9yIDIpIGhhdmUgbmFtZXNwYWNlKHMpXG5cdFx0XHRcdC8vIGEgc3Vic2V0IG9yIGVxdWFsIHRvIHRob3NlIGluIHRoZSBib3VuZCBldmVudCAoYm90aCBjYW4gaGF2ZSBubyBuYW1lc3BhY2UpLlxuXHRcdFx0XHRpZiAoICFldmVudC5ybmFtZXNwYWNlIHx8IGV2ZW50LnJuYW1lc3BhY2UudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkge1xuXG5cdFx0XHRcdFx0ZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xuXHRcdFx0XHRcdGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcblxuXHRcdFx0XHRcdHJldCA9ICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgaGFuZGxlT2JqLm9yaWdUeXBlIF0gfHwge30gKS5oYW5kbGUgfHxcblx0XHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyICkuYXBwbHkoIG1hdGNoZWQuZWxlbSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGlmICggKCBldmVudC5yZXN1bHQgPSByZXQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGwgdGhlIHBvc3REaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGVcblx0XHRpZiAoIHNwZWNpYWwucG9zdERpc3BhdGNoICkge1xuXHRcdFx0c3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdGhhbmRsZXJzOiBmdW5jdGlvbiggZXZlbnQsIGhhbmRsZXJzICkge1xuXHRcdHZhciBpLCBoYW5kbGVPYmosIHNlbCwgbWF0Y2hlZEhhbmRsZXJzLCBtYXRjaGVkU2VsZWN0b3JzLFxuXHRcdFx0aGFuZGxlclF1ZXVlID0gW10sXG5cdFx0XHRkZWxlZ2F0ZUNvdW50ID0gaGFuZGxlcnMuZGVsZWdhdGVDb3VudCxcblx0XHRcdGN1ciA9IGV2ZW50LnRhcmdldDtcblxuXHRcdC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05XG5cdFx0XHQvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAodHJhYy0xMzE4MClcblx0XHRcdGN1ci5ub2RlVHlwZSAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDJcblx0XHRcdC8vIFN1cHByZXNzIHNwZWMtdmlvbGF0aW5nIGNsaWNrcyBpbmRpY2F0aW5nIGEgbm9uLXByaW1hcnkgcG9pbnRlciBidXR0b24gKHRyYWMtMzg2MSlcblx0XHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50LXR5cGUtY2xpY2tcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdC8vIC4uLmJ1dCBub3QgYXJyb3cga2V5IFwiY2xpY2tzXCIgb2YgcmFkaW8gaW5wdXRzLCB3aGljaCBjYW4gaGF2ZSBgYnV0dG9uYCAtMSAoZ2gtMjM0Mylcblx0XHRcdCEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBldmVudC5idXR0b24gPj0gMSApICkge1xuXG5cdFx0XHRmb3IgKCA7IGN1ciAhPT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHtcblxuXHRcdFx0XHQvLyBEb24ndCBjaGVjayBub24tZWxlbWVudHMgKCMxMzIwOClcblx0XHRcdFx0Ly8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKCM2OTExLCAjODE2NSwgIzExMzgyLCAjMTE3NjQpXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlID09PSAxICYmICEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBjdXIuZGlzYWJsZWQgPT09IHRydWUgKSApIHtcblx0XHRcdFx0XHRtYXRjaGVkSGFuZGxlcnMgPSBbXTtcblx0XHRcdFx0XHRtYXRjaGVkU2VsZWN0b3JzID0ge307XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoIzEzMjAzKVxuXHRcdFx0XHRcdFx0c2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXCIgXCI7XG5cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0ID9cblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkoIHNlbCwgdGhpcyApLmluZGV4KCBjdXIgKSA+IC0xIDpcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZCggc2VsLCB0aGlzLCBudWxsLCBbIGN1ciBdICkubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRIYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBtYXRjaGVkSGFuZGxlcnMgfSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcblx0XHRjdXIgPSB0aGlzO1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCA8IGhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IGhhbmRsZXJzLnNsaWNlKCBkZWxlZ2F0ZUNvdW50ICkgfSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBoYW5kbGVyUXVldWU7XG5cdH0sXG5cblx0YWRkUHJvcDogZnVuY3Rpb24oIG5hbWUsIGhvb2sgKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBqUXVlcnkuRXZlbnQucHJvdG90eXBlLCBuYW1lLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXG5cdFx0XHRnZXQ6IGlzRnVuY3Rpb24oIGhvb2sgKSA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gaG9vayggdGhpcy5vcmlnaW5hbEV2ZW50ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IDpcblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLm9yaWdpbmFsRXZlbnRbIG5hbWUgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsIG5hbWUsIHtcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWVcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRmaXg6IGZ1bmN0aW9uKCBvcmlnaW5hbEV2ZW50ICkge1xuXHRcdHJldHVybiBvcmlnaW5hbEV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdG9yaWdpbmFsRXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXHR9LFxuXG5cdHNwZWNpYWw6IHtcblx0XHRsb2FkOiB7XG5cblx0XHRcdC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcblx0XHRcdG5vQnViYmxlOiB0cnVlXG5cdFx0fSxcblx0XHRmb2N1czoge1xuXG5cdFx0XHQvLyBGaXJlIG5hdGl2ZSBldmVudCBpZiBwb3NzaWJsZSBzbyBibHVyL2ZvY3VzIHNlcXVlbmNlIGlzIGNvcnJlY3Rcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMgIT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5mb2N1cyApIHtcblx0XHRcdFx0XHR0aGlzLmZvY3VzKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVsZWdhdGVUeXBlOiBcImZvY3VzaW5cIlxuXHRcdH0sXG5cdFx0Ymx1cjoge1xuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcyA9PT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmJsdXIgKSB7XG5cdFx0XHRcdFx0dGhpcy5ibHVyKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVsZWdhdGVUeXBlOiBcImZvY3Vzb3V0XCJcblx0XHR9LFxuXHRcdGNsaWNrOiB7XG5cblx0XHRcdC8vIEZvciBjaGVja2JveCwgZmlyZSBuYXRpdmUgZXZlbnQgc28gY2hlY2tlZCBzdGF0ZSB3aWxsIGJlIHJpZ2h0XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzLnR5cGUgPT09IFwiY2hlY2tib3hcIiAmJiB0aGlzLmNsaWNrICYmIG5vZGVOYW1lKCB0aGlzLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR0aGlzLmNsaWNrKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBGb3IgY3Jvc3MtYnJvd3NlciBjb25zaXN0ZW5jeSwgZG9uJ3QgZmlyZSBuYXRpdmUgLmNsaWNrKCkgb24gbGlua3Ncblx0XHRcdF9kZWZhdWx0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHJldHVybiBub2RlTmFtZSggZXZlbnQudGFyZ2V0LCBcImFcIiApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRiZWZvcmV1bmxvYWQ6IHtcblx0XHRcdHBvc3REaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggMjArXG5cdFx0XHRcdC8vIEZpcmVmb3ggZG9lc24ndCBhbGVydCBpZiB0aGUgcmV0dXJuVmFsdWUgZmllbGQgaXMgbm90IHNldC5cblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgIT09IHVuZGVmaW5lZCAmJiBldmVudC5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdGV2ZW50Lm9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWUgPSBldmVudC5yZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBoYW5kbGUgKSB7XG5cblx0Ly8gVGhpcyBcImlmXCIgaXMgbmVlZGVkIGZvciBwbGFpbiBvYmplY3RzXG5cdGlmICggZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyICkge1xuXHRcdGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgaGFuZGxlICk7XG5cdH1cbn07XG5cbmpRdWVyeS5FdmVudCA9IGZ1bmN0aW9uKCBzcmMsIHByb3BzICkge1xuXG5cdC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgJ25ldycga2V5d29yZFxuXHRpZiAoICEoIHRoaXMgaW5zdGFuY2VvZiBqUXVlcnkuRXZlbnQgKSApIHtcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5FdmVudCggc3JjLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gRXZlbnQgb2JqZWN0XG5cdGlmICggc3JjICYmIHNyYy50eXBlICkge1xuXHRcdHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcblx0XHR0aGlzLnR5cGUgPSBzcmMudHlwZTtcblxuXHRcdC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXG5cdFx0Ly8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBzcmMuZGVmYXVsdFByZXZlbnRlZCB8fFxuXHRcdFx0XHRzcmMuZGVmYXVsdFByZXZlbnRlZCA9PT0gdW5kZWZpbmVkICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5XG5cdFx0XHRcdHNyYy5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0cmV0dXJuVHJ1ZSA6XG5cdFx0XHRyZXR1cm5GYWxzZTtcblxuXHRcdC8vIENyZWF0ZSB0YXJnZXQgcHJvcGVydGllc1xuXHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA8PTYgLSA3IG9ubHlcblx0XHQvLyBUYXJnZXQgc2hvdWxkIG5vdCBiZSBhIHRleHQgbm9kZSAoIzUwNCwgIzEzMTQzKVxuXHRcdHRoaXMudGFyZ2V0ID0gKCBzcmMudGFyZ2V0ICYmIHNyYy50YXJnZXQubm9kZVR5cGUgPT09IDMgKSA/XG5cdFx0XHRzcmMudGFyZ2V0LnBhcmVudE5vZGUgOlxuXHRcdFx0c3JjLnRhcmdldDtcblxuXHRcdHRoaXMuY3VycmVudFRhcmdldCA9IHNyYy5jdXJyZW50VGFyZ2V0O1xuXHRcdHRoaXMucmVsYXRlZFRhcmdldCA9IHNyYy5yZWxhdGVkVGFyZ2V0O1xuXG5cdC8vIEV2ZW50IHR5cGVcblx0fSBlbHNlIHtcblx0XHR0aGlzLnR5cGUgPSBzcmM7XG5cdH1cblxuXHQvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuXHRpZiAoIHByb3BzICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRoaXMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxuXHR0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG5cblx0Ly8gTWFyayBpdCBhcyBmaXhlZFxuXHR0aGlzWyBqUXVlcnkuZXhwYW5kbyBdID0gdHJ1ZTtcbn07XG5cbi8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxualF1ZXJ5LkV2ZW50LnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IGpRdWVyeS5FdmVudCxcblx0aXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcblx0aXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzU2ltdWxhdGVkOiBmYWxzZSxcblxuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH1cblx0fSxcblx0c3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cblx0XHR0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9XG59O1xuXG4vLyBJbmNsdWRlcyBhbGwgY29tbW9uIGV2ZW50IHByb3BzIGluY2x1ZGluZyBLZXlFdmVudCBhbmQgTW91c2VFdmVudCBzcGVjaWZpYyBwcm9wc1xualF1ZXJ5LmVhY2goIHtcblx0YWx0S2V5OiB0cnVlLFxuXHRidWJibGVzOiB0cnVlLFxuXHRjYW5jZWxhYmxlOiB0cnVlLFxuXHRjaGFuZ2VkVG91Y2hlczogdHJ1ZSxcblx0Y3RybEtleTogdHJ1ZSxcblx0ZGV0YWlsOiB0cnVlLFxuXHRldmVudFBoYXNlOiB0cnVlLFxuXHRtZXRhS2V5OiB0cnVlLFxuXHRwYWdlWDogdHJ1ZSxcblx0cGFnZVk6IHRydWUsXG5cdHNoaWZ0S2V5OiB0cnVlLFxuXHR2aWV3OiB0cnVlLFxuXHRcImNoYXJcIjogdHJ1ZSxcblx0Y2hhckNvZGU6IHRydWUsXG5cdGtleTogdHJ1ZSxcblx0a2V5Q29kZTogdHJ1ZSxcblx0YnV0dG9uOiB0cnVlLFxuXHRidXR0b25zOiB0cnVlLFxuXHRjbGllbnRYOiB0cnVlLFxuXHRjbGllbnRZOiB0cnVlLFxuXHRvZmZzZXRYOiB0cnVlLFxuXHRvZmZzZXRZOiB0cnVlLFxuXHRwb2ludGVySWQ6IHRydWUsXG5cdHBvaW50ZXJUeXBlOiB0cnVlLFxuXHRzY3JlZW5YOiB0cnVlLFxuXHRzY3JlZW5ZOiB0cnVlLFxuXHR0YXJnZXRUb3VjaGVzOiB0cnVlLFxuXHR0b0VsZW1lbnQ6IHRydWUsXG5cdHRvdWNoZXM6IHRydWUsXG5cblx0d2hpY2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xuXG5cdFx0Ly8gQWRkIHdoaWNoIGZvciBrZXkgZXZlbnRzXG5cdFx0aWYgKCBldmVudC53aGljaCA9PSBudWxsICYmIHJrZXlFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XG5cdFx0XHRyZXR1cm4gZXZlbnQuY2hhckNvZGUgIT0gbnVsbCA/IGV2ZW50LmNoYXJDb2RlIDogZXZlbnQua2V5Q29kZTtcblx0XHR9XG5cblx0XHQvLyBBZGQgd2hpY2ggZm9yIGNsaWNrOiAxID09PSBsZWZ0OyAyID09PSBtaWRkbGU7IDMgPT09IHJpZ2h0XG5cdFx0aWYgKCAhZXZlbnQud2hpY2ggJiYgYnV0dG9uICE9PSB1bmRlZmluZWQgJiYgcm1vdXNlRXZlbnQudGVzdCggZXZlbnQudHlwZSApICkge1xuXHRcdFx0aWYgKCBidXR0b24gJiAxICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBidXR0b24gJiAyICkge1xuXHRcdFx0XHRyZXR1cm4gMztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBidXR0b24gJiA0ICkge1xuXHRcdFx0XHRyZXR1cm4gMjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LndoaWNoO1xuXHR9XG59LCBqUXVlcnkuZXZlbnQuYWRkUHJvcCApO1xuXG4vLyBDcmVhdGUgbW91c2VlbnRlci9sZWF2ZSBldmVudHMgdXNpbmcgbW91c2VvdmVyL291dCBhbmQgZXZlbnQtdGltZSBjaGVja3Ncbi8vIHNvIHRoYXQgZXZlbnQgZGVsZWdhdGlvbiB3b3JrcyBpbiBqUXVlcnkuXG4vLyBEbyB0aGUgc2FtZSBmb3IgcG9pbnRlcmVudGVyL3BvaW50ZXJsZWF2ZSBhbmQgcG9pbnRlcm92ZXIvcG9pbnRlcm91dFxuLy9cbi8vIFN1cHBvcnQ6IFNhZmFyaSA3IG9ubHlcbi8vIFNhZmFyaSBzZW5kcyBtb3VzZWVudGVyIHRvbyBvZnRlbjsgc2VlOlxuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDcwMjU4XG4vLyBmb3IgdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBidWcgKGl0IGV4aXN0ZWQgaW4gb2xkZXIgQ2hyb21lIHZlcnNpb25zIGFzIHdlbGwpLlxualF1ZXJ5LmVhY2goIHtcblx0bW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcblx0bW91c2VsZWF2ZTogXCJtb3VzZW91dFwiLFxuXHRwb2ludGVyZW50ZXI6IFwicG9pbnRlcm92ZXJcIixcblx0cG9pbnRlcmxlYXZlOiBcInBvaW50ZXJvdXRcIlxufSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIG9yaWcgXSA9IHtcblx0XHRkZWxlZ2F0ZVR5cGU6IGZpeCxcblx0XHRiaW5kVHlwZTogZml4LFxuXG5cdFx0aGFuZGxlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHR0YXJnZXQgPSB0aGlzLFxuXHRcdFx0XHRyZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldCxcblx0XHRcdFx0aGFuZGxlT2JqID0gZXZlbnQuaGFuZGxlT2JqO1xuXG5cdFx0XHQvLyBGb3IgbW91c2VlbnRlci9sZWF2ZSBjYWxsIHRoZSBoYW5kbGVyIGlmIHJlbGF0ZWQgaXMgb3V0c2lkZSB0aGUgdGFyZ2V0LlxuXHRcdFx0Ly8gTkI6IE5vIHJlbGF0ZWRUYXJnZXQgaWYgdGhlIG1vdXNlIGxlZnQvZW50ZXJlZCB0aGUgYnJvd3NlciB3aW5kb3dcblx0XHRcdGlmICggIXJlbGF0ZWQgfHwgKCByZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyggdGFyZ2V0LCByZWxhdGVkICkgKSApIHtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGhhbmRsZU9iai5vcmlnVHlwZTtcblx0XHRcdFx0cmV0ID0gaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRldmVudC50eXBlID0gZml4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRvbjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdG9uZTogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAxICk7XG5cdH0sXG5cdG9mZjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZm4gKSB7XG5cdFx0dmFyIGhhbmRsZU9iaiwgdHlwZTtcblx0XHRpZiAoIHR5cGVzICYmIHR5cGVzLnByZXZlbnREZWZhdWx0ICYmIHR5cGVzLmhhbmRsZU9iaiApIHtcblxuXHRcdFx0Ly8gKCBldmVudCApICBkaXNwYXRjaGVkIGpRdWVyeS5FdmVudFxuXHRcdFx0aGFuZGxlT2JqID0gdHlwZXMuaGFuZGxlT2JqO1xuXHRcdFx0alF1ZXJ5KCB0eXBlcy5kZWxlZ2F0ZVRhcmdldCApLm9mZihcblx0XHRcdFx0aGFuZGxlT2JqLm5hbWVzcGFjZSA/XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlICsgXCIuXCIgKyBoYW5kbGVPYmoubmFtZXNwYWNlIDpcblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUsXG5cdFx0XHRcdGhhbmRsZU9iai5zZWxlY3Rvcixcblx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXJcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtb2JqZWN0IFssIHNlbGVjdG9yXSApXG5cdFx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0XHR0aGlzLm9mZiggdHlwZSwgc2VsZWN0b3IsIHR5cGVzWyB0eXBlIF0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHNlbGVjdG9yID09PSBmYWxzZSB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcyBbLCBmbl0gKVxuXHRcdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgdHlwZXMsIGZuLCBzZWxlY3RvciApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbnZhclxuXG5cdC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzbGludC9lc2xpbnQvaXNzdWVzLzMyMjlcblx0cnhodG1sVGFnID0gLzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0qKVtePl0qKVxcLz4vZ2ksXG5cblx0LyogZXNsaW50LWVuYWJsZSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSwgRWRnZSAxMiAtIDEzIG9ubHlcblx0Ly8gSW4gSUUvRWRnZSB1c2luZyByZWdleCBncm91cHMgaGVyZSBjYXVzZXMgc2V2ZXJlIHNsb3dkb3ducy5cblx0Ly8gU2VlIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvMTczNjUxMi9cblx0cm5vSW5uZXJodG1sID0gLzxzY3JpcHR8PHN0eWxlfDxsaW5rL2ksXG5cblx0Ly8gY2hlY2tlZD1cImNoZWNrZWRcIiBvciBjaGVja2VkXG5cdHJjaGVja2VkID0gL2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxcblx0cmNsZWFuU2NyaXB0ID0gL15cXHMqPCEoPzpcXFtDREFUQVxcW3wtLSl8KD86XFxdXFxdfC0tKT5cXHMqJC9nO1xuXG4vLyBQcmVmZXIgYSB0Ym9keSBvdmVyIGl0cyBwYXJlbnQgdGFibGUgZm9yIGNvbnRhaW5pbmcgbmV3IHJvd3NcbmZ1bmN0aW9uIG1hbmlwdWxhdGlvblRhcmdldCggZWxlbSwgY29udGVudCApIHtcblx0aWYgKCBub2RlTmFtZSggZWxlbSwgXCJ0YWJsZVwiICkgJiZcblx0XHRub2RlTmFtZSggY29udGVudC5ub2RlVHlwZSAhPT0gMTEgPyBjb250ZW50IDogY29udGVudC5maXJzdENoaWxkLCBcInRyXCIgKSApIHtcblxuXHRcdHJldHVybiBqUXVlcnkoIGVsZW0gKS5jaGlsZHJlbiggXCJ0Ym9keVwiIClbIDAgXSB8fCBlbGVtO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbi8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cbmZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoIGVsZW0gKSB7XG5cdGVsZW0udHlwZSA9ICggZWxlbS5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICkgIT09IG51bGwgKSArIFwiL1wiICsgZWxlbS50eXBlO1xuXHRyZXR1cm4gZWxlbTtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVTY3JpcHQoIGVsZW0gKSB7XG5cdGlmICggKCBlbGVtLnR5cGUgfHwgXCJcIiApLnNsaWNlKCAwLCA1ICkgPT09IFwidHJ1ZS9cIiApIHtcblx0XHRlbGVtLnR5cGUgPSBlbGVtLnR5cGUuc2xpY2UoIDUgKTtcblx0fSBlbHNlIHtcblx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggXCJ0eXBlXCIgKTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5mdW5jdGlvbiBjbG9uZUNvcHlFdmVudCggc3JjLCBkZXN0ICkge1xuXHR2YXIgaSwgbCwgdHlwZSwgcGRhdGFPbGQsIHBkYXRhQ3VyLCB1ZGF0YU9sZCwgdWRhdGFDdXIsIGV2ZW50cztcblxuXHRpZiAoIGRlc3Qubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gMS4gQ29weSBwcml2YXRlIGRhdGE6IGV2ZW50cywgaGFuZGxlcnMsIGV0Yy5cblx0aWYgKCBkYXRhUHJpdi5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHRwZGF0YU9sZCA9IGRhdGFQcml2LmFjY2Vzcyggc3JjICk7XG5cdFx0cGRhdGFDdXIgPSBkYXRhUHJpdi5zZXQoIGRlc3QsIHBkYXRhT2xkICk7XG5cdFx0ZXZlbnRzID0gcGRhdGFPbGQuZXZlbnRzO1xuXG5cdFx0aWYgKCBldmVudHMgKSB7XG5cdFx0XHRkZWxldGUgcGRhdGFDdXIuaGFuZGxlO1xuXHRcdFx0cGRhdGFDdXIuZXZlbnRzID0ge307XG5cblx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IGV2ZW50c1sgdHlwZSBdLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBkZXN0LCB0eXBlLCBldmVudHNbIHR5cGUgXVsgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyAyLiBDb3B5IHVzZXIgZGF0YVxuXHRpZiAoIGRhdGFVc2VyLmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHVkYXRhT2xkID0gZGF0YVVzZXIuYWNjZXNzKCBzcmMgKTtcblx0XHR1ZGF0YUN1ciA9IGpRdWVyeS5leHRlbmQoIHt9LCB1ZGF0YU9sZCApO1xuXG5cdFx0ZGF0YVVzZXIuc2V0KCBkZXN0LCB1ZGF0YUN1ciApO1xuXHR9XG59XG5cbi8vIEZpeCBJRSBidWdzLCBzZWUgc3VwcG9ydCB0ZXN0c1xuZnVuY3Rpb24gZml4SW5wdXQoIHNyYywgZGVzdCApIHtcblx0dmFyIG5vZGVOYW1lID0gZGVzdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdC8vIEZhaWxzIHRvIHBlcnNpc3QgdGhlIGNoZWNrZWQgc3RhdGUgb2YgYSBjbG9uZWQgY2hlY2tib3ggb3IgcmFkaW8gYnV0dG9uLlxuXHRpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgcmNoZWNrYWJsZVR5cGUudGVzdCggc3JjLnR5cGUgKSApIHtcblx0XHRkZXN0LmNoZWNrZWQgPSBzcmMuY2hlY2tlZDtcblxuXHQvLyBGYWlscyB0byByZXR1cm4gdGhlIHNlbGVjdGVkIG9wdGlvbiB0byB0aGUgZGVmYXVsdCBzZWxlY3RlZCBzdGF0ZSB3aGVuIGNsb25pbmcgb3B0aW9uc1xuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIgKSB7XG5cdFx0ZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGRvbU1hbmlwKCBjb2xsZWN0aW9uLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApIHtcblxuXHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdGFyZ3MgPSBjb25jYXQuYXBwbHkoIFtdLCBhcmdzICk7XG5cblx0dmFyIGZyYWdtZW50LCBmaXJzdCwgc2NyaXB0cywgaGFzU2NyaXB0cywgbm9kZSwgZG9jLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBjb2xsZWN0aW9uLmxlbmd0aCxcblx0XHRpTm9DbG9uZSA9IGwgLSAxLFxuXHRcdHZhbHVlID0gYXJnc1sgMCBdLFxuXHRcdHZhbHVlSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0Ly8gV2UgY2FuJ3QgY2xvbmVOb2RlIGZyYWdtZW50cyB0aGF0IGNvbnRhaW4gY2hlY2tlZCwgaW4gV2ViS2l0XG5cdGlmICggdmFsdWVJc0Z1bmN0aW9uIHx8XG5cdFx0XHQoIGwgPiAxICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc3VwcG9ydC5jaGVja0Nsb25lICYmIHJjaGVja2VkLnRlc3QoIHZhbHVlICkgKSApIHtcblx0XHRyZXR1cm4gY29sbGVjdGlvbi5lYWNoKCBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGNvbGxlY3Rpb24uZXEoIGluZGV4ICk7XG5cdFx0XHRpZiAoIHZhbHVlSXNGdW5jdGlvbiApIHtcblx0XHRcdFx0YXJnc1sgMCBdID0gdmFsdWUuY2FsbCggdGhpcywgaW5kZXgsIHNlbGYuaHRtbCgpICk7XG5cdFx0XHR9XG5cdFx0XHRkb21NYW5pcCggc2VsZiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKTtcblx0XHR9ICk7XG5cdH1cblxuXHRpZiAoIGwgKSB7XG5cdFx0ZnJhZ21lbnQgPSBidWlsZEZyYWdtZW50KCBhcmdzLCBjb2xsZWN0aW9uWyAwIF0ub3duZXJEb2N1bWVudCwgZmFsc2UsIGNvbGxlY3Rpb24sIGlnbm9yZWQgKTtcblx0XHRmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRpZiAoIGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0ZnJhZ21lbnQgPSBmaXJzdDtcblx0XHR9XG5cblx0XHQvLyBSZXF1aXJlIGVpdGhlciBuZXcgY29udGVudCBvciBhbiBpbnRlcmVzdCBpbiBpZ25vcmVkIGVsZW1lbnRzIHRvIGludm9rZSB0aGUgY2FsbGJhY2tcblx0XHRpZiAoIGZpcnN0IHx8IGlnbm9yZWQgKSB7XG5cdFx0XHRzY3JpcHRzID0galF1ZXJ5Lm1hcCggZ2V0QWxsKCBmcmFnbWVudCwgXCJzY3JpcHRcIiApLCBkaXNhYmxlU2NyaXB0ICk7XG5cdFx0XHRoYXNTY3JpcHRzID0gc2NyaXB0cy5sZW5ndGg7XG5cblx0XHRcdC8vIFVzZSB0aGUgb3JpZ2luYWwgZnJhZ21lbnQgZm9yIHRoZSBsYXN0IGl0ZW1cblx0XHRcdC8vIGluc3RlYWQgb2YgdGhlIGZpcnN0IGJlY2F1c2UgaXQgY2FuIGVuZCB1cFxuXHRcdFx0Ly8gYmVpbmcgZW1wdGllZCBpbmNvcnJlY3RseSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgKCM4MDcwKS5cblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0bm9kZSA9IGZyYWdtZW50O1xuXG5cdFx0XHRcdGlmICggaSAhPT0gaU5vQ2xvbmUgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IGpRdWVyeS5jbG9uZSggbm9kZSwgdHJ1ZSwgdHJ1ZSApO1xuXG5cdFx0XHRcdFx0Ly8gS2VlcCByZWZlcmVuY2VzIHRvIGNsb25lZCBzY3JpcHRzIGZvciBsYXRlciByZXN0b3JhdGlvblxuXHRcdFx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHNjcmlwdHMsIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2FsbGJhY2suY2FsbCggY29sbGVjdGlvblsgaSBdLCBub2RlLCBpICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblx0XHRcdFx0ZG9jID0gc2NyaXB0c1sgc2NyaXB0cy5sZW5ndGggLSAxIF0ub3duZXJEb2N1bWVudDtcblxuXHRcdFx0XHQvLyBSZWVuYWJsZSBzY3JpcHRzXG5cdFx0XHRcdGpRdWVyeS5tYXAoIHNjcmlwdHMsIHJlc3RvcmVTY3JpcHQgKTtcblxuXHRcdFx0XHQvLyBFdmFsdWF0ZSBleGVjdXRhYmxlIHNjcmlwdHMgb24gZmlyc3QgZG9jdW1lbnQgaW5zZXJ0aW9uXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgaGFzU2NyaXB0czsgaSsrICkge1xuXHRcdFx0XHRcdG5vZGUgPSBzY3JpcHRzWyBpIF07XG5cdFx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBub2RlLnR5cGUgfHwgXCJcIiApICYmXG5cdFx0XHRcdFx0XHQhZGF0YVByaXYuYWNjZXNzKCBub2RlLCBcImdsb2JhbEV2YWxcIiApICYmXG5cdFx0XHRcdFx0XHRqUXVlcnkuY29udGFpbnMoIGRvYywgbm9kZSApICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIG5vZGUuc3JjICYmICggbm9kZS50eXBlIHx8IFwiXCIgKS50b0xvd2VyQ2FzZSgpICAhPT0gXCJtb2R1bGVcIiApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBPcHRpb25hbCBBSkFYIGRlcGVuZGVuY3ksIGJ1dCB3b24ndCBydW4gc2NyaXB0cyBpZiBub3QgcHJlc2VudFxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5fZXZhbFVybCApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuX2V2YWxVcmwoIG5vZGUuc3JjICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdERPTUV2YWwoIG5vZGUudGV4dENvbnRlbnQucmVwbGFjZSggcmNsZWFuU2NyaXB0LCBcIlwiICksIGRvYywgbm9kZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjb2xsZWN0aW9uO1xufVxuXG5mdW5jdGlvbiByZW1vdmUoIGVsZW0sIHNlbGVjdG9yLCBrZWVwRGF0YSApIHtcblx0dmFyIG5vZGUsXG5cdFx0bm9kZXMgPSBzZWxlY3RvciA/IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBlbGVtICkgOiBlbGVtLFxuXHRcdGkgPSAwO1xuXG5cdGZvciAoIDsgKCBub2RlID0gbm9kZXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRpZiAoICFrZWVwRGF0YSAmJiBub2RlLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBub2RlICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG5vZGUucGFyZW50Tm9kZSApIHtcblx0XHRcdGlmICgga2VlcERhdGEgJiYgalF1ZXJ5LmNvbnRhaW5zKCBub2RlLm93bmVyRG9jdW1lbnQsIG5vZGUgKSApIHtcblx0XHRcdFx0c2V0R2xvYmFsRXZhbCggZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdH1cblx0XHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggbm9kZSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGh0bWxQcmVmaWx0ZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHJldHVybiBodG1sLnJlcGxhY2UoIHJ4aHRtbFRhZywgXCI8JDE+PC8kMj5cIiApO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0dmFyIGksIGwsIHNyY0VsZW1lbnRzLCBkZXN0RWxlbWVudHMsXG5cdFx0XHRjbG9uZSA9IGVsZW0uY2xvbmVOb2RlKCB0cnVlICksXG5cdFx0XHRpblBhZ2UgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXG5cdFx0Ly8gRml4IElFIGNsb25pbmcgaXNzdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCAmJiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgZWxlbS5ub2RlVHlwZSA9PT0gMTEgKSAmJlxuXHRcdFx0XHQhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIFdlIGVzY2hldyBTaXp6bGUgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uczogaHR0cHM6Ly9qc3BlcmYuY29tL2dldGFsbC12cy1zaXp6bGUvMlxuXHRcdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSApO1xuXHRcdFx0c3JjRWxlbWVudHMgPSBnZXRBbGwoIGVsZW0gKTtcblxuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGZpeElucHV0KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvcHkgdGhlIGV2ZW50cyBmcm9tIHRoZSBvcmlnaW5hbCB0byB0aGUgY2xvbmVcblx0XHRpZiAoIGRhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRpZiAoIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0XHRzcmNFbGVtZW50cyA9IHNyY0VsZW1lbnRzIHx8IGdldEFsbCggZWxlbSApO1xuXHRcdFx0XHRkZXN0RWxlbWVudHMgPSBkZXN0RWxlbWVudHMgfHwgZ2V0QWxsKCBjbG9uZSApO1xuXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGNsb25lQ29weUV2ZW50KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjbG9uZUNvcHlFdmVudCggZWxlbSwgY2xvbmUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSwgXCJzY3JpcHRcIiApO1xuXHRcdGlmICggZGVzdEVsZW1lbnRzLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCBkZXN0RWxlbWVudHMsICFpblBhZ2UgJiYgZ2V0QWxsKCBlbGVtLCBcInNjcmlwdFwiICkgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gdGhlIGNsb25lZCBzZXRcblx0XHRyZXR1cm4gY2xvbmU7XG5cdH0sXG5cblx0Y2xlYW5EYXRhOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cdFx0dmFyIGRhdGEsIGVsZW0sIHR5cGUsXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWwsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gZWxlbXNbIGkgXSApICE9PSB1bmRlZmluZWQ7IGkrKyApIHtcblx0XHRcdGlmICggYWNjZXB0RGF0YSggZWxlbSApICkge1xuXHRcdFx0XHRpZiAoICggZGF0YSA9IGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSApICkge1xuXHRcdFx0XHRcdGlmICggZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCB0eXBlIGluIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWxbIHR5cGUgXSApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVGhpcyBpcyBhIHNob3J0Y3V0IHRvIGF2b2lkIGpRdWVyeS5ldmVudC5yZW1vdmUncyBvdmVyaGVhZFxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdICkge1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkZXRhY2g6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yICk7XG5cdH0sXG5cblx0dGV4dDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnRleHQoIHRoaXMgKSA6XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdGFwcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHByZXBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIGVsZW0sIHRhcmdldC5maXJzdENoaWxkICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGJlZm9yZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YWZ0ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzLm5leHRTaWJsaW5nICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSB0aGlzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gUHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIGFueSByZW1haW5pbmcgbm9kZXNcblx0XHRcdFx0ZWxlbS50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRkYXRhQW5kRXZlbnRzID0gZGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZmFsc2UgOiBkYXRhQW5kRXZlbnRzO1xuXHRcdGRlZXBEYXRhQW5kRXZlbnRzID0gZGVlcERhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGRhdGFBbmRFdmVudHMgOiBkZWVwRGF0YUFuZEV2ZW50cztcblxuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNsb25lKCB0aGlzLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApO1xuXHRcdH0gKTtcblx0fSxcblxuXHRodG1sOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF0gfHwge30sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRsID0gdGhpcy5sZW5ndGg7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pbm5lckhUTUw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNlZSBpZiB3ZSBjYW4gdGFrZSBhIHNob3J0Y3V0IGFuZCBqdXN0IHVzZSBpbm5lckhUTUxcblx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmICFybm9Jbm5lcmh0bWwudGVzdCggdmFsdWUgKSAmJlxuXHRcdFx0XHQhd3JhcE1hcFsgKCBydGFnTmFtZS5leGVjKCB2YWx1ZSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpIF0gKSB7XG5cblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuaHRtbFByZWZpbHRlciggdmFsdWUgKTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRcdGVsZW0gPSB0aGlzWyBpIF0gfHwge307XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblx0XHRcdFx0XHRcdFx0ZWxlbS5pbm5lckhUTUwgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtID0gMDtcblxuXHRcdFx0XHQvLyBJZiB1c2luZyBpbm5lckhUTUwgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgdXNlIHRoZSBmYWxsYmFjayBtZXRob2Rcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5hcHBlbmQoIHZhbHVlICk7XG5cdFx0XHR9XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRyZXBsYWNlV2l0aDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGlnbm9yZWQgPSBbXTtcblxuXHRcdC8vIE1ha2UgdGhlIGNoYW5nZXMsIHJlcGxhY2luZyBlYWNoIG5vbi1pZ25vcmVkIGNvbnRleHQgZWxlbWVudCB3aXRoIHRoZSBuZXcgY29udGVudFxuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG5cblx0XHRcdGlmICggalF1ZXJ5LmluQXJyYXkoIHRoaXMsIGlnbm9yZWQgKSA8IDAgKSB7XG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggdGhpcyApICk7XG5cdFx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRcdHBhcmVudC5yZXBsYWNlQ2hpbGQoIGVsZW0sIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gRm9yY2UgY2FsbGJhY2sgaW52b2NhdGlvblxuXHRcdH0sIGlnbm9yZWQgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCgge1xuXHRhcHBlbmRUbzogXCJhcHBlbmRcIixcblx0cHJlcGVuZFRvOiBcInByZXBlbmRcIixcblx0aW5zZXJ0QmVmb3JlOiBcImJlZm9yZVwiLFxuXHRpbnNlcnRBZnRlcjogXCJhZnRlclwiLFxuXHRyZXBsYWNlQWxsOiBcInJlcGxhY2VXaXRoXCJcbn0sIGZ1bmN0aW9uKCBuYW1lLCBvcmlnaW5hbCApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGVsZW1zLFxuXHRcdFx0cmV0ID0gW10sXG5cdFx0XHRpbnNlcnQgPSBqUXVlcnkoIHNlbGVjdG9yICksXG5cdFx0XHRsYXN0ID0gaW5zZXJ0Lmxlbmd0aCAtIDEsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgaSA8PSBsYXN0OyBpKysgKSB7XG5cdFx0XHRlbGVtcyA9IGkgPT09IGxhc3QgPyB0aGlzIDogdGhpcy5jbG9uZSggdHJ1ZSApO1xuXHRcdFx0alF1ZXJ5KCBpbnNlcnRbIGkgXSApWyBvcmlnaW5hbCBdKCBlbGVtcyApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdC8vIC5nZXQoKSBiZWNhdXNlIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdHB1c2guYXBwbHkoIHJldCwgZWxlbXMuZ2V0KCkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHJldCApO1xuXHR9O1xufSApO1xudmFyIHJudW1ub25weCA9IG5ldyBSZWdFeHAoIFwiXihcIiArIHBudW0gKyBcIikoPyFweClbYS16JV0rJFwiLCBcImlcIiApO1xuXG52YXIgZ2V0U3R5bGVzID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHksIEZpcmVmb3ggPD0zMCAoIzE1MDk4LCAjMTQxNTApXG5cdFx0Ly8gSUUgdGhyb3dzIG9uIGVsZW1lbnRzIGNyZWF0ZWQgaW4gcG9wdXBzXG5cdFx0Ly8gRkYgbWVhbndoaWxlIHRocm93cyBvbiBmcmFtZSBlbGVtZW50cyB0aHJvdWdoIFwiZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZVwiXG5cdFx0dmFyIHZpZXcgPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cblx0XHRpZiAoICF2aWV3IHx8ICF2aWV3Lm9wZW5lciApIHtcblx0XHRcdHZpZXcgPSB3aW5kb3c7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbSApO1xuXHR9O1xuXG52YXIgcmJveFN0eWxlID0gbmV3IFJlZ0V4cCggY3NzRXhwYW5kLmpvaW4oIFwifFwiICksIFwiaVwiICk7XG5cblxuXG4oIGZ1bmN0aW9uKCkge1xuXG5cdC8vIEV4ZWN1dGluZyBib3RoIHBpeGVsUG9zaXRpb24gJiBib3hTaXppbmdSZWxpYWJsZSB0ZXN0cyByZXF1aXJlIG9ubHkgb25lIGxheW91dFxuXHQvLyBzbyB0aGV5J3JlIGV4ZWN1dGVkIGF0IHRoZSBzYW1lIHRpbWUgdG8gc2F2ZSB0aGUgc2Vjb25kIGNvbXB1dGF0aW9uLlxuXHRmdW5jdGlvbiBjb21wdXRlU3R5bGVUZXN0cygpIHtcblxuXHRcdC8vIFRoaXMgaXMgYSBzaW5nbGV0b24sIHdlIG5lZWQgdG8gZXhlY3V0ZSBpdCBvbmx5IG9uY2Vcblx0XHRpZiAoICFkaXYgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6LTExMTExcHg7d2lkdGg6NjBweDtcIiArXG5cdFx0XHRcIm1hcmdpbi10b3A6MXB4O3BhZGRpbmc6MDtib3JkZXI6MFwiO1xuXHRcdGRpdi5zdHlsZS5jc3NUZXh0ID1cblx0XHRcdFwicG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTpibG9jaztib3gtc2l6aW5nOmJvcmRlci1ib3g7b3ZlcmZsb3c6c2Nyb2xsO1wiICtcblx0XHRcdFwibWFyZ2luOmF1dG87Ym9yZGVyOjFweDtwYWRkaW5nOjFweDtcIiArXG5cdFx0XHRcIndpZHRoOjYwJTt0b3A6MSVcIjtcblx0XHRkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApLmFwcGVuZENoaWxkKCBkaXYgKTtcblxuXHRcdHZhciBkaXZTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBkaXYgKTtcblx0XHRwaXhlbFBvc2l0aW9uVmFsID0gZGl2U3R5bGUudG9wICE9PSBcIjElXCI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBGaXJlZm94IDw9MyAtIDQ0XG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0VmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS5tYXJnaW5MZWZ0ICkgPT09IDEyO1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgU2FmYXJpIDw9OS4xIC0gMTAuMSwgaU9TIDw9Ny4wIC0gOS4zXG5cdFx0Ly8gU29tZSBzdHlsZXMgY29tZSBiYWNrIHdpdGggcGVyY2VudGFnZSB2YWx1ZXMsIGV2ZW4gdGhvdWdoIHRoZXkgc2hvdWxkbid0XG5cdFx0ZGl2LnN0eWxlLnJpZ2h0ID0gXCI2MCVcIjtcblx0XHRwaXhlbEJveFN0eWxlc1ZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUucmlnaHQgKSA9PT0gMzY7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHRcdC8vIERldGVjdCBtaXNyZXBvcnRpbmcgb2YgY29udGVudCBkaW1lbnNpb25zIGZvciBib3gtc2l6aW5nOmJvcmRlci1ib3ggZWxlbWVudHNcblx0XHRib3hTaXppbmdSZWxpYWJsZVZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUud2lkdGggKSA9PT0gMzY7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0XHQvLyBEZXRlY3Qgb3ZlcmZsb3c6c2Nyb2xsIHNjcmV3aW5lc3MgKGdoLTM2OTkpXG5cdFx0ZGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuXHRcdHNjcm9sbGJveFNpemVWYWwgPSBkaXYub2Zmc2V0V2lkdGggPT09IDM2IHx8IFwiYWJzb2x1dGVcIjtcblxuXHRcdGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHQvLyBOdWxsaWZ5IHRoZSBkaXYgc28gaXQgd291bGRuJ3QgYmUgc3RvcmVkIGluIHRoZSBtZW1vcnkgYW5kXG5cdFx0Ly8gaXQgd2lsbCBhbHNvIGJlIGEgc2lnbiB0aGF0IGNoZWNrcyBhbHJlYWR5IHBlcmZvcm1lZFxuXHRcdGRpdiA9IG51bGw7XG5cdH1cblxuXHRmdW5jdGlvbiByb3VuZFBpeGVsTWVhc3VyZXMoIG1lYXN1cmUgKSB7XG5cdFx0cmV0dXJuIE1hdGgucm91bmQoIHBhcnNlRmxvYXQoIG1lYXN1cmUgKSApO1xuXHR9XG5cblx0dmFyIHBpeGVsUG9zaXRpb25WYWwsIGJveFNpemluZ1JlbGlhYmxlVmFsLCBzY3JvbGxib3hTaXplVmFsLCBwaXhlbEJveFN0eWxlc1ZhbCxcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwsXG5cdFx0Y29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLFxuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHQvLyBGaW5pc2ggZWFybHkgaW4gbGltaXRlZCAobm9uLWJyb3dzZXIpIGVudmlyb25tZW50c1xuXHRpZiAoICFkaXYuc3R5bGUgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBTdHlsZSBvZiBjbG9uZWQgZWxlbWVudCBhZmZlY3RzIHNvdXJjZSBlbGVtZW50IGNsb25lZCAoIzg5MDgpXG5cdGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiY29udGVudC1ib3hcIjtcblx0ZGl2LmNsb25lTm9kZSggdHJ1ZSApLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJcIjtcblx0c3VwcG9ydC5jbGVhckNsb25lU3R5bGUgPSBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPT09IFwiY29udGVudC1ib3hcIjtcblxuXHRqUXVlcnkuZXh0ZW5kKCBzdXBwb3J0LCB7XG5cdFx0Ym94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBib3hTaXppbmdSZWxpYWJsZVZhbDtcblx0XHR9LFxuXHRcdHBpeGVsQm94U3R5bGVzOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxCb3hTdHlsZXNWYWw7XG5cdFx0fSxcblx0XHRwaXhlbFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxQb3NpdGlvblZhbDtcblx0XHR9LFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHJlbGlhYmxlTWFyZ2luTGVmdFZhbDtcblx0XHR9LFxuXHRcdHNjcm9sbGJveFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBzY3JvbGxib3hTaXplVmFsO1xuXHRcdH1cblx0fSApO1xufSApKCk7XG5cblxuZnVuY3Rpb24gY3VyQ1NTKCBlbGVtLCBuYW1lLCBjb21wdXRlZCApIHtcblx0dmFyIHdpZHRoLCBtaW5XaWR0aCwgbWF4V2lkdGgsIHJldCxcblxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggNTErXG5cdFx0Ly8gUmV0cmlldmluZyBzdHlsZSBiZWZvcmUgY29tcHV0ZWQgc29tZWhvd1xuXHRcdC8vIGZpeGVzIGFuIGlzc3VlIHdpdGggZ2V0dGluZyB3cm9uZyB2YWx1ZXNcblx0XHQvLyBvbiBkZXRhY2hlZCBlbGVtZW50c1xuXHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApO1xuXG5cdC8vIGdldFByb3BlcnR5VmFsdWUgaXMgbmVlZGVkIGZvcjpcblx0Ly8gICAuY3NzKCdmaWx0ZXInKSAoSUUgOSBvbmx5LCAjMTI1MzcpXG5cdC8vICAgLmNzcygnLS1jdXN0b21Qcm9wZXJ0eSkgKCMzMTQ0KVxuXHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdHJldCA9IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoIG5hbWUgKSB8fCBjb21wdXRlZFsgbmFtZSBdO1xuXG5cdFx0aWYgKCByZXQgPT09IFwiXCIgJiYgIWpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgKSB7XG5cdFx0XHRyZXQgPSBqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG5cdFx0Ly8gQW5kcm9pZCBCcm93c2VyIHJldHVybnMgcGVyY2VudGFnZSBmb3Igc29tZSB2YWx1ZXMsXG5cdFx0Ly8gYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVscy5cblx0XHQvLyBUaGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6XG5cdFx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNyZXNvbHZlZC12YWx1ZXNcblx0XHRpZiAoICFzdXBwb3J0LnBpeGVsQm94U3R5bGVzKCkgJiYgcm51bW5vbnB4LnRlc3QoIHJldCApICYmIHJib3hTdHlsZS50ZXN0KCBuYW1lICkgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcblx0XHRcdHdpZHRoID0gc3R5bGUud2lkdGg7XG5cdFx0XHRtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xuXHRcdFx0bWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDtcblxuXHRcdFx0Ly8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuXHRcdFx0c3R5bGUubWluV2lkdGggPSBzdHlsZS5tYXhXaWR0aCA9IHN0eWxlLndpZHRoID0gcmV0O1xuXHRcdFx0cmV0ID0gY29tcHV0ZWQud2lkdGg7XG5cblx0XHRcdC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcblx0XHRcdHN0eWxlLndpZHRoID0gd2lkdGg7XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IG1pbldpZHRoO1xuXHRcdFx0c3R5bGUubWF4V2lkdGggPSBtYXhXaWR0aDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmV0ICE9PSB1bmRlZmluZWQgP1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHRcdC8vIElFIHJldHVybnMgekluZGV4IHZhbHVlIGFzIGFuIGludGVnZXIuXG5cdFx0cmV0ICsgXCJcIiA6XG5cdFx0cmV0O1xufVxuXG5cbmZ1bmN0aW9uIGFkZEdldEhvb2tJZiggY29uZGl0aW9uRm4sIGhvb2tGbiApIHtcblxuXHQvLyBEZWZpbmUgdGhlIGhvb2ssIHdlJ2xsIGNoZWNrIG9uIHRoZSBmaXJzdCBydW4gaWYgaXQncyByZWFsbHkgbmVlZGVkLlxuXHRyZXR1cm4ge1xuXHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGNvbmRpdGlvbkZuKCkgKSB7XG5cblx0XHRcdFx0Ly8gSG9vayBub3QgbmVlZGVkIChvciBpdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgaXQgZHVlXG5cdFx0XHRcdC8vIHRvIG1pc3NpbmcgZGVwZW5kZW5jeSksIHJlbW92ZSBpdC5cblx0XHRcdFx0ZGVsZXRlIHRoaXMuZ2V0O1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhvb2sgbmVlZGVkOyByZWRlZmluZSBpdCBzbyB0aGF0IHRoZSBzdXBwb3J0IHRlc3QgaXMgbm90IGV4ZWN1dGVkIGFnYWluLlxuXHRcdFx0cmV0dXJuICggdGhpcy5nZXQgPSBob29rRm4gKS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fVxuXHR9O1xufVxuXG5cbnZhclxuXG5cdC8vIFN3YXBwYWJsZSBpZiBkaXNwbGF5IGlzIG5vbmUgb3Igc3RhcnRzIHdpdGggdGFibGVcblx0Ly8gZXhjZXB0IFwidGFibGVcIiwgXCJ0YWJsZS1jZWxsXCIsIG9yIFwidGFibGUtY2FwdGlvblwiXG5cdC8vIFNlZSBoZXJlIGZvciBkaXNwbGF5IHZhbHVlczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9DU1MvZGlzcGxheVxuXHRyZGlzcGxheXN3YXAgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sXG5cdHJjdXN0b21Qcm9wID0gL14tLS8sXG5cdGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiB9LFxuXHRjc3NOb3JtYWxUcmFuc2Zvcm0gPSB7XG5cdFx0bGV0dGVyU3BhY2luZzogXCIwXCIsXG5cdFx0Zm9udFdlaWdodDogXCI0MDBcIlxuXHR9LFxuXG5cdGNzc1ByZWZpeGVzID0gWyBcIldlYmtpdFwiLCBcIk1velwiLCBcIm1zXCIgXSxcblx0ZW1wdHlTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKS5zdHlsZTtcblxuLy8gUmV0dXJuIGEgY3NzIHByb3BlcnR5IG1hcHBlZCB0byBhIHBvdGVudGlhbGx5IHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eVxuZnVuY3Rpb24gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB7XG5cblx0Ly8gU2hvcnRjdXQgZm9yIG5hbWVzIHRoYXQgYXJlIG5vdCB2ZW5kb3IgcHJlZml4ZWRcblx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cblxuXHQvLyBDaGVjayBmb3IgdmVuZG9yIHByZWZpeGVkIG5hbWVzXG5cdHZhciBjYXBOYW1lID0gbmFtZVsgMCBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKCAxICksXG5cdFx0aSA9IGNzc1ByZWZpeGVzLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRuYW1lID0gY3NzUHJlZml4ZXNbIGkgXSArIGNhcE5hbWU7XG5cdFx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0XHRyZXR1cm4gbmFtZTtcblx0XHR9XG5cdH1cbn1cblxuLy8gUmV0dXJuIGEgcHJvcGVydHkgbWFwcGVkIGFsb25nIHdoYXQgalF1ZXJ5LmNzc1Byb3BzIHN1Z2dlc3RzIG9yIHRvXG4vLyBhIHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eS5cbmZ1bmN0aW9uIGZpbmFsUHJvcE5hbWUoIG5hbWUgKSB7XG5cdHZhciByZXQgPSBqUXVlcnkuY3NzUHJvcHNbIG5hbWUgXTtcblx0aWYgKCAhcmV0ICkge1xuXHRcdHJldCA9IGpRdWVyeS5jc3NQcm9wc1sgbmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB8fCBuYW1lO1xuXHR9XG5cdHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKSB7XG5cblx0Ly8gQW55IHJlbGF0aXZlICgrLy0pIHZhbHVlcyBoYXZlIGFscmVhZHkgYmVlblxuXHQvLyBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnRcblx0dmFyIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICk7XG5cdHJldHVybiBtYXRjaGVzID9cblxuXHRcdC8vIEd1YXJkIGFnYWluc3QgdW5kZWZpbmVkIFwic3VidHJhY3RcIiwgZS5nLiwgd2hlbiB1c2VkIGFzIGluIGNzc0hvb2tzXG5cdFx0TWF0aC5tYXgoIDAsIG1hdGNoZXNbIDIgXSAtICggc3VidHJhY3QgfHwgMCApICkgKyAoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSA6XG5cdFx0dmFsdWU7XG59XG5cbmZ1bmN0aW9uIGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBib3gsIGlzQm9yZGVyQm94LCBzdHlsZXMsIGNvbXB1dGVkVmFsICkge1xuXHR2YXIgaSA9IGRpbWVuc2lvbiA9PT0gXCJ3aWR0aFwiID8gMSA6IDAsXG5cdFx0ZXh0cmEgPSAwLFxuXHRcdGRlbHRhID0gMDtcblxuXHQvLyBBZGp1c3RtZW50IG1heSBub3QgYmUgbmVjZXNzYXJ5XG5cdGlmICggYm94ID09PSAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICkgKSB7XG5cdFx0cmV0dXJuIDA7XG5cdH1cblxuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgKSB7XG5cblx0XHQvLyBCb3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW5cblx0XHRpZiAoIGJveCA9PT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIGJveCArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgY29udGVudC1ib3gsIHdlJ3JlIHNlZWtpbmcgXCJwYWRkaW5nXCIgb3IgXCJib3JkZXJcIiBvciBcIm1hcmdpblwiXG5cdFx0aWYgKCAhaXNCb3JkZXJCb3ggKSB7XG5cblx0XHRcdC8vIEFkZCBwYWRkaW5nXG5cdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gRm9yIFwiYm9yZGVyXCIgb3IgXCJtYXJnaW5cIiwgYWRkIGJvcmRlclxuXHRcdFx0aWYgKCBib3ggIT09IFwicGFkZGluZ1wiICkge1xuXHRcdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBCdXQgc3RpbGwga2VlcCB0cmFjayBvZiBpdCBvdGhlcndpc2Vcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGV4dHJhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgYm9yZGVyLWJveCAoY29udGVudCArIHBhZGRpbmcgKyBib3JkZXIpLCB3ZSdyZSBzZWVraW5nIFwiY29udGVudFwiIG9yXG5cdFx0Ly8gXCJwYWRkaW5nXCIgb3IgXCJtYXJnaW5cIlxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEZvciBcImNvbnRlbnRcIiwgc3VidHJhY3QgcGFkZGluZ1xuXHRcdFx0aWYgKCBib3ggPT09IFwiY29udGVudFwiICkge1xuXHRcdFx0XHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yIFwiY29udGVudFwiIG9yIFwicGFkZGluZ1wiLCBzdWJ0cmFjdCBib3JkZXJcblx0XHRcdGlmICggYm94ICE9PSBcIm1hcmdpblwiICkge1xuXHRcdFx0XHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFjY291bnQgZm9yIHBvc2l0aXZlIGNvbnRlbnQtYm94IHNjcm9sbCBndXR0ZXIgd2hlbiByZXF1ZXN0ZWQgYnkgcHJvdmlkaW5nIGNvbXB1dGVkVmFsXG5cdGlmICggIWlzQm9yZGVyQm94ICYmIGNvbXB1dGVkVmFsID49IDAgKSB7XG5cblx0XHQvLyBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgaXMgYSByb3VuZGVkIHN1bSBvZiBjb250ZW50LCBwYWRkaW5nLCBzY3JvbGwgZ3V0dGVyLCBhbmQgYm9yZGVyXG5cdFx0Ly8gQXNzdW1pbmcgaW50ZWdlciBzY3JvbGwgZ3V0dGVyLCBzdWJ0cmFjdCB0aGUgcmVzdCBhbmQgcm91bmQgZG93blxuXHRcdGRlbHRhICs9IE1hdGgubWF4KCAwLCBNYXRoLmNlaWwoXG5cdFx0XHRlbGVtWyBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF0gLVxuXHRcdFx0Y29tcHV0ZWRWYWwgLVxuXHRcdFx0ZGVsdGEgLVxuXHRcdFx0ZXh0cmEgLVxuXHRcdFx0MC41XG5cdFx0KSApO1xuXHR9XG5cblx0cmV0dXJuIGRlbHRhO1xufVxuXG5mdW5jdGlvbiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICkge1xuXG5cdC8vIFN0YXJ0IHdpdGggY29tcHV0ZWQgc3R5bGVcblx0dmFyIHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgZGltZW5zaW9uLCBzdHlsZXMgKSxcblx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94O1xuXG5cdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxuXHQvLyBSZXR1cm4gYSBjb25mb3VuZGluZyBub24tcGl4ZWwgdmFsdWUgb3IgZmVpZ24gaWdub3JhbmNlLCBhcyBhcHByb3ByaWF0ZS5cblx0aWYgKCBybnVtbm9ucHgudGVzdCggdmFsICkgKSB7XG5cdFx0aWYgKCAhZXh0cmEgKSB7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblx0XHR2YWwgPSBcImF1dG9cIjtcblx0fVxuXG5cdC8vIENoZWNrIGZvciBzdHlsZSBpbiBjYXNlIGEgYnJvd3NlciB3aGljaCByZXR1cm5zIHVucmVsaWFibGUgdmFsdWVzXG5cdC8vIGZvciBnZXRDb21wdXRlZFN0eWxlIHNpbGVudGx5IGZhbGxzIGJhY2sgdG8gdGhlIHJlbGlhYmxlIGVsZW0uc3R5bGVcblx0dmFsdWVJc0JvcmRlckJveCA9IHZhbHVlSXNCb3JkZXJCb3ggJiZcblx0XHQoIHN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSB8fCB2YWwgPT09IGVsZW0uc3R5bGVbIGRpbWVuc2lvbiBdICk7XG5cblx0Ly8gRmFsbCBiYWNrIHRvIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCB3aGVuIHZhbHVlIGlzIFwiYXV0b1wiXG5cdC8vIFRoaXMgaGFwcGVucyBmb3IgaW5saW5lIGVsZW1lbnRzIHdpdGggbm8gZXhwbGljaXQgc2V0dGluZyAoZ2gtMzU3MSlcblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSAtIDQuMyBvbmx5XG5cdC8vIEFsc28gdXNlIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBmb3IgbWlzcmVwb3J0ZWQgaW5saW5lIGRpbWVuc2lvbnMgKGdoLTM2MDIpXG5cdGlmICggdmFsID09PSBcImF1dG9cIiB8fFxuXHRcdCFwYXJzZUZsb2F0KCB2YWwgKSAmJiBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImlubGluZVwiICkge1xuXG5cdFx0dmFsID0gZWxlbVsgXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKSBdO1xuXG5cdFx0Ly8gb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IHByb3ZpZGUgYm9yZGVyLWJveCB2YWx1ZXNcblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gdHJ1ZTtcblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBcIlwiIGFuZCBhdXRvXG5cdHZhbCA9IHBhcnNlRmxvYXQoIHZhbCApIHx8IDA7XG5cblx0Ly8gQWRqdXN0IGZvciB0aGUgZWxlbWVudCdzIGJveCBtb2RlbFxuXHRyZXR1cm4gKCB2YWwgK1xuXHRcdGJveE1vZGVsQWRqdXN0bWVudChcblx0XHRcdGVsZW0sXG5cdFx0XHRkaW1lbnNpb24sXG5cdFx0XHRleHRyYSB8fCAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICksXG5cdFx0XHR2YWx1ZUlzQm9yZGVyQm94LFxuXHRcdFx0c3R5bGVzLFxuXG5cdFx0XHQvLyBQcm92aWRlIHRoZSBjdXJyZW50IGNvbXB1dGVkIHNpemUgdG8gcmVxdWVzdCBzY3JvbGwgZ3V0dGVyIGNhbGN1bGF0aW9uIChnaC0zNTg5KVxuXHRcdFx0dmFsXG5cdFx0KVxuXHQpICsgXCJweFwiO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQWRkIGluIHN0eWxlIHByb3BlcnR5IGhvb2tzIGZvciBvdmVycmlkaW5nIHRoZSBkZWZhdWx0XG5cdC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxuXHRjc3NIb29rczoge1xuXHRcdG9wYWNpdHk6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdFx0Ly8gV2Ugc2hvdWxkIGFsd2F5cyBnZXQgYSBudW1iZXIgYmFjayBmcm9tIG9wYWNpdHlcblx0XHRcdFx0XHR2YXIgcmV0ID0gY3VyQ1NTKCBlbGVtLCBcIm9wYWNpdHlcIiApO1xuXHRcdFx0XHRcdHJldHVybiByZXQgPT09IFwiXCIgPyBcIjFcIiA6IHJldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBEb24ndCBhdXRvbWF0aWNhbGx5IGFkZCBcInB4XCIgdG8gdGhlc2UgcG9zc2libHktdW5pdGxlc3MgcHJvcGVydGllc1xuXHRjc3NOdW1iZXI6IHtcblx0XHRcImFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50XCI6IHRydWUsXG5cdFx0XCJjb2x1bW5Db3VudFwiOiB0cnVlLFxuXHRcdFwiZmlsbE9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcImZsZXhHcm93XCI6IHRydWUsXG5cdFx0XCJmbGV4U2hyaW5rXCI6IHRydWUsXG5cdFx0XCJmb250V2VpZ2h0XCI6IHRydWUsXG5cdFx0XCJsaW5lSGVpZ2h0XCI6IHRydWUsXG5cdFx0XCJvcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJvcmRlclwiOiB0cnVlLFxuXHRcdFwib3JwaGFuc1wiOiB0cnVlLFxuXHRcdFwid2lkb3dzXCI6IHRydWUsXG5cdFx0XCJ6SW5kZXhcIjogdHJ1ZSxcblx0XHRcInpvb21cIjogdHJ1ZVxuXHR9LFxuXG5cdC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcblx0Ly8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxuXHRjc3NQcm9wczoge30sXG5cblx0Ly8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcblx0c3R5bGU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEgKSB7XG5cblx0XHQvLyBEb24ndCBzZXQgc3R5bGVzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHR2YXIgcmV0LCB0eXBlLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICksXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBxdWVyeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG5cdFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb24sIHRoZW4gdW5wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0XHQvLyBDb252ZXJ0IFwiKz1cIiBvciBcIi09XCIgdG8gcmVsYXRpdmUgbnVtYmVycyAoIzczNDUpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgJiYgKCByZXQgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJiByZXRbIDEgXSApIHtcblx0XHRcdFx0dmFsdWUgPSBhZGp1c3RDU1MoIGVsZW0sIG5hbWUsIHJldCApO1xuXG5cdFx0XHRcdC8vIEZpeGVzIGJ1ZyAjOTIzN1xuXHRcdFx0XHR0eXBlID0gXCJudW1iZXJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbnVsbCBhbmQgTmFOIHZhbHVlcyBhcmVuJ3Qgc2V0ICgjNzExNilcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBudW1iZXIgd2FzIHBhc3NlZCBpbiwgYWRkIHRoZSB1bml0IChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbHVlICs9IHJldCAmJiByZXRbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIG9yaWdOYW1lIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGJhY2tncm91bmQtKiBwcm9wcyBhZmZlY3Qgb3JpZ2luYWwgY2xvbmUncyB2YWx1ZXNcblx0XHRcdGlmICggIXN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlICYmIHZhbHVlID09PSBcIlwiICYmIG5hbWUuaW5kZXhPZiggXCJiYWNrZ3JvdW5kXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IFwiaW5oZXJpdFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3Qgc2V0IHRoZSBzcGVjaWZpZWQgdmFsdWVcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fFxuXHRcdFx0XHQoIHZhbHVlID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0aWYgKCBpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRcdFx0c3R5bGUuc2V0UHJvcGVydHkoIG5hbWUsIHZhbHVlICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgbm9uLWNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgZmFsc2UsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE90aGVyd2lzZSBqdXN0IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XG5cdFx0XHRyZXR1cm4gc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cdH0sXG5cblx0Y3NzOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZXh0cmEsIHN0eWxlcyApIHtcblx0XHR2YXIgdmFsLCBudW0sIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBjYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdGlzQ3VzdG9tUHJvcCA9IHJjdXN0b21Qcm9wLnRlc3QoIG5hbWUgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZS4gV2UgZG9uJ3Rcblx0XHQvLyB3YW50IHRvIG1vZGlmeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG5cdFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIFRyeSBwcmVmaXhlZCBuYW1lIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIG5hbWVcblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsID0gaG9va3MuZ2V0KCBlbGVtLCB0cnVlLCBleHRyYSApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XG5cdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBcIm5vcm1hbFwiIHRvIGNvbXB1dGVkIHZhbHVlXG5cdFx0aWYgKCB2YWwgPT09IFwibm9ybWFsXCIgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0gKSB7XG5cdFx0XHR2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIG51bWVyaWMgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcblx0XHRpZiAoIGV4dHJhID09PSBcIlwiIHx8IGV4dHJhICkge1xuXHRcdFx0bnVtID0gcGFyc2VGbG9hdCggdmFsICk7XG5cdFx0XHRyZXR1cm4gZXh0cmEgPT09IHRydWUgfHwgaXNGaW5pdGUoIG51bSApID8gbnVtIHx8IDAgOiB2YWw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbDtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImhlaWdodFwiLCBcIndpZHRoXCIgXSwgZnVuY3Rpb24oIGksIGRpbWVuc2lvbiApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBkaW1lbnNpb24gXSA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCwgZXh0cmEgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdC8vIENlcnRhaW4gZWxlbWVudHMgY2FuIGhhdmUgZGltZW5zaW9uIGluZm8gaWYgd2UgaW52aXNpYmx5IHNob3cgdGhlbVxuXHRcdFx0XHQvLyBidXQgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdFxuXHRcdFx0XHRyZXR1cm4gcmRpc3BsYXlzd2FwLnRlc3QoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgKSAmJlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrXG5cdFx0XHRcdFx0Ly8gVGFibGUgY29sdW1ucyBpbiBTYWZhcmkgaGF2ZSBub24temVybyBvZmZzZXRXaWR0aCAmIHplcm9cblx0XHRcdFx0XHQvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCB1bmxlc3MgZGlzcGxheSBpcyBjaGFuZ2VkLlxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdFx0XHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGEgZGlzY29ubmVjdGVkIG5vZGVcblx0XHRcdFx0XHQvLyBpbiBJRSB0aHJvd3MgYW4gZXJyb3IuXG5cdFx0XHRcdFx0KCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCB8fCAhZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCApID9cblx0XHRcdFx0XHRcdHN3YXAoIGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApO1xuXHRcdFx0XHRcdFx0fSApIDpcblx0XHRcdFx0XHRcdGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIGV4dHJhICkge1xuXHRcdFx0dmFyIG1hdGNoZXMsXG5cdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXHRcdFx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0XHRcdHN1YnRyYWN0ID0gZXh0cmEgJiYgYm94TW9kZWxBZGp1c3RtZW50KFxuXHRcdFx0XHRcdGVsZW0sXG5cdFx0XHRcdFx0ZGltZW5zaW9uLFxuXHRcdFx0XHRcdGV4dHJhLFxuXHRcdFx0XHRcdGlzQm9yZGVyQm94LFxuXHRcdFx0XHRcdHN0eWxlc1xuXHRcdFx0XHQpO1xuXG5cdFx0XHQvLyBBY2NvdW50IGZvciB1bnJlbGlhYmxlIGJvcmRlci1ib3ggZGltZW5zaW9ucyBieSBjb21wYXJpbmcgb2Zmc2V0KiB0byBjb21wdXRlZCBhbmRcblx0XHRcdC8vIGZha2luZyBhIGNvbnRlbnQtYm94IHRvIGdldCBib3JkZXIgYW5kIHBhZGRpbmcgKGdoLTM2OTkpXG5cdFx0XHRpZiAoIGlzQm9yZGVyQm94ICYmIHN1cHBvcnQuc2Nyb2xsYm94U2l6ZSgpID09PSBzdHlsZXMucG9zaXRpb24gKSB7XG5cdFx0XHRcdHN1YnRyYWN0IC09IE1hdGguY2VpbChcblx0XHRcdFx0XHRlbGVtWyBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF0gLVxuXHRcdFx0XHRcdHBhcnNlRmxvYXQoIHN0eWxlc1sgZGltZW5zaW9uIF0gKSAtXG5cdFx0XHRcdFx0Ym94TW9kZWxBZGp1c3RtZW50KCBlbGVtLCBkaW1lbnNpb24sIFwiYm9yZGVyXCIsIGZhbHNlLCBzdHlsZXMgKSAtXG5cdFx0XHRcdFx0MC41XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgdG8gcGl4ZWxzIGlmIHZhbHVlIGFkanVzdG1lbnQgaXMgbmVlZGVkXG5cdFx0XHRpZiAoIHN1YnRyYWN0ICYmICggbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmXG5cdFx0XHRcdCggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApICE9PSBcInB4XCIgKSB7XG5cblx0XHRcdFx0ZWxlbS5zdHlsZVsgZGltZW5zaW9uIF0gPSB2YWx1ZTtcblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuY3NzKCBlbGVtLCBkaW1lbnNpb24gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKTtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5jc3NIb29rcy5tYXJnaW5MZWZ0ID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnJlbGlhYmxlTWFyZ2luTGVmdCxcblx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4gKCBwYXJzZUZsb2F0KCBjdXJDU1MoIGVsZW0sIFwibWFyZ2luTGVmdFwiICkgKSB8fFxuXHRcdFx0XHRlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLVxuXHRcdFx0XHRcdHN3YXAoIGVsZW0sIHsgbWFyZ2luTGVmdDogMCB9LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG5cdFx0XHRcdFx0fSApXG5cdFx0XHRcdCkgKyBcInB4XCI7XG5cdFx0fVxuXHR9XG4pO1xuXG4vLyBUaGVzZSBob29rcyBhcmUgdXNlZCBieSBhbmltYXRlIHRvIGV4cGFuZCBwcm9wZXJ0aWVzXG5qUXVlcnkuZWFjaCgge1xuXHRtYXJnaW46IFwiXCIsXG5cdHBhZGRpbmc6IFwiXCIsXG5cdGJvcmRlcjogXCJXaWR0aFwiXG59LCBmdW5jdGlvbiggcHJlZml4LCBzdWZmaXggKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0gPSB7XG5cdFx0ZXhwYW5kOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgaSA9IDAsXG5cdFx0XHRcdGV4cGFuZGVkID0ge30sXG5cblx0XHRcdFx0Ly8gQXNzdW1lcyBhIHNpbmdsZSBudW1iZXIgaWYgbm90IGEgc3RyaW5nXG5cdFx0XHRcdHBhcnRzID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUuc3BsaXQoIFwiIFwiICkgOiBbIHZhbHVlIF07XG5cblx0XHRcdGZvciAoIDsgaSA8IDQ7IGkrKyApIHtcblx0XHRcdFx0ZXhwYW5kZWRbIHByZWZpeCArIGNzc0V4cGFuZFsgaSBdICsgc3VmZml4IF0gPVxuXHRcdFx0XHRcdHBhcnRzWyBpIF0gfHwgcGFydHNbIGkgLSAyIF0gfHwgcGFydHNbIDAgXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV4cGFuZGVkO1xuXHRcdH1cblx0fTtcblxuXHRpZiAoIHByZWZpeCAhPT0gXCJtYXJnaW5cIiApIHtcblx0XHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdLnNldCA9IHNldFBvc2l0aXZlTnVtYmVyO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0Y3NzOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0dmFyIHN0eWxlcywgbGVuLFxuXHRcdFx0XHRtYXAgPSB7fSxcblx0XHRcdFx0aSA9IDA7XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggbmFtZSApICkge1xuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKTtcblx0XHRcdFx0bGVuID0gbmFtZS5sZW5ndGg7XG5cblx0XHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0bWFwWyBuYW1lWyBpIF0gXSA9IGpRdWVyeS5jc3MoIGVsZW0sIG5hbWVbIGkgXSwgZmFsc2UsIHN0eWxlcyApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG1hcDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUsIHZhbHVlICkgOlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XG5cdFx0fSwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH1cbn0gKTtcblxuXG5mdW5jdGlvbiBUd2VlbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKSB7XG5cdHJldHVybiBuZXcgVHdlZW4ucHJvdG90eXBlLmluaXQoIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICk7XG59XG5qUXVlcnkuVHdlZW4gPSBUd2VlbjtcblxuVHdlZW4ucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogVHdlZW4sXG5cdGluaXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZywgdW5pdCApIHtcblx0XHR0aGlzLmVsZW0gPSBlbGVtO1xuXHRcdHRoaXMucHJvcCA9IHByb3A7XG5cdFx0dGhpcy5lYXNpbmcgPSBlYXNpbmcgfHwgalF1ZXJ5LmVhc2luZy5fZGVmYXVsdDtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHRoaXMuc3RhcnQgPSB0aGlzLm5vdyA9IHRoaXMuY3VyKCk7XG5cdFx0dGhpcy5lbmQgPSBlbmQ7XG5cdFx0dGhpcy51bml0ID0gdW5pdCB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0fSxcblx0Y3VyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0cmV0dXJuIGhvb2tzICYmIGhvb2tzLmdldCA/XG5cdFx0XHRob29rcy5nZXQoIHRoaXMgKSA6XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KCB0aGlzICk7XG5cdH0sXG5cdHJ1bjogZnVuY3Rpb24oIHBlcmNlbnQgKSB7XG5cdFx0dmFyIGVhc2VkLFxuXHRcdFx0aG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0galF1ZXJ5LmVhc2luZ1sgdGhpcy5lYXNpbmcgXShcblx0XHRcdFx0cGVyY2VudCwgdGhpcy5vcHRpb25zLmR1cmF0aW9uICogcGVyY2VudCwgMCwgMSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0gcGVyY2VudDtcblx0XHR9XG5cdFx0dGhpcy5ub3cgPSAoIHRoaXMuZW5kIC0gdGhpcy5zdGFydCApICogZWFzZWQgKyB0aGlzLnN0YXJ0O1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuc3RlcCApIHtcblx0XHRcdHRoaXMub3B0aW9ucy5zdGVwLmNhbGwoIHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnNldCApIHtcblx0XHRcdGhvb2tzLnNldCggdGhpcyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KCB0aGlzICk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59O1xuXG5Ud2Vlbi5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGUgPSBUd2Vlbi5wcm90b3R5cGU7XG5cblR3ZWVuLnByb3BIb29rcyA9IHtcblx0X2RlZmF1bHQ6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRcdHZhciByZXN1bHQ7XG5cblx0XHRcdC8vIFVzZSBhIHByb3BlcnR5IG9uIHRoZSBlbGVtZW50IGRpcmVjdGx5IHdoZW4gaXQgaXMgbm90IGEgRE9NIGVsZW1lbnQsXG5cdFx0XHQvLyBvciB3aGVuIHRoZXJlIGlzIG5vIG1hdGNoaW5nIHN0eWxlIHByb3BlcnR5IHRoYXQgZXhpc3RzLlxuXHRcdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICE9PSAxIHx8XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSAhPSBudWxsICYmIHR3ZWVuLmVsZW0uc3R5bGVbIHR3ZWVuLnByb3AgXSA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQYXNzaW5nIGFuIGVtcHR5IHN0cmluZyBhcyBhIDNyZCBwYXJhbWV0ZXIgdG8gLmNzcyB3aWxsIGF1dG9tYXRpY2FsbHlcblx0XHRcdC8vIGF0dGVtcHQgYSBwYXJzZUZsb2F0IGFuZCBmYWxsYmFjayB0byBhIHN0cmluZyBpZiB0aGUgcGFyc2UgZmFpbHMuXG5cdFx0XHQvLyBTaW1wbGUgdmFsdWVzIHN1Y2ggYXMgXCIxMHB4XCIgYXJlIHBhcnNlZCB0byBGbG9hdDtcblx0XHRcdC8vIGNvbXBsZXggdmFsdWVzIHN1Y2ggYXMgXCJyb3RhdGUoMXJhZClcIiBhcmUgcmV0dXJuZWQgYXMtaXMuXG5cdFx0XHRyZXN1bHQgPSBqUXVlcnkuY3NzKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCBcIlwiICk7XG5cblx0XHRcdC8vIEVtcHR5IHN0cmluZ3MsIG51bGwsIHVuZGVmaW5lZCBhbmQgXCJhdXRvXCIgYXJlIGNvbnZlcnRlZCB0byAwLlxuXHRcdFx0cmV0dXJuICFyZXN1bHQgfHwgcmVzdWx0ID09PSBcImF1dG9cIiA/IDAgOiByZXN1bHQ7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblxuXHRcdFx0Ly8gVXNlIHN0ZXAgaG9vayBmb3IgYmFjayBjb21wYXQuXG5cdFx0XHQvLyBVc2UgY3NzSG9vayBpZiBpdHMgdGhlcmUuXG5cdFx0XHQvLyBVc2UgLnN0eWxlIGlmIGF2YWlsYWJsZSBhbmQgdXNlIHBsYWluIHByb3BlcnRpZXMgd2hlcmUgYXZhaWxhYmxlLlxuXHRcdFx0aWYgKCBqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdICkge1xuXHRcdFx0XHRqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdKCB0d2VlbiApO1xuXHRcdFx0fSBlbHNlIGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIHR3ZWVuLmVsZW0uc3R5bGVbIGpRdWVyeS5jc3NQcm9wc1sgdHdlZW4ucHJvcCBdIF0gIT0gbnVsbCB8fFxuXHRcdFx0XHRcdGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgdHdlZW4ubm93ICsgdHdlZW4udW5pdCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbi8vIFBhbmljIGJhc2VkIGFwcHJvYWNoIHRvIHNldHRpbmcgdGhpbmdzIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuVHdlZW4ucHJvcEhvb2tzLnNjcm9sbFRvcCA9IFR3ZWVuLnByb3BIb29rcy5zY3JvbGxMZWZ0ID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgJiYgdHdlZW4uZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmVhc2luZyA9IHtcblx0bGluZWFyOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gcDtcblx0fSxcblx0c3dpbmc6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiAwLjUgLSBNYXRoLmNvcyggcCAqIE1hdGguUEkgKSAvIDI7XG5cdH0sXG5cdF9kZWZhdWx0OiBcInN3aW5nXCJcbn07XG5cbmpRdWVyeS5meCA9IFR3ZWVuLnByb3RvdHlwZS5pbml0O1xuXG4vLyBCYWNrIGNvbXBhdCA8MS44IGV4dGVuc2lvbiBwb2ludFxualF1ZXJ5LmZ4LnN0ZXAgPSB7fTtcblxuXG5cblxudmFyXG5cdGZ4Tm93LCBpblByb2dyZXNzLFxuXHRyZnh0eXBlcyA9IC9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxcblx0cnJ1biA9IC9xdWV1ZUhvb2tzJC87XG5cbmZ1bmN0aW9uIHNjaGVkdWxlKCkge1xuXHRpZiAoIGluUHJvZ3Jlc3MgKSB7XG5cdFx0aWYgKCBkb2N1bWVudC5oaWRkZW4gPT09IGZhbHNlICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKSB7XG5cdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBzY2hlZHVsZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3aW5kb3cuc2V0VGltZW91dCggc2NoZWR1bGUsIGpRdWVyeS5meC5pbnRlcnZhbCApO1xuXHRcdH1cblxuXHRcdGpRdWVyeS5meC50aWNrKCk7XG5cdH1cbn1cblxuLy8gQW5pbWF0aW9ucyBjcmVhdGVkIHN5bmNocm9ub3VzbHkgd2lsbCBydW4gc3luY2hyb25vdXNseVxuZnVuY3Rpb24gY3JlYXRlRnhOb3coKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRmeE5vdyA9IHVuZGVmaW5lZDtcblx0fSApO1xuXHRyZXR1cm4gKCBmeE5vdyA9IERhdGUubm93KCkgKTtcbn1cblxuLy8gR2VuZXJhdGUgcGFyYW1ldGVycyB0byBjcmVhdGUgYSBzdGFuZGFyZCBhbmltYXRpb25cbmZ1bmN0aW9uIGdlbkZ4KCB0eXBlLCBpbmNsdWRlV2lkdGggKSB7XG5cdHZhciB3aGljaCxcblx0XHRpID0gMCxcblx0XHRhdHRycyA9IHsgaGVpZ2h0OiB0eXBlIH07XG5cblx0Ly8gSWYgd2UgaW5jbHVkZSB3aWR0aCwgc3RlcCB2YWx1ZSBpcyAxIHRvIGRvIGFsbCBjc3NFeHBhbmQgdmFsdWVzLFxuXHQvLyBvdGhlcndpc2Ugc3RlcCB2YWx1ZSBpcyAyIHRvIHNraXAgb3ZlciBMZWZ0IGFuZCBSaWdodFxuXHRpbmNsdWRlV2lkdGggPSBpbmNsdWRlV2lkdGggPyAxIDogMDtcblx0Zm9yICggOyBpIDwgNDsgaSArPSAyIC0gaW5jbHVkZVdpZHRoICkge1xuXHRcdHdoaWNoID0gY3NzRXhwYW5kWyBpIF07XG5cdFx0YXR0cnNbIFwibWFyZ2luXCIgKyB3aGljaCBdID0gYXR0cnNbIFwicGFkZGluZ1wiICsgd2hpY2ggXSA9IHR5cGU7XG5cdH1cblxuXHRpZiAoIGluY2x1ZGVXaWR0aCApIHtcblx0XHRhdHRycy5vcGFjaXR5ID0gYXR0cnMud2lkdGggPSB0eXBlO1xuXHR9XG5cblx0cmV0dXJuIGF0dHJzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUd2VlbiggdmFsdWUsIHByb3AsIGFuaW1hdGlvbiApIHtcblx0dmFyIHR3ZWVuLFxuXHRcdGNvbGxlY3Rpb24gPSAoIEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdICkuY29uY2F0KCBBbmltYXRpb24udHdlZW5lcnNbIFwiKlwiIF0gKSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCAoIHR3ZWVuID0gY29sbGVjdGlvblsgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIHByb3AsIHZhbHVlICkgKSApIHtcblxuXHRcdFx0Ly8gV2UncmUgZG9uZSB3aXRoIHRoaXMgcHJvcGVydHlcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdFByZWZpbHRlciggZWxlbSwgcHJvcHMsIG9wdHMgKSB7XG5cdHZhciBwcm9wLCB2YWx1ZSwgdG9nZ2xlLCBob29rcywgb2xkZmlyZSwgcHJvcFR3ZWVuLCByZXN0b3JlRGlzcGxheSwgZGlzcGxheSxcblx0XHRpc0JveCA9IFwid2lkdGhcIiBpbiBwcm9wcyB8fCBcImhlaWdodFwiIGluIHByb3BzLFxuXHRcdGFuaW0gPSB0aGlzLFxuXHRcdG9yaWcgPSB7fSxcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGUsXG5cdFx0aGlkZGVuID0gZWxlbS5ub2RlVHlwZSAmJiBpc0hpZGRlbldpdGhpblRyZWUoIGVsZW0gKSxcblx0XHRkYXRhU2hvdyA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJmeHNob3dcIiApO1xuXG5cdC8vIFF1ZXVlLXNraXBwaW5nIGFuaW1hdGlvbnMgaGlqYWNrIHRoZSBmeCBob29rc1xuXHRpZiAoICFvcHRzLnF1ZXVlICkge1xuXHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCBcImZ4XCIgKTtcblx0XHRpZiAoIGhvb2tzLnVucXVldWVkID09IG51bGwgKSB7XG5cdFx0XHRob29rcy51bnF1ZXVlZCA9IDA7XG5cdFx0XHRvbGRmaXJlID0gaG9va3MuZW1wdHkuZmlyZTtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhaG9va3MudW5xdWV1ZWQgKSB7XG5cdFx0XHRcdFx0b2xkZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRob29rcy51bnF1ZXVlZCsrO1xuXG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBFbnN1cmUgdGhlIGNvbXBsZXRlIGhhbmRsZXIgaXMgY2FsbGVkIGJlZm9yZSB0aGlzIGNvbXBsZXRlc1xuXHRcdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRob29rcy51bnF1ZXVlZC0tO1xuXHRcdFx0XHRpZiAoICFqUXVlcnkucXVldWUoIGVsZW0sIFwiZnhcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBEZXRlY3Qgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0Zm9yICggcHJvcCBpbiBwcm9wcyApIHtcblx0XHR2YWx1ZSA9IHByb3BzWyBwcm9wIF07XG5cdFx0aWYgKCByZnh0eXBlcy50ZXN0KCB2YWx1ZSApICkge1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBwcm9wIF07XG5cdFx0XHR0b2dnbGUgPSB0b2dnbGUgfHwgdmFsdWUgPT09IFwidG9nZ2xlXCI7XG5cdFx0XHRpZiAoIHZhbHVlID09PSAoIGhpZGRlbiA/IFwiaGlkZVwiIDogXCJzaG93XCIgKSApIHtcblxuXHRcdFx0XHQvLyBQcmV0ZW5kIHRvIGJlIGhpZGRlbiBpZiB0aGlzIGlzIGEgXCJzaG93XCIgYW5kXG5cdFx0XHRcdC8vIHRoZXJlIGlzIHN0aWxsIGRhdGEgZnJvbSBhIHN0b3BwZWQgc2hvdy9oaWRlXG5cdFx0XHRcdGlmICggdmFsdWUgPT09IFwic2hvd1wiICYmIGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSB0cnVlO1xuXG5cdFx0XHRcdC8vIElnbm9yZSBhbGwgb3RoZXIgbm8tb3Agc2hvdy9oaWRlIGRhdGFcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0b3JpZ1sgcHJvcCBdID0gZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSB8fCBqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBCYWlsIG91dCBpZiB0aGlzIGlzIGEgbm8tb3AgbGlrZSAuaGlkZSgpLmhpZGUoKVxuXHRwcm9wVHdlZW4gPSAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3BzICk7XG5cdGlmICggIXByb3BUd2VlbiAmJiBqUXVlcnkuaXNFbXB0eU9iamVjdCggb3JpZyApICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFJlc3RyaWN0IFwib3ZlcmZsb3dcIiBhbmQgXCJkaXNwbGF5XCIgc3R5bGVzIGR1cmluZyBib3ggYW5pbWF0aW9uc1xuXHRpZiAoIGlzQm94ICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDE1XG5cdFx0Ly8gUmVjb3JkIGFsbCAzIG92ZXJmbG93IGF0dHJpYnV0ZXMgYmVjYXVzZSBJRSBkb2VzIG5vdCBpbmZlciB0aGUgc2hvcnRoYW5kXG5cdFx0Ly8gZnJvbSBpZGVudGljYWxseS12YWx1ZWQgb3ZlcmZsb3dYIGFuZCBvdmVyZmxvd1kgYW5kIEVkZ2UganVzdCBtaXJyb3JzXG5cdFx0Ly8gdGhlIG92ZXJmbG93WCB2YWx1ZSB0aGVyZS5cblx0XHRvcHRzLm92ZXJmbG93ID0gWyBzdHlsZS5vdmVyZmxvdywgc3R5bGUub3ZlcmZsb3dYLCBzdHlsZS5vdmVyZmxvd1kgXTtcblxuXHRcdC8vIElkZW50aWZ5IGEgZGlzcGxheSB0eXBlLCBwcmVmZXJyaW5nIG9sZCBzaG93L2hpZGUgZGF0YSBvdmVyIHRoZSBDU1MgY2FzY2FkZVxuXHRcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVNob3cgJiYgZGF0YVNob3cuZGlzcGxheTtcblx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHR9XG5cdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdGlmICggcmVzdG9yZURpc3BsYXkgKSB7XG5cdFx0XHRcdGRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gR2V0IG5vbmVtcHR5IHZhbHVlKHMpIGJ5IHRlbXBvcmFyaWx5IGZvcmNpbmcgdmlzaWJpbGl0eVxuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcblx0XHRcdFx0cmVzdG9yZURpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXkgfHwgcmVzdG9yZURpc3BsYXk7XG5cdFx0XHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBbmltYXRlIGlubGluZSBlbGVtZW50cyBhcyBpbmxpbmUtYmxvY2tcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwiaW5saW5lXCIgfHwgZGlzcGxheSA9PT0gXCJpbmxpbmUtYmxvY2tcIiAmJiByZXN0b3JlRGlzcGxheSAhPSBudWxsICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcImZsb2F0XCIgKSA9PT0gXCJub25lXCIgKSB7XG5cblx0XHRcdFx0Ly8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgZGlzcGxheSB2YWx1ZSBhdCB0aGUgZW5kIG9mIHB1cmUgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0XHRcdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRzdHlsZS5kaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdGRpc3BsYXkgPSBzdHlsZS5kaXNwbGF5O1xuXHRcdFx0XHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkaXNwbGF5ID09PSBcIm5vbmVcIiA/IFwiXCIgOiBkaXNwbGF5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRzdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIG9wdHMub3ZlcmZsb3cgKSB7XG5cdFx0c3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdHN0eWxlLm92ZXJmbG93ID0gb3B0cy5vdmVyZmxvd1sgMCBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dYID0gb3B0cy5vdmVyZmxvd1sgMSBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dZID0gb3B0cy5vdmVyZmxvd1sgMiBdO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEltcGxlbWVudCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRwcm9wVHdlZW4gPSBmYWxzZTtcblx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXG5cdFx0Ly8gR2VuZXJhbCBzaG93L2hpZGUgc2V0dXAgZm9yIHRoaXMgZWxlbWVudCBhbmltYXRpb25cblx0XHRpZiAoICFwcm9wVHdlZW4gKSB7XG5cdFx0XHRpZiAoIGRhdGFTaG93ICkge1xuXHRcdFx0XHRpZiAoIFwiaGlkZGVuXCIgaW4gZGF0YVNob3cgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gZGF0YVNob3cuaGlkZGVuO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkYXRhU2hvdyA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgXCJmeHNob3dcIiwgeyBkaXNwbGF5OiByZXN0b3JlRGlzcGxheSB9ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0b3JlIGhpZGRlbi92aXNpYmxlIGZvciB0b2dnbGUgc28gYC5zdG9wKCkudG9nZ2xlKClgIFwicmV2ZXJzZXNcIlxuXHRcdFx0aWYgKCB0b2dnbGUgKSB7XG5cdFx0XHRcdGRhdGFTaG93LmhpZGRlbiA9ICFoaWRkZW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNob3cgZWxlbWVudHMgYmVmb3JlIGFuaW1hdGluZyB0aGVtXG5cdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG5cdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG5cdFx0XHRcdC8vIFRoZSBmaW5hbCBzdGVwIG9mIGEgXCJoaWRlXCIgYW5pbWF0aW9uIGlzIGFjdHVhbGx5IGhpZGluZyB0aGUgZWxlbWVudFxuXHRcdFx0XHRpZiAoICFoaWRkZW4gKSB7XG5cdFx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cdFx0XHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIG9yaWdbIHByb3AgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0Ly8gUGVyLXByb3BlcnR5IHNldHVwXG5cdFx0cHJvcFR3ZWVuID0gY3JlYXRlVHdlZW4oIGhpZGRlbiA/IGRhdGFTaG93WyBwcm9wIF0gOiAwLCBwcm9wLCBhbmltICk7XG5cdFx0aWYgKCAhKCBwcm9wIGluIGRhdGFTaG93ICkgKSB7XG5cdFx0XHRkYXRhU2hvd1sgcHJvcCBdID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHByb3BUd2Vlbi5lbmQgPSBwcm9wVHdlZW4uc3RhcnQ7XG5cdFx0XHRcdHByb3BUd2Vlbi5zdGFydCA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHByb3BGaWx0ZXIoIHByb3BzLCBzcGVjaWFsRWFzaW5nICkge1xuXHR2YXIgaW5kZXgsIG5hbWUsIGVhc2luZywgdmFsdWUsIGhvb2tzO1xuXG5cdC8vIGNhbWVsQ2FzZSwgc3BlY2lhbEVhc2luZyBhbmQgZXhwYW5kIGNzc0hvb2sgcGFzc1xuXHRmb3IgKCBpbmRleCBpbiBwcm9wcyApIHtcblx0XHRuYW1lID0gY2FtZWxDYXNlKCBpbmRleCApO1xuXHRcdGVhc2luZyA9IHNwZWNpYWxFYXNpbmdbIG5hbWUgXTtcblx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdO1xuXHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdGVhc2luZyA9IHZhbHVlWyAxIF07XG5cdFx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdID0gdmFsdWVbIDAgXTtcblx0XHR9XG5cblx0XHRpZiAoIGluZGV4ICE9PSBuYW1lICkge1xuXHRcdFx0cHJvcHNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBpbmRleCBdO1xuXHRcdH1cblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF07XG5cdFx0aWYgKCBob29rcyAmJiBcImV4cGFuZFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsdWUgPSBob29rcy5leHBhbmQoIHZhbHVlICk7XG5cdFx0XHRkZWxldGUgcHJvcHNbIG5hbWUgXTtcblxuXHRcdFx0Ly8gTm90IHF1aXRlICQuZXh0ZW5kLCB0aGlzIHdvbid0IG92ZXJ3cml0ZSBleGlzdGluZyBrZXlzLlxuXHRcdFx0Ly8gUmV1c2luZyAnaW5kZXgnIGJlY2F1c2Ugd2UgaGF2ZSB0aGUgY29ycmVjdCBcIm5hbWVcIlxuXHRcdFx0Zm9yICggaW5kZXggaW4gdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggISggaW5kZXggaW4gcHJvcHMgKSApIHtcblx0XHRcdFx0XHRwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyBpbmRleCBdO1xuXHRcdFx0XHRcdHNwZWNpYWxFYXNpbmdbIGluZGV4IF0gPSBlYXNpbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0c3BlY2lhbEVhc2luZ1sgbmFtZSBdID0gZWFzaW5nO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBBbmltYXRpb24oIGVsZW0sIHByb3BlcnRpZXMsIG9wdGlvbnMgKSB7XG5cdHZhciByZXN1bHQsXG5cdFx0c3RvcHBlZCxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gQW5pbWF0aW9uLnByZWZpbHRlcnMubGVuZ3RoLFxuXHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCkuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRG9uJ3QgbWF0Y2ggZWxlbSBpbiB0aGUgOmFuaW1hdGVkIHNlbGVjdG9yXG5cdFx0XHRkZWxldGUgdGljay5lbGVtO1xuXHRcdH0gKSxcblx0XHR0aWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHZhciBjdXJyZW50VGltZSA9IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRcdHJlbWFpbmluZyA9IE1hdGgubWF4KCAwLCBhbmltYXRpb24uc3RhcnRUaW1lICsgYW5pbWF0aW9uLmR1cmF0aW9uIC0gY3VycmVudFRpbWUgKSxcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuMyBvbmx5XG5cdFx0XHRcdC8vIEFyY2hhaWMgY3Jhc2ggYnVnIHdvbid0IGFsbG93IHVzIHRvIHVzZSBgMSAtICggMC41IHx8IDAgKWAgKCMxMjQ5Nylcblx0XHRcdFx0dGVtcCA9IHJlbWFpbmluZyAvIGFuaW1hdGlvbi5kdXJhdGlvbiB8fCAwLFxuXHRcdFx0XHRwZXJjZW50ID0gMSAtIHRlbXAsXG5cdFx0XHRcdGluZGV4ID0gMCxcblx0XHRcdFx0bGVuZ3RoID0gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGg7XG5cblx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCBwZXJjZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBwZXJjZW50LCByZW1haW5pbmcgXSApO1xuXG5cdFx0XHQvLyBJZiB0aGVyZSdzIG1vcmUgdG8gZG8sIHlpZWxkXG5cdFx0XHRpZiAoIHBlcmNlbnQgPCAxICYmIGxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuIHJlbWFpbmluZztcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhpcyB3YXMgYW4gZW1wdHkgYW5pbWF0aW9uLCBzeW50aGVzaXplIGEgZmluYWwgcHJvZ3Jlc3Mgbm90aWZpY2F0aW9uXG5cdFx0XHRpZiAoICFsZW5ndGggKSB7XG5cdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVzb2x2ZSB0aGUgYW5pbWF0aW9uIGFuZCByZXBvcnQgaXRzIGNvbmNsdXNpb25cblx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiBdICk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblx0XHRhbmltYXRpb24gPSBkZWZlcnJlZC5wcm9taXNlKCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0cHJvcHM6IGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wZXJ0aWVzICksXG5cdFx0XHRvcHRzOiBqUXVlcnkuZXh0ZW5kKCB0cnVlLCB7XG5cdFx0XHRcdHNwZWNpYWxFYXNpbmc6IHt9LFxuXHRcdFx0XHRlYXNpbmc6IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHRcblx0XHRcdH0sIG9wdGlvbnMgKSxcblx0XHRcdG9yaWdpbmFsUHJvcGVydGllczogcHJvcGVydGllcyxcblx0XHRcdG9yaWdpbmFsT3B0aW9uczogb3B0aW9ucyxcblx0XHRcdHN0YXJ0VGltZTogZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuXHRcdFx0dHdlZW5zOiBbXSxcblx0XHRcdGNyZWF0ZVR3ZWVuOiBmdW5jdGlvbiggcHJvcCwgZW5kICkge1xuXHRcdFx0XHR2YXIgdHdlZW4gPSBqUXVlcnkuVHdlZW4oIGVsZW0sIGFuaW1hdGlvbi5vcHRzLCBwcm9wLCBlbmQsXG5cdFx0XHRcdFx0XHRhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nWyBwcm9wIF0gfHwgYW5pbWF0aW9uLm9wdHMuZWFzaW5nICk7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnMucHVzaCggdHdlZW4gKTtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdFx0fSxcblx0XHRcdHN0b3A6IGZ1bmN0aW9uKCBnb3RvRW5kICkge1xuXHRcdFx0XHR2YXIgaW5kZXggPSAwLFxuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgYXJlIGdvaW5nIHRvIHRoZSBlbmQsIHdlIHdhbnQgdG8gcnVuIGFsbCB0aGUgdHdlZW5zXG5cdFx0XHRcdFx0Ly8gb3RoZXJ3aXNlIHdlIHNraXAgdGhpcyBwYXJ0XG5cdFx0XHRcdFx0bGVuZ3RoID0gZ290b0VuZCA/IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoIDogMDtcblx0XHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0b3BwZWQgPSB0cnVlO1xuXHRcdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCAxICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXNvbHZlIHdoZW4gd2UgcGxheWVkIHRoZSBsYXN0IGZyYW1lOyBvdGhlcndpc2UsIHJlamVjdFxuXHRcdFx0XHRpZiAoIGdvdG9FbmQgKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdH0gKSxcblx0XHRwcm9wcyA9IGFuaW1hdGlvbi5wcm9wcztcblxuXHRwcm9wRmlsdGVyKCBwcm9wcywgYW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZyApO1xuXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0cmVzdWx0ID0gQW5pbWF0aW9uLnByZWZpbHRlcnNbIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBlbGVtLCBwcm9wcywgYW5pbWF0aW9uLm9wdHMgKTtcblx0XHRpZiAoIHJlc3VsdCApIHtcblx0XHRcdGlmICggaXNGdW5jdGlvbiggcmVzdWx0LnN0b3AgKSApIHtcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCBhbmltYXRpb24uZWxlbSwgYW5pbWF0aW9uLm9wdHMucXVldWUgKS5zdG9wID1cblx0XHRcdFx0XHRyZXN1bHQuc3RvcC5iaW5kKCByZXN1bHQgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXHR9XG5cblx0alF1ZXJ5Lm1hcCggcHJvcHMsIGNyZWF0ZVR3ZWVuLCBhbmltYXRpb24gKTtcblxuXHRpZiAoIGlzRnVuY3Rpb24oIGFuaW1hdGlvbi5vcHRzLnN0YXJ0ICkgKSB7XG5cdFx0YW5pbWF0aW9uLm9wdHMuc3RhcnQuY2FsbCggZWxlbSwgYW5pbWF0aW9uICk7XG5cdH1cblxuXHQvLyBBdHRhY2ggY2FsbGJhY2tzIGZyb20gb3B0aW9uc1xuXHRhbmltYXRpb25cblx0XHQucHJvZ3Jlc3MoIGFuaW1hdGlvbi5vcHRzLnByb2dyZXNzIClcblx0XHQuZG9uZSggYW5pbWF0aW9uLm9wdHMuZG9uZSwgYW5pbWF0aW9uLm9wdHMuY29tcGxldGUgKVxuXHRcdC5mYWlsKCBhbmltYXRpb24ub3B0cy5mYWlsIClcblx0XHQuYWx3YXlzKCBhbmltYXRpb24ub3B0cy5hbHdheXMgKTtcblxuXHRqUXVlcnkuZngudGltZXIoXG5cdFx0alF1ZXJ5LmV4dGVuZCggdGljaywge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdGFuaW06IGFuaW1hdGlvbixcblx0XHRcdHF1ZXVlOiBhbmltYXRpb24ub3B0cy5xdWV1ZVxuXHRcdH0gKVxuXHQpO1xuXG5cdHJldHVybiBhbmltYXRpb247XG59XG5cbmpRdWVyeS5BbmltYXRpb24gPSBqUXVlcnkuZXh0ZW5kKCBBbmltYXRpb24sIHtcblxuXHR0d2VlbmVyczoge1xuXHRcdFwiKlwiOiBbIGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuY3JlYXRlVHdlZW4oIHByb3AsIHZhbHVlICk7XG5cdFx0XHRhZGp1c3RDU1MoIHR3ZWVuLmVsZW0sIHByb3AsIHJjc3NOdW0uZXhlYyggdmFsdWUgKSwgdHdlZW4gKTtcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9IF1cblx0fSxcblxuXHR0d2VlbmVyOiBmdW5jdGlvbiggcHJvcHMsIGNhbGxiYWNrICkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggcHJvcHMgKSApIHtcblx0XHRcdGNhbGxiYWNrID0gcHJvcHM7XG5cdFx0XHRwcm9wcyA9IFsgXCIqXCIgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cHJvcHMgPSBwcm9wcy5tYXRjaCggcm5vdGh0bWx3aGl0ZSApO1xuXHRcdH1cblxuXHRcdHZhciBwcm9wLFxuXHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0bGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdHByb3AgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdID0gQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW107XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXS51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH1cblx0fSxcblxuXHRwcmVmaWx0ZXJzOiBbIGRlZmF1bHRQcmVmaWx0ZXIgXSxcblxuXHRwcmVmaWx0ZXI6IGZ1bmN0aW9uKCBjYWxsYmFjaywgcHJlcGVuZCApIHtcblx0XHRpZiAoIHByZXBlbmQgKSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy5wdXNoKCBjYWxsYmFjayApO1xuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuc3BlZWQgPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgZm4gKSB7XG5cdHZhciBvcHQgPSBzcGVlZCAmJiB0eXBlb2Ygc3BlZWQgPT09IFwib2JqZWN0XCIgPyBqUXVlcnkuZXh0ZW5kKCB7fSwgc3BlZWQgKSA6IHtcblx0XHRjb21wbGV0ZTogZm4gfHwgIWZuICYmIGVhc2luZyB8fFxuXHRcdFx0aXNGdW5jdGlvbiggc3BlZWQgKSAmJiBzcGVlZCxcblx0XHRkdXJhdGlvbjogc3BlZWQsXG5cdFx0ZWFzaW5nOiBmbiAmJiBlYXNpbmcgfHwgZWFzaW5nICYmICFpc0Z1bmN0aW9uKCBlYXNpbmcgKSAmJiBlYXNpbmdcblx0fTtcblxuXHQvLyBHbyB0byB0aGUgZW5kIHN0YXRlIGlmIGZ4IGFyZSBvZmZcblx0aWYgKCBqUXVlcnkuZngub2ZmICkge1xuXHRcdG9wdC5kdXJhdGlvbiA9IDA7XG5cblx0fSBlbHNlIHtcblx0XHRpZiAoIHR5cGVvZiBvcHQuZHVyYXRpb24gIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRpZiAoIG9wdC5kdXJhdGlvbiBpbiBqUXVlcnkuZnguc3BlZWRzICkge1xuXHRcdFx0XHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzWyBvcHQuZHVyYXRpb24gXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkcy5fZGVmYXVsdDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgb3B0LnF1ZXVlIC0gdHJ1ZS91bmRlZmluZWQvbnVsbCAtPiBcImZ4XCJcblx0aWYgKCBvcHQucXVldWUgPT0gbnVsbCB8fCBvcHQucXVldWUgPT09IHRydWUgKSB7XG5cdFx0b3B0LnF1ZXVlID0gXCJmeFwiO1xuXHR9XG5cblx0Ly8gUXVldWVpbmdcblx0b3B0Lm9sZCA9IG9wdC5jb21wbGV0ZTtcblxuXHRvcHQuY29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIG9wdC5vbGQgKSApIHtcblx0XHRcdG9wdC5vbGQuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0LnF1ZXVlICkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIG9wdC5xdWV1ZSApO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gb3B0O1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmYWRlVG86IGZ1bmN0aW9uKCBzcGVlZCwgdG8sIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cblx0XHQvLyBTaG93IGFueSBoaWRkZW4gZWxlbWVudHMgYWZ0ZXIgc2V0dGluZyBvcGFjaXR5IHRvIDBcblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGlzSGlkZGVuV2l0aGluVHJlZSApLmNzcyggXCJvcGFjaXR5XCIsIDAgKS5zaG93KClcblxuXHRcdFx0Ly8gQW5pbWF0ZSB0byB0aGUgdmFsdWUgc3BlY2lmaWVkXG5cdFx0XHQuZW5kKCkuYW5pbWF0ZSggeyBvcGFjaXR5OiB0byB9LCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9LFxuXHRhbmltYXRlOiBmdW5jdGlvbiggcHJvcCwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGVtcHR5ID0galF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3AgKSxcblx0XHRcdG9wdGFsbCA9IGpRdWVyeS5zcGVlZCggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSxcblx0XHRcdGRvQW5pbWF0aW9uID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gT3BlcmF0ZSBvbiBhIGNvcHkgb2YgcHJvcCBzbyBwZXItcHJvcGVydHkgZWFzaW5nIHdvbid0IGJlIGxvc3Rcblx0XHRcdFx0dmFyIGFuaW0gPSBBbmltYXRpb24oIHRoaXMsIGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wICksIG9wdGFsbCApO1xuXG5cdFx0XHRcdC8vIEVtcHR5IGFuaW1hdGlvbnMsIG9yIGZpbmlzaGluZyByZXNvbHZlcyBpbW1lZGlhdGVseVxuXHRcdFx0XHRpZiAoIGVtcHR5IHx8IGRhdGFQcml2LmdldCggdGhpcywgXCJmaW5pc2hcIiApICkge1xuXHRcdFx0XHRcdGFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0ZG9BbmltYXRpb24uZmluaXNoID0gZG9BbmltYXRpb247XG5cblx0XHRyZXR1cm4gZW1wdHkgfHwgb3B0YWxsLnF1ZXVlID09PSBmYWxzZSA/XG5cdFx0XHR0aGlzLmVhY2goIGRvQW5pbWF0aW9uICkgOlxuXHRcdFx0dGhpcy5xdWV1ZSggb3B0YWxsLnF1ZXVlLCBkb0FuaW1hdGlvbiApO1xuXHR9LFxuXHRzdG9wOiBmdW5jdGlvbiggdHlwZSwgY2xlYXJRdWV1ZSwgZ290b0VuZCApIHtcblx0XHR2YXIgc3RvcFF1ZXVlID0gZnVuY3Rpb24oIGhvb2tzICkge1xuXHRcdFx0dmFyIHN0b3AgPSBob29rcy5zdG9wO1xuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRzdG9wKCBnb3RvRW5kICk7XG5cdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRnb3RvRW5kID0gY2xlYXJRdWV1ZTtcblx0XHRcdGNsZWFyUXVldWUgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBjbGVhclF1ZXVlICYmIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZGVxdWV1ZSA9IHRydWUsXG5cdFx0XHRcdGluZGV4ID0gdHlwZSAhPSBudWxsICYmIHR5cGUgKyBcInF1ZXVlSG9va3NcIixcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApO1xuXG5cdFx0XHRpZiAoIGluZGV4ICkge1xuXHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICkge1xuXHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBpbmRleCBpbiBkYXRhICkge1xuXHRcdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgJiYgcnJ1bi50ZXN0KCBpbmRleCApICkge1xuXHRcdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiZcblx0XHRcdFx0XHQoIHR5cGUgPT0gbnVsbCB8fCB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSApIHtcblxuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIGdvdG9FbmQgKTtcblx0XHRcdFx0XHRkZXF1ZXVlID0gZmFsc2U7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGFydCB0aGUgbmV4dCBpbiB0aGUgcXVldWUgaWYgdGhlIGxhc3Qgc3RlcCB3YXNuJ3QgZm9yY2VkLlxuXHRcdFx0Ly8gVGltZXJzIGN1cnJlbnRseSB3aWxsIGNhbGwgdGhlaXIgY29tcGxldGUgY2FsbGJhY2tzLCB3aGljaFxuXHRcdFx0Ly8gd2lsbCBkZXF1ZXVlIGJ1dCBvbmx5IGlmIHRoZXkgd2VyZSBnb3RvRW5kLlxuXHRcdFx0aWYgKCBkZXF1ZXVlIHx8ICFnb3RvRW5kICkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblx0ZmluaXNoOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRpZiAoIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpbmRleCxcblx0XHRcdFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApLFxuXHRcdFx0XHRxdWV1ZSA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlXCIgXSxcblx0XHRcdFx0aG9va3MgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgXSxcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0bGVuZ3RoID0gcXVldWUgPyBxdWV1ZS5sZW5ndGggOiAwO1xuXG5cdFx0XHQvLyBFbmFibGUgZmluaXNoaW5nIGZsYWcgb24gcHJpdmF0ZSBkYXRhXG5cdFx0XHRkYXRhLmZpbmlzaCA9IHRydWU7XG5cblx0XHRcdC8vIEVtcHR5IHRoZSBxdWV1ZSBmaXJzdFxuXHRcdFx0alF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBbXSApO1xuXG5cdFx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnN0b3AgKSB7XG5cdFx0XHRcdGhvb2tzLnN0b3AuY2FsbCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYWN0aXZlIGFuaW1hdGlvbnMsIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJiB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSB7XG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFuaW1hdGlvbnMgaW4gdGhlIG9sZCBxdWV1ZSBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGlmICggcXVldWVbIGluZGV4IF0gJiYgcXVldWVbIGluZGV4IF0uZmluaXNoICkge1xuXHRcdFx0XHRcdHF1ZXVlWyBpbmRleCBdLmZpbmlzaC5jYWxsKCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVHVybiBvZmYgZmluaXNoaW5nIGZsYWdcblx0XHRcdGRlbGV0ZSBkYXRhLmZpbmlzaDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJ0b2dnbGVcIiwgXCJzaG93XCIsIFwiaGlkZVwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHR2YXIgY3NzRm4gPSBqUXVlcnkuZm5bIG5hbWUgXTtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHNwZWVkID09IG51bGwgfHwgdHlwZW9mIHNwZWVkID09PSBcImJvb2xlYW5cIiA/XG5cdFx0XHRjc3NGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICkgOlxuXHRcdFx0dGhpcy5hbmltYXRlKCBnZW5GeCggbmFtZSwgdHJ1ZSApLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG4vLyBHZW5lcmF0ZSBzaG9ydGN1dHMgZm9yIGN1c3RvbSBhbmltYXRpb25zXG5qUXVlcnkuZWFjaCgge1xuXHRzbGlkZURvd246IGdlbkZ4KCBcInNob3dcIiApLFxuXHRzbGlkZVVwOiBnZW5GeCggXCJoaWRlXCIgKSxcblx0c2xpZGVUb2dnbGU6IGdlbkZ4KCBcInRvZ2dsZVwiICksXG5cdGZhZGVJbjogeyBvcGFjaXR5OiBcInNob3dcIiB9LFxuXHRmYWRlT3V0OiB7IG9wYWNpdHk6IFwiaGlkZVwiIH0sXG5cdGZhZGVUb2dnbGU6IHsgb3BhY2l0eTogXCJ0b2dnbGVcIiB9XG59LCBmdW5jdGlvbiggbmFtZSwgcHJvcHMgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLmFuaW1hdGUoIHByb3BzLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkudGltZXJzID0gW107XG5qUXVlcnkuZngudGljayA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgdGltZXIsXG5cdFx0aSA9IDAsXG5cdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycztcblxuXHRmeE5vdyA9IERhdGUubm93KCk7XG5cblx0Zm9yICggOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrICkge1xuXHRcdHRpbWVyID0gdGltZXJzWyBpIF07XG5cblx0XHQvLyBSdW4gdGhlIHRpbWVyIGFuZCBzYWZlbHkgcmVtb3ZlIGl0IHdoZW4gZG9uZSAoYWxsb3dpbmcgZm9yIGV4dGVybmFsIHJlbW92YWwpXG5cdFx0aWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7XG5cdFx0XHR0aW1lcnMuc3BsaWNlKCBpLS0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoICF0aW1lcnMubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5meC5zdG9wKCk7XG5cdH1cblx0ZnhOb3cgPSB1bmRlZmluZWQ7XG59O1xuXG5qUXVlcnkuZngudGltZXIgPSBmdW5jdGlvbiggdGltZXIgKSB7XG5cdGpRdWVyeS50aW1lcnMucHVzaCggdGltZXIgKTtcblx0alF1ZXJ5LmZ4LnN0YXJ0KCk7XG59O1xuXG5qUXVlcnkuZnguaW50ZXJ2YWwgPSAxMztcbmpRdWVyeS5meC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoIGluUHJvZ3Jlc3MgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aW5Qcm9ncmVzcyA9IHRydWU7XG5cdHNjaGVkdWxlKCk7XG59O1xuXG5qUXVlcnkuZnguc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRpblByb2dyZXNzID0gbnVsbDtcbn07XG5cbmpRdWVyeS5meC5zcGVlZHMgPSB7XG5cdHNsb3c6IDYwMCxcblx0ZmFzdDogMjAwLFxuXG5cdC8vIERlZmF1bHQgc3BlZWRcblx0X2RlZmF1bHQ6IDQwMFxufTtcblxuXG4vLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXG4vLyBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxMDAzMjQwMTQ3NDcvaHR0cDovL2JsaW5kc2lnbmFscy5jb20vaW5kZXgucGhwLzIwMDkvMDcvanF1ZXJ5LWRlbGF5L1xualF1ZXJ5LmZuLmRlbGF5ID0gZnVuY3Rpb24oIHRpbWUsIHR5cGUgKSB7XG5cdHRpbWUgPSBqUXVlcnkuZnggPyBqUXVlcnkuZnguc3BlZWRzWyB0aW1lIF0gfHwgdGltZSA6IHRpbWU7XG5cdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSwgZnVuY3Rpb24oIG5leHQsIGhvb2tzICkge1xuXHRcdHZhciB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoIG5leHQsIHRpbWUgKTtcblx0XHRob29rcy5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XG5cdFx0fTtcblx0fSApO1xufTtcblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKSxcblx0XHRzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInNlbGVjdFwiICksXG5cdFx0b3B0ID0gc2VsZWN0LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9wdGlvblwiICkgKTtcblxuXHRpbnB1dC50eXBlID0gXCJjaGVja2JveFwiO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjMgb25seVxuXHQvLyBEZWZhdWx0IHZhbHVlIGZvciBhIGNoZWNrYm94IHNob3VsZCBiZSBcIm9uXCJcblx0c3VwcG9ydC5jaGVja09uID0gaW5wdXQudmFsdWUgIT09IFwiXCI7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE11c3QgYWNjZXNzIHNlbGVjdGVkSW5kZXggdG8gbWFrZSBkZWZhdWx0IG9wdGlvbnMgc2VsZWN0XG5cdHN1cHBvcnQub3B0U2VsZWN0ZWQgPSBvcHQuc2VsZWN0ZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIEFuIGlucHV0IGxvc2VzIGl0cyB2YWx1ZSBhZnRlciBiZWNvbWluZyBhIHJhZGlvXG5cdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdGlucHV0LnZhbHVlID0gXCJ0XCI7XG5cdGlucHV0LnR5cGUgPSBcInJhZGlvXCI7XG5cdHN1cHBvcnQucmFkaW9WYWx1ZSA9IGlucHV0LnZhbHVlID09PSBcInRcIjtcbn0gKSgpO1xuXG5cbnZhciBib29sSG9vayxcblx0YXR0ckhhbmRsZSA9IGpRdWVyeS5leHByLmF0dHJIYW5kbGU7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5hdHRyLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCB0aGlzLCBuYW1lICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucHJvcCggZWxlbSwgbmFtZSwgdmFsdWUgKTtcblx0XHR9XG5cblx0XHQvLyBBdHRyaWJ1dGUgaG9va3MgYXJlIGRldGVybWluZWQgYnkgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uXG5cdFx0Ly8gR3JhYiBuZWNlc3NhcnkgaG9vayBpZiBvbmUgaXMgZGVmaW5lZFxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXHRcdFx0aG9va3MgPSBqUXVlcnkuYXR0ckhvb2tzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHQoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApID8gYm9vbEhvb2sgOiB1bmRlZmluZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCB2YWx1ZSArIFwiXCIgKTtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXQgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHQvLyBOb24tZXhpc3RlbnQgYXR0cmlidXRlcyByZXR1cm4gbnVsbCwgd2Ugbm9ybWFsaXplIHRvIHVuZGVmaW5lZFxuXHRcdHJldHVybiByZXQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHJldDtcblx0fSxcblxuXHRhdHRySG9va3M6IHtcblx0XHR0eXBlOiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhc3VwcG9ydC5yYWRpb1ZhbHVlICYmIHZhbHVlID09PSBcInJhZGlvXCIgJiZcblx0XHRcdFx0XHRub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dmFyIHZhbCA9IGVsZW0udmFsdWU7XG5cdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCB2YWx1ZSApO1xuXHRcdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdFx0ZWxlbS52YWx1ZSA9IHZhbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHR2YXIgbmFtZSxcblx0XHRcdGkgPSAwLFxuXG5cdFx0XHQvLyBBdHRyaWJ1dGUgbmFtZXMgY2FuIGNvbnRhaW4gbm9uLUhUTUwgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzXG5cdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNhdHRyaWJ1dGVzLTJcblx0XHRcdGF0dHJOYW1lcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cblx0XHRpZiAoIGF0dHJOYW1lcyAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0d2hpbGUgKCAoIG5hbWUgPSBhdHRyTmFtZXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBuYW1lICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhvb2tzIGZvciBib29sZWFuIGF0dHJpYnV0ZXNcbmJvb2xIb29rID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcblx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGJvb2xlYW4gYXR0cmlidXRlcyB3aGVuIHNldCB0byBmYWxzZVxuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cbn07XG5cbmpRdWVyeS5lYWNoKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCggL1xcdysvZyApLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGdldHRlciA9IGF0dHJIYW5kbGVbIG5hbWUgXSB8fCBqUXVlcnkuZmluZC5hdHRyO1xuXG5cdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgcmV0LCBoYW5kbGUsXG5cdFx0XHRsb3dlcmNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cblx0XHRcdC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3AgYnkgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBnZXR0ZXJcblx0XHRcdGhhbmRsZSA9IGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXTtcblx0XHRcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IHJldDtcblx0XHRcdHJldCA9IGdldHRlciggZWxlbSwgbmFtZSwgaXNYTUwgKSAhPSBudWxsID9cblx0XHRcdFx0bG93ZXJjYXNlTmFtZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSBoYW5kbGU7XG5cdFx0fVxuXHRcdHJldHVybiByZXQ7XG5cdH07XG59ICk7XG5cblxuXG5cbnZhciByZm9jdXNhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmNsaWNrYWJsZSA9IC9eKD86YXxhcmVhKSQvaTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LnByb3AsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZVByb3A6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGVsZXRlIHRoaXNbIGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZSBdO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBGaXggbmFtZSBhbmQgYXR0YWNoIGhvb2tzXG5cdFx0XHRuYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0aG9va3MgPSBqUXVlcnkucHJvcEhvb2tzWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuICggZWxlbVsgbmFtZSBdID0gdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdO1xuXHR9LFxuXG5cdHByb3BIb29rczoge1xuXHRcdHRhYkluZGV4OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHRcdFx0Ly8gZWxlbS50YWJJbmRleCBkb2Vzbid0IGFsd2F5cyByZXR1cm4gdGhlXG5cdFx0XHRcdC8vIGNvcnJlY3QgdmFsdWUgd2hlbiBpdCBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IHNldFxuXHRcdFx0XHQvLyBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxNDExMTYyMzMzNDcvaHR0cDovL2ZsdWlkcHJvamVjdC5vcmcvYmxvZy8yMDA4LzAxLzA5L2dldHRpbmctc2V0dGluZy1hbmQtcmVtb3ZpbmctdGFiaW5kZXgtdmFsdWVzLXdpdGgtamF2YXNjcmlwdC9cblx0XHRcdFx0Ly8gVXNlIHByb3BlciBhdHRyaWJ1dGUgcmV0cmlldmFsKCMxMjA3Milcblx0XHRcdFx0dmFyIHRhYmluZGV4ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ0YWJpbmRleFwiICk7XG5cblx0XHRcdFx0aWYgKCB0YWJpbmRleCApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGFyc2VJbnQoIHRhYmluZGV4LCAxMCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdHJmb2N1c2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApIHx8XG5cdFx0XHRcdFx0cmNsaWNrYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgJiZcblx0XHRcdFx0XHRlbGVtLmhyZWZcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHByb3BGaXg6IHtcblx0XHRcImZvclwiOiBcImh0bWxGb3JcIixcblx0XHRcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCJcblx0fVxufSApO1xuXG4vLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcbi8vIEFjY2Vzc2luZyB0aGUgc2VsZWN0ZWRJbmRleCBwcm9wZXJ0eVxuLy8gZm9yY2VzIHRoZSBicm93c2VyIHRvIHJlc3BlY3Qgc2V0dGluZyBzZWxlY3RlZFxuLy8gb24gdGhlIG9wdGlvblxuLy8gVGhlIGdldHRlciBlbnN1cmVzIGEgZGVmYXVsdCBvcHRpb24gaXMgc2VsZWN0ZWRcbi8vIHdoZW4gaW4gYW4gb3B0Z3JvdXBcbi8vIGVzbGludCBydWxlIFwibm8tdW51c2VkLWV4cHJlc3Npb25zXCIgaXMgZGlzYWJsZWQgZm9yIHRoaXMgY29kZVxuLy8gc2luY2UgaXQgY29uc2lkZXJzIHN1Y2ggYWNjZXNzaW9ucyBub29wXG5pZiAoICFzdXBwb3J0Lm9wdFNlbGVjdGVkICkge1xuXHRqUXVlcnkucHJvcEhvb2tzLnNlbGVjdGVkID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cblxuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICYmIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0cGFyZW50LnNlbGVjdGVkSW5kZXg7XG5cblx0XHRcdFx0aWYgKCBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG5qUXVlcnkuZWFjaCggW1xuXHRcInRhYkluZGV4XCIsXG5cdFwicmVhZE9ubHlcIixcblx0XCJtYXhMZW5ndGhcIixcblx0XCJjZWxsU3BhY2luZ1wiLFxuXHRcImNlbGxQYWRkaW5nXCIsXG5cdFwicm93U3BhblwiLFxuXHRcImNvbFNwYW5cIixcblx0XCJ1c2VNYXBcIixcblx0XCJmcmFtZUJvcmRlclwiLFxuXHRcImNvbnRlbnRFZGl0YWJsZVwiXG5dLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnByb3BGaXhbIHRoaXMudG9Mb3dlckNhc2UoKSBdID0gdGhpcztcbn0gKTtcblxuXG5cblxuXHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZSBhY2NvcmRpbmcgdG8gSFRNTCBzcGVjXG5cdC8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2UtYXNjaWktd2hpdGVzcGFjZVxuXHRmdW5jdGlvbiBzdHJpcEFuZENvbGxhcHNlKCB2YWx1ZSApIHtcblx0XHR2YXIgdG9rZW5zID0gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblx0XHRyZXR1cm4gdG9rZW5zLmpvaW4oIFwiIFwiICk7XG5cdH1cblxuXG5mdW5jdGlvbiBnZXRDbGFzcyggZWxlbSApIHtcblx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlICYmIGVsZW0uZ2V0QXR0cmlidXRlKCBcImNsYXNzXCIgKSB8fCBcIlwiO1xufVxuXG5mdW5jdGlvbiBjbGFzc2VzVG9BcnJheSggdmFsdWUgKSB7XG5cdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cblx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cdH1cblx0cmV0dXJuIFtdO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGFkZENsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuYWRkQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGNsYXNzZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggY2xhc3Nlcy5sZW5ndGggKSB7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggY3VyVmFsdWUgKSArIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblx0XHRcdFx0XHRcdGlmICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApIDwgMCApIHtcblx0XHRcdFx0XHRcdFx0Y3VyICs9IGNsYXp6ICsgXCIgXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZW1vdmVDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnJlbW92ZUNsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYXR0ciggXCJjbGFzc1wiLCBcIlwiICk7XG5cdFx0fVxuXG5cdFx0Y2xhc3NlcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0aWYgKCBjbGFzc2VzLmxlbmd0aCApIHtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xuXG5cdFx0XHRcdC8vIFRoaXMgZXhwcmVzc2lvbiBpcyBoZXJlIGZvciBiZXR0ZXIgY29tcHJlc3NpYmlsaXR5IChzZWUgYWRkQ2xhc3MpXG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSAqYWxsKiBpbnN0YW5jZXNcblx0XHRcdFx0XHRcdHdoaWxlICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciA9IGN1ci5yZXBsYWNlKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIsIFwiIFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR0b2dnbGVDbGFzczogZnVuY3Rpb24oIHZhbHVlLCBzdGF0ZVZhbCApIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZSxcblx0XHRcdGlzVmFsaWRWYWx1ZSA9IHR5cGUgPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggdHlwZW9mIHN0YXRlVmFsID09PSBcImJvb2xlYW5cIiAmJiBpc1ZhbGlkVmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGVWYWwgPyB0aGlzLmFkZENsYXNzKCB2YWx1ZSApIDogdGhpcy5yZW1vdmVDbGFzcyggdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkudG9nZ2xlQ2xhc3MoXG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggdGhpcywgaSwgZ2V0Q2xhc3MoIHRoaXMgKSwgc3RhdGVWYWwgKSxcblx0XHRcdFx0XHRzdGF0ZVZhbFxuXHRcdFx0XHQpO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNsYXNzTmFtZSwgaSwgc2VsZiwgY2xhc3NOYW1lcztcblxuXHRcdFx0aWYgKCBpc1ZhbGlkVmFsdWUgKSB7XG5cblx0XHRcdFx0Ly8gVG9nZ2xlIGluZGl2aWR1YWwgY2xhc3MgbmFtZXNcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdHNlbGYgPSBqUXVlcnkoIHRoaXMgKTtcblx0XHRcdFx0Y2xhc3NOYW1lcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0XHRcdHdoaWxlICggKCBjbGFzc05hbWUgPSBjbGFzc05hbWVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdFx0Ly8gQ2hlY2sgZWFjaCBjbGFzc05hbWUgZ2l2ZW4sIHNwYWNlIHNlcGFyYXRlZCBsaXN0XG5cdFx0XHRcdFx0aWYgKCBzZWxmLmhhc0NsYXNzKCBjbGFzc05hbWUgKSApIHtcblx0XHRcdFx0XHRcdHNlbGYucmVtb3ZlQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZWxmLmFkZENsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gVG9nZ2xlIHdob2xlIGNsYXNzIG5hbWVcblx0XHRcdH0gZWxzZSBpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRcdGNsYXNzTmFtZSA9IGdldENsYXNzKCB0aGlzICk7XG5cdFx0XHRcdGlmICggY2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0Ly8gU3RvcmUgY2xhc3NOYW1lIGlmIHNldFxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIsIGNsYXNzTmFtZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGVsZW1lbnQgaGFzIGEgY2xhc3MgbmFtZSBvciBpZiB3ZSdyZSBwYXNzZWQgYGZhbHNlYCxcblx0XHRcdFx0Ly8gdGhlbiByZW1vdmUgdGhlIHdob2xlIGNsYXNzbmFtZSAoaWYgdGhlcmUgd2FzIG9uZSwgdGhlIGFib3ZlIHNhdmVkIGl0KS5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGJyaW5nIGJhY2sgd2hhdGV2ZXIgd2FzIHByZXZpb3VzbHkgc2F2ZWQgKGlmIGFueXRoaW5nKSxcblx0XHRcdFx0Ly8gZmFsbGluZyBiYWNrIHRvIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuXHRcdFx0XHRpZiAoIHRoaXMuc2V0QXR0cmlidXRlICkge1xuXHRcdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsXG5cdFx0XHRcdFx0XHRjbGFzc05hbWUgfHwgdmFsdWUgPT09IGZhbHNlID9cblx0XHRcdFx0XHRcdFwiXCIgOlxuXHRcdFx0XHRcdFx0ZGF0YVByaXYuZ2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiApIHx8IFwiXCJcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGhhc0NsYXNzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSwgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Y2xhc3NOYW1lID0gXCIgXCIgKyBzZWxlY3RvciArIFwiIFwiO1xuXHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggZ2V0Q2xhc3MoIGVsZW0gKSApICsgXCIgXCIgKS5pbmRleE9mKCBjbGFzc05hbWUgKSA+IC0xICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgcnJldHVybiA9IC9cXHIvZztcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR2YWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgaG9va3MsIHJldCwgdmFsdWVJc0Z1bmN0aW9uLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fFxuXHRcdFx0XHRcdGpRdWVyeS52YWxIb29rc1sgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdFx0aWYgKCBob29rcyAmJlxuXHRcdFx0XHRcdFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgXCJ2YWx1ZVwiICkgKSAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXQgPSBlbGVtLnZhbHVlO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcblx0XHRcdFx0aWYgKCB0eXBlb2YgcmV0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRcdHJldHVybiByZXQucmVwbGFjZSggcnJldHVybiwgXCJcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSGFuZGxlIGNhc2VzIHdoZXJlIHZhbHVlIGlzIG51bGwvdW5kZWYgb3IgbnVtYmVyXG5cdFx0XHRcdHJldHVybiByZXQgPT0gbnVsbCA/IFwiXCIgOiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHR2YXIgdmFsO1xuXG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlLmNhbGwoIHRoaXMsIGksIGpRdWVyeSggdGhpcyApLnZhbCgpICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVHJlYXQgbnVsbC91bmRlZmluZWQgYXMgXCJcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dmFsID0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsICs9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHR2YWwgPSBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCI7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIHRoaXMudHlwZSBdIHx8IGpRdWVyeS52YWxIb29rc1sgdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdC8vIElmIHNldCByZXR1cm5zIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG5vcm1hbCBzZXR0aW5nXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHwgaG9va3Muc2V0KCB0aGlzLCB2YWwsIFwidmFsdWVcIiApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0dmFsSG9va3M6IHtcblx0XHRvcHRpb246IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0dmFyIHZhbCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidmFsdWVcIiApO1xuXHRcdFx0XHRyZXR1cm4gdmFsICE9IG51bGwgP1xuXHRcdFx0XHRcdHZhbCA6XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEgb25seVxuXHRcdFx0XHRcdC8vIG9wdGlvbi50ZXh0IHRocm93cyBleGNlcHRpb25zICgjMTQ2ODYsICMxNDg1OClcblx0XHRcdFx0XHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZVxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS13aGl0ZXNwYWNlXG5cdFx0XHRcdFx0c3RyaXBBbmRDb2xsYXBzZSggalF1ZXJ5LnRleHQoIGVsZW0gKSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2VsZWN0OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIG9wdGlvbiwgaSxcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxuXHRcdFx0XHRcdG9uZSA9IGVsZW0udHlwZSA9PT0gXCJzZWxlY3Qtb25lXCIsXG5cdFx0XHRcdFx0dmFsdWVzID0gb25lID8gbnVsbCA6IFtdLFxuXHRcdFx0XHRcdG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdGlmICggaW5kZXggPCAwICkge1xuXHRcdFx0XHRcdGkgPSBtYXg7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpID0gb25lID8gaW5kZXggOiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBtYXg7IGkrKyApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdC8vIElFOC05IGRvZXNuJ3QgdXBkYXRlIHNlbGVjdGVkIGFmdGVyIGZvcm0gcmVzZXQgKCMyNTUxKVxuXHRcdFx0XHRcdGlmICggKCBvcHRpb24uc2VsZWN0ZWQgfHwgaSA9PT0gaW5kZXggKSAmJlxuXG5cdFx0XHRcdFx0XHRcdC8vIERvbid0IHJldHVybiBvcHRpb25zIHRoYXQgYXJlIGRpc2FibGVkIG9yIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdFx0XHRcdFx0IW9wdGlvbi5kaXNhYmxlZCAmJlxuXHRcdFx0XHRcdFx0XHQoICFvcHRpb24ucGFyZW50Tm9kZS5kaXNhYmxlZCB8fFxuXHRcdFx0XHRcdFx0XHRcdCFub2RlTmFtZSggb3B0aW9uLnBhcmVudE5vZGUsIFwib3B0Z3JvdXBcIiApICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb25cblx0XHRcdFx0XHRcdHZhbHVlID0galF1ZXJ5KCBvcHRpb24gKS52YWwoKTtcblxuXHRcdFx0XHRcdFx0Ly8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHNcblx0XHRcdFx0XHRcdGlmICggb25lICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE11bHRpLVNlbGVjdHMgcmV0dXJuIGFuIGFycmF5XG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBvcHRpb25TZXQsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdHZhbHVlcyA9IGpRdWVyeS5tYWtlQXJyYXkoIHZhbHVlICksXG5cdFx0XHRcdFx0aSA9IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG5cblx0XHRcdFx0XHRpZiAoIG9wdGlvbi5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggalF1ZXJ5LnZhbEhvb2tzLm9wdGlvbi5nZXQoIG9wdGlvbiApLCB2YWx1ZXMgKSA+IC0xXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRvcHRpb25TZXQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZvcmNlIGJyb3dzZXJzIHRvIGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBub24tbWF0Y2hpbmcgdmFsdWUgaXMgc2V0XG5cdFx0XHRcdGlmICggIW9wdGlvblNldCApIHtcblx0XHRcdFx0XHRlbGVtLnNlbGVjdGVkSW5kZXggPSAtMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxualF1ZXJ5LmVhY2goIFsgXCJyYWRpb1wiLCBcImNoZWNrYm94XCIgXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdID0ge1xuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLmNoZWNrZWQgPSBqUXVlcnkuaW5BcnJheSggalF1ZXJ5KCBlbGVtICkudmFsKCksIHZhbHVlICkgPiAtMSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0aWYgKCAhc3VwcG9ydC5jaGVja09uICkge1xuXHRcdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdLmdldCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gbnVsbCA/IFwib25cIiA6IGVsZW0udmFsdWU7XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBSZXR1cm4galF1ZXJ5IGZvciBhdHRyaWJ1dGVzLW9ubHkgaW5jbHVzaW9uXG5cblxuc3VwcG9ydC5mb2N1c2luID0gXCJvbmZvY3VzaW5cIiBpbiB3aW5kb3c7XG5cblxudmFyIHJmb2N1c01vcnBoID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvLFxuXHRzdG9wUHJvcGFnYXRpb25DYWxsYmFjayA9IGZ1bmN0aW9uKCBlICkge1xuXHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH07XG5cbmpRdWVyeS5leHRlbmQoIGpRdWVyeS5ldmVudCwge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCBldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzICkge1xuXG5cdFx0dmFyIGksIGN1ciwgdG1wLCBidWJibGVUeXBlLCBvbnR5cGUsIGhhbmRsZSwgc3BlY2lhbCwgbGFzdEVsZW1lbnQsXG5cdFx0XHRldmVudFBhdGggPSBbIGVsZW0gfHwgZG9jdW1lbnQgXSxcblx0XHRcdHR5cGUgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwidHlwZVwiICkgPyBldmVudC50eXBlIDogZXZlbnQsXG5cdFx0XHRuYW1lc3BhY2VzID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcIm5hbWVzcGFjZVwiICkgPyBldmVudC5uYW1lc3BhY2Uuc3BsaXQoIFwiLlwiICkgOiBbXTtcblxuXHRcdGN1ciA9IGxhc3RFbGVtZW50ID0gdG1wID0gZWxlbSA9IGVsZW0gfHwgZG9jdW1lbnQ7XG5cblx0XHQvLyBEb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xuXHRcdGlmICggcmZvY3VzTW9ycGgudGVzdCggdHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGUuaW5kZXhPZiggXCIuXCIgKSA+IC0xICkge1xuXG5cdFx0XHQvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXG5cdFx0XHRuYW1lc3BhY2VzID0gdHlwZS5zcGxpdCggXCIuXCIgKTtcblx0XHRcdHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XG5cdFx0XHRuYW1lc3BhY2VzLnNvcnQoKTtcblx0XHR9XG5cdFx0b250eXBlID0gdHlwZS5pbmRleE9mKCBcIjpcIiApIDwgMCAmJiBcIm9uXCIgKyB0eXBlO1xuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXG5cdFx0ZXZlbnQgPSBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRldmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgZXZlbnQgKTtcblxuXHRcdC8vIFRyaWdnZXIgYml0bWFzazogJiAxIGZvciBuYXRpdmUgaGFuZGxlcnM7ICYgMiBmb3IgalF1ZXJ5IChhbHdheXMgdHJ1ZSlcblx0XHRldmVudC5pc1RyaWdnZXIgPSBvbmx5SGFuZGxlcnMgPyAyIDogMztcblx0XHRldmVudC5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiICk7XG5cdFx0ZXZlbnQucm5hbWVzcGFjZSA9IGV2ZW50Lm5hbWVzcGFjZSA/XG5cdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKSA6XG5cdFx0XHRudWxsO1xuXG5cdFx0Ly8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXG5cdFx0ZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGVsZW07XG5cdFx0fVxuXG5cdFx0Ly8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxuXHRcdGRhdGEgPSBkYXRhID09IG51bGwgP1xuXHRcdFx0WyBldmVudCBdIDpcblx0XHRcdGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEsIFsgZXZlbnQgXSApO1xuXG5cdFx0Ly8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xuXHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiBzcGVjaWFsLnRyaWdnZXIgJiYgc3BlY2lhbC50cmlnZ2VyLmFwcGx5KCBlbGVtLCBkYXRhICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKCM5OTUxKVxuXHRcdC8vIEJ1YmJsZSB1cCB0byBkb2N1bWVudCwgdGhlbiB0byB3aW5kb3c7IHdhdGNoIGZvciBhIGdsb2JhbCBvd25lckRvY3VtZW50IHZhciAoIzk3MjQpXG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRidWJibGVUeXBlID0gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgfHwgdHlwZTtcblx0XHRcdGlmICggIXJmb2N1c01vcnBoLnRlc3QoIGJ1YmJsZVR5cGUgKyB0eXBlICkgKSB7XG5cdFx0XHRcdGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICggOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggY3VyICk7XG5cdFx0XHRcdHRtcCA9IGN1cjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT25seSBhZGQgd2luZG93IGlmIHdlIGdvdCB0byBkb2N1bWVudCAoZS5nLiwgbm90IHBsYWluIG9iaiBvciBkZXRhY2hlZCBET00pXG5cdFx0XHRpZiAoIHRtcCA9PT0gKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQgKSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIHRtcC5kZWZhdWx0VmlldyB8fCB0bXAucGFyZW50V2luZG93IHx8IHdpbmRvdyApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZpcmUgaGFuZGxlcnMgb24gdGhlIGV2ZW50IHBhdGhcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggY3VyID0gZXZlbnRQYXRoWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0bGFzdEVsZW1lbnQgPSBjdXI7XG5cdFx0XHRldmVudC50eXBlID0gaSA+IDEgP1xuXHRcdFx0XHRidWJibGVUeXBlIDpcblx0XHRcdFx0c3BlY2lhbC5iaW5kVHlwZSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBqUXVlcnkgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gKCBkYXRhUHJpdi5nZXQoIGN1ciwgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSAmJlxuXHRcdFx0XHRkYXRhUHJpdi5nZXQoIGN1ciwgXCJoYW5kbGVcIiApO1xuXHRcdFx0aWYgKCBoYW5kbGUgKSB7XG5cdFx0XHRcdGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5hdGl2ZSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSBvbnR5cGUgJiYgY3VyWyBvbnR5cGUgXTtcblx0XHRcdGlmICggaGFuZGxlICYmIGhhbmRsZS5hcHBseSAmJiBhY2NlcHREYXRhKCBjdXIgKSApIHtcblx0XHRcdFx0ZXZlbnQucmVzdWx0ID0gaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZXZlbnQudHlwZSA9IHR5cGU7XG5cblx0XHQvLyBJZiBub2JvZHkgcHJldmVudGVkIHRoZSBkZWZhdWx0IGFjdGlvbiwgZG8gaXQgbm93XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblxuXHRcdFx0aWYgKCAoICFzcGVjaWFsLl9kZWZhdWx0IHx8XG5cdFx0XHRcdHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoIGV2ZW50UGF0aC5wb3AoKSwgZGF0YSApID09PSBmYWxzZSApICYmXG5cdFx0XHRcdGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblxuXHRcdFx0XHQvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuXHRcdFx0XHQvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXG5cdFx0XHRcdGlmICggb250eXBlICYmIGlzRnVuY3Rpb24oIGVsZW1bIHR5cGUgXSApICYmICFpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgcmUtdHJpZ2dlciBhbiBvbkZPTyBldmVudCB3aGVuIHdlIGNhbGwgaXRzIEZPTygpIG1ldGhvZFxuXHRcdFx0XHRcdHRtcCA9IGVsZW1bIG9udHlwZSBdO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJldmVudCByZS10cmlnZ2VyaW5nIG9mIHRoZSBzYW1lIGV2ZW50LCBzaW5jZSB3ZSBhbHJlYWR5IGJ1YmJsZWQgaXQgYWJvdmVcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdHlwZTtcblxuXHRcdFx0XHRcdGlmICggZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdFx0XHRcdGxhc3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbVsgdHlwZSBdKCk7XG5cblx0XHRcdFx0XHRpZiAoIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRcdFx0XHRsYXN0RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gdG1wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0Ly8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lXG5cdC8vIFVzZWQgb25seSBmb3IgYGZvY3VzKGluIHwgb3V0KWAgZXZlbnRzXG5cdHNpbXVsYXRlOiBmdW5jdGlvbiggdHlwZSwgZWxlbSwgZXZlbnQgKSB7XG5cdFx0dmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCgpLFxuXHRcdFx0ZXZlbnQsXG5cdFx0XHR7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdGlzU2ltdWxhdGVkOiB0cnVlXG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBlLCBudWxsLCBlbGVtICk7XG5cdH1cblxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgdGhpcyApO1xuXHRcdH0gKTtcblx0fSxcblx0dHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBlbGVtID0gdGhpc1sgMCBdO1xuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgZWxlbSwgdHJ1ZSApO1xuXHRcdH1cblx0fVxufSApO1xuXG5cbi8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00NFxuLy8gRmlyZWZveCBkb2Vzbid0IGhhdmUgZm9jdXMoaW4gfCBvdXQpIGV2ZW50c1xuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02ODc3ODdcbi8vXG4vLyBTdXBwb3J0OiBDaHJvbWUgPD00OCAtIDQ5LCBTYWZhcmkgPD05LjAgLSA5LjFcbi8vIGZvY3VzKGluIHwgb3V0KSBldmVudHMgZmlyZSBhZnRlciBmb2N1cyAmIGJsdXIgZXZlbnRzLFxuLy8gd2hpY2ggaXMgc3BlYyB2aW9sYXRpb24gLSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1mb2N1c2V2ZW50LWV2ZW50LW9yZGVyXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0OTg1N1xuaWYgKCAhc3VwcG9ydC5mb2N1c2luICkge1xuXHRqUXVlcnkuZWFjaCggeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXG5cdFx0Ly8gQXR0YWNoIGEgc2luZ2xlIGNhcHR1cmluZyBoYW5kbGVyIG9uIHRoZSBkb2N1bWVudCB3aGlsZSBzb21lb25lIHdhbnRzIGZvY3VzaW4vZm9jdXNvdXRcblx0XHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggZml4LCBldmVudC50YXJnZXQsIGpRdWVyeS5ldmVudC5maXgoIGV2ZW50ICkgKTtcblx0XHR9O1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGZpeCBdID0ge1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLmFkZEV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCAoIGF0dGFjaGVzIHx8IDAgKSArIDEgKTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKSAtIDE7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCBhdHRhY2hlcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSApO1xufVxudmFyIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuXG52YXIgbm9uY2UgPSBEYXRlLm5vdygpO1xuXG52YXIgcnF1ZXJ5ID0gKCAvXFw/LyApO1xuXG5cblxuLy8gQ3Jvc3MtYnJvd3NlciB4bWwgcGFyc2luZ1xualF1ZXJ5LnBhcnNlWE1MID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdHZhciB4bWw7XG5cdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHQvLyBJRSB0aHJvd3Mgb24gcGFyc2VGcm9tU3RyaW5nIHdpdGggaW52YWxpZCBpbnB1dC5cblx0dHJ5IHtcblx0XHR4bWwgPSAoIG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkgKS5wYXJzZUZyb21TdHJpbmcoIGRhdGEsIFwidGV4dC94bWxcIiApO1xuXHR9IGNhdGNoICggZSApIHtcblx0XHR4bWwgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHRpZiAoICF4bWwgfHwgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInBhcnNlcmVycm9yXCIgKS5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmVycm9yKCBcIkludmFsaWQgWE1MOiBcIiArIGRhdGEgKTtcblx0fVxuXHRyZXR1cm4geG1sO1xufTtcblxuXG52YXJcblx0cmJyYWNrZXQgPSAvXFxbXFxdJC8sXG5cdHJDUkxGID0gL1xccj9cXG4vZyxcblx0cnN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLFxuXHRyc3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XG5cbmZ1bmN0aW9uIGJ1aWxkUGFyYW1zKCBwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCApIHtcblx0dmFyIG5hbWU7XG5cblx0aWYgKCBBcnJheS5pc0FycmF5KCBvYmogKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxuXHRcdGpRdWVyeS5lYWNoKCBvYmosIGZ1bmN0aW9uKCBpLCB2ICkge1xuXHRcdFx0aWYgKCB0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KCBwcmVmaXggKSApIHtcblxuXHRcdFx0XHQvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXG5cdFx0XHRcdGFkZCggcHJlZml4LCB2ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gSXRlbSBpcyBub24tc2NhbGFyIChhcnJheSBvciBvYmplY3QpLCBlbmNvZGUgaXRzIG51bWVyaWMgaW5kZXguXG5cdFx0XHRcdGJ1aWxkUGFyYW1zKFxuXHRcdFx0XHRcdHByZWZpeCArIFwiW1wiICsgKCB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2ICE9IG51bGwgPyBpIDogXCJcIiApICsgXCJdXCIsXG5cdFx0XHRcdFx0dixcblx0XHRcdFx0XHR0cmFkaXRpb25hbCxcblx0XHRcdFx0XHRhZGRcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0fSBlbHNlIGlmICggIXRyYWRpdGlvbmFsICYmIHRvVHlwZSggb2JqICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4ICsgXCJbXCIgKyBuYW1lICsgXCJdXCIsIG9ialsgbmFtZSBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBTZXJpYWxpemUgc2NhbGFyIGl0ZW0uXG5cdFx0YWRkKCBwcmVmaXgsIG9iaiApO1xuXHR9XG59XG5cbi8vIFNlcmlhbGl6ZSBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzIG9yIGEgc2V0IG9mXG4vLyBrZXkvdmFsdWVzIGludG8gYSBxdWVyeSBzdHJpbmdcbmpRdWVyeS5wYXJhbSA9IGZ1bmN0aW9uKCBhLCB0cmFkaXRpb25hbCApIHtcblx0dmFyIHByZWZpeCxcblx0XHRzID0gW10sXG5cdFx0YWRkID0gZnVuY3Rpb24oIGtleSwgdmFsdWVPckZ1bmN0aW9uICkge1xuXG5cdFx0XHQvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHVzZSBpdHMgcmV0dXJuIHZhbHVlXG5cdFx0XHR2YXIgdmFsdWUgPSBpc0Z1bmN0aW9uKCB2YWx1ZU9yRnVuY3Rpb24gKSA/XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbigpIDpcblx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uO1xuXG5cdFx0XHRzWyBzLmxlbmd0aCBdID0gZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArIFwiPVwiICtcblx0XHRcdFx0ZW5jb2RlVVJJQ29tcG9uZW50KCB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICk7XG5cdFx0fTtcblxuXHQvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIGEgKSB8fCAoIGEuanF1ZXJ5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggYSApICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcblx0XHRqUXVlcnkuZWFjaCggYSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRhZGQoIHRoaXMubmFtZSwgdGhpcy52YWx1ZSApO1xuXHRcdH0gKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcblx0XHQvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cblx0XHRmb3IgKCBwcmVmaXggaW4gYSApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXgsIGFbIHByZWZpeCBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxuXHRyZXR1cm4gcy5qb2luKCBcIiZcIiApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnkucGFyYW0oIHRoaXMuc2VyaWFsaXplQXJyYXkoKSApO1xuXHR9LFxuXHRzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gQ2FuIGFkZCBwcm9wSG9vayBmb3IgXCJlbGVtZW50c1wiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xuXHRcdFx0dmFyIGVsZW1lbnRzID0galF1ZXJ5LnByb3AoIHRoaXMsIFwiZWxlbWVudHNcIiApO1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheSggZWxlbWVudHMgKSA6IHRoaXM7XG5cdFx0fSApXG5cdFx0LmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdFx0Ly8gVXNlIC5pcyggXCI6ZGlzYWJsZWRcIiApIHNvIHRoYXQgZmllbGRzZXRbZGlzYWJsZWRdIHdvcmtzXG5cdFx0XHRyZXR1cm4gdGhpcy5uYW1lICYmICFqUXVlcnkoIHRoaXMgKS5pcyggXCI6ZGlzYWJsZWRcIiApICYmXG5cdFx0XHRcdHJzdWJtaXR0YWJsZS50ZXN0KCB0aGlzLm5vZGVOYW1lICkgJiYgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KCB0eXBlICkgJiZcblx0XHRcdFx0KCB0aGlzLmNoZWNrZWQgfHwgIXJjaGVja2FibGVUeXBlLnRlc3QoIHR5cGUgKSApO1xuXHRcdH0gKVxuXHRcdC5tYXAoIGZ1bmN0aW9uKCBpLCBlbGVtICkge1xuXHRcdFx0dmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xuXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbCApIHtcblx0XHRcdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0fSApLmdldCgpO1xuXHR9XG59ICk7XG5cblxudmFyXG5cdHIyMCA9IC8lMjAvZyxcblx0cmhhc2ggPSAvIy4qJC8sXG5cdHJhbnRpQ2FjaGUgPSAvKFs/Jl0pXz1bXiZdKi8sXG5cdHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopJC9tZyxcblxuXHQvLyAjNzY1MywgIzgxMjUsICM4MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cblx0cmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcblx0cm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG5cdHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcblxuXHQvKiBQcmVmaWx0ZXJzXG5cdCAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG5cdCAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XG5cdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcblx0ICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuXHQgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHByZWZpbHRlcnMgPSB7fSxcblxuXHQvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG5cdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHRyYW5zcG9ydHMgPSB7fSxcblxuXHQvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cblx0YWxsVHlwZXMgPSBcIiovXCIuY29uY2F0KCBcIipcIiApLFxuXG5cdC8vIEFuY2hvciB0YWcgZm9yIHBhcnNpbmcgdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvcmlnaW5BbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXHRvcmlnaW5BbmNob3IuaHJlZiA9IGxvY2F0aW9uLmhyZWY7XG5cbi8vIEJhc2UgXCJjb25zdHJ1Y3RvclwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcbmZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlICkge1xuXG5cdC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXCIqXCJcblx0cmV0dXJuIGZ1bmN0aW9uKCBkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMgKSB7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xuXHRcdFx0ZGF0YVR5cGVFeHByZXNzaW9uID0gXCIqXCI7XG5cdFx0fVxuXG5cdFx0dmFyIGRhdGFUeXBlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRkYXRhVHlwZXMgPSBkYXRhVHlwZUV4cHJlc3Npb24udG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBmdW5jICkgKSB7XG5cblx0XHRcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cblx0XHRcdHdoaWxlICggKCBkYXRhVHlwZSA9IGRhdGFUeXBlc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHQvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxuXHRcdFx0XHRpZiAoIGRhdGFUeXBlWyAwIF0gPT09IFwiK1wiICkge1xuXHRcdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnVuc2hpZnQoIGZ1bmMgKTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYXBwZW5kXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS5wdXNoKCBmdW5jICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuXHR2YXIgaW5zcGVjdGVkID0ge30sXG5cdFx0c2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XG5cblx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XG5cdFx0dmFyIHNlbGVjdGVkO1xuXHRcdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG5cdFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcblx0XHRcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblxuXHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcblx0XHRcdFx0cmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gc2VsZWN0ZWQ7XG5cdH1cblxuXHRyZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbn1cblxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuLy8gRml4ZXMgIzk4ODdcbmZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuXHR2YXIga2V5LCBkZWVwLFxuXHRcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuXHRmb3IgKCBrZXkgaW4gc3JjICkge1xuXHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0KCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKCBkZWVwID0ge30gKSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcblx0XHR9XG5cdH1cblx0aWYgKCBkZWVwICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXG5cdHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcblx0XHRjb250ZW50cyA9IHMuY29udGVudHMsXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XG5cblx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3Ncblx0d2hpbGUgKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XG5cdFx0ZGF0YVR5cGVzLnNoaWZ0KCk7XG5cdFx0aWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXG5cdGlmICggY3QgKSB7XG5cdFx0Zm9yICggdHlwZSBpbiBjb250ZW50cyApIHtcblx0XHRcdGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XG5cdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0eXBlICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuXHRpZiAoIGRhdGFUeXBlc1sgMCBdIGluIHJlc3BvbnNlcyApIHtcblx0XHRmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWyAwIF07XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXG5cdFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1sgMCBdIF0gKSB7XG5cdFx0XHRcdGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XG5cdFx0XHRcdGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxuXHRcdGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XG5cdH1cblxuXHQvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXG5cdC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXG5cdC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2Vcblx0aWYgKCBmaW5hbERhdGFUeXBlICkge1xuXHRcdGlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7XG5cdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggZmluYWxEYXRhVHlwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XG5cdH1cbn1cblxuLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxuICogQWxzbyBzZXRzIHRoZSByZXNwb25zZVhYWCBmaWVsZHMgb24gdGhlIGpxWEhSIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHtcblx0dmFyIGNvbnYyLCBjdXJyZW50LCBjb252LCB0bXAsIHByZXYsXG5cdFx0Y29udmVydGVycyA9IHt9LFxuXG5cdFx0Ly8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XG5cblx0Ly8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG5cdGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XG5cdFx0Zm9yICggY29udiBpbiBzLmNvbnZlcnRlcnMgKSB7XG5cdFx0XHRjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xuXHRcdH1cblx0fVxuXG5cdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHQvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuXHR3aGlsZSAoIGN1cnJlbnQgKSB7XG5cblx0XHRpZiAoIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSApIHtcblx0XHRcdGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG5cdFx0aWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xuXHRcdFx0cmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XG5cdFx0fVxuXG5cdFx0cHJldiA9IGN1cnJlbnQ7XG5cdFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdFx0aWYgKCBjdXJyZW50ICkge1xuXG5cdFx0XHQvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXG5cdFx0XHRpZiAoIGN1cnJlbnQgPT09IFwiKlwiICkge1xuXG5cdFx0XHRcdGN1cnJlbnQgPSBwcmV2O1xuXG5cdFx0XHQvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XG5cdFx0XHR9IGVsc2UgaWYgKCBwcmV2ICE9PSBcIipcIiAmJiBwcmV2ICE9PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdC8vIFNlZWsgYSBkaXJlY3QgY29udmVydGVyXG5cdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyBjdXJyZW50IF0gfHwgY29udmVydGVyc1sgXCIqIFwiICsgY3VycmVudCBdO1xuXG5cdFx0XHRcdC8vIElmIG5vbmUgZm91bmQsIHNlZWsgYSBwYWlyXG5cdFx0XHRcdGlmICggIWNvbnYgKSB7XG5cdFx0XHRcdFx0Zm9yICggY29udjIgaW4gY29udmVydGVycyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgY29udjIgb3V0cHV0cyBjdXJyZW50XG5cdFx0XHRcdFx0XHR0bXAgPSBjb252Mi5zcGxpdCggXCIgXCIgKTtcblx0XHRcdFx0XHRcdGlmICggdG1wWyAxIF0gPT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gSWYgcHJldiBjYW4gYmUgY29udmVydGVkIHRvIGFjY2VwdGVkIGlucHV0XG5cdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyB0bXBbIDAgXSBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1sgXCIqIFwiICsgdG1wWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0aWYgKCBjb252ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVyc1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY29udiA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBjb252MiBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnZlcnRlcnNbIGNvbnYyIF0gIT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gdG1wWyAwIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdG1wWyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcblx0XHRcdFx0aWYgKCBjb252ICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Ly8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxuXHRcdFx0XHRcdGlmICggY29udiAmJiBzLnRocm93cyApIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGU6IFwicGFyc2VyZXJyb3JcIixcblx0XHRcdFx0XHRcdFx0XHRlcnJvcjogY29udiA/IGUgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIHByZXYgKyBcIiB0byBcIiArIGN1cnJlbnRcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHJlc3BvbnNlIH07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcblx0YWN0aXZlOiAwLFxuXG5cdC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3Rcblx0bGFzdE1vZGlmaWVkOiB7fSxcblx0ZXRhZzoge30sXG5cblx0YWpheFNldHRpbmdzOiB7XG5cdFx0dXJsOiBsb2NhdGlvbi5ocmVmLFxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0aXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggbG9jYXRpb24ucHJvdG9jb2wgKSxcblx0XHRnbG9iYWw6IHRydWUsXG5cdFx0cHJvY2Vzc0RhdGE6IHRydWUsXG5cdFx0YXN5bmM6IHRydWUsXG5cdFx0Y29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsXG5cblx0XHQvKlxuXHRcdHRpbWVvdXQ6IDAsXG5cdFx0ZGF0YTogbnVsbCxcblx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRwYXNzd29yZDogbnVsbCxcblx0XHRjYWNoZTogbnVsbCxcblx0XHR0aHJvd3M6IGZhbHNlLFxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcblx0XHRoZWFkZXJzOiB7fSxcblx0XHQqL1xuXG5cdFx0YWNjZXB0czoge1xuXHRcdFx0XCIqXCI6IGFsbFR5cGVzLFxuXHRcdFx0dGV4dDogXCJ0ZXh0L3BsYWluXCIsXG5cdFx0XHRodG1sOiBcInRleHQvaHRtbFwiLFxuXHRcdFx0eG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcblx0XHRcdGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJcblx0XHR9LFxuXG5cdFx0Y29udGVudHM6IHtcblx0XHRcdHhtbDogL1xcYnhtbFxcYi8sXG5cdFx0XHRodG1sOiAvXFxiaHRtbC8sXG5cdFx0XHRqc29uOiAvXFxianNvblxcYi9cblx0XHR9LFxuXG5cdFx0cmVzcG9uc2VGaWVsZHM6IHtcblx0XHRcdHhtbDogXCJyZXNwb25zZVhNTFwiLFxuXHRcdFx0dGV4dDogXCJyZXNwb25zZVRleHRcIixcblx0XHRcdGpzb246IFwicmVzcG9uc2VKU09OXCJcblx0XHR9LFxuXG5cdFx0Ly8gRGF0YSBjb252ZXJ0ZXJzXG5cdFx0Ly8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFwiKlwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuXHRcdGNvbnZlcnRlcnM6IHtcblxuXHRcdFx0Ly8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG5cdFx0XHRcIiogdGV4dFwiOiBTdHJpbmcsXG5cblx0XHRcdC8vIFRleHQgdG8gaHRtbCAodHJ1ZSA9IG5vIHRyYW5zZm9ybWF0aW9uKVxuXHRcdFx0XCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcblxuXHRcdFx0Ly8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxuXHRcdFx0XCJ0ZXh0IGpzb25cIjogSlNPTi5wYXJzZSxcblxuXHRcdFx0Ly8gUGFyc2UgdGV4dCBhcyB4bWxcblx0XHRcdFwidGV4dCB4bWxcIjogalF1ZXJ5LnBhcnNlWE1MXG5cdFx0fSxcblxuXHRcdC8vIEZvciBvcHRpb25zIHRoYXQgc2hvdWxkbid0IGJlIGRlZXAgZXh0ZW5kZWQ6XG5cdFx0Ly8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxuXHRcdC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG5cdFx0Ly8gZGVlcCBleHRlbmRlZCAoc2VlIGFqYXhFeHRlbmQpXG5cdFx0ZmxhdE9wdGlvbnM6IHtcblx0XHRcdHVybDogdHJ1ZSxcblx0XHRcdGNvbnRleHQ6IHRydWVcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcblx0Ly8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuXHQvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxuXHRhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xuXHRcdHJldHVybiBzZXR0aW5ncyA/XG5cblx0XHRcdC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0XHRhamF4RXh0ZW5kKCBhamF4RXh0ZW5kKCB0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MgKSwgc2V0dGluZ3MgKSA6XG5cblx0XHRcdC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3Ncblx0XHRcdGFqYXhFeHRlbmQoIGpRdWVyeS5hamF4U2V0dGluZ3MsIHRhcmdldCApO1xuXHR9LFxuXG5cdGFqYXhQcmVmaWx0ZXI6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycyApLFxuXHRhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSxcblxuXHQvLyBNYWluIG1ldGhvZFxuXHRhamF4OiBmdW5jdGlvbiggdXJsLCBvcHRpb25zICkge1xuXG5cdFx0Ly8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcblx0XHRpZiAoIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRvcHRpb25zID0gdXJsO1xuXHRcdFx0dXJsID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXIgdHJhbnNwb3J0LFxuXG5cdFx0XHQvLyBVUkwgd2l0aG91dCBhbnRpLWNhY2hlIHBhcmFtXG5cdFx0XHRjYWNoZVVSTCxcblxuXHRcdFx0Ly8gUmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxuXHRcdFx0cmVzcG9uc2VIZWFkZXJzLFxuXG5cdFx0XHQvLyB0aW1lb3V0IGhhbmRsZVxuXHRcdFx0dGltZW91dFRpbWVyLFxuXG5cdFx0XHQvLyBVcmwgY2xlYW51cCB2YXJcblx0XHRcdHVybEFuY2hvcixcblxuXHRcdFx0Ly8gUmVxdWVzdCBzdGF0ZSAoYmVjb21lcyBmYWxzZSB1cG9uIHNlbmQgYW5kIHRydWUgdXBvbiBjb21wbGV0aW9uKVxuXHRcdFx0Y29tcGxldGVkLFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcblx0XHRcdGZpcmVHbG9iYWxzLFxuXG5cdFx0XHQvLyBMb29wIHZhcmlhYmxlXG5cdFx0XHRpLFxuXG5cdFx0XHQvLyB1bmNhY2hlZCBwYXJ0IG9mIHRoZSB1cmxcblx0XHRcdHVuY2FjaGVkLFxuXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XG5cdFx0XHRzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcblxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcblx0XHRcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXG5cdFx0XHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcblx0XHRcdFx0KCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cblx0XHRcdFx0XHRqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDpcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQsXG5cblx0XHRcdC8vIERlZmVycmVkc1xuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG5cblx0XHRcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG5cdFx0XHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxuXHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuXG5cdFx0XHQvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2Vcblx0XHRcdHN0ckFib3J0ID0gXCJjYW5jZWxlZFwiLFxuXG5cdFx0XHQvLyBGYWtlIHhoclxuXHRcdFx0anFYSFIgPSB7XG5cdFx0XHRcdHJlYWR5U3RhdGU6IDAsXG5cblx0XHRcdFx0Ly8gQnVpbGRzIGhlYWRlcnMgaGFzaHRhYmxlIGlmIG5lZWRlZFxuXHRcdFx0XHRnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHR2YXIgbWF0Y2g7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpIF0gPSBtYXRjaFsgMiBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtYXRjaCA9IHJlc3BvbnNlSGVhZGVyc1sga2V5LnRvTG93ZXJDYXNlKCkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2g7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmF3IHN0cmluZ1xuXHRcdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBjb21wbGV0ZWQgPyByZXNwb25zZUhlYWRlcnNTdHJpbmcgOiBudWxsO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhY2hlcyB0aGUgaGVhZGVyXG5cdFx0XHRcdHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0bmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdID1cblx0XHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHwgbmFtZTtcblx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGVzIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBoZWFkZXJcblx0XHRcdFx0b3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdHMubWltZVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0XHRzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xuXHRcdFx0XHRcdHZhciBjb2RlO1xuXHRcdFx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXG5cdFx0XHRcdFx0XHRcdGpxWEhSLmFsd2F5cyggbWFwWyBqcVhIUi5zdGF0dXMgXSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBMYXp5LWFkZCB0aGUgbmV3IGNhbGxiYWNrcyBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuXHRcdFx0XHRcdFx0XHRmb3IgKCBjb2RlIGluIG1hcCApIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0dXNDb2RlWyBjb2RlIF0gPSBbIHN0YXR1c0NvZGVbIGNvZGUgXSwgbWFwWyBjb2RlIF0gXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYW5jZWwgdGhlIHJlcXVlc3Rcblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHZhciBmaW5hbFRleHQgPSBzdGF0dXNUZXh0IHx8IHN0ckFib3J0O1xuXHRcdFx0XHRcdGlmICggdHJhbnNwb3J0ICkge1xuXHRcdFx0XHRcdFx0dHJhbnNwb3J0LmFib3J0KCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZG9uZSggMCwgZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHQvLyBBdHRhY2ggZGVmZXJyZWRzXG5cdFx0ZGVmZXJyZWQucHJvbWlzZSgganFYSFIgKTtcblxuXHRcdC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKHByZWZpbHRlcnMgbWlnaHQgZXhwZWN0IGl0KVxuXHRcdC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAoIzEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXG5cdFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXG5cdFx0cy51cmwgPSAoICggdXJsIHx8IHMudXJsIHx8IGxvY2F0aW9uLmhyZWYgKSArIFwiXCIgKVxuXHRcdFx0LnJlcGxhY2UoIHJwcm90b2NvbCwgbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKTtcblxuXHRcdC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxuXHRcdHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cblx0XHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG5cdFx0cy5kYXRhVHlwZXMgPSAoIHMuZGF0YVR5cGUgfHwgXCIqXCIgKS50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cblx0XHQvLyBBIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyIHdoZW4gdGhlIG9yaWdpbiBkb2Vzbid0IG1hdGNoIHRoZSBjdXJyZW50IG9yaWdpbi5cblx0XHRpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcblx0XHRcdHVybEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExLCBFZGdlIDEyIC0gMTVcblx0XHRcdC8vIElFIHRocm93cyBleGNlcHRpb24gb24gYWNjZXNzaW5nIHRoZSBocmVmIHByb3BlcnR5IGlmIHVybCBpcyBtYWxmb3JtZWQsXG5cdFx0XHQvLyBlLmcuIGh0dHA6Ly9leGFtcGxlLmNvbTo4MHgvXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHMudXJsO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExIG9ubHlcblx0XHRcdFx0Ly8gQW5jaG9yJ3MgaG9zdCBwcm9wZXJ0eSBpc24ndCBjb3JyZWN0bHkgc2V0IHdoZW4gcy51cmwgaXMgcmVsYXRpdmVcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSB1cmxBbmNob3IuaHJlZjtcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IG9yaWdpbkFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIG9yaWdpbkFuY2hvci5ob3N0ICE9PVxuXHRcdFx0XHRcdHVybEFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIHVybEFuY2hvci5ob3N0O1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgYW4gZXJyb3IgcGFyc2luZyB0aGUgVVJMLCBhc3N1bWUgaXQgaXMgY3Jvc3NEb21haW4sXG5cdFx0XHRcdC8vIGl0IGNhbiBiZSByZWplY3RlZCBieSB0aGUgdHJhbnNwb3J0IGlmIGl0IGlzIGludmFsaWRcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cy5kYXRhID0galF1ZXJ5LnBhcmFtKCBzLmRhdGEsIHMudHJhZGl0aW9uYWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwcmVmaWx0ZXJzXG5cdFx0aW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxuXHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdH1cblxuXHRcdC8vIFdlIGNhbiBmaXJlIGdsb2JhbCBldmVudHMgYXMgb2Ygbm93IGlmIGFza2VkIHRvXG5cdFx0Ly8gRG9uJ3QgZmlyZSBldmVudHMgaWYgalF1ZXJ5LmV2ZW50IGlzIHVuZGVmaW5lZCBpbiBhbiBBTUQtdXNhZ2Ugc2NlbmFyaW8gKCMxNTExOClcblx0XHRmaXJlR2xvYmFscyA9IGpRdWVyeS5ldmVudCAmJiBzLmdsb2JhbDtcblxuXHRcdC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcblx0XHRpZiAoIGZpcmVHbG9iYWxzICYmIGpRdWVyeS5hY3RpdmUrKyA9PT0gMCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdGFydFwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gVXBwZXJjYXNlIHRoZSB0eXBlXG5cdFx0cy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XG5cblx0XHQvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuXHRcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xuXG5cdFx0Ly8gU2F2ZSB0aGUgVVJMIGluIGNhc2Ugd2UncmUgdG95aW5nIHdpdGggdGhlIElmLU1vZGlmaWVkLVNpbmNlXG5cdFx0Ly8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXG5cdFx0Ly8gUmVtb3ZlIGhhc2ggdG8gc2ltcGxpZnkgdXJsIG1hbmlwdWxhdGlvblxuXHRcdGNhY2hlVVJMID0gcy51cmwucmVwbGFjZSggcmhhc2gsIFwiXCIgKTtcblxuXHRcdC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XG5cdFx0aWYgKCAhcy5oYXNDb250ZW50ICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgaGFzaCBzbyB3ZSBjYW4gcHV0IGl0IGJhY2tcblx0XHRcdHVuY2FjaGVkID0gcy51cmwuc2xpY2UoIGNhY2hlVVJMLmxlbmd0aCApO1xuXG5cdFx0XHQvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSBhbmQgc2hvdWxkIGJlIHByb2Nlc3NlZCwgYXBwZW5kIGRhdGEgdG8gdXJsXG5cdFx0XHRpZiAoIHMuZGF0YSAmJiAoIHMucHJvY2Vzc0RhdGEgfHwgdHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiApICkge1xuXHRcdFx0XHRjYWNoZVVSTCArPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgcy5kYXRhO1xuXG5cdFx0XHRcdC8vICM5NjgyOiByZW1vdmUgZGF0YSBzbyB0aGF0IGl0J3Mgbm90IHVzZWQgaW4gYW4gZXZlbnR1YWwgcmV0cnlcblx0XHRcdFx0ZGVsZXRlIHMuZGF0YTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIG9yIHVwZGF0ZSBhbnRpLWNhY2hlIHBhcmFtIGlmIG5lZWRlZFxuXHRcdFx0aWYgKCBzLmNhY2hlID09PSBmYWxzZSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgPSBjYWNoZVVSTC5yZXBsYWNlKCByYW50aUNhY2hlLCBcIiQxXCIgKTtcblx0XHRcdFx0dW5jYWNoZWQgPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgXCJfPVwiICsgKCBub25jZSsrICkgKyB1bmNhY2hlZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUHV0IGhhc2ggYW5kIGFudGktY2FjaGUgb24gdGhlIFVSTCB0aGF0IHdpbGwgYmUgcmVxdWVzdGVkIChnaC0xNzMyKVxuXHRcdFx0cy51cmwgPSBjYWNoZVVSTCArIHVuY2FjaGVkO1xuXG5cdFx0Ly8gQ2hhbmdlICclMjAnIHRvICcrJyBpZiB0aGlzIGlzIGVuY29kZWQgZm9ybSBib2R5IGNvbnRlbnQgKGdoLTI2NTgpXG5cdFx0fSBlbHNlIGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiZcblx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiICkuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICkge1xuXHRcdFx0cy5kYXRhID0gcy5kYXRhLnJlcGxhY2UoIHIyMCwgXCIrXCIgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0aWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTm9uZS1NYXRjaFwiLCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuXHRcdGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcblx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxuXHRcdFx0XCJBY2NlcHRcIixcblx0XHRcdHMuZGF0YVR5cGVzWyAwIF0gJiYgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gP1xuXHRcdFx0XHRzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSArXG5cdFx0XHRcdFx0KCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIiApIDpcblx0XHRcdFx0cy5hY2NlcHRzWyBcIipcIiBdXG5cdFx0KTtcblxuXHRcdC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuXHRcdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XG5cdFx0aWYgKCBzLmJlZm9yZVNlbmQgJiZcblx0XHRcdCggcy5iZWZvcmVTZW5kLmNhbGwoIGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMgKSA9PT0gZmFsc2UgfHwgY29tcGxldGVkICkgKSB7XG5cblx0XHRcdC8vIEFib3J0IGlmIG5vdCBkb25lIGFscmVhZHkgYW5kIHJldHVyblxuXHRcdFx0cmV0dXJuIGpxWEhSLmFib3J0KCk7XG5cdFx0fVxuXG5cdFx0Ly8gQWJvcnRpbmcgaXMgbm8gbG9uZ2VyIGEgY2FuY2VsbGF0aW9uXG5cdFx0c3RyQWJvcnQgPSBcImFib3J0XCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrcyBvbiBkZWZlcnJlZHNcblx0XHRjb21wbGV0ZURlZmVycmVkLmFkZCggcy5jb21wbGV0ZSApO1xuXHRcdGpxWEhSLmRvbmUoIHMuc3VjY2VzcyApO1xuXHRcdGpxWEhSLmZhaWwoIHMuZXJyb3IgKTtcblxuXHRcdC8vIEdldCB0cmFuc3BvcnRcblx0XHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIG5vIHRyYW5zcG9ydCwgd2UgYXV0by1hYm9ydFxuXHRcdGlmICggIXRyYW5zcG9ydCApIHtcblx0XHRcdGRvbmUoIC0xLCBcIk5vIFRyYW5zcG9ydFwiICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSAxO1xuXG5cdFx0XHQvLyBTZW5kIGdsb2JhbCBldmVudFxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheFNlbmRcIiwgWyBqcVhIUiwgcyBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGFqYXhTZW5kLCBzdG9wIHRoZXJlXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaW1lb3V0XG5cdFx0XHRpZiAoIHMuYXN5bmMgJiYgcy50aW1lb3V0ID4gMCApIHtcblx0XHRcdFx0dGltZW91dFRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGpxWEhSLmFib3J0KCBcInRpbWVvdXRcIiApO1xuXHRcdFx0XHR9LCBzLnRpbWVvdXQgKTtcblx0XHRcdH1cblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29tcGxldGVkID0gZmFsc2U7XG5cdFx0XHRcdHRyYW5zcG9ydC5zZW5kKCByZXF1ZXN0SGVhZGVycywgZG9uZSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gUmV0aHJvdyBwb3N0LWNvbXBsZXRpb24gZXhjZXB0aW9uc1xuXHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUHJvcGFnYXRlIG90aGVycyBhcyByZXN1bHRzXG5cdFx0XHRcdGRvbmUoIC0xLCBlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGJhY2sgZm9yIHdoZW4gZXZlcnl0aGluZyBpcyBkb25lXG5cdFx0ZnVuY3Rpb24gZG9uZSggc3RhdHVzLCBuYXRpdmVTdGF0dXNUZXh0LCByZXNwb25zZXMsIGhlYWRlcnMgKSB7XG5cdFx0XHR2YXIgaXNTdWNjZXNzLCBzdWNjZXNzLCBlcnJvciwgcmVzcG9uc2UsIG1vZGlmaWVkLFxuXHRcdFx0XHRzdGF0dXNUZXh0ID0gbmF0aXZlU3RhdHVzVGV4dDtcblxuXHRcdFx0Ly8gSWdub3JlIHJlcGVhdCBpbnZvY2F0aW9uc1xuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29tcGxldGVkID0gdHJ1ZTtcblxuXHRcdFx0Ly8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcblx0XHRcdGlmICggdGltZW91dFRpbWVyICkge1xuXHRcdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cblx0XHRcdC8vIChubyBtYXR0ZXIgaG93IGxvbmcgdGhlIGpxWEhSIG9iamVjdCB3aWxsIGJlIHVzZWQpXG5cdFx0XHR0cmFuc3BvcnQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXCJcIjtcblxuXHRcdFx0Ly8gU2V0IHJlYWR5U3RhdGVcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XG5cblx0XHRcdC8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsXG5cdFx0XHRpc1N1Y2Nlc3MgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNDtcblxuXHRcdFx0Ly8gR2V0IHJlc3BvbnNlIGRhdGFcblx0XHRcdGlmICggcmVzcG9uc2VzICkge1xuXHRcdFx0XHRyZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCBubyBtYXR0ZXIgd2hhdCAodGhhdCB3YXkgcmVzcG9uc2VYWFggZmllbGRzIGFyZSBhbHdheXMgc2V0KVxuXHRcdFx0cmVzcG9uc2UgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKTtcblxuXHRcdFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXG5cdFx0XHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0XHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiTGFzdC1Nb2RpZmllZFwiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJldGFnXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiBubyBjb250ZW50XG5cdFx0XHRcdGlmICggc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIiApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub2NvbnRlbnRcIjtcblxuXHRcdFx0XHQvLyBpZiBub3QgbW9kaWZpZWRcblx0XHRcdFx0fSBlbHNlIGlmICggc3RhdHVzID09PSAzMDQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjtcblxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7XG5cdFx0XHRcdFx0c3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XG5cdFx0XHRcdFx0ZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcblx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSAhZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gRXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHQgYW5kIG5vcm1hbGl6ZSBmb3Igbm9uLWFib3J0c1xuXHRcdFx0XHRlcnJvciA9IHN0YXR1c1RleHQ7XG5cdFx0XHRcdGlmICggc3RhdHVzIHx8ICFzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG5cdFx0XHRcdFx0aWYgKCBzdGF0dXMgPCAwICkge1xuXHRcdFx0XHRcdFx0c3RhdHVzID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3Rcblx0XHRcdGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcblx0XHRcdGpxWEhSLnN0YXR1c1RleHQgPSAoIG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCApICsgXCJcIjtcblxuXHRcdFx0Ly8gU3VjY2Vzcy9FcnJvclxuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsgc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFIgXSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0LCBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRqcVhIUi5zdGF0dXNDb2RlKCBzdGF0dXNDb2RlICk7XG5cdFx0XHRzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggaXNTdWNjZXNzID8gXCJhamF4U3VjY2Vzc1wiIDogXCJhamF4RXJyb3JcIixcblx0XHRcdFx0XHRbIGpxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21wbGV0ZVxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheENvbXBsZXRlXCIsIFsganFYSFIsIHMgXSApO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxuXHRcdFx0XHRpZiAoICEoIC0talF1ZXJ5LmFjdGl2ZSApICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdG9wXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBqcVhIUjtcblx0fSxcblxuXHRnZXRKU09OOiBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCBkYXRhLCBjYWxsYmFjaywgXCJqc29uXCIgKTtcblx0fSxcblxuXHRnZXRTY3JpcHQ6IGZ1bmN0aW9uKCB1cmwsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImdldFwiLCBcInBvc3RcIiBdLCBmdW5jdGlvbiggaSwgbWV0aG9kICkge1xuXHRqUXVlcnlbIG1ldGhvZCBdID0gZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUgKSB7XG5cblx0XHQvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuXHRcdGlmICggaXNGdW5jdGlvbiggZGF0YSApICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG5cdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFRoZSB1cmwgY2FuIGJlIGFuIG9wdGlvbnMgb2JqZWN0ICh3aGljaCB0aGVuIG11c3QgaGF2ZSAudXJsKVxuXHRcdHJldHVybiBqUXVlcnkuYWpheCggalF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cdFx0XHR0eXBlOiBtZXRob2QsXG5cdFx0XHRkYXRhVHlwZTogdHlwZSxcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRzdWNjZXNzOiBjYWxsYmFja1xuXHRcdH0sIGpRdWVyeS5pc1BsYWluT2JqZWN0KCB1cmwgKSAmJiB1cmwgKSApO1xuXHR9O1xufSApO1xuXG5cbmpRdWVyeS5fZXZhbFVybCA9IGZ1bmN0aW9uKCB1cmwgKSB7XG5cdHJldHVybiBqUXVlcnkuYWpheCgge1xuXHRcdHVybDogdXJsLFxuXG5cdFx0Ly8gTWFrZSB0aGlzIGV4cGxpY2l0LCBzaW5jZSB1c2VyIGNhbiBvdmVycmlkZSB0aGlzIHRocm91Z2ggYWpheFNldHVwICgjMTEyNjQpXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRkYXRhVHlwZTogXCJzY3JpcHRcIixcblx0XHRjYWNoZTogdHJ1ZSxcblx0XHRhc3luYzogZmFsc2UsXG5cdFx0Z2xvYmFsOiBmYWxzZSxcblx0XHRcInRocm93c1wiOiB0cnVlXG5cdH0gKTtcbn07XG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR3cmFwQWxsOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgd3JhcDtcblxuXHRcdGlmICggdGhpc1sgMCBdICkge1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRcdGh0bWwgPSBodG1sLmNhbGwoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGUgZWxlbWVudHMgdG8gd3JhcCB0aGUgdGFyZ2V0IGFyb3VuZFxuXHRcdFx0d3JhcCA9IGpRdWVyeSggaHRtbCwgdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQgKS5lcSggMCApLmNsb25lKCB0cnVlICk7XG5cblx0XHRcdGlmICggdGhpc1sgMCBdLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHdyYXAuaW5zZXJ0QmVmb3JlKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0d3JhcC5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IHRoaXM7XG5cblx0XHRcdFx0d2hpbGUgKCBlbGVtLmZpcnN0RWxlbWVudENoaWxkICkge1xuXHRcdFx0XHRcdGVsZW0gPSBlbGVtLmZpcnN0RWxlbWVudENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0XHR9ICkuYXBwZW5kKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0d3JhcElubmVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwSW5uZXIoIGh0bWwuY2FsbCggdGhpcywgaSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGpRdWVyeSggdGhpcyApLFxuXHRcdFx0XHRjb250ZW50cyA9IHNlbGYuY29udGVudHMoKTtcblxuXHRcdFx0aWYgKCBjb250ZW50cy5sZW5ndGggKSB7XG5cdFx0XHRcdGNvbnRlbnRzLndyYXBBbGwoIGh0bWwgKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VsZi5hcHBlbmQoIGh0bWwgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0d3JhcDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIGh0bWxJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggaHRtbCApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwQWxsKCBodG1sSXNGdW5jdGlvbiA/IGh0bWwuY2FsbCggdGhpcywgaSApIDogaHRtbCApO1xuXHRcdH0gKTtcblx0fSxcblxuXHR1bndyYXA6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR0aGlzLnBhcmVudCggc2VsZWN0b3IgKS5ub3QoIFwiYm9keVwiICkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS5yZXBsYWNlV2l0aCggdGhpcy5jaGlsZE5vZGVzICk7XG5cdFx0fSApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4cHIucHNldWRvcy5oaWRkZW4gPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICFqUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUoIGVsZW0gKTtcbn07XG5qUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICEhKCBlbGVtLm9mZnNldFdpZHRoIHx8IGVsZW0ub2Zmc2V0SGVpZ2h0IHx8IGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKTtcbn07XG5cblxuXG5cbmpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24oKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcblx0fSBjYXRjaCAoIGUgKSB7fVxufTtcblxudmFyIHhoclN1Y2Nlc3NTdGF0dXMgPSB7XG5cblx0XHQvLyBGaWxlIHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIGNvZGUgMCwgYXNzdW1lIDIwMFxuXHRcdDA6IDIwMCxcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0Ly8gIzE0NTA6IHNvbWV0aW1lcyBJRSByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0XG5cdFx0MTIyMzogMjA0XG5cdH0sXG5cdHhoclN1cHBvcnRlZCA9IGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCk7XG5cbnN1cHBvcnQuY29ycyA9ICEheGhyU3VwcG9ydGVkICYmICggXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHJTdXBwb3J0ZWQgKTtcbnN1cHBvcnQuYWpheCA9IHhoclN1cHBvcnRlZCA9ICEheGhyU3VwcG9ydGVkO1xuXG5qUXVlcnkuYWpheFRyYW5zcG9ydCggZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdHZhciBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaztcblxuXHQvLyBDcm9zcyBkb21haW4gb25seSBhbGxvd2VkIGlmIHN1cHBvcnRlZCB0aHJvdWdoIFhNTEh0dHBSZXF1ZXN0XG5cdGlmICggc3VwcG9ydC5jb3JzIHx8IHhoclN1cHBvcnRlZCAmJiAhb3B0aW9ucy5jcm9zc0RvbWFpbiApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIGhlYWRlcnMsIGNvbXBsZXRlICkge1xuXHRcdFx0XHR2YXIgaSxcblx0XHRcdFx0XHR4aHIgPSBvcHRpb25zLnhocigpO1xuXG5cdFx0XHRcdHhoci5vcGVuKFxuXHRcdFx0XHRcdG9wdGlvbnMudHlwZSxcblx0XHRcdFx0XHRvcHRpb25zLnVybCxcblx0XHRcdFx0XHRvcHRpb25zLmFzeW5jLFxuXHRcdFx0XHRcdG9wdGlvbnMudXNlcm5hbWUsXG5cdFx0XHRcdFx0b3B0aW9ucy5wYXNzd29yZFxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIEFwcGx5IGN1c3RvbSBmaWVsZHMgaWYgcHJvdmlkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRmb3IgKCBpIGluIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdFx0eGhyWyBpIF0gPSBvcHRpb25zLnhockZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlIG1pbWUgdHlwZSBpZiBuZWVkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlICkge1xuXHRcdFx0XHRcdHhoci5vdmVycmlkZU1pbWVUeXBlKCBvcHRpb25zLm1pbWVUeXBlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBYLVJlcXVlc3RlZC1XaXRoIGhlYWRlclxuXHRcdFx0XHQvLyBGb3IgY3Jvc3MtZG9tYWluIHJlcXVlc3RzLCBzZWVpbmcgYXMgY29uZGl0aW9ucyBmb3IgYSBwcmVmbGlnaHQgYXJlXG5cdFx0XHRcdC8vIGFraW4gdG8gYSBqaWdzYXcgcHV6emxlLCB3ZSBzaW1wbHkgbmV2ZXIgc2V0IGl0IHRvIGJlIHN1cmUuXG5cdFx0XHRcdC8vIChpdCBjYW4gYWx3YXlzIGJlIHNldCBvbiBhIHBlci1yZXF1ZXN0IGJhc2lzIG9yIGV2ZW4gdXNpbmcgYWpheFNldHVwKVxuXHRcdFx0XHQvLyBGb3Igc2FtZS1kb21haW4gcmVxdWVzdHMsIHdvbid0IGNoYW5nZSBoZWFkZXIgaWYgYWxyZWFkeSBwcm92aWRlZC5cblx0XHRcdFx0aWYgKCAhb3B0aW9ucy5jcm9zc0RvbWFpbiAmJiAhaGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSApIHtcblx0XHRcdFx0XHRoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0IGhlYWRlcnNcblx0XHRcdFx0Zm9yICggaSBpbiBoZWFkZXJzICkge1xuXHRcdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBoZWFkZXJzWyBpIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBlcnJvckNhbGxiYWNrID0geGhyLm9ubG9hZCA9XG5cdFx0XHRcdFx0XHRcdFx0eGhyLm9uZXJyb3IgPSB4aHIub25hYm9ydCA9IHhoci5vbnRpbWVvdXQgPVxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlID09PSBcImFib3J0XCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0eGhyLmFib3J0KCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwiZXJyb3JcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gT24gYSBtYW51YWwgbmF0aXZlIGFib3J0LCBJRTkgdGhyb3dzXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZXJyb3JzIG9uIGFueSBwcm9wZXJ0eSBhY2Nlc3MgdGhhdCBpcyBub3QgcmVhZHlTdGF0ZVxuXHRcdFx0XHRcdFx0XHRcdGlmICggdHlwZW9mIHhoci5zdGF0dXMgIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggMCwgXCJlcnJvclwiICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIEZpbGU6IHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIDA7IHNlZSAjODYwNSwgIzE0MjA3XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblx0XHRcdFx0XHRcdFx0XHRcdHhoclN1Y2Nlc3NTdGF0dXNbIHhoci5zdGF0dXMgXSB8fCB4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHQsXG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJRTkgaGFzIG5vIFhIUjIgYnV0IHRocm93cyBvbiBiaW5hcnkgKHRyYWMtMTE0MjYpXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBGb3IgWEhSMiBub24tdGV4dCwgbGV0IHRoZSBjYWxsZXIgaGFuZGxlIGl0IChnaC0yNDk4KVxuXHRcdFx0XHRcdFx0XHRcdFx0KCB4aHIucmVzcG9uc2VUeXBlIHx8IFwidGV4dFwiICkgIT09IFwidGV4dFwiICB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHhoci5yZXNwb25zZVRleHQgIT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IGJpbmFyeTogeGhyLnJlc3BvbnNlIH0gOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IHRleHQ6IHhoci5yZXNwb25zZVRleHQgfSxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIExpc3RlbiB0byBldmVudHNcblx0XHRcdFx0eGhyLm9ubG9hZCA9IGNhbGxiYWNrKCk7XG5cdFx0XHRcdGVycm9yQ2FsbGJhY2sgPSB4aHIub25lcnJvciA9IHhoci5vbnRpbWVvdXQgPSBjYWxsYmFjayggXCJlcnJvclwiICk7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0XHRcdC8vIFVzZSBvbnJlYWR5c3RhdGVjaGFuZ2UgdG8gcmVwbGFjZSBvbmFib3J0XG5cdFx0XHRcdC8vIHRvIGhhbmRsZSB1bmNhdWdodCBhYm9ydHNcblx0XHRcdFx0aWYgKCB4aHIub25hYm9ydCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHhoci5vbmFib3J0ID0gZXJyb3JDYWxsYmFjaztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIENoZWNrIHJlYWR5U3RhdGUgYmVmb3JlIHRpbWVvdXQgYXMgaXQgY2hhbmdlc1xuXHRcdFx0XHRcdFx0aWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBbGxvdyBvbmVycm9yIHRvIGJlIGNhbGxlZCBmaXJzdCxcblx0XHRcdFx0XHRcdFx0Ly8gYnV0IHRoYXQgd2lsbCBub3QgaGFuZGxlIGEgbmF0aXZlIGFib3J0XG5cdFx0XHRcdFx0XHRcdC8vIEFsc28sIHNhdmUgZXJyb3JDYWxsYmFjayB0byBhIHZhcmlhYmxlXG5cdFx0XHRcdFx0XHRcdC8vIGFzIHhoci5vbmVycm9yIGNhbm5vdCBiZSBhY2Nlc3NlZFxuXHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGVycm9yQ2FsbGJhY2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBhYm9ydCBjYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGNhbGxiYWNrKCBcImFib3J0XCIgKTtcblxuXHRcdFx0XHR0cnkge1xuXG5cdFx0XHRcdFx0Ly8gRG8gc2VuZCB0aGUgcmVxdWVzdCAodGhpcyBtYXkgcmFpc2UgYW4gZXhjZXB0aW9uKVxuXHRcdFx0XHRcdHhoci5zZW5kKCBvcHRpb25zLmhhc0NvbnRlbnQgJiYgb3B0aW9ucy5kYXRhIHx8IG51bGwgKTtcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHQvLyAjMTQ2ODM6IE9ubHkgcmV0aHJvdyBpZiB0aGlzIGhhc24ndCBiZWVuIG5vdGlmaWVkIGFzIGFuIGVycm9yIHlldFxuXHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFByZXZlbnQgYXV0by1leGVjdXRpb24gb2Ygc2NyaXB0cyB3aGVuIG5vIGV4cGxpY2l0IGRhdGFUeXBlIHdhcyBwcm92aWRlZCAoU2VlIGdoLTI0MzIpXG5qUXVlcnkuYWpheFByZWZpbHRlciggZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLmNvbnRlbnRzLnNjcmlwdCA9IGZhbHNlO1xuXHR9XG59ICk7XG5cbi8vIEluc3RhbGwgc2NyaXB0IGRhdGFUeXBlXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGFjY2VwdHM6IHtcblx0XHRzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBcIiArXG5cdFx0XHRcImFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwiXG5cdH0sXG5cdGNvbnRlbnRzOiB7XG5cdFx0c2NyaXB0OiAvXFxiKD86amF2YXxlY21hKXNjcmlwdFxcYi9cblx0fSxcblx0Y29udmVydGVyczoge1xuXHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggdGV4dCApO1xuXHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgY3Jvc3NEb21haW5cbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cy5jYWNoZSA9IGZhbHNlO1xuXHR9XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLnR5cGUgPSBcIkdFVFwiO1xuXHR9XG59ICk7XG5cbi8vIEJpbmQgc2NyaXB0IHRhZyBoYWNrIHRyYW5zcG9ydFxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXG5cdC8vIFRoaXMgdHJhbnNwb3J0IG9ubHkgZGVhbHMgd2l0aCBjcm9zcyBkb21haW4gcmVxdWVzdHNcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHZhciBzY3JpcHQsIGNhbGxiYWNrO1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggXywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHNjcmlwdCA9IGpRdWVyeSggXCI8c2NyaXB0PlwiICkucHJvcCgge1xuXHRcdFx0XHRcdGNoYXJzZXQ6IHMuc2NyaXB0Q2hhcnNldCxcblx0XHRcdFx0XHRzcmM6IHMudXJsXG5cdFx0XHRcdH0gKS5vbihcblx0XHRcdFx0XHRcImxvYWQgZXJyb3JcIixcblx0XHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRzY3JpcHQucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IG51bGw7XG5cdFx0XHRcdFx0XHRpZiAoIGV2dCApIHtcblx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIGV2dC50eXBlID09PSBcImVycm9yXCIgPyA0MDQgOiAyMDAsIGV2dC50eXBlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIFVzZSBuYXRpdmUgRE9NIG1hbmlwdWxhdGlvbiB0byBhdm9pZCBvdXIgZG9tTWFuaXAgQUpBWCB0cmlja2VyeVxuXHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHRbIDAgXSApO1xuXHRcdFx0fSxcblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgb2xkQ2FsbGJhY2tzID0gW10sXG5cdHJqc29ucCA9IC8oPSlcXD8oPz0mfCQpfFxcP1xcPy87XG5cbi8vIERlZmF1bHQganNvbnAgc2V0dGluZ3NcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0anNvbnA6IFwiY2FsbGJhY2tcIixcblx0anNvbnBDYWxsYmFjazogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNhbGxiYWNrID0gb2xkQ2FsbGJhY2tzLnBvcCgpIHx8ICggalF1ZXJ5LmV4cGFuZG8gKyBcIl9cIiArICggbm9uY2UrKyApICk7XG5cdFx0dGhpc1sgY2FsbGJhY2sgXSA9IHRydWU7XG5cdFx0cmV0dXJuIGNhbGxiYWNrO1xuXHR9XG59ICk7XG5cbi8vIERldGVjdCwgbm9ybWFsaXplIG9wdGlvbnMgYW5kIGluc3RhbGwgY2FsbGJhY2tzIGZvciBqc29ucCByZXF1ZXN0c1xualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwianNvbiBqc29ucFwiLCBmdW5jdGlvbiggcywgb3JpZ2luYWxTZXR0aW5ncywganFYSFIgKSB7XG5cblx0dmFyIGNhbGxiYWNrTmFtZSwgb3ZlcndyaXR0ZW4sIHJlc3BvbnNlQ29udGFpbmVyLFxuXHRcdGpzb25Qcm9wID0gcy5qc29ucCAhPT0gZmFsc2UgJiYgKCByanNvbnAudGVzdCggcy51cmwgKSA/XG5cdFx0XHRcInVybFwiIDpcblx0XHRcdHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKVxuXHRcdFx0XHRcdC5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgJiZcblx0XHRcdFx0cmpzb25wLnRlc3QoIHMuZGF0YSApICYmIFwiZGF0YVwiXG5cdFx0KTtcblxuXHQvLyBIYW5kbGUgaWZmIHRoZSBleHBlY3RlZCBkYXRhIHR5cGUgaXMgXCJqc29ucFwiIG9yIHdlIGhhdmUgYSBwYXJhbWV0ZXIgdG8gc2V0XG5cdGlmICgganNvblByb3AgfHwgcy5kYXRhVHlwZXNbIDAgXSA9PT0gXCJqc29ucFwiICkge1xuXG5cdFx0Ly8gR2V0IGNhbGxiYWNrIG5hbWUsIHJlbWVtYmVyaW5nIHByZWV4aXN0aW5nIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBpdFxuXHRcdGNhbGxiYWNrTmFtZSA9IHMuanNvbnBDYWxsYmFjayA9IGlzRnVuY3Rpb24oIHMuanNvbnBDYWxsYmFjayApID9cblx0XHRcdHMuanNvbnBDYWxsYmFjaygpIDpcblx0XHRcdHMuanNvbnBDYWxsYmFjaztcblxuXHRcdC8vIEluc2VydCBjYWxsYmFjayBpbnRvIHVybCBvciBmb3JtIGRhdGFcblx0XHRpZiAoIGpzb25Qcm9wICkge1xuXHRcdFx0c1sganNvblByb3AgXSA9IHNbIGpzb25Qcm9wIF0ucmVwbGFjZSggcmpzb25wLCBcIiQxXCIgKyBjYWxsYmFja05hbWUgKTtcblx0XHR9IGVsc2UgaWYgKCBzLmpzb25wICE9PSBmYWxzZSApIHtcblx0XHRcdHMudXJsICs9ICggcnF1ZXJ5LnRlc3QoIHMudXJsICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmpzb25wICsgXCI9XCIgKyBjYWxsYmFja05hbWU7XG5cdFx0fVxuXG5cdFx0Ly8gVXNlIGRhdGEgY29udmVydGVyIHRvIHJldHJpZXZlIGpzb24gYWZ0ZXIgc2NyaXB0IGV4ZWN1dGlvblxuXHRcdHMuY29udmVydGVyc1sgXCJzY3JpcHQganNvblwiIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXJlc3BvbnNlQ29udGFpbmVyICkge1xuXHRcdFx0XHRqUXVlcnkuZXJyb3IoIGNhbGxiYWNrTmFtZSArIFwiIHdhcyBub3QgY2FsbGVkXCIgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXNwb25zZUNvbnRhaW5lclsgMCBdO1xuXHRcdH07XG5cblx0XHQvLyBGb3JjZSBqc29uIGRhdGFUeXBlXG5cdFx0cy5kYXRhVHlwZXNbIDAgXSA9IFwianNvblwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja1xuXHRcdG92ZXJ3cml0dGVuID0gd2luZG93WyBjYWxsYmFja05hbWUgXTtcblx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IGFyZ3VtZW50cztcblx0XHR9O1xuXG5cdFx0Ly8gQ2xlYW4tdXAgZnVuY3Rpb24gKGZpcmVzIGFmdGVyIGNvbnZlcnRlcnMpXG5cdFx0anFYSFIuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gSWYgcHJldmlvdXMgdmFsdWUgZGlkbid0IGV4aXN0IC0gcmVtb3ZlIGl0XG5cdFx0XHRpZiAoIG92ZXJ3cml0dGVuID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGpRdWVyeSggd2luZG93ICkucmVtb3ZlUHJvcCggY2FsbGJhY2tOYW1lICk7XG5cblx0XHRcdC8vIE90aGVyd2lzZSByZXN0b3JlIHByZWV4aXN0aW5nIHZhbHVlXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gb3ZlcndyaXR0ZW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNhdmUgYmFjayBhcyBmcmVlXG5cdFx0XHRpZiAoIHNbIGNhbGxiYWNrTmFtZSBdICkge1xuXG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHJlLXVzaW5nIHRoZSBvcHRpb25zIGRvZXNuJ3Qgc2NyZXcgdGhpbmdzIGFyb3VuZFxuXHRcdFx0XHRzLmpzb25wQ2FsbGJhY2sgPSBvcmlnaW5hbFNldHRpbmdzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHRcdFx0Ly8gU2F2ZSB0aGUgY2FsbGJhY2sgbmFtZSBmb3IgZnV0dXJlIHVzZVxuXHRcdFx0XHRvbGRDYWxsYmFja3MucHVzaCggY2FsbGJhY2tOYW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhbGwgaWYgaXQgd2FzIGEgZnVuY3Rpb24gYW5kIHdlIGhhdmUgYSByZXNwb25zZVxuXHRcdFx0aWYgKCByZXNwb25zZUNvbnRhaW5lciAmJiBpc0Z1bmN0aW9uKCBvdmVyd3JpdHRlbiApICkge1xuXHRcdFx0XHRvdmVyd3JpdHRlbiggcmVzcG9uc2VDb250YWluZXJbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IG92ZXJ3cml0dGVuID0gdW5kZWZpbmVkO1xuXHRcdH0gKTtcblxuXHRcdC8vIERlbGVnYXRlIHRvIHNjcmlwdFxuXHRcdHJldHVybiBcInNjcmlwdFwiO1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA4IG9ubHlcbi8vIEluIFNhZmFyaSA4IGRvY3VtZW50cyBjcmVhdGVkIHZpYSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnRcbi8vIGNvbGxhcHNlIHNpYmxpbmcgZm9ybXM6IHRoZSBzZWNvbmQgb25lIGJlY29tZXMgYSBjaGlsZCBvZiB0aGUgZmlyc3Qgb25lLlxuLy8gQmVjYXVzZSBvZiB0aGF0LCB0aGlzIHNlY3VyaXR5IG1lYXN1cmUgaGFzIHRvIGJlIGRpc2FibGVkIGluIFNhZmFyaSA4LlxuLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNzMzN1xuc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgPSAoIGZ1bmN0aW9uKCkge1xuXHR2YXIgYm9keSA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApLmJvZHk7XG5cdGJvZHkuaW5uZXJIVE1MID0gXCI8Zm9ybT48L2Zvcm0+PGZvcm0+PC9mb3JtPlwiO1xuXHRyZXR1cm4gYm9keS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMjtcbn0gKSgpO1xuXG5cbi8vIEFyZ3VtZW50IFwiZGF0YVwiIHNob3VsZCBiZSBzdHJpbmcgb2YgaHRtbFxuLy8gY29udGV4dCAob3B0aW9uYWwpOiBJZiBzcGVjaWZpZWQsIHRoZSBmcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQgaW4gdGhpcyBjb250ZXh0LFxuLy8gZGVmYXVsdHMgdG8gZG9jdW1lbnRcbi8vIGtlZXBTY3JpcHRzIChvcHRpb25hbCk6IElmIHRydWUsIHdpbGwgaW5jbHVkZSBzY3JpcHRzIHBhc3NlZCBpbiB0aGUgaHRtbCBzdHJpbmdcbmpRdWVyeS5wYXJzZUhUTUwgPSBmdW5jdGlvbiggZGF0YSwgY29udGV4dCwga2VlcFNjcmlwdHMgKSB7XG5cdGlmICggdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIFtdO1xuXHR9XG5cdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGtlZXBTY3JpcHRzID0gY29udGV4dDtcblx0XHRjb250ZXh0ID0gZmFsc2U7XG5cdH1cblxuXHR2YXIgYmFzZSwgcGFyc2VkLCBzY3JpcHRzO1xuXG5cdGlmICggIWNvbnRleHQgKSB7XG5cblx0XHQvLyBTdG9wIHNjcmlwdHMgb3IgaW5saW5lIGV2ZW50IGhhbmRsZXJzIGZyb20gYmVpbmcgZXhlY3V0ZWQgaW1tZWRpYXRlbHlcblx0XHQvLyBieSB1c2luZyBkb2N1bWVudC5pbXBsZW1lbnRhdGlvblxuXHRcdGlmICggc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgKSB7XG5cdFx0XHRjb250ZXh0ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICk7XG5cblx0XHRcdC8vIFNldCB0aGUgYmFzZSBocmVmIGZvciB0aGUgY3JlYXRlZCBkb2N1bWVudFxuXHRcdFx0Ly8gc28gYW55IHBhcnNlZCBlbGVtZW50cyB3aXRoIFVSTHNcblx0XHRcdC8vIGFyZSBiYXNlZCBvbiB0aGUgZG9jdW1lbnQncyBVUkwgKGdoLTI5NjUpXG5cdFx0XHRiYXNlID0gY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImJhc2VcIiApO1xuXHRcdFx0YmFzZS5ocmVmID0gZG9jdW1lbnQubG9jYXRpb24uaHJlZjtcblx0XHRcdGNvbnRleHQuaGVhZC5hcHBlbmRDaGlsZCggYmFzZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb250ZXh0ID0gZG9jdW1lbnQ7XG5cdFx0fVxuXHR9XG5cblx0cGFyc2VkID0gcnNpbmdsZVRhZy5leGVjKCBkYXRhICk7XG5cdHNjcmlwdHMgPSAha2VlcFNjcmlwdHMgJiYgW107XG5cblx0Ly8gU2luZ2xlIHRhZ1xuXHRpZiAoIHBhcnNlZCApIHtcblx0XHRyZXR1cm4gWyBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIHBhcnNlZFsgMSBdICkgXTtcblx0fVxuXG5cdHBhcnNlZCA9IGJ1aWxkRnJhZ21lbnQoIFsgZGF0YSBdLCBjb250ZXh0LCBzY3JpcHRzICk7XG5cblx0aWYgKCBzY3JpcHRzICYmIHNjcmlwdHMubGVuZ3RoICkge1xuXHRcdGpRdWVyeSggc2NyaXB0cyApLnJlbW92ZSgpO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIHBhcnNlZC5jaGlsZE5vZGVzICk7XG59O1xuXG5cbi8qKlxuICogTG9hZCBhIHVybCBpbnRvIGEgcGFnZVxuICovXG5qUXVlcnkuZm4ubG9hZCA9IGZ1bmN0aW9uKCB1cmwsIHBhcmFtcywgY2FsbGJhY2sgKSB7XG5cdHZhciBzZWxlY3RvciwgdHlwZSwgcmVzcG9uc2UsXG5cdFx0c2VsZiA9IHRoaXMsXG5cdFx0b2ZmID0gdXJsLmluZGV4T2YoIFwiIFwiICk7XG5cblx0aWYgKCBvZmYgPiAtMSApIHtcblx0XHRzZWxlY3RvciA9IHN0cmlwQW5kQ29sbGFwc2UoIHVybC5zbGljZSggb2ZmICkgKTtcblx0XHR1cmwgPSB1cmwuc2xpY2UoIDAsIG9mZiApO1xuXHR9XG5cblx0Ly8gSWYgaXQncyBhIGZ1bmN0aW9uXG5cdGlmICggaXNGdW5jdGlvbiggcGFyYW1zICkgKSB7XG5cblx0XHQvLyBXZSBhc3N1bWUgdGhhdCBpdCdzIHRoZSBjYWxsYmFja1xuXHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdHBhcmFtcyA9IHVuZGVmaW5lZDtcblxuXHQvLyBPdGhlcndpc2UsIGJ1aWxkIGEgcGFyYW0gc3RyaW5nXG5cdH0gZWxzZSBpZiAoIHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zID09PSBcIm9iamVjdFwiICkge1xuXHRcdHR5cGUgPSBcIlBPU1RcIjtcblx0fVxuXG5cdC8vIElmIHdlIGhhdmUgZWxlbWVudHMgdG8gbW9kaWZ5LCBtYWtlIHRoZSByZXF1ZXN0XG5cdGlmICggc2VsZi5sZW5ndGggPiAwICkge1xuXHRcdGpRdWVyeS5hamF4KCB7XG5cdFx0XHR1cmw6IHVybCxcblxuXHRcdFx0Ly8gSWYgXCJ0eXBlXCIgdmFyaWFibGUgaXMgdW5kZWZpbmVkLCB0aGVuIFwiR0VUXCIgbWV0aG9kIHdpbGwgYmUgdXNlZC5cblx0XHRcdC8vIE1ha2UgdmFsdWUgb2YgdGhpcyBmaWVsZCBleHBsaWNpdCBzaW5jZVxuXHRcdFx0Ly8gdXNlciBjYW4gb3ZlcnJpZGUgaXQgdGhyb3VnaCBhamF4U2V0dXAgbWV0aG9kXG5cdFx0XHR0eXBlOiB0eXBlIHx8IFwiR0VUXCIsXG5cdFx0XHRkYXRhVHlwZTogXCJodG1sXCIsXG5cdFx0XHRkYXRhOiBwYXJhbXNcblx0XHR9ICkuZG9uZSggZnVuY3Rpb24oIHJlc3BvbnNlVGV4dCApIHtcblxuXHRcdFx0Ly8gU2F2ZSByZXNwb25zZSBmb3IgdXNlIGluIGNvbXBsZXRlIGNhbGxiYWNrXG5cdFx0XHRyZXNwb25zZSA9IGFyZ3VtZW50cztcblxuXHRcdFx0c2VsZi5odG1sKCBzZWxlY3RvciA/XG5cblx0XHRcdFx0Ly8gSWYgYSBzZWxlY3RvciB3YXMgc3BlY2lmaWVkLCBsb2NhdGUgdGhlIHJpZ2h0IGVsZW1lbnRzIGluIGEgZHVtbXkgZGl2XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgc2NyaXB0cyB0byBhdm9pZCBJRSAnUGVybWlzc2lvbiBEZW5pZWQnIGVycm9yc1xuXHRcdFx0XHRqUXVlcnkoIFwiPGRpdj5cIiApLmFwcGVuZCggalF1ZXJ5LnBhcnNlSFRNTCggcmVzcG9uc2VUZXh0ICkgKS5maW5kKCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgdXNlIHRoZSBmdWxsIHJlc3VsdFxuXHRcdFx0XHRyZXNwb25zZVRleHQgKTtcblxuXHRcdC8vIElmIHRoZSByZXF1ZXN0IHN1Y2NlZWRzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJkYXRhXCIsIFwic3RhdHVzXCIsIFwianFYSFJcIlxuXHRcdC8vIGJ1dCB0aGV5IGFyZSBpZ25vcmVkIGJlY2F1c2UgcmVzcG9uc2Ugd2FzIHNldCBhYm92ZS5cblx0XHQvLyBJZiBpdCBmYWlscywgdGhpcyBmdW5jdGlvbiBnZXRzIFwianFYSFJcIiwgXCJzdGF0dXNcIiwgXCJlcnJvclwiXG5cdFx0fSApLmFsd2F5cyggY2FsbGJhY2sgJiYgZnVuY3Rpb24oIGpxWEhSLCBzdGF0dXMgKSB7XG5cdFx0XHRzZWxmLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjYWxsYmFjay5hcHBseSggdGhpcywgcmVzcG9uc2UgfHwgWyBqcVhIUi5yZXNwb25zZVRleHQsIHN0YXR1cywganFYSFIgXSApO1xuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuXG5cblxuLy8gQXR0YWNoIGEgYnVuY2ggb2YgZnVuY3Rpb25zIGZvciBoYW5kbGluZyBjb21tb24gQUpBWCBldmVudHNcbmpRdWVyeS5lYWNoKCBbXG5cdFwiYWpheFN0YXJ0XCIsXG5cdFwiYWpheFN0b3BcIixcblx0XCJhamF4Q29tcGxldGVcIixcblx0XCJhamF4RXJyb3JcIixcblx0XCJhamF4U3VjY2Vzc1wiLFxuXHRcImFqYXhTZW5kXCJcbl0sIGZ1bmN0aW9uKCBpLCB0eXBlICkge1xuXHRqUXVlcnkuZm5bIHR5cGUgXSA9IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZSwgZm4gKTtcblx0fTtcbn0gKTtcblxuXG5cblxualF1ZXJ5LmV4cHIucHNldWRvcy5hbmltYXRlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGpRdWVyeS50aW1lcnMsIGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gZWxlbSA9PT0gZm4uZWxlbTtcblx0fSApLmxlbmd0aDtcbn07XG5cblxuXG5cbmpRdWVyeS5vZmZzZXQgPSB7XG5cdHNldE9mZnNldDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGkgKSB7XG5cdFx0dmFyIGN1clBvc2l0aW9uLCBjdXJMZWZ0LCBjdXJDU1NUb3AsIGN1clRvcCwgY3VyT2Zmc2V0LCBjdXJDU1NMZWZ0LCBjYWxjdWxhdGVQb3NpdGlvbixcblx0XHRcdHBvc2l0aW9uID0galF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICksXG5cdFx0XHRjdXJFbGVtID0galF1ZXJ5KCBlbGVtICksXG5cdFx0XHRwcm9wcyA9IHt9O1xuXG5cdFx0Ly8gU2V0IHBvc2l0aW9uIGZpcnN0LCBpbi1jYXNlIHRvcC9sZWZ0IGFyZSBzZXQgZXZlbiBvbiBzdGF0aWMgZWxlbVxuXHRcdGlmICggcG9zaXRpb24gPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRlbGVtLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuXHRcdH1cblxuXHRcdGN1ck9mZnNldCA9IGN1ckVsZW0ub2Zmc2V0KCk7XG5cdFx0Y3VyQ1NTVG9wID0galF1ZXJ5LmNzcyggZWxlbSwgXCJ0b3BcIiApO1xuXHRcdGN1ckNTU0xlZnQgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImxlZnRcIiApO1xuXHRcdGNhbGN1bGF0ZVBvc2l0aW9uID0gKCBwb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiIHx8IHBvc2l0aW9uID09PSBcImZpeGVkXCIgKSAmJlxuXHRcdFx0KCBjdXJDU1NUb3AgKyBjdXJDU1NMZWZ0ICkuaW5kZXhPZiggXCJhdXRvXCIgKSA+IC0xO1xuXG5cdFx0Ly8gTmVlZCB0byBiZSBhYmxlIHRvIGNhbGN1bGF0ZSBwb3NpdGlvbiBpZiBlaXRoZXJcblx0XHQvLyB0b3Agb3IgbGVmdCBpcyBhdXRvIGFuZCBwb3NpdGlvbiBpcyBlaXRoZXIgYWJzb2x1dGUgb3IgZml4ZWRcblx0XHRpZiAoIGNhbGN1bGF0ZVBvc2l0aW9uICkge1xuXHRcdFx0Y3VyUG9zaXRpb24gPSBjdXJFbGVtLnBvc2l0aW9uKCk7XG5cdFx0XHRjdXJUb3AgPSBjdXJQb3NpdGlvbi50b3A7XG5cdFx0XHRjdXJMZWZ0ID0gY3VyUG9zaXRpb24ubGVmdDtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJUb3AgPSBwYXJzZUZsb2F0KCBjdXJDU1NUb3AgKSB8fCAwO1xuXHRcdFx0Y3VyTGVmdCA9IHBhcnNlRmxvYXQoIGN1ckNTU0xlZnQgKSB8fCAwO1xuXHRcdH1cblxuXHRcdGlmICggaXNGdW5jdGlvbiggb3B0aW9ucyApICkge1xuXG5cdFx0XHQvLyBVc2UgalF1ZXJ5LmV4dGVuZCBoZXJlIHRvIGFsbG93IG1vZGlmaWNhdGlvbiBvZiBjb29yZGluYXRlcyBhcmd1bWVudCAoZ2gtMTg0OClcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zLmNhbGwoIGVsZW0sIGksIGpRdWVyeS5leHRlbmQoIHt9LCBjdXJPZmZzZXQgKSApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy50b3AgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLnRvcCA9ICggb3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wICkgKyBjdXJUb3A7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5sZWZ0ICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy5sZWZ0ID0gKCBvcHRpb25zLmxlZnQgLSBjdXJPZmZzZXQubGVmdCApICsgY3VyTGVmdDtcblx0XHR9XG5cblx0XHRpZiAoIFwidXNpbmdcIiBpbiBvcHRpb25zICkge1xuXHRcdFx0b3B0aW9ucy51c2luZy5jYWxsKCBlbGVtLCBwcm9wcyApO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1ckVsZW0uY3NzKCBwcm9wcyApO1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdC8vIG9mZnNldCgpIHJlbGF0ZXMgYW4gZWxlbWVudCdzIGJvcmRlciBib3ggdG8gdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvZmZzZXQ6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdFx0Ly8gUHJlc2VydmUgY2hhaW5pbmcgZm9yIHNldHRlclxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiBvcHRpb25zID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHR0aGlzIDpcblx0XHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0XHRqUXVlcnkub2Zmc2V0LnNldE9mZnNldCggdGhpcywgb3B0aW9ucywgaSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0dmFyIHJlY3QsIHdpbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB6ZXJvcyBmb3IgZGlzY29ubmVjdGVkIGFuZCBoaWRkZW4gKGRpc3BsYXk6IG5vbmUpIGVsZW1lbnRzIChnaC0yMzEwKVxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGFcblx0XHQvLyBkaXNjb25uZWN0ZWQgbm9kZSBpbiBJRSB0aHJvd3MgYW4gZXJyb3Jcblx0XHRpZiAoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cdFx0fVxuXG5cdFx0Ly8gR2V0IGRvY3VtZW50LXJlbGF0aXZlIHBvc2l0aW9uIGJ5IGFkZGluZyB2aWV3cG9ydCBzY3JvbGwgdG8gdmlld3BvcnQtcmVsYXRpdmUgZ0JDUlxuXHRcdHJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdHdpbiA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldztcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiByZWN0LnRvcCArIHdpbi5wYWdlWU9mZnNldCxcblx0XHRcdGxlZnQ6IHJlY3QubGVmdCArIHdpbi5wYWdlWE9mZnNldFxuXHRcdH07XG5cdH0sXG5cblx0Ly8gcG9zaXRpb24oKSByZWxhdGVzIGFuIGVsZW1lbnQncyBtYXJnaW4gYm94IHRvIGl0cyBvZmZzZXQgcGFyZW50J3MgcGFkZGluZyBib3hcblx0Ly8gVGhpcyBjb3JyZXNwb25kcyB0byB0aGUgYmVoYXZpb3Igb2YgQ1NTIGFic29sdXRlIHBvc2l0aW9uaW5nXG5cdHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoICF0aGlzWyAwIF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIG9mZnNldFBhcmVudCwgb2Zmc2V0LCBkb2MsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0cGFyZW50T2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblxuXHRcdC8vIHBvc2l0aW9uOmZpeGVkIGVsZW1lbnRzIGFyZSBvZmZzZXQgZnJvbSB0aGUgdmlld3BvcnQsIHdoaWNoIGl0c2VsZiBhbHdheXMgaGFzIHplcm8gb2Zmc2V0XG5cdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSA9PT0gXCJmaXhlZFwiICkge1xuXG5cdFx0XHQvLyBBc3N1bWUgcG9zaXRpb246Zml4ZWQgaW1wbGllcyBhdmFpbGFiaWxpdHkgb2YgZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG5cdFx0XHRvZmZzZXQgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdG9mZnNldCA9IHRoaXMub2Zmc2V0KCk7XG5cblx0XHRcdC8vIEFjY291bnQgZm9yIHRoZSAqcmVhbCogb2Zmc2V0IHBhcmVudCwgd2hpY2ggY2FuIGJlIHRoZSBkb2N1bWVudCBvciBpdHMgcm9vdCBlbGVtZW50XG5cdFx0XHQvLyB3aGVuIGEgc3RhdGljYWxseSBwb3NpdGlvbmVkIGVsZW1lbnQgaXMgaWRlbnRpZmllZFxuXHRcdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50O1xuXHRcdFx0b2Zmc2V0UGFyZW50ID0gZWxlbS5vZmZzZXRQYXJlbnQgfHwgZG9jLmRvY3VtZW50RWxlbWVudDtcblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmXG5cdFx0XHRcdCggb2Zmc2V0UGFyZW50ID09PSBkb2MuYm9keSB8fCBvZmZzZXRQYXJlbnQgPT09IGRvYy5kb2N1bWVudEVsZW1lbnQgKSAmJlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuXG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0UGFyZW50ICE9PSBlbGVtICYmIG9mZnNldFBhcmVudC5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSBib3JkZXJzIGludG8gaXRzIG9mZnNldCwgc2luY2UgdGhleSBhcmUgb3V0c2lkZSBpdHMgY29udGVudCBvcmlnaW5cblx0XHRcdFx0cGFyZW50T2Zmc2V0ID0galF1ZXJ5KCBvZmZzZXRQYXJlbnQgKS5vZmZzZXQoKTtcblx0XHRcdFx0cGFyZW50T2Zmc2V0LnRvcCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwiYm9yZGVyVG9wV2lkdGhcIiwgdHJ1ZSApO1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQubGVmdCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwiYm9yZGVyTGVmdFdpZHRoXCIsIHRydWUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTdWJ0cmFjdCBwYXJlbnQgb2Zmc2V0cyBhbmQgZWxlbWVudCBtYXJnaW5zXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogb2Zmc2V0LnRvcCAtIHBhcmVudE9mZnNldC50b3AgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpblRvcFwiLCB0cnVlICksXG5cdFx0XHRsZWZ0OiBvZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0IC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIsIHRydWUgKVxuXHRcdH07XG5cdH0sXG5cblx0Ly8gVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gZG9jdW1lbnRFbGVtZW50IGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG5cdC8vIDEpIEZvciB0aGUgZWxlbWVudCBpbnNpZGUgdGhlIGlmcmFtZSB3aXRob3V0IG9mZnNldFBhcmVudCwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm5cblx0Ly8gICAgZG9jdW1lbnRFbGVtZW50IG9mIHRoZSBwYXJlbnQgd2luZG93XG5cdC8vIDIpIEZvciB0aGUgaGlkZGVuIG9yIGRldGFjaGVkIGVsZW1lbnRcblx0Ly8gMykgRm9yIGJvZHkgb3IgaHRtbCBlbGVtZW50LCBpLmUuIGluIGNhc2Ugb2YgdGhlIGh0bWwgbm9kZSAtIGl0IHdpbGwgcmV0dXJuIGl0c2VsZlxuXHQvL1xuXHQvLyBidXQgdGhvc2UgZXhjZXB0aW9ucyB3ZXJlIG5ldmVyIHByZXNlbnRlZCBhcyBhIHJlYWwgbGlmZSB1c2UtY2FzZXNcblx0Ly8gYW5kIG1pZ2h0IGJlIGNvbnNpZGVyZWQgYXMgbW9yZSBwcmVmZXJhYmxlIHJlc3VsdHMuXG5cdC8vXG5cdC8vIFRoaXMgbG9naWMsIGhvd2V2ZXIsIGlzIG5vdCBndWFyYW50ZWVkIGFuZCBjYW4gY2hhbmdlIGF0IGFueSBwb2ludCBpbiB0aGUgZnV0dXJlXG5cdG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudDtcblxuXHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiYgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG9mZnNldFBhcmVudCB8fCBkb2N1bWVudEVsZW1lbnQ7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbi8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgc2Nyb2xsTGVmdDogXCJwYWdlWE9mZnNldFwiLCBzY3JvbGxUb3A6IFwicGFnZVlPZmZzZXRcIiB9LCBmdW5jdGlvbiggbWV0aG9kLCBwcm9wICkge1xuXHR2YXIgdG9wID0gXCJwYWdlWU9mZnNldFwiID09PSBwcm9wO1xuXG5cdGpRdWVyeS5mblsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdmFsICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBtZXRob2QsIHZhbCApIHtcblxuXHRcdFx0Ly8gQ29hbGVzY2UgZG9jdW1lbnRzIGFuZCB3aW5kb3dzXG5cdFx0XHR2YXIgd2luO1xuXHRcdFx0aWYgKCBpc1dpbmRvdyggZWxlbSApICkge1xuXHRcdFx0XHR3aW4gPSBlbGVtO1xuXHRcdFx0fSBlbHNlIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0d2luID0gZWxlbS5kZWZhdWx0Vmlldztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHdpbiA/IHdpblsgcHJvcCBdIDogZWxlbVsgbWV0aG9kIF07XG5cdFx0XHR9XG5cblx0XHRcdGlmICggd2luICkge1xuXHRcdFx0XHR3aW4uc2Nyb2xsVG8oXG5cdFx0XHRcdFx0IXRvcCA/IHZhbCA6IHdpbi5wYWdlWE9mZnNldCxcblx0XHRcdFx0XHR0b3AgPyB2YWwgOiB3aW4ucGFnZVlPZmZzZXRcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbVsgbWV0aG9kIF0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSwgbWV0aG9kLCB2YWwsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fTtcbn0gKTtcblxuLy8gU3VwcG9ydDogU2FmYXJpIDw9NyAtIDkuMSwgQ2hyb21lIDw9MzcgLSA0OVxuLy8gQWRkIHRoZSB0b3AvbGVmdCBjc3NIb29rcyB1c2luZyBqUXVlcnkuZm4ucG9zaXRpb25cbi8vIFdlYmtpdCBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTA4NFxuLy8gQmxpbmsgYnVnOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD01ODkzNDdcbi8vIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyBwZXJjZW50IHdoZW4gc3BlY2lmaWVkIGZvciB0b3AvbGVmdC9ib3R0b20vcmlnaHQ7XG4vLyByYXRoZXIgdGhhbiBtYWtlIHRoZSBjc3MgbW9kdWxlIGRlcGVuZCBvbiB0aGUgb2Zmc2V0IG1vZHVsZSwganVzdCBjaGVjayBmb3IgaXQgaGVyZVxualF1ZXJ5LmVhY2goIFsgXCJ0b3BcIiwgXCJsZWZ0XCIgXSwgZnVuY3Rpb24oIGksIHByb3AgKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJvcCBdID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnBpeGVsUG9zaXRpb24sXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdFx0Y29tcHV0ZWQgPSBjdXJDU1MoIGVsZW0sIHByb3AgKTtcblxuXHRcdFx0XHQvLyBJZiBjdXJDU1MgcmV0dXJucyBwZXJjZW50YWdlLCBmYWxsYmFjayB0byBvZmZzZXRcblx0XHRcdFx0cmV0dXJuIHJudW1ub25weC50ZXN0KCBjb21wdXRlZCApID9cblx0XHRcdFx0XHRqUXVlcnkoIGVsZW0gKS5wb3NpdGlvbigpWyBwcm9wIF0gKyBcInB4XCIgOlxuXHRcdFx0XHRcdGNvbXB1dGVkO1xuXHRcdFx0fVxuXHRcdH1cblx0KTtcbn0gKTtcblxuXG4vLyBDcmVhdGUgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIGhlaWdodCwgd2lkdGgsIG91dGVySGVpZ2h0IGFuZCBvdXRlcldpZHRoIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IEhlaWdodDogXCJoZWlnaHRcIiwgV2lkdGg6IFwid2lkdGhcIiB9LCBmdW5jdGlvbiggbmFtZSwgdHlwZSApIHtcblx0alF1ZXJ5LmVhY2goIHsgcGFkZGluZzogXCJpbm5lclwiICsgbmFtZSwgY29udGVudDogdHlwZSwgXCJcIjogXCJvdXRlclwiICsgbmFtZSB9LFxuXHRcdGZ1bmN0aW9uKCBkZWZhdWx0RXh0cmEsIGZ1bmNOYW1lICkge1xuXG5cdFx0Ly8gTWFyZ2luIGlzIG9ubHkgZm9yIG91dGVySGVpZ2h0LCBvdXRlcldpZHRoXG5cdFx0alF1ZXJ5LmZuWyBmdW5jTmFtZSBdID0gZnVuY3Rpb24oIG1hcmdpbiwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgY2hhaW5hYmxlID0gYXJndW1lbnRzLmxlbmd0aCAmJiAoIGRlZmF1bHRFeHRyYSB8fCB0eXBlb2YgbWFyZ2luICE9PSBcImJvb2xlYW5cIiApLFxuXHRcdFx0XHRleHRyYSA9IGRlZmF1bHRFeHRyYSB8fCAoIG1hcmdpbiA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gdHJ1ZSA/IFwibWFyZ2luXCIgOiBcImJvcmRlclwiICk7XG5cblx0XHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIGRvYztcblxuXHRcdFx0XHRpZiAoIGlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyAkKCB3aW5kb3cgKS5vdXRlcldpZHRoL0hlaWdodCByZXR1cm4gdy9oIGluY2x1ZGluZyBzY3JvbGxiYXJzIChnaC0xNzI5KVxuXHRcdFx0XHRcdHJldHVybiBmdW5jTmFtZS5pbmRleE9mKCBcIm91dGVyXCIgKSA9PT0gMCA/XG5cdFx0XHRcdFx0XHRlbGVtWyBcImlubmVyXCIgKyBuYW1lIF0gOlxuXHRcdFx0XHRcdFx0ZWxlbS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbIFwiY2xpZW50XCIgKyBuYW1lIF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBHZXQgZG9jdW1lbnQgd2lkdGggb3IgaGVpZ2h0XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRkb2MgPSBlbGVtLmRvY3VtZW50RWxlbWVudDtcblxuXHRcdFx0XHRcdC8vIEVpdGhlciBzY3JvbGxbV2lkdGgvSGVpZ2h0XSBvciBvZmZzZXRbV2lkdGgvSGVpZ2h0XSBvciBjbGllbnRbV2lkdGgvSGVpZ2h0XSxcblx0XHRcdFx0XHQvLyB3aGljaGV2ZXIgaXMgZ3JlYXRlc3Rcblx0XHRcdFx0XHRyZXR1cm4gTWF0aC5tYXgoXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwic2Nyb2xsXCIgKyBuYW1lIF0sIGRvY1sgXCJzY3JvbGxcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJvZmZzZXRcIiArIG5hbWUgXSwgZG9jWyBcIm9mZnNldFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZG9jWyBcImNsaWVudFwiICsgbmFtZSBdXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblxuXHRcdFx0XHRcdC8vIEdldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnQsIHJlcXVlc3RpbmcgYnV0IG5vdCBmb3JjaW5nIHBhcnNlRmxvYXRcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCB0eXBlLCBleHRyYSApIDpcblxuXHRcdFx0XHRcdC8vIFNldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnRcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHR5cGUsIHZhbHVlLCBleHRyYSApO1xuXHRcdFx0fSwgdHlwZSwgY2hhaW5hYmxlID8gbWFyZ2luIDogdW5kZWZpbmVkLCBjaGFpbmFibGUgKTtcblx0XHR9O1xuXHR9ICk7XG59ICk7XG5cblxualF1ZXJ5LmVhY2goICggXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgcmVzaXplIHNjcm9sbCBjbGljayBkYmxjbGljayBcIiArXG5cdFwibW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgXCIgK1xuXHRcImNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgY29udGV4dG1lbnVcIiApLnNwbGl0KCBcIiBcIiApLFxuXHRmdW5jdGlvbiggaSwgbmFtZSApIHtcblxuXHQvLyBIYW5kbGUgZXZlbnQgYmluZGluZ1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xuXHRcdFx0dGhpcy5vbiggbmFtZSwgbnVsbCwgZGF0YSwgZm4gKSA6XG5cdFx0XHR0aGlzLnRyaWdnZXIoIG5hbWUgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRob3ZlcjogZnVuY3Rpb24oIGZuT3ZlciwgZm5PdXQgKSB7XG5cdFx0cmV0dXJuIHRoaXMubW91c2VlbnRlciggZm5PdmVyICkubW91c2VsZWF2ZSggZm5PdXQgfHwgZm5PdmVyICk7XG5cdH1cbn0gKTtcblxuXG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdGJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBudWxsLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub2ZmKCB0eXBlcywgbnVsbCwgZm4gKTtcblx0fSxcblxuXHRkZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5kZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZm4gKSB7XG5cblx0XHQvLyAoIG5hbWVzcGFjZSApIG9yICggc2VsZWN0b3IsIHR5cGVzIFssIGZuXSApXG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgP1xuXHRcdFx0dGhpcy5vZmYoIHNlbGVjdG9yLCBcIioqXCIgKSA6XG5cdFx0XHR0aGlzLm9mZiggdHlwZXMsIHNlbGVjdG9yIHx8IFwiKipcIiwgZm4gKTtcblx0fVxufSApO1xuXG4vLyBCaW5kIGEgZnVuY3Rpb24gdG8gYSBjb250ZXh0LCBvcHRpb25hbGx5IHBhcnRpYWxseSBhcHBseWluZyBhbnlcbi8vIGFyZ3VtZW50cy5cbi8vIGpRdWVyeS5wcm94eSBpcyBkZXByZWNhdGVkIHRvIHByb21vdGUgc3RhbmRhcmRzIChzcGVjaWZpY2FsbHkgRnVuY3Rpb24jYmluZClcbi8vIEhvd2V2ZXIsIGl0IGlzIG5vdCBzbGF0ZWQgZm9yIHJlbW92YWwgYW55IHRpbWUgc29vblxualF1ZXJ5LnByb3h5ID0gZnVuY3Rpb24oIGZuLCBjb250ZXh0ICkge1xuXHR2YXIgdG1wLCBhcmdzLCBwcm94eTtcblxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdHRtcCA9IGZuWyBjb250ZXh0IF07XG5cdFx0Y29udGV4dCA9IGZuO1xuXHRcdGZuID0gdG1wO1xuXHR9XG5cblx0Ly8gUXVpY2sgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRhcmdldCBpcyBjYWxsYWJsZSwgaW4gdGhlIHNwZWNcblx0Ly8gdGhpcyB0aHJvd3MgYSBUeXBlRXJyb3IsIGJ1dCB3ZSB3aWxsIGp1c3QgcmV0dXJuIHVuZGVmaW5lZC5cblx0aWYgKCAhaXNGdW5jdGlvbiggZm4gKSApIHtcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHR9XG5cblx0Ly8gU2ltdWxhdGVkIGJpbmRcblx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMiApO1xuXHRwcm94eSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBmbi5hcHBseSggY29udGV4dCB8fCB0aGlzLCBhcmdzLmNvbmNhdCggc2xpY2UuY2FsbCggYXJndW1lbnRzICkgKSApO1xuXHR9O1xuXG5cdC8vIFNldCB0aGUgZ3VpZCBvZiB1bmlxdWUgaGFuZGxlciB0byB0aGUgc2FtZSBvZiBvcmlnaW5hbCBoYW5kbGVyLCBzbyBpdCBjYW4gYmUgcmVtb3ZlZFxuXHRwcm94eS5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgalF1ZXJ5Lmd1aWQrKztcblxuXHRyZXR1cm4gcHJveHk7XG59O1xuXG5qUXVlcnkuaG9sZFJlYWR5ID0gZnVuY3Rpb24oIGhvbGQgKSB7XG5cdGlmICggaG9sZCApIHtcblx0XHRqUXVlcnkucmVhZHlXYWl0Kys7XG5cdH0gZWxzZSB7XG5cdFx0alF1ZXJ5LnJlYWR5KCB0cnVlICk7XG5cdH1cbn07XG5qUXVlcnkuaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5qUXVlcnkucGFyc2VKU09OID0gSlNPTi5wYXJzZTtcbmpRdWVyeS5ub2RlTmFtZSA9IG5vZGVOYW1lO1xualF1ZXJ5LmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xualF1ZXJ5LmlzV2luZG93ID0gaXNXaW5kb3c7XG5qUXVlcnkuY2FtZWxDYXNlID0gY2FtZWxDYXNlO1xualF1ZXJ5LnR5cGUgPSB0b1R5cGU7XG5cbmpRdWVyeS5ub3cgPSBEYXRlLm5vdztcblxualF1ZXJ5LmlzTnVtZXJpYyA9IGZ1bmN0aW9uKCBvYmogKSB7XG5cblx0Ly8gQXMgb2YgalF1ZXJ5IDMuMCwgaXNOdW1lcmljIGlzIGxpbWl0ZWQgdG9cblx0Ly8gc3RyaW5ncyBhbmQgbnVtYmVycyAocHJpbWl0aXZlcyBvciBvYmplY3RzKVxuXHQvLyB0aGF0IGNhbiBiZSBjb2VyY2VkIHRvIGZpbml0ZSBudW1iZXJzIChnaC0yNjYyKVxuXHR2YXIgdHlwZSA9IGpRdWVyeS50eXBlKCBvYmogKTtcblx0cmV0dXJuICggdHlwZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlID09PSBcInN0cmluZ1wiICkgJiZcblxuXHRcdC8vIHBhcnNlRmxvYXQgTmFOcyBudW1lcmljLWNhc3QgZmFsc2UgcG9zaXRpdmVzIChcIlwiKVxuXHRcdC8vIC4uLmJ1dCBtaXNpbnRlcnByZXRzIGxlYWRpbmctbnVtYmVyIHN0cmluZ3MsIHBhcnRpY3VsYXJseSBoZXggbGl0ZXJhbHMgKFwiMHguLi5cIilcblx0XHQvLyBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cblx0XHQhaXNOYU4oIG9iaiAtIHBhcnNlRmxvYXQoIG9iaiApICk7XG59O1xuXG5cblxuXG4vLyBSZWdpc3RlciBhcyBhIG5hbWVkIEFNRCBtb2R1bGUsIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcbi8vIGZpbGVzIHRoYXQgbWF5IHVzZSBkZWZpbmUsIGJ1dCBub3QgdmlhIGEgcHJvcGVyIGNvbmNhdGVuYXRpb24gc2NyaXB0IHRoYXRcbi8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxuLy8gd2F5IHRvIHJlZ2lzdGVyLiBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZVxuLy8gZGVyaXZlZCBmcm9tIGZpbGUgbmFtZXMsIGFuZCBqUXVlcnkgaXMgbm9ybWFsbHkgZGVsaXZlcmVkIGluIGEgbG93ZXJjYXNlXG4vLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcbi8vIHRvIGNhbGwgbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cblxuLy8gTm90ZSB0aGF0IGZvciBtYXhpbXVtIHBvcnRhYmlsaXR5LCBsaWJyYXJpZXMgdGhhdCBhcmUgbm90IGpRdWVyeSBzaG91bGRcbi8vIGRlY2xhcmUgdGhlbXNlbHZlcyBhcyBhbm9ueW1vdXMgbW9kdWxlcywgYW5kIGF2b2lkIHNldHRpbmcgYSBnbG9iYWwgaWYgYW5cbi8vIEFNRCBsb2FkZXIgaXMgcHJlc2VudC4galF1ZXJ5IGlzIGEgc3BlY2lhbCBjYXNlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanJidXJrZS9yZXF1aXJlanMvd2lraS9VcGRhdGluZy1leGlzdGluZy1saWJyYXJpZXMjd2lraS1hbm9uXG5cbmlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdGRlZmluZSggXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnk7XG5cdH0gKTtcbn1cblxuXG5cblxudmFyXG5cblx0Ly8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF9qUXVlcnkgPSB3aW5kb3cualF1ZXJ5LFxuXG5cdC8vIE1hcCBvdmVyIHRoZSAkIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF8kID0gd2luZG93LiQ7XG5cbmpRdWVyeS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oIGRlZXAgKSB7XG5cdGlmICggd2luZG93LiQgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cuJCA9IF8kO1xuXHR9XG5cblx0aWYgKCBkZWVwICYmIHdpbmRvdy5qUXVlcnkgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cualF1ZXJ5ID0gX2pRdWVyeTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnk7XG59O1xuXG4vLyBFeHBvc2UgalF1ZXJ5IGFuZCAkIGlkZW50aWZpZXJzLCBldmVuIGluIEFNRFxuLy8gKCM3MTAyI2NvbW1lbnQ6MTAsIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNTU3KVxuLy8gYW5kIENvbW1vbkpTIGZvciBicm93c2VyIGVtdWxhdG9ycyAoIzEzNTY2KVxuaWYgKCAhbm9HbG9iYWwgKSB7XG5cdHdpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IGpRdWVyeTtcbn1cblxuXG5cblxucmV0dXJuIGpRdWVyeTtcbn0gKTtcbiIsIi8qISBEYXRhVGFibGVzIDEuMTAuN1xuICogwqkyMDA4LTIwMTQgU3ByeU1lZGlhIEx0ZCAtIGRhdGF0YWJsZXMubmV0L2xpY2Vuc2VcbiAqL1xuXG4vKipcbiAqIEBzdW1tYXJ5ICAgICBEYXRhVGFibGVzXG4gKiBAZGVzY3JpcHRpb24gUGFnaW5hdGUsIHNlYXJjaCBhbmQgb3JkZXIgSFRNTCB0YWJsZXNcbiAqIEB2ZXJzaW9uICAgICAxLjEwLjdcbiAqIEBmaWxlICAgICAgICBqcXVlcnkuZGF0YVRhYmxlcy5qc1xuICogQGF1dGhvciAgICAgIFNwcnlNZWRpYSBMdGQgKHd3dy5zcHJ5bWVkaWEuY28udWspXG4gKiBAY29udGFjdCAgICAgd3d3LnNwcnltZWRpYS5jby51ay9jb250YWN0XG4gKiBAY29weXJpZ2h0ICAgQ29weXJpZ2h0IDIwMDgtMjAxNCBTcHJ5TWVkaWEgTHRkLlxuICpcbiAqIFRoaXMgc291cmNlIGZpbGUgaXMgZnJlZSBzb2Z0d2FyZSwgYXZhaWxhYmxlIHVuZGVyIHRoZSBmb2xsb3dpbmcgbGljZW5zZTpcbiAqICAgTUlUIGxpY2Vuc2UgLSBodHRwOi8vZGF0YXRhYmxlcy5uZXQvbGljZW5zZVxuICpcbiAqIFRoaXMgc291cmNlIGZpbGUgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0XG4gKiBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICogb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgbGljZW5zZSBmaWxlcyBmb3IgZGV0YWlscy5cbiAqXG4gKiBGb3IgZGV0YWlscyBwbGVhc2UgcmVmZXIgdG86IGh0dHA6Ly93d3cuZGF0YXRhYmxlcy5uZXRcbiAqL1xuXG4vKmpzbGludCBldmlsOiB0cnVlLCB1bmRlZjogdHJ1ZSwgYnJvd3NlcjogdHJ1ZSAqL1xuLypnbG9iYWxzICQscmVxdWlyZSxqUXVlcnksZGVmaW5lLF9zZWxlY3Rvcl9ydW4sX3NlbGVjdG9yX29wdHMsX3NlbGVjdG9yX2ZpcnN0LF9zZWxlY3Rvcl9yb3dfaW5kZXhlcyxfZXh0LF9BcGksX2FwaV9yZWdpc3RlcixfYXBpX3JlZ2lzdGVyUGx1cmFsLF9yZV9uZXdfbGluZXMsX3JlX2h0bWwsX3JlX2Zvcm1hdHRlZF9udW1lcmljLF9yZV9lc2NhcGVfcmVnZXgsX2VtcHR5LF9pbnRWYWwsX251bVRvRGVjaW1hbCxfaXNOdW1iZXIsX2lzSHRtbCxfaHRtbE51bWVyaWMsX3BsdWNrLF9wbHVja19vcmRlcixfcmFuZ2UsX3N0cmlwSHRtbCxfdW5pcXVlLF9mbkJ1aWxkQWpheCxfZm5BamF4VXBkYXRlLF9mbkFqYXhQYXJhbWV0ZXJzLF9mbkFqYXhVcGRhdGVEcmF3LF9mbkFqYXhEYXRhU3JjLF9mbkFkZENvbHVtbixfZm5Db2x1bW5PcHRpb25zLF9mbkFkanVzdENvbHVtblNpemluZyxfZm5WaXNpYmxlVG9Db2x1bW5JbmRleCxfZm5Db2x1bW5JbmRleFRvVmlzaWJsZSxfZm5WaXNibGVDb2x1bW5zLF9mbkdldENvbHVtbnMsX2ZuQ29sdW1uVHlwZXMsX2ZuQXBwbHlDb2x1bW5EZWZzLF9mbkh1bmdhcmlhbk1hcCxfZm5DYW1lbFRvSHVuZ2FyaWFuLF9mbkxhbmd1YWdlQ29tcGF0LF9mbkJyb3dzZXJEZXRlY3QsX2ZuQWRkRGF0YSxfZm5BZGRUcixfZm5Ob2RlVG9EYXRhSW5kZXgsX2ZuTm9kZVRvQ29sdW1uSW5kZXgsX2ZuR2V0Q2VsbERhdGEsX2ZuU2V0Q2VsbERhdGEsX2ZuU3BsaXRPYmpOb3RhdGlvbixfZm5HZXRPYmplY3REYXRhRm4sX2ZuU2V0T2JqZWN0RGF0YUZuLF9mbkdldERhdGFNYXN0ZXIsX2ZuQ2xlYXJUYWJsZSxfZm5EZWxldGVJbmRleCxfZm5JbnZhbGlkYXRlLF9mbkdldFJvd0VsZW1lbnRzLF9mbkNyZWF0ZVRyLF9mbkJ1aWxkSGVhZCxfZm5EcmF3SGVhZCxfZm5EcmF3LF9mblJlRHJhdyxfZm5BZGRPcHRpb25zSHRtbCxfZm5EZXRlY3RIZWFkZXIsX2ZuR2V0VW5pcXVlVGhzLF9mbkZlYXR1cmVIdG1sRmlsdGVyLF9mbkZpbHRlckNvbXBsZXRlLF9mbkZpbHRlckN1c3RvbSxfZm5GaWx0ZXJDb2x1bW4sX2ZuRmlsdGVyLF9mbkZpbHRlckNyZWF0ZVNlYXJjaCxfZm5Fc2NhcGVSZWdleCxfZm5GaWx0ZXJEYXRhLF9mbkZlYXR1cmVIdG1sSW5mbyxfZm5VcGRhdGVJbmZvLF9mbkluZm9NYWNyb3MsX2ZuSW5pdGlhbGlzZSxfZm5Jbml0Q29tcGxldGUsX2ZuTGVuZ3RoQ2hhbmdlLF9mbkZlYXR1cmVIdG1sTGVuZ3RoLF9mbkZlYXR1cmVIdG1sUGFnaW5hdGUsX2ZuUGFnZUNoYW5nZSxfZm5GZWF0dXJlSHRtbFByb2Nlc3NpbmcsX2ZuUHJvY2Vzc2luZ0Rpc3BsYXksX2ZuRmVhdHVyZUh0bWxUYWJsZSxfZm5TY3JvbGxEcmF3LF9mbkFwcGx5VG9DaGlsZHJlbixfZm5DYWxjdWxhdGVDb2x1bW5XaWR0aHMsX2ZuVGhyb3R0bGUsX2ZuQ29udmVydFRvV2lkdGgsX2ZuU2Nyb2xsaW5nV2lkdGhBZGp1c3QsX2ZuR2V0V2lkZXN0Tm9kZSxfZm5HZXRNYXhMZW5TdHJpbmcsX2ZuU3RyaW5nVG9Dc3MsX2ZuU2Nyb2xsQmFyV2lkdGgsX2ZuU29ydEZsYXR0ZW4sX2ZuU29ydCxfZm5Tb3J0QXJpYSxfZm5Tb3J0TGlzdGVuZXIsX2ZuU29ydEF0dGFjaExpc3RlbmVyLF9mblNvcnRpbmdDbGFzc2VzLF9mblNvcnREYXRhLF9mblNhdmVTdGF0ZSxfZm5Mb2FkU3RhdGUsX2ZuU2V0dGluZ3NGcm9tTm9kZSxfZm5Mb2csX2ZuTWFwLF9mbkJpbmRBY3Rpb24sX2ZuQ2FsbGJhY2tSZWcsX2ZuQ2FsbGJhY2tGaXJlLF9mbkxlbmd0aE92ZXJmbG93LF9mblJlbmRlcmVyLF9mbkRhdGFTb3VyY2UsX2ZuUm93QXR0cmlidXRlcyovXG5cbigvKiogQGxlbmRzIDxnbG9iYWw+ICovZnVuY3Rpb24oIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCApIHtcblxuKGZ1bmN0aW9uKCBmYWN0b3J5ICkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcblx0XHQvLyBEZWZpbmUgYXMgYW4gQU1EIG1vZHVsZSBpZiBwb3NzaWJsZVxuXHRcdGRlZmluZSggJ2RhdGF0YWJsZXMnLCBbJ2pxdWVyeSddLCBmYWN0b3J5ICk7XG5cdH1cbiAgICBlbHNlIGlmICggdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICkge1xuICAgICAgICAvLyBOb2RlL0NvbW1vbkpTXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSggcmVxdWlyZSggJ2pxdWVyeScgKSApO1xuICAgIH1cblx0ZWxzZSBpZiAoIGpRdWVyeSAmJiAhalF1ZXJ5LmZuLmRhdGFUYWJsZSApIHtcblx0XHQvLyBEZWZpbmUgdXNpbmcgYnJvd3NlciBnbG9iYWxzIG90aGVyd2lzZVxuXHRcdC8vIFByZXZlbnQgbXVsdGlwbGUgaW5zdGFudGlhdGlvbnMgaWYgdGhlIHNjcmlwdCBpcyBsb2FkZWQgdHdpY2Vcblx0XHRmYWN0b3J5KCBqUXVlcnkgKTtcblx0fVxufVxuKC8qKiBAbGVuZHMgPGdsb2JhbD4gKi9mdW5jdGlvbiggJCApIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyoqXG5cdCAqIERhdGFUYWJsZXMgaXMgYSBwbHVnLWluIGZvciB0aGUgalF1ZXJ5IEphdmFzY3JpcHQgbGlicmFyeS4gSXQgaXMgYSBoaWdobHlcblx0ICogZmxleGlibGUgdG9vbCwgYmFzZWQgdXBvbiB0aGUgZm91bmRhdGlvbnMgb2YgcHJvZ3Jlc3NpdmUgZW5oYW5jZW1lbnQsXG5cdCAqIHdoaWNoIHdpbGwgYWRkIGFkdmFuY2VkIGludGVyYWN0aW9uIGNvbnRyb2xzIHRvIGFueSBIVE1MIHRhYmxlLiBGb3IgYVxuXHQgKiBmdWxsIGxpc3Qgb2YgZmVhdHVyZXMgcGxlYXNlIHJlZmVyIHRvXG5cdCAqIFtEYXRhVGFibGVzLm5ldF0oaHJlZj1cImh0dHA6Ly9kYXRhdGFibGVzLm5ldCkuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCB0aGUgYERhdGFUYWJsZWAgb2JqZWN0IGlzIG5vdCBhIGdsb2JhbCB2YXJpYWJsZSBidXQgaXMgYWxpYXNlZFxuXHQgKiB0byBgalF1ZXJ5LmZuLkRhdGFUYWJsZWAgYW5kIGBqUXVlcnkuZm4uZGF0YVRhYmxlYCB0aHJvdWdoIHdoaWNoIGl0IG1heVxuXHQgKiBiZSAgYWNjZXNzZWQuXG5cdCAqXG5cdCAqICBAY2xhc3Ncblx0ICogIEBwYXJhbSB7b2JqZWN0fSBbaW5pdD17fV0gQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIERhdGFUYWJsZXMuIE9wdGlvbnNcblx0ICogICAgYXJlIGRlZmluZWQgYnkge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c31cblx0ICogIEByZXF1aXJlcyBqUXVlcnkgMS43K1xuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgLy8gQmFzaWMgaW5pdGlhbGlzYXRpb25cblx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uIHtcblx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHQgKiAgICB9ICk7XG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAvLyBJbml0aWFsaXNhdGlvbiB3aXRoIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyAtIGluIHRoaXMgY2FzZSwgZGlzYWJsZVxuXHQgKiAgICAvLyBwYWdpbmF0aW9uIGFuZCBzb3J0aW5nLlxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24ge1xuXHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdCAqICAgICAgICBcInBhZ2luYXRlXCI6IGZhbHNlLFxuXHQgKiAgICAgICAgXCJzb3J0XCI6IGZhbHNlXG5cdCAqICAgICAgfSApO1xuXHQgKiAgICB9ICk7XG5cdCAqL1xuXHR2YXIgRGF0YVRhYmxlO1xuXG5cdFxuXHQvKlxuXHQgKiBJdCBpcyB1c2VmdWwgdG8gaGF2ZSB2YXJpYWJsZXMgd2hpY2ggYXJlIHNjb3BlZCBsb2NhbGx5IHNvIG9ubHkgdGhlXG5cdCAqIERhdGFUYWJsZXMgZnVuY3Rpb25zIGNhbiBhY2Nlc3MgdGhlbSBhbmQgdGhleSBkb24ndCBsZWFrIGludG8gZ2xvYmFsIHNwYWNlLlxuXHQgKiBBdCB0aGUgc2FtZSB0aW1lIHRoZXNlIGZ1bmN0aW9ucyBhcmUgb2Z0ZW4gdXNlZnVsIG92ZXIgbXVsdGlwbGUgZmlsZXMgaW4gdGhlXG5cdCAqIGNvcmUgYW5kIEFQSSwgc28gd2UgbGlzdCwgb3IgYXQgbGVhc3QgZG9jdW1lbnQsIGFsbCB2YXJpYWJsZXMgd2hpY2ggYXJlIHVzZWRcblx0ICogYnkgRGF0YVRhYmxlcyBhcyBwcml2YXRlIHZhcmlhYmxlcyBoZXJlLiBUaGlzIGFsc28gZW5zdXJlcyB0aGF0IHRoZXJlIGlzIG5vXG5cdCAqIGNsYXNoaW5nIG9mIHZhcmlhYmxlIG5hbWVzIGFuZCB0aGF0IHRoZXkgY2FuIGVhc2lseSByZWZlcmVuY2VkIGZvciByZXVzZS5cblx0ICovXG5cdFxuXHRcblx0Ly8gRGVmaW5lZCBlbHNlIHdoZXJlXG5cdC8vICBfc2VsZWN0b3JfcnVuXG5cdC8vICBfc2VsZWN0b3Jfb3B0c1xuXHQvLyAgX3NlbGVjdG9yX2ZpcnN0XG5cdC8vICBfc2VsZWN0b3Jfcm93X2luZGV4ZXNcblx0XG5cdHZhciBfZXh0OyAvLyBEYXRhVGFibGUuZXh0XG5cdHZhciBfQXBpOyAvLyBEYXRhVGFibGUuQXBpXG5cdHZhciBfYXBpX3JlZ2lzdGVyOyAvLyBEYXRhVGFibGUuQXBpLnJlZ2lzdGVyXG5cdHZhciBfYXBpX3JlZ2lzdGVyUGx1cmFsOyAvLyBEYXRhVGFibGUuQXBpLnJlZ2lzdGVyUGx1cmFsXG5cdFxuXHR2YXIgX3JlX2RpYyA9IHt9O1xuXHR2YXIgX3JlX25ld19saW5lcyA9IC9bXFxyXFxuXS9nO1xuXHR2YXIgX3JlX2h0bWwgPSAvPC4qPz4vZztcblx0dmFyIF9yZV9kYXRlX3N0YXJ0ID0gL15bXFx3XFwrXFwtXS87XG5cdHZhciBfcmVfZGF0ZV9lbmQgPSAvW1xcd1xcK1xcLV0kLztcblx0XG5cdC8vIEVzY2FwZSByZWd1bGFyIGV4cHJlc3Npb24gc3BlY2lhbCBjaGFyYWN0ZXJzXG5cdHZhciBfcmVfZXNjYXBlX3JlZ2V4ID0gbmV3IFJlZ0V4cCggJyhcXFxcJyArIFsgJy8nLCAnLicsICcqJywgJysnLCAnPycsICd8JywgJygnLCAnKScsICdbJywgJ10nLCAneycsICd9JywgJ1xcXFwnLCAnJCcsICdeJywgJy0nIF0uam9pbignfFxcXFwnKSArICcpJywgJ2cnICk7XG5cdFxuXHQvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ZvcmVpZ25fZXhjaGFuZ2VfbWFya2V0XG5cdC8vIC0gXFx1MjBCRCAtIFJ1c3NpYW4gcnVibGUuXG5cdC8vIC0gXFx1MjBhOSAtIFNvdXRoIEtvcmVhbiBXb25cblx0Ly8gLSBcXHUyMEJBIC0gVHVya2lzaCBMaXJhXG5cdC8vIC0gXFx1MjBCOSAtIEluZGlhbiBSdXBlZVxuXHQvLyAtIFIgLSBCcmF6aWwgKFIkKSBhbmQgU291dGggQWZyaWNhXG5cdC8vIC0gZnIgLSBTd2lzcyBGcmFuY1xuXHQvLyAtIGtyIC0gU3dlZGlzaCBrcm9uYSwgTm9yd2VnaWFuIGtyb25lIGFuZCBEYW5pc2gga3JvbmVcblx0Ly8gLSBcXHUyMDA5IGlzIHRoaW4gc3BhY2UgYW5kIFxcdTIwMkYgaXMgbmFycm93IG5vLWJyZWFrIHNwYWNlLCBib3RoIHVzZWQgaW4gbWFueVxuXHQvLyAgIHN0YW5kYXJkcyBhcyB0aG91c2FuZHMgc2VwYXJhdG9ycy5cblx0dmFyIF9yZV9mb3JtYXR0ZWRfbnVtZXJpYyA9IC9bJywkwqPigqzCpSVcXHUyMDA5XFx1MjAyRlxcdTIwQkRcXHUyMGE5XFx1MjBCQXJma10vZ2k7XG5cdFxuXHRcblx0dmFyIF9lbXB0eSA9IGZ1bmN0aW9uICggZCApIHtcblx0XHRyZXR1cm4gIWQgfHwgZCA9PT0gdHJ1ZSB8fCBkID09PSAnLScgPyB0cnVlIDogZmFsc2U7XG5cdH07XG5cdFxuXHRcblx0dmFyIF9pbnRWYWwgPSBmdW5jdGlvbiAoIHMgKSB7XG5cdFx0dmFyIGludGVnZXIgPSBwYXJzZUludCggcywgMTAgKTtcblx0XHRyZXR1cm4gIWlzTmFOKGludGVnZXIpICYmIGlzRmluaXRlKHMpID8gaW50ZWdlciA6IG51bGw7XG5cdH07XG5cdFxuXHQvLyBDb252ZXJ0IGZyb20gYSBmb3JtYXR0ZWQgbnVtYmVyIHdpdGggY2hhcmFjdGVycyBvdGhlciB0aGFuIGAuYCBhcyB0aGVcblx0Ly8gZGVjaW1hbCBwbGFjZSwgdG8gYSBKYXZhc2NyaXB0IG51bWJlclxuXHR2YXIgX251bVRvRGVjaW1hbCA9IGZ1bmN0aW9uICggbnVtLCBkZWNpbWFsUG9pbnQgKSB7XG5cdFx0Ly8gQ2FjaGUgY3JlYXRlZCByZWd1bGFyIGV4cHJlc3Npb25zIGZvciBzcGVlZCBhcyB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvZnRlblxuXHRcdGlmICggISBfcmVfZGljWyBkZWNpbWFsUG9pbnQgXSApIHtcblx0XHRcdF9yZV9kaWNbIGRlY2ltYWxQb2ludCBdID0gbmV3IFJlZ0V4cCggX2ZuRXNjYXBlUmVnZXgoIGRlY2ltYWxQb2ludCApLCAnZycgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHR5cGVvZiBudW0gPT09ICdzdHJpbmcnICYmIGRlY2ltYWxQb2ludCAhPT0gJy4nID9cblx0XHRcdG51bS5yZXBsYWNlKCAvXFwuL2csICcnICkucmVwbGFjZSggX3JlX2RpY1sgZGVjaW1hbFBvaW50IF0sICcuJyApIDpcblx0XHRcdG51bTtcblx0fTtcblx0XG5cdFxuXHR2YXIgX2lzTnVtYmVyID0gZnVuY3Rpb24gKCBkLCBkZWNpbWFsUG9pbnQsIGZvcm1hdHRlZCApIHtcblx0XHR2YXIgc3RyVHlwZSA9IHR5cGVvZiBkID09PSAnc3RyaW5nJztcblx0XG5cdFx0Ly8gSWYgZW1wdHkgcmV0dXJuIGltbWVkaWF0ZWx5IHNvIHRoZXJlIG11c3QgYmUgYSBudW1iZXIgaWYgaXQgaXMgYVxuXHRcdC8vIGZvcm1hdHRlZCBzdHJpbmcgKHRoaXMgc3RvcHMgdGhlIHN0cmluZyBcImtcIiwgb3IgXCJrclwiLCBldGMgYmVpbmcgZGV0ZWN0ZWRcblx0XHQvLyBhcyBhIGZvcm1hdHRlZCBudW1iZXIgZm9yIGN1cnJlbmN5XG5cdFx0aWYgKCBfZW1wdHkoIGQgKSApIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XG5cdFx0aWYgKCBkZWNpbWFsUG9pbnQgJiYgc3RyVHlwZSApIHtcblx0XHRcdGQgPSBfbnVtVG9EZWNpbWFsKCBkLCBkZWNpbWFsUG9pbnQgKTtcblx0XHR9XG5cdFxuXHRcdGlmICggZm9ybWF0dGVkICYmIHN0clR5cGUgKSB7XG5cdFx0XHRkID0gZC5yZXBsYWNlKCBfcmVfZm9ybWF0dGVkX251bWVyaWMsICcnICk7XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gIWlzTmFOKCBwYXJzZUZsb2F0KGQpICkgJiYgaXNGaW5pdGUoIGQgKTtcblx0fTtcblx0XG5cdFxuXHQvLyBBIHN0cmluZyB3aXRob3V0IEhUTUwgaW4gaXQgY2FuIGJlIGNvbnNpZGVyZWQgdG8gYmUgSFRNTCBzdGlsbFxuXHR2YXIgX2lzSHRtbCA9IGZ1bmN0aW9uICggZCApIHtcblx0XHRyZXR1cm4gX2VtcHR5KCBkICkgfHwgdHlwZW9mIGQgPT09ICdzdHJpbmcnO1xuXHR9O1xuXHRcblx0XG5cdHZhciBfaHRtbE51bWVyaWMgPSBmdW5jdGlvbiAoIGQsIGRlY2ltYWxQb2ludCwgZm9ybWF0dGVkICkge1xuXHRcdGlmICggX2VtcHR5KCBkICkgKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFxuXHRcdHZhciBodG1sID0gX2lzSHRtbCggZCApO1xuXHRcdHJldHVybiAhIGh0bWwgP1xuXHRcdFx0bnVsbCA6XG5cdFx0XHRfaXNOdW1iZXIoIF9zdHJpcEh0bWwoIGQgKSwgZGVjaW1hbFBvaW50LCBmb3JtYXR0ZWQgKSA/XG5cdFx0XHRcdHRydWUgOlxuXHRcdFx0XHRudWxsO1xuXHR9O1xuXHRcblx0XG5cdHZhciBfcGx1Y2sgPSBmdW5jdGlvbiAoIGEsIHByb3AsIHByb3AyICkge1xuXHRcdHZhciBvdXQgPSBbXTtcblx0XHR2YXIgaT0wLCBpZW49YS5sZW5ndGg7XG5cdFxuXHRcdC8vIENvdWxkIGhhdmUgdGhlIHRlc3QgaW4gdGhlIGxvb3AgZm9yIHNsaWdodGx5IHNtYWxsZXIgY29kZSwgYnV0IHNwZWVkXG5cdFx0Ly8gaXMgZXNzZW50aWFsIGhlcmVcblx0XHRpZiAoIHByb3AyICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRmb3IgKCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGFbaV0gJiYgYVtpXVsgcHJvcCBdICkge1xuXHRcdFx0XHRcdG91dC5wdXNoKCBhW2ldWyBwcm9wIF1bIHByb3AyIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGZvciAoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYVtpXSApIHtcblx0XHRcdFx0XHRvdXQucHVzaCggYVtpXVsgcHJvcCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdHJldHVybiBvdXQ7XG5cdH07XG5cdFxuXHRcblx0Ly8gQmFzaWNhbGx5IHRoZSBzYW1lIGFzIF9wbHVjaywgYnV0IHJhdGhlciB0aGFuIGxvb3Bpbmcgb3ZlciBgYWAgd2UgdXNlIGBvcmRlcmBcblx0Ly8gYXMgdGhlIGluZGV4ZXMgdG8gcGljayBmcm9tIGBhYFxuXHR2YXIgX3BsdWNrX29yZGVyID0gZnVuY3Rpb24gKCBhLCBvcmRlciwgcHJvcCwgcHJvcDIgKVxuXHR7XG5cdFx0dmFyIG91dCA9IFtdO1xuXHRcdHZhciBpPTAsIGllbj1vcmRlci5sZW5ndGg7XG5cdFxuXHRcdC8vIENvdWxkIGhhdmUgdGhlIHRlc3QgaW4gdGhlIGxvb3AgZm9yIHNsaWdodGx5IHNtYWxsZXIgY29kZSwgYnV0IHNwZWVkXG5cdFx0Ly8gaXMgZXNzZW50aWFsIGhlcmVcblx0XHRpZiAoIHByb3AyICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRmb3IgKCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGFbIG9yZGVyW2ldIF1bIHByb3AgXSApIHtcblx0XHRcdFx0XHRvdXQucHVzaCggYVsgb3JkZXJbaV0gXVsgcHJvcCBdWyBwcm9wMiBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRmb3IgKCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRvdXQucHVzaCggYVsgb3JkZXJbaV0gXVsgcHJvcCBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gb3V0O1xuXHR9O1xuXHRcblx0XG5cdHZhciBfcmFuZ2UgPSBmdW5jdGlvbiAoIGxlbiwgc3RhcnQgKVxuXHR7XG5cdFx0dmFyIG91dCA9IFtdO1xuXHRcdHZhciBlbmQ7XG5cdFxuXHRcdGlmICggc3RhcnQgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHN0YXJ0ID0gMDtcblx0XHRcdGVuZCA9IGxlbjtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRlbmQgPSBzdGFydDtcblx0XHRcdHN0YXJ0ID0gbGVuO1xuXHRcdH1cblx0XG5cdFx0Zm9yICggdmFyIGk9c3RhcnQgOyBpPGVuZCA7IGkrKyApIHtcblx0XHRcdG91dC5wdXNoKCBpICk7XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gb3V0O1xuXHR9O1xuXHRcblx0XG5cdHZhciBfcmVtb3ZlRW1wdHkgPSBmdW5jdGlvbiAoIGEgKVxuXHR7XG5cdFx0dmFyIG91dCA9IFtdO1xuXHRcblx0XHRmb3IgKCB2YXIgaT0wLCBpZW49YS5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdGlmICggYVtpXSApIHsgLy8gY2FyZWZ1bCAtIHdpbGwgcmVtb3ZlIGFsbCBmYWxzeSB2YWx1ZXMhXG5cdFx0XHRcdG91dC5wdXNoKCBhW2ldICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gb3V0O1xuXHR9O1xuXHRcblx0XG5cdHZhciBfc3RyaXBIdG1sID0gZnVuY3Rpb24gKCBkICkge1xuXHRcdHJldHVybiBkLnJlcGxhY2UoIF9yZV9odG1sLCAnJyApO1xuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHQgKiBGaW5kIHRoZSB1bmlxdWUgZWxlbWVudHMgaW4gYSBzb3VyY2UgYXJyYXkuXG5cdCAqXG5cdCAqIEBwYXJhbSAge2FycmF5fSBzcmMgU291cmNlIGFycmF5XG5cdCAqIEByZXR1cm4ge2FycmF5fSBBcnJheSBvZiB1bmlxdWUgaXRlbXNcblx0ICogQGlnbm9yZVxuXHQgKi9cblx0dmFyIF91bmlxdWUgPSBmdW5jdGlvbiAoIHNyYyApXG5cdHtcblx0XHQvLyBBIGZhc3RlciB1bmlxdWUgbWV0aG9kIGlzIHRvIHVzZSBvYmplY3Qga2V5cyB0byBpZGVudGlmeSB1c2VkIHZhbHVlcyxcblx0XHQvLyBidXQgdGhpcyBkb2Vzbid0IHdvcmsgd2l0aCBhcnJheXMgb3Igb2JqZWN0cywgd2hpY2ggd2UgbXVzdCBhbHNvXG5cdFx0Ly8gY29uc2lkZXIuIFNlZSBqc3BlcmYuY29tL2NvbXBhcmUtYXJyYXktdW5pcXVlLXZlcnNpb25zLzQgZm9yIG1vcmVcblx0XHQvLyBpbmZvcm1hdGlvbi5cblx0XHR2YXJcblx0XHRcdG91dCA9IFtdLFxuXHRcdFx0dmFsLFxuXHRcdFx0aSwgaWVuPXNyYy5sZW5ndGgsXG5cdFx0XHRqLCBrPTA7XG5cdFxuXHRcdGFnYWluOiBmb3IgKCBpPTAgOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdHZhbCA9IHNyY1tpXTtcblx0XG5cdFx0XHRmb3IgKCBqPTAgOyBqPGsgOyBqKysgKSB7XG5cdFx0XHRcdGlmICggb3V0W2pdID09PSB2YWwgKSB7XG5cdFx0XHRcdFx0Y29udGludWUgYWdhaW47XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHRvdXQucHVzaCggdmFsICk7XG5cdFx0XHRrKys7XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gb3V0O1xuXHR9O1xuXHRcblx0XG5cdFxuXHQvKipcblx0ICogQ3JlYXRlIGEgbWFwcGluZyBvYmplY3QgdGhhdCBhbGxvd3MgY2FtZWwgY2FzZSBwYXJhbWV0ZXJzIHRvIGJlIGxvb2tlZCB1cFxuXHQgKiBmb3IgdGhlaXIgSHVuZ2FyaWFuIGNvdW50ZXJwYXJ0cy4gVGhlIG1hcHBpbmcgaXMgc3RvcmVkIGluIGEgcHJpdmF0ZVxuXHQgKiBwYXJhbWV0ZXIgY2FsbGVkIGBfaHVuZ2FyaWFuTWFwYCB3aGljaCBjYW4gYmUgYWNjZXNzZWQgb24gdGhlIHNvdXJjZSBvYmplY3QuXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1xuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5IdW5nYXJpYW5NYXAgKCBvIClcblx0e1xuXHRcdHZhclxuXHRcdFx0aHVuZ2FyaWFuID0gJ2EgYWEgYWkgYW8gYXMgYiBmbiBpIG0gbyBzICcsXG5cdFx0XHRtYXRjaCxcblx0XHRcdG5ld0tleSxcblx0XHRcdG1hcCA9IHt9O1xuXHRcblx0XHQkLmVhY2goIG8sIGZ1bmN0aW9uIChrZXksIHZhbCkge1xuXHRcdFx0bWF0Y2ggPSBrZXkubWF0Y2goL14oW15BLVpdKz8pKFtBLVpdKS8pO1xuXHRcblx0XHRcdGlmICggbWF0Y2ggJiYgaHVuZ2FyaWFuLmluZGV4T2YobWF0Y2hbMV0rJyAnKSAhPT0gLTEgKVxuXHRcdFx0e1xuXHRcdFx0XHRuZXdLZXkgPSBrZXkucmVwbGFjZSggbWF0Y2hbMF0sIG1hdGNoWzJdLnRvTG93ZXJDYXNlKCkgKTtcblx0XHRcdFx0bWFwWyBuZXdLZXkgXSA9IGtleTtcblx0XG5cdFx0XHRcdGlmICggbWF0Y2hbMV0gPT09ICdvJyApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRfZm5IdW5nYXJpYW5NYXAoIG9ba2V5XSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcblx0XHRvLl9odW5nYXJpYW5NYXAgPSBtYXA7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogQ29udmVydCBmcm9tIGNhbWVsIGNhc2UgcGFyYW1ldGVycyB0byBIdW5nYXJpYW4sIGJhc2VkIG9uIGEgSHVuZ2FyaWFuIG1hcFxuXHQgKiBjcmVhdGVkIGJ5IF9mbkh1bmdhcmlhbk1hcC5cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzcmMgVGhlIG1vZGVsIG9iamVjdCB3aGljaCBob2xkcyBhbGwgcGFyYW1ldGVycyB0aGF0IGNhbiBiZVxuXHQgKiAgICBtYXBwZWQuXG5cdCAqICBAcGFyYW0ge29iamVjdH0gdXNlciBUaGUgb2JqZWN0IHRvIGNvbnZlcnQgZnJvbSBjYW1lbCBjYXNlIHRvIEh1bmdhcmlhbi5cblx0ICogIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2UgV2hlbiBzZXQgdG8gYHRydWVgLCBwcm9wZXJ0aWVzIHdoaWNoIGFscmVhZHkgaGF2ZSBhXG5cdCAqICAgIEh1bmdhcmlhbiB2YWx1ZSBpbiB0aGUgYHVzZXJgIG9iamVjdCB3aWxsIGJlIG92ZXJ3cml0dGVuLiBPdGhlcndpc2UgdGhleVxuXHQgKiAgICB3b24ndCBiZS5cblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQ2FtZWxUb0h1bmdhcmlhbiAoIHNyYywgdXNlciwgZm9yY2UgKVxuXHR7XG5cdFx0aWYgKCAhIHNyYy5faHVuZ2FyaWFuTWFwICkge1xuXHRcdFx0X2ZuSHVuZ2FyaWFuTWFwKCBzcmMgKTtcblx0XHR9XG5cdFxuXHRcdHZhciBodW5nYXJpYW5LZXk7XG5cdFxuXHRcdCQuZWFjaCggdXNlciwgZnVuY3Rpb24gKGtleSwgdmFsKSB7XG5cdFx0XHRodW5nYXJpYW5LZXkgPSBzcmMuX2h1bmdhcmlhbk1hcFsga2V5IF07XG5cdFxuXHRcdFx0aWYgKCBodW5nYXJpYW5LZXkgIT09IHVuZGVmaW5lZCAmJiAoZm9yY2UgfHwgdXNlcltodW5nYXJpYW5LZXldID09PSB1bmRlZmluZWQpIClcblx0XHRcdHtcblx0XHRcdFx0Ly8gRm9yIG9iamVjdHMsIHdlIG5lZWQgdG8gYnV6eiBkb3duIGludG8gdGhlIG9iamVjdCB0byBjb3B5IHBhcmFtZXRlcnNcblx0XHRcdFx0aWYgKCBodW5nYXJpYW5LZXkuY2hhckF0KDApID09PSAnbycgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Ly8gQ29weSB0aGUgY2FtZWxDYXNlIG9wdGlvbnMgb3ZlciB0byB0aGUgaHVuZ2FyaWFuXG5cdFx0XHRcdFx0aWYgKCAhIHVzZXJbIGh1bmdhcmlhbktleSBdICkge1xuXHRcdFx0XHRcdFx0dXNlclsgaHVuZ2FyaWFuS2V5IF0gPSB7fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0JC5leHRlbmQoIHRydWUsIHVzZXJbaHVuZ2FyaWFuS2V5XSwgdXNlcltrZXldICk7XG5cdFxuXHRcdFx0XHRcdF9mbkNhbWVsVG9IdW5nYXJpYW4oIHNyY1todW5nYXJpYW5LZXldLCB1c2VyW2h1bmdhcmlhbktleV0sIGZvcmNlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dXNlcltodW5nYXJpYW5LZXldID0gdXNlclsga2V5IF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogTGFuZ3VhZ2UgY29tcGF0aWJpbGl0eSAtIHdoZW4gY2VydGFpbiBvcHRpb25zIGFyZSBnaXZlbiwgYW5kIG90aGVycyBhcmVuJ3QsIHdlXG5cdCAqIG5lZWQgdG8gZHVwbGljYXRlIHRoZSB2YWx1ZXMgb3ZlciwgaW4gb3JkZXIgdG8gcHJvdmlkZSBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHQgKiB3aXRoIG9sZGVyIGxhbmd1YWdlIGZpbGVzLlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5MYW5ndWFnZUNvbXBhdCggbGFuZyApXG5cdHtcblx0XHR2YXIgZGVmYXVsdHMgPSBEYXRhVGFibGUuZGVmYXVsdHMub0xhbmd1YWdlO1xuXHRcdHZhciB6ZXJvUmVjb3JkcyA9IGxhbmcuc1plcm9SZWNvcmRzO1xuXHRcblx0XHQvKiBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSAtIGlmIHRoZXJlIGlzIG5vIHNFbXB0eVRhYmxlIGdpdmVuLCB0aGVuIHVzZSB0aGUgc2FtZSBhc1xuXHRcdCAqIHNaZXJvUmVjb3JkcyAtIGFzc3VtaW5nIHRoYXQgaXMgZ2l2ZW4uXG5cdFx0ICovXG5cdFx0aWYgKCAhIGxhbmcuc0VtcHR5VGFibGUgJiYgemVyb1JlY29yZHMgJiZcblx0XHRcdGRlZmF1bHRzLnNFbXB0eVRhYmxlID09PSBcIk5vIGRhdGEgYXZhaWxhYmxlIGluIHRhYmxlXCIgKVxuXHRcdHtcblx0XHRcdF9mbk1hcCggbGFuZywgbGFuZywgJ3NaZXJvUmVjb3JkcycsICdzRW1wdHlUYWJsZScgKTtcblx0XHR9XG5cdFxuXHRcdC8qIExpa2V3aXNlIHdpdGggbG9hZGluZyByZWNvcmRzICovXG5cdFx0aWYgKCAhIGxhbmcuc0xvYWRpbmdSZWNvcmRzICYmIHplcm9SZWNvcmRzICYmXG5cdFx0XHRkZWZhdWx0cy5zTG9hZGluZ1JlY29yZHMgPT09IFwiTG9hZGluZy4uLlwiIClcblx0XHR7XG5cdFx0XHRfZm5NYXAoIGxhbmcsIGxhbmcsICdzWmVyb1JlY29yZHMnLCAnc0xvYWRpbmdSZWNvcmRzJyApO1xuXHRcdH1cblx0XG5cdFx0Ly8gT2xkIHBhcmFtZXRlciBuYW1lIG9mIHRoZSB0aG91c2FuZHMgc2VwYXJhdG9yIG1hcHBlZCBvbnRvIHRoZSBuZXdcblx0XHRpZiAoIGxhbmcuc0luZm9UaG91c2FuZHMgKSB7XG5cdFx0XHRsYW5nLnNUaG91c2FuZHMgPSBsYW5nLnNJbmZvVGhvdXNhbmRzO1xuXHRcdH1cblx0XG5cdFx0dmFyIGRlY2ltYWwgPSBsYW5nLnNEZWNpbWFsO1xuXHRcdGlmICggZGVjaW1hbCApIHtcblx0XHRcdF9hZGROdW1lcmljU29ydCggZGVjaW1hbCApO1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBNYXAgb25lIHBhcmFtZXRlciBvbnRvIGFub3RoZXJcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvIE9iamVjdCB0byBtYXBcblx0ICogIEBwYXJhbSB7Kn0ga25ldyBUaGUgbmV3IHBhcmFtZXRlciBuYW1lXG5cdCAqICBAcGFyYW0geyp9IG9sZCBUaGUgb2xkIHBhcmFtZXRlciBuYW1lXG5cdCAqL1xuXHR2YXIgX2ZuQ29tcGF0TWFwID0gZnVuY3Rpb24gKCBvLCBrbmV3LCBvbGQgKSB7XG5cdFx0aWYgKCBvWyBrbmV3IF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdG9bIG9sZCBdID0gb1sga25ldyBdO1xuXHRcdH1cblx0fTtcblx0XG5cdFxuXHQvKipcblx0ICogUHJvdmlkZSBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmb3IgdGhlIG1haW4gRFQgb3B0aW9ucy4gTm90ZSB0aGF0IHRoZSBuZXdcblx0ICogb3B0aW9ucyBhcmUgbWFwcGVkIG9udG8gdGhlIG9sZCBwYXJhbWV0ZXJzLCBzbyB0aGlzIGlzIGFuIGV4dGVybmFsIGludGVyZmFjZVxuXHQgKiBjaGFuZ2Ugb25seS5cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBpbml0IE9iamVjdCB0byBtYXBcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkNvbXBhdE9wdHMgKCBpbml0IClcblx0e1xuXHRcdF9mbkNvbXBhdE1hcCggaW5pdCwgJ29yZGVyaW5nJywgICAgICAnYlNvcnQnICk7XG5cdFx0X2ZuQ29tcGF0TWFwKCBpbml0LCAnb3JkZXJNdWx0aScsICAgICdiU29ydE11bHRpJyApO1xuXHRcdF9mbkNvbXBhdE1hcCggaW5pdCwgJ29yZGVyQ2xhc3NlcycsICAnYlNvcnRDbGFzc2VzJyApO1xuXHRcdF9mbkNvbXBhdE1hcCggaW5pdCwgJ29yZGVyQ2VsbHNUb3AnLCAnYlNvcnRDZWxsc1RvcCcgKTtcblx0XHRfZm5Db21wYXRNYXAoIGluaXQsICdvcmRlcicsICAgICAgICAgJ2FhU29ydGluZycgKTtcblx0XHRfZm5Db21wYXRNYXAoIGluaXQsICdvcmRlckZpeGVkJywgICAgJ2FhU29ydGluZ0ZpeGVkJyApO1xuXHRcdF9mbkNvbXBhdE1hcCggaW5pdCwgJ3BhZ2luZycsICAgICAgICAnYlBhZ2luYXRlJyApO1xuXHRcdF9mbkNvbXBhdE1hcCggaW5pdCwgJ3BhZ2luZ1R5cGUnLCAgICAnc1BhZ2luYXRpb25UeXBlJyApO1xuXHRcdF9mbkNvbXBhdE1hcCggaW5pdCwgJ3BhZ2VMZW5ndGgnLCAgICAnaURpc3BsYXlMZW5ndGgnICk7XG5cdFx0X2ZuQ29tcGF0TWFwKCBpbml0LCAnc2VhcmNoaW5nJywgICAgICdiRmlsdGVyJyApO1xuXHRcblx0XHQvLyBDb2x1bW4gc2VhcmNoIG9iamVjdHMgYXJlIGluIGFuIGFycmF5LCBzbyBpdCBuZWVkcyB0byBiZSBjb252ZXJ0ZWRcblx0XHQvLyBlbGVtZW50IGJ5IGVsZW1lbnRcblx0XHR2YXIgc2VhcmNoQ29scyA9IGluaXQuYW9TZWFyY2hDb2xzO1xuXHRcblx0XHRpZiAoIHNlYXJjaENvbHMgKSB7XG5cdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49c2VhcmNoQ29scy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBzZWFyY2hDb2xzW2ldICkge1xuXHRcdFx0XHRcdF9mbkNhbWVsVG9IdW5nYXJpYW4oIERhdGFUYWJsZS5tb2RlbHMub1NlYXJjaCwgc2VhcmNoQ29sc1tpXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIFByb3ZpZGUgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZm9yIGNvbHVtbiBvcHRpb25zLiBOb3RlIHRoYXQgdGhlIG5ldyBvcHRpb25zXG5cdCAqIGFyZSBtYXBwZWQgb250byB0aGUgb2xkIHBhcmFtZXRlcnMsIHNvIHRoaXMgaXMgYW4gZXh0ZXJuYWwgaW50ZXJmYWNlIGNoYW5nZVxuXHQgKiBvbmx5LlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IGluaXQgT2JqZWN0IHRvIG1hcFxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQ29tcGF0Q29scyAoIGluaXQgKVxuXHR7XG5cdFx0X2ZuQ29tcGF0TWFwKCBpbml0LCAnb3JkZXJhYmxlJywgICAgICdiU29ydGFibGUnICk7XG5cdFx0X2ZuQ29tcGF0TWFwKCBpbml0LCAnb3JkZXJEYXRhJywgICAgICdhRGF0YVNvcnQnICk7XG5cdFx0X2ZuQ29tcGF0TWFwKCBpbml0LCAnb3JkZXJTZXF1ZW5jZScsICdhc1NvcnRpbmcnICk7XG5cdFx0X2ZuQ29tcGF0TWFwKCBpbml0LCAnb3JkZXJEYXRhVHlwZScsICdzb3J0RGF0YVR5cGUnICk7XG5cdFxuXHRcdC8vIG9yZGVyRGF0YSBjYW4gYmUgZ2l2ZW4gYXMgYW4gaW50ZWdlclxuXHRcdHZhciBkYXRhU29ydCA9IGluaXQuYURhdGFTb3J0O1xuXHRcdGlmICggZGF0YVNvcnQgJiYgISAkLmlzQXJyYXkoIGRhdGFTb3J0ICkgKSB7XG5cdFx0XHRpbml0LmFEYXRhU29ydCA9IFsgZGF0YVNvcnQgXTtcblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogQnJvd3NlciBmZWF0dXJlIGRldGVjdGlvbiBmb3IgY2FwYWJpbGl0aWVzLCBxdWlya3Ncblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5Ccm93c2VyRGV0ZWN0KCBzZXR0aW5ncyApXG5cdHtcblx0XHR2YXIgYnJvd3NlciA9IHNldHRpbmdzLm9Ccm93c2VyO1xuXHRcblx0XHQvLyBTY3JvbGxpbmcgZmVhdHVyZSAvIHF1aXJrcyBkZXRlY3Rpb25cblx0XHR2YXIgbiA9ICQoJzxkaXYvPicpXG5cdFx0XHQuY3NzKCB7XG5cdFx0XHRcdHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuXHRcdFx0XHR0b3A6IDAsXG5cdFx0XHRcdGxlZnQ6IDAsXG5cdFx0XHRcdGhlaWdodDogMSxcblx0XHRcdFx0d2lkdGg6IDEsXG5cdFx0XHRcdG92ZXJmbG93OiAnaGlkZGVuJ1xuXHRcdFx0fSApXG5cdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHQkKCc8ZGl2Lz4nKVxuXHRcdFx0XHRcdC5jc3MoIHtcblx0XHRcdFx0XHRcdHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuXHRcdFx0XHRcdFx0dG9wOiAxLFxuXHRcdFx0XHRcdFx0bGVmdDogMSxcblx0XHRcdFx0XHRcdHdpZHRoOiAxMDAsXG5cdFx0XHRcdFx0XHRvdmVyZmxvdzogJ3Njcm9sbCdcblx0XHRcdFx0XHR9IClcblx0XHRcdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHRcdFx0JCgnPGRpdiBjbGFzcz1cInRlc3RcIi8+Jylcblx0XHRcdFx0XHRcdFx0LmNzcygge1xuXHRcdFx0XHRcdFx0XHRcdHdpZHRoOiAnMTAwJScsXG5cdFx0XHRcdFx0XHRcdFx0aGVpZ2h0OiAxMFxuXHRcdFx0XHRcdFx0XHR9IClcblx0XHRcdFx0XHQpXG5cdFx0XHQpXG5cdFx0XHQuYXBwZW5kVG8oICdib2R5JyApO1xuXHRcblx0XHR2YXIgdGVzdCA9IG4uZmluZCgnLnRlc3QnKTtcblx0XG5cdFx0Ly8gSUU2Lzcgd2lsbCBvdmVyc2l6ZSBhIHdpZHRoIDEwMCUgZWxlbWVudCBpbnNpZGUgYSBzY3JvbGxpbmcgZWxlbWVudCwgdG9cblx0XHQvLyBpbmNsdWRlIHRoZSB3aWR0aCBvZiB0aGUgc2Nyb2xsYmFyLCB3aGlsZSBvdGhlciBicm93c2VycyBlbnN1cmUgdGhlIGlubmVyXG5cdFx0Ly8gZWxlbWVudCBpcyBjb250YWluZWQgd2l0aG91dCBmb3JjaW5nIHNjcm9sbGluZ1xuXHRcdGJyb3dzZXIuYlNjcm9sbE92ZXJzaXplID0gdGVzdFswXS5vZmZzZXRXaWR0aCA9PT0gMTAwO1xuXHRcblx0XHQvLyBJbiBydGwgdGV4dCBsYXlvdXQsIHNvbWUgYnJvd3NlcnMgKG1vc3QsIGJ1dCBub3QgYWxsKSB3aWxsIHBsYWNlIHRoZVxuXHRcdC8vIHNjcm9sbGJhciBvbiB0aGUgbGVmdCwgcmF0aGVyIHRoYW4gdGhlIHJpZ2h0LlxuXHRcdGJyb3dzZXIuYlNjcm9sbGJhckxlZnQgPSBNYXRoLnJvdW5kKCB0ZXN0Lm9mZnNldCgpLmxlZnQgKSAhPT0gMTtcblx0XG5cdFx0bi5yZW1vdmUoKTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBBcnJheS5wcm90b3R5cGUgcmVkdWNlW1JpZ2h0XSBtZXRob2QsIHVzZWQgZm9yIGJyb3dzZXJzIHdoaWNoIGRvbid0IHN1cHBvcnRcblx0ICogSlMgMS42LiBEb25lIHRoaXMgd2F5IHRvIHJlZHVjZSBjb2RlIHNpemUsIHNpbmNlIHdlIGl0ZXJhdGUgZWl0aGVyIHdheVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mblJlZHVjZSAoIHRoYXQsIGZuLCBpbml0LCBzdGFydCwgZW5kLCBpbmMgKVxuXHR7XG5cdFx0dmFyXG5cdFx0XHRpID0gc3RhcnQsXG5cdFx0XHR2YWx1ZSxcblx0XHRcdGlzU2V0ID0gZmFsc2U7XG5cdFxuXHRcdGlmICggaW5pdCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dmFsdWUgPSBpbml0O1xuXHRcdFx0aXNTZXQgPSB0cnVlO1xuXHRcdH1cblx0XG5cdFx0d2hpbGUgKCBpICE9PSBlbmQgKSB7XG5cdFx0XHRpZiAoICEgdGhhdC5oYXNPd25Qcm9wZXJ0eShpKSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFxuXHRcdFx0dmFsdWUgPSBpc1NldCA/XG5cdFx0XHRcdGZuKCB2YWx1ZSwgdGhhdFtpXSwgaSwgdGhhdCApIDpcblx0XHRcdFx0dGhhdFtpXTtcblx0XG5cdFx0XHRpc1NldCA9IHRydWU7XG5cdFx0XHRpICs9IGluYztcblx0XHR9XG5cdFxuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEFkZCBhIGNvbHVtbiB0byB0aGUgbGlzdCB1c2VkIGZvciB0aGUgdGFibGUgd2l0aCBkZWZhdWx0IHZhbHVlc1xuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtub2RlfSBuVGggVGhlIHRoIGVsZW1lbnQgZm9yIHRoaXMgY29sdW1uXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkFkZENvbHVtbiggb1NldHRpbmdzLCBuVGggKVxuXHR7XG5cdFx0Ly8gQWRkIGNvbHVtbiB0byBhb0NvbHVtbnMgYXJyYXlcblx0XHR2YXIgb0RlZmF1bHRzID0gRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbjtcblx0XHR2YXIgaUNvbCA9IG9TZXR0aW5ncy5hb0NvbHVtbnMubGVuZ3RoO1xuXHRcdHZhciBvQ29sID0gJC5leHRlbmQoIHt9LCBEYXRhVGFibGUubW9kZWxzLm9Db2x1bW4sIG9EZWZhdWx0cywge1xuXHRcdFx0XCJuVGhcIjogblRoID8gblRoIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGgnKSxcblx0XHRcdFwic1RpdGxlXCI6ICAgIG9EZWZhdWx0cy5zVGl0bGUgICAgPyBvRGVmYXVsdHMuc1RpdGxlICAgIDogblRoID8gblRoLmlubmVySFRNTCA6ICcnLFxuXHRcdFx0XCJhRGF0YVNvcnRcIjogb0RlZmF1bHRzLmFEYXRhU29ydCA/IG9EZWZhdWx0cy5hRGF0YVNvcnQgOiBbaUNvbF0sXG5cdFx0XHRcIm1EYXRhXCI6IG9EZWZhdWx0cy5tRGF0YSA/IG9EZWZhdWx0cy5tRGF0YSA6IGlDb2wsXG5cdFx0XHRpZHg6IGlDb2xcblx0XHR9ICk7XG5cdFx0b1NldHRpbmdzLmFvQ29sdW1ucy5wdXNoKCBvQ29sICk7XG5cdFxuXHRcdC8vIEFkZCBzZWFyY2ggb2JqZWN0IGZvciBjb2x1bW4gc3BlY2lmaWMgc2VhcmNoLiBOb3RlIHRoYXQgdGhlIGBzZWFyY2hDb2xzWyBpQ29sIF1gXG5cdFx0Ly8gcGFzc2VkIGludG8gZXh0ZW5kIGNhbiBiZSB1bmRlZmluZWQuIFRoaXMgYWxsb3dzIHRoZSB1c2VyIHRvIGdpdmUgYSBkZWZhdWx0XG5cdFx0Ly8gd2l0aCBvbmx5IHNvbWUgb2YgdGhlIHBhcmFtZXRlcnMgZGVmaW5lZCwgYW5kIGFsc28gbm90IGdpdmUgYSBkZWZhdWx0XG5cdFx0dmFyIHNlYXJjaENvbHMgPSBvU2V0dGluZ3MuYW9QcmVTZWFyY2hDb2xzO1xuXHRcdHNlYXJjaENvbHNbIGlDb2wgXSA9ICQuZXh0ZW5kKCB7fSwgRGF0YVRhYmxlLm1vZGVscy5vU2VhcmNoLCBzZWFyY2hDb2xzWyBpQ29sIF0gKTtcblx0XG5cdFx0Ly8gVXNlIHRoZSBkZWZhdWx0IGNvbHVtbiBvcHRpb25zIGZ1bmN0aW9uIHRvIGluaXRpYWxpc2UgY2xhc3NlcyBldGNcblx0XHRfZm5Db2x1bW5PcHRpb25zKCBvU2V0dGluZ3MsIGlDb2wsICQoblRoKS5kYXRhKCkgKTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBBcHBseSBvcHRpb25zIGZvciBhIGNvbHVtblxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtpbnR9IGlDb2wgY29sdW1uIGluZGV4IHRvIGNvbnNpZGVyXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb09wdGlvbnMgb2JqZWN0IHdpdGggc1R5cGUsIGJWaXNpYmxlIGFuZCBiU2VhcmNoYWJsZSBldGNcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQ29sdW1uT3B0aW9ucyggb1NldHRpbmdzLCBpQ29sLCBvT3B0aW9ucyApXG5cdHtcblx0XHR2YXIgb0NvbCA9IG9TZXR0aW5ncy5hb0NvbHVtbnNbIGlDb2wgXTtcblx0XHR2YXIgb0NsYXNzZXMgPSBvU2V0dGluZ3Mub0NsYXNzZXM7XG5cdFx0dmFyIHRoID0gJChvQ29sLm5UaCk7XG5cdFxuXHRcdC8vIFRyeSB0byBnZXQgd2lkdGggaW5mb3JtYXRpb24gZnJvbSB0aGUgRE9NLiBXZSBjYW4ndCBnZXQgaXQgZnJvbSBDU1Ncblx0XHQvLyBhcyB3ZSdkIG5lZWQgdG8gcGFyc2UgdGhlIENTUyBzdHlsZXNoZWV0LiBgd2lkdGhgIG9wdGlvbiBjYW4gb3ZlcnJpZGVcblx0XHRpZiAoICEgb0NvbC5zV2lkdGhPcmlnICkge1xuXHRcdFx0Ly8gV2lkdGggYXR0cmlidXRlXG5cdFx0XHRvQ29sLnNXaWR0aE9yaWcgPSB0aC5hdHRyKCd3aWR0aCcpIHx8IG51bGw7XG5cdFxuXHRcdFx0Ly8gU3R5bGUgYXR0cmlidXRlXG5cdFx0XHR2YXIgdCA9ICh0aC5hdHRyKCdzdHlsZScpIHx8ICcnKS5tYXRjaCgvd2lkdGg6XFxzKihcXGQrW3B4ZW0lXSspLyk7XG5cdFx0XHRpZiAoIHQgKSB7XG5cdFx0XHRcdG9Db2wuc1dpZHRoT3JpZyA9IHRbMV07XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHQvKiBVc2VyIHNwZWNpZmllZCBjb2x1bW4gb3B0aW9ucyAqL1xuXHRcdGlmICggb09wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvT3B0aW9ucyAhPT0gbnVsbCApXG5cdFx0e1xuXHRcdFx0Ly8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0XHRcdF9mbkNvbXBhdENvbHMoIG9PcHRpb25zICk7XG5cdFxuXHRcdFx0Ly8gTWFwIGNhbWVsIGNhc2UgcGFyYW1ldGVycyB0byB0aGVpciBIdW5nYXJpYW4gY291bnRlcnBhcnRzXG5cdFx0XHRfZm5DYW1lbFRvSHVuZ2FyaWFuKCBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLCBvT3B0aW9ucyApO1xuXHRcblx0XHRcdC8qIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZvciBtRGF0YVByb3AgKi9cblx0XHRcdGlmICggb09wdGlvbnMubURhdGFQcm9wICE9PSB1bmRlZmluZWQgJiYgIW9PcHRpb25zLm1EYXRhIClcblx0XHRcdHtcblx0XHRcdFx0b09wdGlvbnMubURhdGEgPSBvT3B0aW9ucy5tRGF0YVByb3A7XG5cdFx0XHR9XG5cdFxuXHRcdFx0aWYgKCBvT3B0aW9ucy5zVHlwZSApXG5cdFx0XHR7XG5cdFx0XHRcdG9Db2wuX3NNYW51YWxUeXBlID0gb09wdGlvbnMuc1R5cGU7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gYGNsYXNzYCBpcyBhIHJlc2VydmVkIHdvcmQgaW4gSmF2YXNjcmlwdCwgc28gd2UgbmVlZCB0byBwcm92aWRlXG5cdFx0XHQvLyB0aGUgYWJpbGl0eSB0byB1c2UgYSB2YWxpZCBuYW1lIGZvciB0aGUgY2FtZWwgY2FzZSBpbnB1dFxuXHRcdFx0aWYgKCBvT3B0aW9ucy5jbGFzc05hbWUgJiYgISBvT3B0aW9ucy5zQ2xhc3MgKVxuXHRcdFx0e1xuXHRcdFx0XHRvT3B0aW9ucy5zQ2xhc3MgPSBvT3B0aW9ucy5jbGFzc05hbWU7XG5cdFx0XHR9XG5cdFxuXHRcdFx0JC5leHRlbmQoIG9Db2wsIG9PcHRpb25zICk7XG5cdFx0XHRfZm5NYXAoIG9Db2wsIG9PcHRpb25zLCBcInNXaWR0aFwiLCBcInNXaWR0aE9yaWdcIiApO1xuXHRcblx0XHRcdC8qIGlEYXRhU29ydCB0byBiZSBhcHBsaWVkIChiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSksIGJ1dCBhRGF0YVNvcnQgd2lsbCB0YWtlXG5cdFx0XHQgKiBwcmlvcml0eSBpZiBkZWZpbmVkXG5cdFx0XHQgKi9cblx0XHRcdGlmICggb09wdGlvbnMuaURhdGFTb3J0ICE9PSB1bmRlZmluZWQgKVxuXHRcdFx0e1xuXHRcdFx0XHRvQ29sLmFEYXRhU29ydCA9IFsgb09wdGlvbnMuaURhdGFTb3J0IF07XG5cdFx0XHR9XG5cdFx0XHRfZm5NYXAoIG9Db2wsIG9PcHRpb25zLCBcImFEYXRhU29ydFwiICk7XG5cdFx0fVxuXHRcblx0XHQvKiBDYWNoZSB0aGUgZGF0YSBnZXQgYW5kIHNldCBmdW5jdGlvbnMgZm9yIHNwZWVkICovXG5cdFx0dmFyIG1EYXRhU3JjID0gb0NvbC5tRGF0YTtcblx0XHR2YXIgbURhdGEgPSBfZm5HZXRPYmplY3REYXRhRm4oIG1EYXRhU3JjICk7XG5cdFx0dmFyIG1SZW5kZXIgPSBvQ29sLm1SZW5kZXIgPyBfZm5HZXRPYmplY3REYXRhRm4oIG9Db2wubVJlbmRlciApIDogbnVsbDtcblx0XG5cdFx0dmFyIGF0dHJUZXN0ID0gZnVuY3Rpb24oIHNyYyApIHtcblx0XHRcdHJldHVybiB0eXBlb2Ygc3JjID09PSAnc3RyaW5nJyAmJiBzcmMuaW5kZXhPZignQCcpICE9PSAtMTtcblx0XHR9O1xuXHRcdG9Db2wuX2JBdHRyU3JjID0gJC5pc1BsYWluT2JqZWN0KCBtRGF0YVNyYyApICYmIChcblx0XHRcdGF0dHJUZXN0KG1EYXRhU3JjLnNvcnQpIHx8IGF0dHJUZXN0KG1EYXRhU3JjLnR5cGUpIHx8IGF0dHJUZXN0KG1EYXRhU3JjLmZpbHRlcilcblx0XHQpO1xuXHRcblx0XHRvQ29sLmZuR2V0RGF0YSA9IGZ1bmN0aW9uIChyb3dEYXRhLCB0eXBlLCBtZXRhKSB7XG5cdFx0XHR2YXIgaW5uZXJEYXRhID0gbURhdGEoIHJvd0RhdGEsIHR5cGUsIHVuZGVmaW5lZCwgbWV0YSApO1xuXHRcblx0XHRcdHJldHVybiBtUmVuZGVyICYmIHR5cGUgP1xuXHRcdFx0XHRtUmVuZGVyKCBpbm5lckRhdGEsIHR5cGUsIHJvd0RhdGEsIG1ldGEgKSA6XG5cdFx0XHRcdGlubmVyRGF0YTtcblx0XHR9O1xuXHRcdG9Db2wuZm5TZXREYXRhID0gZnVuY3Rpb24gKCByb3dEYXRhLCB2YWwsIG1ldGEgKSB7XG5cdFx0XHRyZXR1cm4gX2ZuU2V0T2JqZWN0RGF0YUZuKCBtRGF0YVNyYyApKCByb3dEYXRhLCB2YWwsIG1ldGEgKTtcblx0XHR9O1xuXHRcblx0XHQvLyBJbmRpY2F0ZSBpZiBEYXRhVGFibGVzIHNob3VsZCByZWFkIERPTSBkYXRhIGFzIGFuIG9iamVjdCBvciBhcnJheVxuXHRcdC8vIFVzZWQgaW4gX2ZuR2V0Um93RWxlbWVudHNcblx0XHRpZiAoIHR5cGVvZiBtRGF0YVNyYyAhPT0gJ251bWJlcicgKSB7XG5cdFx0XHRvU2V0dGluZ3MuX3Jvd1JlYWRPYmplY3QgPSB0cnVlO1xuXHRcdH1cblx0XG5cdFx0LyogRmVhdHVyZSBzb3J0aW5nIG92ZXJyaWRlcyBjb2x1bW4gc3BlY2lmaWMgd2hlbiBvZmYgKi9cblx0XHRpZiAoICFvU2V0dGluZ3Mub0ZlYXR1cmVzLmJTb3J0IClcblx0XHR7XG5cdFx0XHRvQ29sLmJTb3J0YWJsZSA9IGZhbHNlO1xuXHRcdFx0dGguYWRkQ2xhc3MoIG9DbGFzc2VzLnNTb3J0YWJsZU5vbmUgKTsgLy8gSGF2ZSB0byBhZGQgY2xhc3MgaGVyZSBhcyBvcmRlciBldmVudCBpc24ndCBjYWxsZWRcblx0XHR9XG5cdFxuXHRcdC8qIENoZWNrIHRoYXQgdGhlIGNsYXNzIGFzc2lnbm1lbnQgaXMgY29ycmVjdCBmb3Igc29ydGluZyAqL1xuXHRcdHZhciBiQXNjID0gJC5pbkFycmF5KCdhc2MnLCBvQ29sLmFzU29ydGluZykgIT09IC0xO1xuXHRcdHZhciBiRGVzYyA9ICQuaW5BcnJheSgnZGVzYycsIG9Db2wuYXNTb3J0aW5nKSAhPT0gLTE7XG5cdFx0aWYgKCAhb0NvbC5iU29ydGFibGUgfHwgKCFiQXNjICYmICFiRGVzYykgKVxuXHRcdHtcblx0XHRcdG9Db2wuc1NvcnRpbmdDbGFzcyA9IG9DbGFzc2VzLnNTb3J0YWJsZU5vbmU7XG5cdFx0XHRvQ29sLnNTb3J0aW5nQ2xhc3NKVUkgPSBcIlwiO1xuXHRcdH1cblx0XHRlbHNlIGlmICggYkFzYyAmJiAhYkRlc2MgKVxuXHRcdHtcblx0XHRcdG9Db2wuc1NvcnRpbmdDbGFzcyA9IG9DbGFzc2VzLnNTb3J0YWJsZUFzYztcblx0XHRcdG9Db2wuc1NvcnRpbmdDbGFzc0pVSSA9IG9DbGFzc2VzLnNTb3J0SlVJQXNjQWxsb3dlZDtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoICFiQXNjICYmIGJEZXNjIClcblx0XHR7XG5cdFx0XHRvQ29sLnNTb3J0aW5nQ2xhc3MgPSBvQ2xhc3Nlcy5zU29ydGFibGVEZXNjO1xuXHRcdFx0b0NvbC5zU29ydGluZ0NsYXNzSlVJID0gb0NsYXNzZXMuc1NvcnRKVUlEZXNjQWxsb3dlZDtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdG9Db2wuc1NvcnRpbmdDbGFzcyA9IG9DbGFzc2VzLnNTb3J0YWJsZTtcblx0XHRcdG9Db2wuc1NvcnRpbmdDbGFzc0pVSSA9IG9DbGFzc2VzLnNTb3J0SlVJO1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBBZGp1c3QgdGhlIHRhYmxlIGNvbHVtbiB3aWR0aHMgZm9yIG5ldyBkYXRhLiBOb3RlOiB5b3Ugd291bGQgcHJvYmFibHkgd2FudCB0b1xuXHQgKiBkbyBhIHJlZHJhdyBhZnRlciBjYWxsaW5nIHRoaXMgZnVuY3Rpb24hXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQWRqdXN0Q29sdW1uU2l6aW5nICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0LyogTm90IGludGVyZXN0ZWQgaW4gZG9pbmcgY29sdW1uIHdpZHRoIGNhbGN1bGF0aW9uIGlmIGF1dG8td2lkdGggaXMgZGlzYWJsZWQgKi9cblx0XHRpZiAoIHNldHRpbmdzLm9GZWF0dXJlcy5iQXV0b1dpZHRoICE9PSBmYWxzZSApXG5cdFx0e1xuXHRcdFx0dmFyIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XG5cdFxuXHRcdFx0X2ZuQ2FsY3VsYXRlQ29sdW1uV2lkdGhzKCBzZXR0aW5ncyApO1xuXHRcdFx0Zm9yICggdmFyIGk9MCAsIGlMZW49Y29sdW1ucy5sZW5ndGggOyBpPGlMZW4gOyBpKysgKVxuXHRcdFx0e1xuXHRcdFx0XHRjb2x1bW5zW2ldLm5UaC5zdHlsZS53aWR0aCA9IGNvbHVtbnNbaV0uc1dpZHRoO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0dmFyIHNjcm9sbCA9IHNldHRpbmdzLm9TY3JvbGw7XG5cdFx0aWYgKCBzY3JvbGwuc1kgIT09ICcnIHx8IHNjcm9sbC5zWCAhPT0gJycpXG5cdFx0e1xuXHRcdFx0X2ZuU2Nyb2xsRHJhdyggc2V0dGluZ3MgKTtcblx0XHR9XG5cdFxuXHRcdF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsIG51bGwsICdjb2x1bW4tc2l6aW5nJywgW3NldHRpbmdzXSApO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIENvdmVydCB0aGUgaW5kZXggb2YgYSB2aXNpYmxlIGNvbHVtbiB0byB0aGUgaW5kZXggaW4gdGhlIGRhdGEgYXJyYXkgKHRha2UgYWNjb3VudFxuXHQgKiBvZiBoaWRkZW4gY29sdW1ucylcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7aW50fSBpTWF0Y2ggVmlzaWJsZSBjb2x1bW4gaW5kZXggdG8gbG9va3VwXG5cdCAqICBAcmV0dXJucyB7aW50fSBpIHRoZSBkYXRhIGluZGV4XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mblZpc2libGVUb0NvbHVtbkluZGV4KCBvU2V0dGluZ3MsIGlNYXRjaCApXG5cdHtcblx0XHR2YXIgYWlWaXMgPSBfZm5HZXRDb2x1bW5zKCBvU2V0dGluZ3MsICdiVmlzaWJsZScgKTtcblx0XG5cdFx0cmV0dXJuIHR5cGVvZiBhaVZpc1tpTWF0Y2hdID09PSAnbnVtYmVyJyA/XG5cdFx0XHRhaVZpc1tpTWF0Y2hdIDpcblx0XHRcdG51bGw7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogQ292ZXJ0IHRoZSBpbmRleCBvZiBhbiBpbmRleCBpbiB0aGUgZGF0YSBhcnJheSBhbmQgY29udmVydCBpdCB0byB0aGUgdmlzaWJsZVxuXHQgKiAgIGNvbHVtbiBpbmRleCAodGFrZSBhY2NvdW50IG9mIGhpZGRlbiBjb2x1bW5zKVxuXHQgKiAgQHBhcmFtIHtpbnR9IGlNYXRjaCBDb2x1bW4gaW5kZXggdG8gbG9va3VwXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcmV0dXJucyB7aW50fSBpIHRoZSBkYXRhIGluZGV4XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkNvbHVtbkluZGV4VG9WaXNpYmxlKCBvU2V0dGluZ3MsIGlNYXRjaCApXG5cdHtcblx0XHR2YXIgYWlWaXMgPSBfZm5HZXRDb2x1bW5zKCBvU2V0dGluZ3MsICdiVmlzaWJsZScgKTtcblx0XHR2YXIgaVBvcyA9ICQuaW5BcnJheSggaU1hdGNoLCBhaVZpcyApO1xuXHRcblx0XHRyZXR1cm4gaVBvcyAhPT0gLTEgPyBpUG9zIDogbnVsbDtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBHZXQgdGhlIG51bWJlciBvZiB2aXNpYmxlIGNvbHVtbnNcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEByZXR1cm5zIHtpbnR9IGkgdGhlIG51bWJlciBvZiB2aXNpYmxlIGNvbHVtbnNcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuVmlzYmxlQ29sdW1ucyggb1NldHRpbmdzIClcblx0e1xuXHRcdHJldHVybiBfZm5HZXRDb2x1bW5zKCBvU2V0dGluZ3MsICdiVmlzaWJsZScgKS5sZW5ndGg7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogR2V0IGFuIGFycmF5IG9mIGNvbHVtbiBpbmRleGVzIHRoYXQgbWF0Y2ggYSBnaXZlbiBwcm9wZXJ0eVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IHNQYXJhbSBQYXJhbWV0ZXIgaW4gYW9Db2x1bW5zIHRvIGxvb2sgZm9yIC0gdHlwaWNhbGx5XG5cdCAqICAgIGJWaXNpYmxlIG9yIGJTZWFyY2hhYmxlXG5cdCAqICBAcmV0dXJucyB7YXJyYXl9IEFycmF5IG9mIGluZGV4ZXMgd2l0aCBtYXRjaGVkIHByb3BlcnRpZXNcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuR2V0Q29sdW1ucyggb1NldHRpbmdzLCBzUGFyYW0gKVxuXHR7XG5cdFx0dmFyIGEgPSBbXTtcblx0XG5cdFx0JC5tYXAoIG9TZXR0aW5ncy5hb0NvbHVtbnMsIGZ1bmN0aW9uKHZhbCwgaSkge1xuXHRcdFx0aWYgKCB2YWxbc1BhcmFtXSApIHtcblx0XHRcdFx0YS5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcblx0XHRyZXR1cm4gYTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBDYWxjdWxhdGUgdGhlICd0eXBlJyBvZiBhIGNvbHVtblxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkNvbHVtblR5cGVzICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XG5cdFx0dmFyIGRhdGEgPSBzZXR0aW5ncy5hb0RhdGE7XG5cdFx0dmFyIHR5cGVzID0gRGF0YVRhYmxlLmV4dC50eXBlLmRldGVjdDtcblx0XHR2YXIgaSwgaWVuLCBqLCBqZW4sIGssIGtlbjtcblx0XHR2YXIgY29sLCBjZWxsLCBkZXRlY3RlZFR5cGUsIGNhY2hlO1xuXHRcblx0XHQvLyBGb3IgZWFjaCBjb2x1bW4sIHNwaW4gb3ZlciB0aGUgXG5cdFx0Zm9yICggaT0wLCBpZW49Y29sdW1ucy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdGNvbCA9IGNvbHVtbnNbaV07XG5cdFx0XHRjYWNoZSA9IFtdO1xuXHRcblx0XHRcdGlmICggISBjb2wuc1R5cGUgJiYgY29sLl9zTWFudWFsVHlwZSApIHtcblx0XHRcdFx0Y29sLnNUeXBlID0gY29sLl9zTWFudWFsVHlwZTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCAhIGNvbC5zVHlwZSApIHtcblx0XHRcdFx0Zm9yICggaj0wLCBqZW49dHlwZXMubGVuZ3RoIDsgajxqZW4gOyBqKysgKSB7XG5cdFx0XHRcdFx0Zm9yICggaz0wLCBrZW49ZGF0YS5sZW5ndGggOyBrPGtlbiA7IGsrKyApIHtcblx0XHRcdFx0XHRcdC8vIFVzZSBhIGNhY2hlIGFycmF5IHNvIHdlIG9ubHkgbmVlZCB0byBnZXQgdGhlIHR5cGUgZGF0YVxuXHRcdFx0XHRcdFx0Ly8gZnJvbSB0aGUgZm9ybWF0dGVyIG9uY2UgKHdoZW4gdXNpbmcgbXVsdGlwbGUgZGV0ZWN0b3JzKVxuXHRcdFx0XHRcdFx0aWYgKCBjYWNoZVtrXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRjYWNoZVtrXSA9IF9mbkdldENlbGxEYXRhKCBzZXR0aW5ncywgaywgaSwgJ3R5cGUnICk7XG5cdFx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdFx0ZGV0ZWN0ZWRUeXBlID0gdHlwZXNbal0oIGNhY2hlW2tdLCBzZXR0aW5ncyApO1xuXHRcblx0XHRcdFx0XHRcdC8vIElmIG51bGwsIHRoZW4gdGhpcyB0eXBlIGNhbid0IGFwcGx5IHRvIHRoaXMgY29sdW1uLCBzb1xuXHRcdFx0XHRcdFx0Ly8gcmF0aGVyIHRoYW4gdGVzdGluZyBhbGwgY2VsbHMsIGJyZWFrIG91dC4gVGhlcmUgaXMgYW5cblx0XHRcdFx0XHRcdC8vIGV4Y2VwdGlvbiBmb3IgdGhlIGxhc3QgdHlwZSB3aGljaCBpcyBgaHRtbGAuIFdlIG5lZWQgdG9cblx0XHRcdFx0XHRcdC8vIHNjYW4gYWxsIHJvd3Mgc2luY2UgaXQgaXMgcG9zc2libGUgdG8gbWl4IHN0cmluZyBhbmQgSFRNTFxuXHRcdFx0XHRcdFx0Ly8gdHlwZXNcblx0XHRcdFx0XHRcdGlmICggISBkZXRlY3RlZFR5cGUgJiYgaiAhPT0gdHlwZXMubGVuZ3RoLTEgKSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRcdC8vIE9ubHkgYSBzaW5nbGUgbWF0Y2ggaXMgbmVlZGVkIGZvciBodG1sIHR5cGUgc2luY2UgaXQgaXNcblx0XHRcdFx0XHRcdC8vIGJvdHRvbSBvZiB0aGUgcGlsZSBhbmQgdmVyeSBzaW1pbGFyIHRvIHN0cmluZ1xuXHRcdFx0XHRcdFx0aWYgKCBkZXRlY3RlZFR5cGUgPT09ICdodG1sJyApIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHQvLyBUeXBlIGlzIHZhbGlkIGZvciBhbGwgZGF0YSBwb2ludHMgaW4gdGhlIGNvbHVtbiAtIHVzZSB0aGlzXG5cdFx0XHRcdFx0Ly8gdHlwZVxuXHRcdFx0XHRcdGlmICggZGV0ZWN0ZWRUeXBlICkge1xuXHRcdFx0XHRcdFx0Y29sLnNUeXBlID0gZGV0ZWN0ZWRUeXBlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHQvLyBGYWxsIGJhY2sgLSBpZiBubyB0eXBlIHdhcyBkZXRlY3RlZCwgYWx3YXlzIHVzZSBzdHJpbmdcblx0XHRcdFx0aWYgKCAhIGNvbC5zVHlwZSApIHtcblx0XHRcdFx0XHRjb2wuc1R5cGUgPSAnc3RyaW5nJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBUYWtlIHRoZSBjb2x1bW4gZGVmaW5pdGlvbnMgYW5kIHN0YXRpYyBjb2x1bW5zIGFycmF5cyBhbmQgY2FsY3VsYXRlIGhvd1xuXHQgKiB0aGV5IHJlbGF0ZSB0byBjb2x1bW4gaW5kZXhlcy4gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpbGwgdGhlbiBhcHBseSB0aGVcblx0ICogZGVmaW5pdGlvbiBmb3VuZCBmb3IgYSBjb2x1bW4gdG8gYSBzdWl0YWJsZSBjb25maWd1cmF0aW9uIG9iamVjdC5cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7YXJyYXl9IGFvQ29sRGVmcyBUaGUgYW9Db2x1bW5EZWZzIGFycmF5IHRoYXQgaXMgdG8gYmUgYXBwbGllZFxuXHQgKiAgQHBhcmFtIHthcnJheX0gYW9Db2xzIFRoZSBhb0NvbHVtbnMgYXJyYXkgdGhhdCBkZWZpbmVzIGNvbHVtbnMgaW5kaXZpZHVhbGx5XG5cdCAqICBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBDYWxsYmFjayBmdW5jdGlvbiAtIHRha2VzIHR3byBwYXJhbWV0ZXJzLCB0aGUgY2FsY3VsYXRlZFxuXHQgKiAgICBjb2x1bW4gaW5kZXggYW5kIHRoZSBkZWZpbml0aW9uIGZvciB0aGF0IGNvbHVtbi5cblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQXBwbHlDb2x1bW5EZWZzKCBvU2V0dGluZ3MsIGFvQ29sRGVmcywgYW9Db2xzLCBmbiApXG5cdHtcblx0XHR2YXIgaSwgaUxlbiwgaiwgakxlbiwgaywga0xlbiwgZGVmO1xuXHRcdHZhciBjb2x1bW5zID0gb1NldHRpbmdzLmFvQ29sdW1ucztcblx0XG5cdFx0Ly8gQ29sdW1uIGRlZmluaXRpb25zIHdpdGggYVRhcmdldHNcblx0XHRpZiAoIGFvQ29sRGVmcyApXG5cdFx0e1xuXHRcdFx0LyogTG9vcCBvdmVyIHRoZSBkZWZpbml0aW9ucyBhcnJheSAtIGxvb3AgaW4gcmV2ZXJzZSBzbyBmaXJzdCBpbnN0YW5jZSBoYXMgcHJpb3JpdHkgKi9cblx0XHRcdGZvciAoIGk9YW9Db2xEZWZzLmxlbmd0aC0xIDsgaT49MCA7IGktLSApXG5cdFx0XHR7XG5cdFx0XHRcdGRlZiA9IGFvQ29sRGVmc1tpXTtcblx0XG5cdFx0XHRcdC8qIEVhY2ggZGVmaW5pdGlvbiBjYW4gdGFyZ2V0IG11bHRpcGxlIGNvbHVtbnMsIGFzIGl0IGlzIGFuIGFycmF5ICovXG5cdFx0XHRcdHZhciBhVGFyZ2V0cyA9IGRlZi50YXJnZXRzICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRcdGRlZi50YXJnZXRzIDpcblx0XHRcdFx0XHRkZWYuYVRhcmdldHM7XG5cdFxuXHRcdFx0XHRpZiAoICEgJC5pc0FycmF5KCBhVGFyZ2V0cyApIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGFUYXJnZXRzID0gWyBhVGFyZ2V0cyBdO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRmb3IgKCBqPTAsIGpMZW49YVRhcmdldHMubGVuZ3RoIDsgajxqTGVuIDsgaisrIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmICggdHlwZW9mIGFUYXJnZXRzW2pdID09PSAnbnVtYmVyJyAmJiBhVGFyZ2V0c1tqXSA+PSAwIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHQvKiBBZGQgY29sdW1ucyB0aGF0IHdlIGRvbid0IHlldCBrbm93IGFib3V0ICovXG5cdFx0XHRcdFx0XHR3aGlsZSggY29sdW1ucy5sZW5ndGggPD0gYVRhcmdldHNbal0gKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRfZm5BZGRDb2x1bW4oIG9TZXR0aW5ncyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRcdC8qIEludGVnZXIsIGJhc2ljIGluZGV4ICovXG5cdFx0XHRcdFx0XHRmbiggYVRhcmdldHNbal0sIGRlZiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGlmICggdHlwZW9mIGFUYXJnZXRzW2pdID09PSAnbnVtYmVyJyAmJiBhVGFyZ2V0c1tqXSA8IDAgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdC8qIE5lZ2F0aXZlIGludGVnZXIsIHJpZ2h0IHRvIGxlZnQgY29sdW1uIGNvdW50aW5nICovXG5cdFx0XHRcdFx0XHRmbiggY29sdW1ucy5sZW5ndGgrYVRhcmdldHNbal0sIGRlZiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGlmICggdHlwZW9mIGFUYXJnZXRzW2pdID09PSAnc3RyaW5nJyApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0LyogQ2xhc3MgbmFtZSBtYXRjaGluZyBvbiBUSCBlbGVtZW50ICovXG5cdFx0XHRcdFx0XHRmb3IgKCBrPTAsIGtMZW49Y29sdW1ucy5sZW5ndGggOyBrPGtMZW4gOyBrKysgKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRpZiAoIGFUYXJnZXRzW2pdID09IFwiX2FsbFwiIHx8XG5cdFx0XHRcdFx0XHRcdCAgICAgJChjb2x1bW5zW2tdLm5UaCkuaGFzQ2xhc3MoIGFUYXJnZXRzW2pdICkgKVxuXHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0Zm4oIGssIGRlZiApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHQvLyBTdGF0aWNhbGx5IGRlZmluZWQgY29sdW1ucyBhcnJheVxuXHRcdGlmICggYW9Db2xzIClcblx0XHR7XG5cdFx0XHRmb3IgKCBpPTAsIGlMZW49YW9Db2xzLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApXG5cdFx0XHR7XG5cdFx0XHRcdGZuKCBpLCBhb0NvbHNbaV0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBBZGQgYSBkYXRhIGFycmF5IHRvIHRoZSB0YWJsZSwgY3JlYXRpbmcgRE9NIG5vZGUgZXRjLiBUaGlzIGlzIHRoZSBwYXJhbGxlbCB0b1xuXHQgKiBfZm5HYXRoZXJEYXRhLCBidXQgZm9yIGFkZGluZyByb3dzIGZyb20gYSBKYXZhc2NyaXB0IHNvdXJjZSwgcmF0aGVyIHRoYW4gYVxuXHQgKiBET00gc291cmNlLlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHthcnJheX0gYURhdGEgZGF0YSBhcnJheSB0byBiZSBhZGRlZFxuXHQgKiAgQHBhcmFtIHtub2RlfSBbblRyXSBUUiBlbGVtZW50IHRvIGFkZCB0byB0aGUgdGFibGUgLSBvcHRpb25hbC4gSWYgbm90IGdpdmVuLFxuXHQgKiAgICBEYXRhVGFibGVzIHdpbGwgY3JlYXRlIGEgcm93IGF1dG9tYXRpY2FsbHlcblx0ICogIEBwYXJhbSB7YXJyYXl9IFthblRkc10gQXJyYXkgb2YgVER8VEggZWxlbWVudHMgZm9yIHRoZSByb3cgLSBtdXN0IGJlIGdpdmVuXG5cdCAqICAgIGlmIG5UciBpcy5cblx0ICogIEByZXR1cm5zIHtpbnR9ID49MCBpZiBzdWNjZXNzZnVsIChpbmRleCBvZiBuZXcgYW9EYXRhIGVudHJ5KSwgLTEgaWYgZmFpbGVkXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkFkZERhdGEgKCBvU2V0dGluZ3MsIGFEYXRhSW4sIG5UciwgYW5UZHMgKVxuXHR7XG5cdFx0LyogQ3JlYXRlIHRoZSBvYmplY3QgZm9yIHN0b3JpbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhpcyBuZXcgcm93ICovXG5cdFx0dmFyIGlSb3cgPSBvU2V0dGluZ3MuYW9EYXRhLmxlbmd0aDtcblx0XHR2YXIgb0RhdGEgPSAkLmV4dGVuZCggdHJ1ZSwge30sIERhdGFUYWJsZS5tb2RlbHMub1Jvdywge1xuXHRcdFx0c3JjOiBuVHIgPyAnZG9tJyA6ICdkYXRhJ1xuXHRcdH0gKTtcblx0XG5cdFx0b0RhdGEuX2FEYXRhID0gYURhdGFJbjtcblx0XHRvU2V0dGluZ3MuYW9EYXRhLnB1c2goIG9EYXRhICk7XG5cdFxuXHRcdC8qIENyZWF0ZSB0aGUgY2VsbHMgKi9cblx0XHR2YXIgblRkLCBzVGhpc1R5cGU7XG5cdFx0dmFyIGNvbHVtbnMgPSBvU2V0dGluZ3MuYW9Db2x1bW5zO1xuXHRcdGZvciAoIHZhciBpPTAsIGlMZW49Y29sdW1ucy5sZW5ndGggOyBpPGlMZW4gOyBpKysgKVxuXHRcdHtcblx0XHRcdC8vIFdoZW4gd29ya2luZyB3aXRoIGEgcm93LCB0aGUgZGF0YSBzb3VyY2Ugb2JqZWN0IG11c3QgYmUgcG9wdWxhdGVkLiBJblxuXHRcdFx0Ly8gYWxsIG90aGVyIGNhc2VzLCB0aGUgZGF0YSBzb3VyY2Ugb2JqZWN0IGlzIGFscmVhZHkgcG9wdWxhdGVkLCBzbyB3ZVxuXHRcdFx0Ly8gZG9uJ3Qgb3ZlcndyaXRlIGl0LCB3aGljaCBtaWdodCBicmVhayBiaW5kaW5ncyBldGNcblx0XHRcdGlmICggblRyICkge1xuXHRcdFx0XHRfZm5TZXRDZWxsRGF0YSggb1NldHRpbmdzLCBpUm93LCBpLCBfZm5HZXRDZWxsRGF0YSggb1NldHRpbmdzLCBpUm93LCBpICkgKTtcblx0XHRcdH1cblx0XHRcdGNvbHVtbnNbaV0uc1R5cGUgPSBudWxsO1xuXHRcdH1cblx0XG5cdFx0LyogQWRkIHRvIHRoZSBkaXNwbGF5IGFycmF5ICovXG5cdFx0b1NldHRpbmdzLmFpRGlzcGxheU1hc3Rlci5wdXNoKCBpUm93ICk7XG5cdFxuXHRcdC8qIENyZWF0ZSB0aGUgRE9NIGluZm9ybWF0aW9uLCBvciByZWdpc3RlciBpdCBpZiBhbHJlYWR5IHByZXNlbnQgKi9cblx0XHRpZiAoIG5UciB8fCAhIG9TZXR0aW5ncy5vRmVhdHVyZXMuYkRlZmVyUmVuZGVyIClcblx0XHR7XG5cdFx0XHRfZm5DcmVhdGVUciggb1NldHRpbmdzLCBpUm93LCBuVHIsIGFuVGRzICk7XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gaVJvdztcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBBZGQgb25lIG9yIG1vcmUgVFIgZWxlbWVudHMgdG8gdGhlIHRhYmxlLiBHZW5lcmFsbHkgd2UnZCBleHBlY3QgdG9cblx0ICogdXNlIHRoaXMgZm9yIHJlYWRpbmcgZGF0YSBmcm9tIGEgRE9NIHNvdXJjZWQgdGFibGUsIGJ1dCBpdCBjb3VsZCBiZVxuXHQgKiB1c2VkIGZvciBhbiBUUiBlbGVtZW50LiBOb3RlIHRoYXQgaWYgYSBUUiBpcyBnaXZlbiwgaXQgaXMgdXNlZCAoaS5lLlxuXHQgKiBpdCBpcyBub3QgY2xvbmVkKS5cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHthcnJheXxub2RlfGpRdWVyeX0gdHJzIFRoZSBUUiBlbGVtZW50KHMpIHRvIGFkZCB0byB0aGUgdGFibGVcblx0ICogIEByZXR1cm5zIHthcnJheX0gQXJyYXkgb2YgaW5kZXhlcyBmb3IgdGhlIGFkZGVkIHJvd3Ncblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQWRkVHIoIHNldHRpbmdzLCB0cnMgKVxuXHR7XG5cdFx0dmFyIHJvdztcblx0XG5cdFx0Ly8gQWxsb3cgYW4gaW5kaXZpZHVhbCBub2RlIHRvIGJlIHBhc3NlZCBpblxuXHRcdGlmICggISAodHJzIGluc3RhbmNlb2YgJCkgKSB7XG5cdFx0XHR0cnMgPSAkKHRycyk7XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gdHJzLm1hcCggZnVuY3Rpb24gKGksIGVsKSB7XG5cdFx0XHRyb3cgPSBfZm5HZXRSb3dFbGVtZW50cyggc2V0dGluZ3MsIGVsICk7XG5cdFx0XHRyZXR1cm4gX2ZuQWRkRGF0YSggc2V0dGluZ3MsIHJvdy5kYXRhLCBlbCwgcm93LmNlbGxzICk7XG5cdFx0fSApO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIFRha2UgYSBUUiBlbGVtZW50IGFuZCBjb252ZXJ0IGl0IHRvIGFuIGluZGV4IGluIGFvRGF0YVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtub2RlfSBuIHRoZSBUUiBlbGVtZW50IHRvIGZpbmRcblx0ICogIEByZXR1cm5zIHtpbnR9IGluZGV4IGlmIHRoZSBub2RlIGlzIGZvdW5kLCBudWxsIGlmIG5vdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5Ob2RlVG9EYXRhSW5kZXgoIG9TZXR0aW5ncywgbiApXG5cdHtcblx0XHRyZXR1cm4gKG4uX0RUX1Jvd0luZGV4IT09dW5kZWZpbmVkKSA/IG4uX0RUX1Jvd0luZGV4IDogbnVsbDtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBUYWtlIGEgVEQgZWxlbWVudCBhbmQgY29udmVydCBpdCBpbnRvIGEgY29sdW1uIGRhdGEgaW5kZXggKG5vdCB0aGUgdmlzaWJsZSBpbmRleClcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7aW50fSBpUm93IFRoZSByb3cgbnVtYmVyIHRoZSBURC9USCBjYW4gYmUgZm91bmQgaW5cblx0ICogIEBwYXJhbSB7bm9kZX0gbiBUaGUgVEQvVEggZWxlbWVudCB0byBmaW5kXG5cdCAqICBAcmV0dXJucyB7aW50fSBpbmRleCBpZiB0aGUgbm9kZSBpcyBmb3VuZCwgLTEgaWYgbm90XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbk5vZGVUb0NvbHVtbkluZGV4KCBvU2V0dGluZ3MsIGlSb3csIG4gKVxuXHR7XG5cdFx0cmV0dXJuICQuaW5BcnJheSggbiwgb1NldHRpbmdzLmFvRGF0YVsgaVJvdyBdLmFuQ2VsbHMgKTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBHZXQgdGhlIGRhdGEgZm9yIGEgZ2l2ZW4gY2VsbCBmcm9tIHRoZSBpbnRlcm5hbCBjYWNoZSwgdGFraW5nIGludG8gYWNjb3VudCBkYXRhIG1hcHBpbmdcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtpbnR9IHJvd0lkeCBhb0RhdGEgcm93IGlkXG5cdCAqICBAcGFyYW0ge2ludH0gY29sSWR4IENvbHVtbiBpbmRleFxuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IHR5cGUgZGF0YSBnZXQgdHlwZSAoJ2Rpc3BsYXknLCAndHlwZScgJ2ZpbHRlcicgJ3NvcnQnKVxuXHQgKiAgQHJldHVybnMgeyp9IENlbGwgZGF0YVxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5HZXRDZWxsRGF0YSggc2V0dGluZ3MsIHJvd0lkeCwgY29sSWR4LCB0eXBlIClcblx0e1xuXHRcdHZhciBkcmF3ICAgICAgICAgICA9IHNldHRpbmdzLmlEcmF3O1xuXHRcdHZhciBjb2wgICAgICAgICAgICA9IHNldHRpbmdzLmFvQ29sdW1uc1tjb2xJZHhdO1xuXHRcdHZhciByb3dEYXRhICAgICAgICA9IHNldHRpbmdzLmFvRGF0YVtyb3dJZHhdLl9hRGF0YTtcblx0XHR2YXIgZGVmYXVsdENvbnRlbnQgPSBjb2wuc0RlZmF1bHRDb250ZW50O1xuXHRcdHZhciBjZWxsRGF0YSAgICAgICA9IGNvbC5mbkdldERhdGEoIHJvd0RhdGEsIHR5cGUsIHtcblx0XHRcdHNldHRpbmdzOiBzZXR0aW5ncyxcblx0XHRcdHJvdzogICAgICByb3dJZHgsXG5cdFx0XHRjb2w6ICAgICAgY29sSWR4XG5cdFx0fSApO1xuXHRcblx0XHRpZiAoIGNlbGxEYXRhID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHNldHRpbmdzLmlEcmF3RXJyb3IgIT0gZHJhdyAmJiBkZWZhdWx0Q29udGVudCA9PT0gbnVsbCApIHtcblx0XHRcdFx0X2ZuTG9nKCBzZXR0aW5ncywgMCwgXCJSZXF1ZXN0ZWQgdW5rbm93biBwYXJhbWV0ZXIgXCIrXG5cdFx0XHRcdFx0KHR5cGVvZiBjb2wubURhdGE9PSdmdW5jdGlvbicgPyAne2Z1bmN0aW9ufScgOiBcIidcIitjb2wubURhdGErXCInXCIpK1xuXHRcdFx0XHRcdFwiIGZvciByb3cgXCIrcm93SWR4LCA0ICk7XG5cdFx0XHRcdHNldHRpbmdzLmlEcmF3RXJyb3IgPSBkcmF3O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGRlZmF1bHRDb250ZW50O1xuXHRcdH1cblx0XG5cdFx0LyogV2hlbiB0aGUgZGF0YSBzb3VyY2UgaXMgbnVsbCwgd2UgY2FuIHVzZSBkZWZhdWx0IGNvbHVtbiBkYXRhICovXG5cdFx0aWYgKCAoY2VsbERhdGEgPT09IHJvd0RhdGEgfHwgY2VsbERhdGEgPT09IG51bGwpICYmIGRlZmF1bHRDb250ZW50ICE9PSBudWxsICkge1xuXHRcdFx0Y2VsbERhdGEgPSBkZWZhdWx0Q29udGVudDtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHR5cGVvZiBjZWxsRGF0YSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdC8vIElmIHRoZSBkYXRhIHNvdXJjZSBpcyBhIGZ1bmN0aW9uLCB0aGVuIHdlIHJ1biBpdCBhbmQgdXNlIHRoZSByZXR1cm4sXG5cdFx0XHQvLyBleGVjdXRpbmcgaW4gdGhlIHNjb3BlIG9mIHRoZSBkYXRhIG9iamVjdCAoZm9yIGluc3RhbmNlcylcblx0XHRcdHJldHVybiBjZWxsRGF0YS5jYWxsKCByb3dEYXRhICk7XG5cdFx0fVxuXHRcblx0XHRpZiAoIGNlbGxEYXRhID09PSBudWxsICYmIHR5cGUgPT0gJ2Rpc3BsYXknICkge1xuXHRcdFx0cmV0dXJuICcnO1xuXHRcdH1cblx0XHRyZXR1cm4gY2VsbERhdGE7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogU2V0IHRoZSB2YWx1ZSBmb3IgYSBzcGVjaWZpYyBjZWxsLCBpbnRvIHRoZSBpbnRlcm5hbCBkYXRhIGNhY2hlXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7aW50fSByb3dJZHggYW9EYXRhIHJvdyBpZFxuXHQgKiAgQHBhcmFtIHtpbnR9IGNvbElkeCBDb2x1bW4gaW5kZXhcblx0ICogIEBwYXJhbSB7Kn0gdmFsIFZhbHVlIHRvIHNldFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5TZXRDZWxsRGF0YSggc2V0dGluZ3MsIHJvd0lkeCwgY29sSWR4LCB2YWwgKVxuXHR7XG5cdFx0dmFyIGNvbCAgICAgPSBzZXR0aW5ncy5hb0NvbHVtbnNbY29sSWR4XTtcblx0XHR2YXIgcm93RGF0YSA9IHNldHRpbmdzLmFvRGF0YVtyb3dJZHhdLl9hRGF0YTtcblx0XG5cdFx0Y29sLmZuU2V0RGF0YSggcm93RGF0YSwgdmFsLCB7XG5cdFx0XHRzZXR0aW5nczogc2V0dGluZ3MsXG5cdFx0XHRyb3c6ICAgICAgcm93SWR4LFxuXHRcdFx0Y29sOiAgICAgIGNvbElkeFxuXHRcdH0gICk7XG5cdH1cblx0XG5cdFxuXHQvLyBQcml2YXRlIHZhcmlhYmxlIHRoYXQgaXMgdXNlZCB0byBtYXRjaCBhY3Rpb24gc3ludGF4IGluIHRoZSBkYXRhIHByb3BlcnR5IG9iamVjdFxuXHR2YXIgX19yZUFycmF5ID0gL1xcWy4qP1xcXSQvO1xuXHR2YXIgX19yZUZuID0gL1xcKFxcKSQvO1xuXHRcblx0LyoqXG5cdCAqIFNwbGl0IHN0cmluZyBvbiBwZXJpb2RzLCB0YWtpbmcgaW50byBhY2NvdW50IGVzY2FwZWQgcGVyaW9kc1xuXHQgKiBAcGFyYW0gIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gc3BsaXRcblx0ICogQHJldHVybiB7YXJyYXl9IFNwbGl0IHN0cmluZ1xuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuU3BsaXRPYmpOb3RhdGlvbiggc3RyIClcblx0e1xuXHRcdHJldHVybiAkLm1hcCggc3RyLm1hdGNoKC8oXFxcXC58W15cXC5dKSsvZyksIGZ1bmN0aW9uICggcyApIHtcblx0XHRcdHJldHVybiBzLnJlcGxhY2UoL1xcXFwuL2csICcuJyk7XG5cdFx0fSApO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gZ2V0IGRhdGEgZnJvbSBhIHNvdXJjZSBvYmplY3QsIHRha2luZ1xuXHQgKiBpbnRvIGFjY291bnQgdGhlIGFiaWxpdHkgdG8gdXNlIG5lc3RlZCBvYmplY3RzIGFzIGEgc291cmNlXG5cdCAqICBAcGFyYW0ge3N0cmluZ3xpbnR8ZnVuY3Rpb259IG1Tb3VyY2UgVGhlIGRhdGEgc291cmNlIGZvciB0aGUgb2JqZWN0XG5cdCAqICBAcmV0dXJucyB7ZnVuY3Rpb259IERhdGEgZ2V0IGZ1bmN0aW9uXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkdldE9iamVjdERhdGFGbiggbVNvdXJjZSApXG5cdHtcblx0XHRpZiAoICQuaXNQbGFpbk9iamVjdCggbVNvdXJjZSApIClcblx0XHR7XG5cdFx0XHQvKiBCdWlsZCBhbiBvYmplY3Qgb2YgZ2V0IGZ1bmN0aW9ucywgYW5kIHdyYXAgdGhlbSBpbiBhIHNpbmdsZSBjYWxsICovXG5cdFx0XHR2YXIgbyA9IHt9O1xuXHRcdFx0JC5lYWNoKCBtU291cmNlLCBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcblx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0b1trZXldID0gX2ZuR2V0T2JqZWN0RGF0YUZuKCB2YWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcblx0XHRcdHJldHVybiBmdW5jdGlvbiAoZGF0YSwgdHlwZSwgcm93LCBtZXRhKSB7XG5cdFx0XHRcdHZhciB0ID0gb1t0eXBlXSB8fCBvLl87XG5cdFx0XHRcdHJldHVybiB0ICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRcdHQoZGF0YSwgdHlwZSwgcm93LCBtZXRhKSA6XG5cdFx0XHRcdFx0ZGF0YTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBtU291cmNlID09PSBudWxsIClcblx0XHR7XG5cdFx0XHQvKiBHaXZlIGFuIGVtcHR5IHN0cmluZyBmb3IgcmVuZGVyaW5nIC8gc29ydGluZyBldGMgKi9cblx0XHRcdHJldHVybiBmdW5jdGlvbiAoZGF0YSkgeyAvLyB0eXBlLCByb3cgYW5kIG1ldGEgYWxzbyBwYXNzZWQsIGJ1dCBub3QgdXNlZFxuXHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCB0eXBlb2YgbVNvdXJjZSA9PT0gJ2Z1bmN0aW9uJyApXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChkYXRhLCB0eXBlLCByb3csIG1ldGEpIHtcblx0XHRcdFx0cmV0dXJuIG1Tb3VyY2UoIGRhdGEsIHR5cGUsIHJvdywgbWV0YSApO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHR5cGVvZiBtU291cmNlID09PSAnc3RyaW5nJyAmJiAobVNvdXJjZS5pbmRleE9mKCcuJykgIT09IC0xIHx8XG5cdFx0XHQgICAgICBtU291cmNlLmluZGV4T2YoJ1snKSAhPT0gLTEgfHwgbVNvdXJjZS5pbmRleE9mKCcoJykgIT09IC0xKSApXG5cdFx0e1xuXHRcdFx0LyogSWYgdGhlcmUgaXMgYSAuIGluIHRoZSBzb3VyY2Ugc3RyaW5nIHRoZW4gdGhlIGRhdGEgc291cmNlIGlzIGluIGFcblx0XHRcdCAqIG5lc3RlZCBvYmplY3Qgc28gd2UgbG9vcCBvdmVyIHRoZSBkYXRhIGZvciBlYWNoIGxldmVsIHRvIGdldCB0aGUgbmV4dFxuXHRcdFx0ICogbGV2ZWwgZG93bi4gT24gZWFjaCBsb29wIHdlIHRlc3QgZm9yIHVuZGVmaW5lZCwgYW5kIGlmIGZvdW5kIGltbWVkaWF0ZWx5XG5cdFx0XHQgKiByZXR1cm4uIFRoaXMgYWxsb3dzIGVudGlyZSBvYmplY3RzIHRvIGJlIG1pc3NpbmcgYW5kIHNEZWZhdWx0Q29udGVudCB0b1xuXHRcdFx0ICogYmUgdXNlZCBpZiBkZWZpbmVkLCByYXRoZXIgdGhhbiB0aHJvd2luZyBhbiBlcnJvclxuXHRcdFx0ICovXG5cdFx0XHR2YXIgZmV0Y2hEYXRhID0gZnVuY3Rpb24gKGRhdGEsIHR5cGUsIHNyYykge1xuXHRcdFx0XHR2YXIgYXJyYXlOb3RhdGlvbiwgZnVuY05vdGF0aW9uLCBvdXQsIGlubmVyU3JjO1xuXHRcblx0XHRcdFx0aWYgKCBzcmMgIT09IFwiXCIgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dmFyIGEgPSBfZm5TcGxpdE9iak5vdGF0aW9uKCBzcmMgKTtcblx0XG5cdFx0XHRcdFx0Zm9yICggdmFyIGk9MCwgaUxlbj1hLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Ly8gQ2hlY2sgaWYgd2UgYXJlIGRlYWxpbmcgd2l0aCBzcGVjaWFsIG5vdGF0aW9uXG5cdFx0XHRcdFx0XHRhcnJheU5vdGF0aW9uID0gYVtpXS5tYXRjaChfX3JlQXJyYXkpO1xuXHRcdFx0XHRcdFx0ZnVuY05vdGF0aW9uID0gYVtpXS5tYXRjaChfX3JlRm4pO1xuXHRcblx0XHRcdFx0XHRcdGlmICggYXJyYXlOb3RhdGlvbiApXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdC8vIEFycmF5IG5vdGF0aW9uXG5cdFx0XHRcdFx0XHRcdGFbaV0gPSBhW2ldLnJlcGxhY2UoX19yZUFycmF5LCAnJyk7XG5cdFxuXHRcdFx0XHRcdFx0XHQvLyBDb25kaXRpb24gYWxsb3dzIHNpbXBseSBbXSB0byBiZSBwYXNzZWQgaW5cblx0XHRcdFx0XHRcdFx0aWYgKCBhW2ldICE9PSBcIlwiICkge1xuXHRcdFx0XHRcdFx0XHRcdGRhdGEgPSBkYXRhWyBhW2ldIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0b3V0ID0gW107XG5cdFxuXHRcdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHJlbWFpbmRlciBvZiB0aGUgbmVzdGVkIG9iamVjdCB0byBnZXRcblx0XHRcdFx0XHRcdFx0YS5zcGxpY2UoIDAsIGkrMSApO1xuXHRcdFx0XHRcdFx0XHRpbm5lclNyYyA9IGEuam9pbignLicpO1xuXHRcblx0XHRcdFx0XHRcdFx0Ly8gVHJhdmVyc2UgZWFjaCBlbnRyeSBpbiB0aGUgYXJyYXkgZ2V0dGluZyB0aGUgcHJvcGVydGllcyByZXF1ZXN0ZWRcblx0XHRcdFx0XHRcdFx0Zm9yICggdmFyIGo9MCwgakxlbj1kYXRhLmxlbmd0aCA7IGo8akxlbiA7IGorKyApIHtcblx0XHRcdFx0XHRcdFx0XHRvdXQucHVzaCggZmV0Y2hEYXRhKCBkYXRhW2pdLCB0eXBlLCBpbm5lclNyYyApICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0XHRcdC8vIElmIGEgc3RyaW5nIGlzIGdpdmVuIGluIGJldHdlZW4gdGhlIGFycmF5IG5vdGF0aW9uIGluZGljYXRvcnMsIHRoYXRcblx0XHRcdFx0XHRcdFx0Ly8gaXMgdXNlZCB0byBqb2luIHRoZSBzdHJpbmdzIHRvZ2V0aGVyLCBvdGhlcndpc2UgYW4gYXJyYXkgaXMgcmV0dXJuZWRcblx0XHRcdFx0XHRcdFx0dmFyIGpvaW4gPSBhcnJheU5vdGF0aW9uWzBdLnN1YnN0cmluZygxLCBhcnJheU5vdGF0aW9uWzBdLmxlbmd0aC0xKTtcblx0XHRcdFx0XHRcdFx0ZGF0YSA9IChqb2luPT09XCJcIikgPyBvdXQgOiBvdXQuam9pbihqb2luKTtcblx0XG5cdFx0XHRcdFx0XHRcdC8vIFRoZSBpbm5lciBjYWxsIHRvIGZldGNoRGF0YSBoYXMgYWxyZWFkeSB0cmF2ZXJzZWQgdGhyb3VnaCB0aGUgcmVtYWluZGVyXG5cdFx0XHRcdFx0XHRcdC8vIG9mIHRoZSBzb3VyY2UgcmVxdWVzdGVkLCBzbyB3ZSBleGl0IGZyb20gdGhlIGxvb3Bcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIGlmICggZnVuY05vdGF0aW9uIClcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0Ly8gRnVuY3Rpb24gY2FsbFxuXHRcdFx0XHRcdFx0XHRhW2ldID0gYVtpXS5yZXBsYWNlKF9fcmVGbiwgJycpO1xuXHRcdFx0XHRcdFx0XHRkYXRhID0gZGF0YVsgYVtpXSBdKCk7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRcdGlmICggZGF0YSA9PT0gbnVsbCB8fCBkYXRhWyBhW2ldIF0gPT09IHVuZGVmaW5lZCApXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRkYXRhID0gZGF0YVsgYVtpXSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHR9O1xuXHRcblx0XHRcdHJldHVybiBmdW5jdGlvbiAoZGF0YSwgdHlwZSkgeyAvLyByb3cgYW5kIG1ldGEgYWxzbyBwYXNzZWQsIGJ1dCBub3QgdXNlZFxuXHRcdFx0XHRyZXR1cm4gZmV0Y2hEYXRhKCBkYXRhLCB0eXBlLCBtU291cmNlICk7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0LyogQXJyYXkgb3IgZmxhdCBvYmplY3QgbWFwcGluZyAqL1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChkYXRhLCB0eXBlKSB7IC8vIHJvdyBhbmQgbWV0YSBhbHNvIHBhc3NlZCwgYnV0IG5vdCB1c2VkXG5cdFx0XHRcdHJldHVybiBkYXRhW21Tb3VyY2VdO1xuXHRcdFx0fTtcblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBzZXQgZGF0YSBmcm9tIGEgc291cmNlIG9iamVjdCwgdGFraW5nXG5cdCAqIGludG8gYWNjb3VudCB0aGUgYWJpbGl0eSB0byB1c2UgbmVzdGVkIG9iamVjdHMgYXMgYSBzb3VyY2Vcblx0ICogIEBwYXJhbSB7c3RyaW5nfGludHxmdW5jdGlvbn0gbVNvdXJjZSBUaGUgZGF0YSBzb3VyY2UgZm9yIHRoZSBvYmplY3Rcblx0ICogIEByZXR1cm5zIHtmdW5jdGlvbn0gRGF0YSBzZXQgZnVuY3Rpb25cblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuU2V0T2JqZWN0RGF0YUZuKCBtU291cmNlIClcblx0e1xuXHRcdGlmICggJC5pc1BsYWluT2JqZWN0KCBtU291cmNlICkgKVxuXHRcdHtcblx0XHRcdC8qIFVubGlrZSBnZXQsIG9ubHkgdGhlIHVuZGVyc2NvcmUgKGdsb2JhbCkgb3B0aW9uIGlzIHVzZWQgZm9yIGZvclxuXHRcdFx0ICogc2V0dGluZyBkYXRhIHNpbmNlIHdlIGRvbid0IGtub3cgdGhlIHR5cGUgaGVyZS4gVGhpcyBpcyB3aHkgYW4gb2JqZWN0XG5cdFx0XHQgKiBvcHRpb24gaXMgbm90IGRvY3VtZW50ZWQgZm9yIGBtRGF0YWAgKHdoaWNoIGlzIHJlYWQvd3JpdGUpLCBidXQgaXQgaXNcblx0XHRcdCAqIGZvciBgbVJlbmRlcmAgd2hpY2ggaXMgcmVhZCBvbmx5LlxuXHRcdFx0ICovXG5cdFx0XHRyZXR1cm4gX2ZuU2V0T2JqZWN0RGF0YUZuKCBtU291cmNlLl8gKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIG1Tb3VyY2UgPT09IG51bGwgKVxuXHRcdHtcblx0XHRcdC8qIE5vdGhpbmcgdG8gZG8gd2hlbiB0aGUgZGF0YSBzb3VyY2UgaXMgbnVsbCAqL1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHt9O1xuXHRcdH1cblx0XHRlbHNlIGlmICggdHlwZW9mIG1Tb3VyY2UgPT09ICdmdW5jdGlvbicgKVxuXHRcdHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiAoZGF0YSwgdmFsLCBtZXRhKSB7XG5cdFx0XHRcdG1Tb3VyY2UoIGRhdGEsICdzZXQnLCB2YWwsIG1ldGEgKTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCB0eXBlb2YgbVNvdXJjZSA9PT0gJ3N0cmluZycgJiYgKG1Tb3VyY2UuaW5kZXhPZignLicpICE9PSAtMSB8fFxuXHRcdFx0ICAgICAgbVNvdXJjZS5pbmRleE9mKCdbJykgIT09IC0xIHx8IG1Tb3VyY2UuaW5kZXhPZignKCcpICE9PSAtMSkgKVxuXHRcdHtcblx0XHRcdC8qIExpa2UgdGhlIGdldCwgd2UgbmVlZCB0byBnZXQgZGF0YSBmcm9tIGEgbmVzdGVkIG9iamVjdCAqL1xuXHRcdFx0dmFyIHNldERhdGEgPSBmdW5jdGlvbiAoZGF0YSwgdmFsLCBzcmMpIHtcblx0XHRcdFx0dmFyIGEgPSBfZm5TcGxpdE9iak5vdGF0aW9uKCBzcmMgKSwgYjtcblx0XHRcdFx0dmFyIGFMYXN0ID0gYVthLmxlbmd0aC0xXTtcblx0XHRcdFx0dmFyIGFycmF5Tm90YXRpb24sIGZ1bmNOb3RhdGlvbiwgbywgaW5uZXJTcmM7XG5cdFxuXHRcdFx0XHRmb3IgKCB2YXIgaT0wLCBpTGVuPWEubGVuZ3RoLTEgOyBpPGlMZW4gOyBpKysgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Ly8gQ2hlY2sgaWYgd2UgYXJlIGRlYWxpbmcgd2l0aCBhbiBhcnJheSBub3RhdGlvbiByZXF1ZXN0XG5cdFx0XHRcdFx0YXJyYXlOb3RhdGlvbiA9IGFbaV0ubWF0Y2goX19yZUFycmF5KTtcblx0XHRcdFx0XHRmdW5jTm90YXRpb24gPSBhW2ldLm1hdGNoKF9fcmVGbik7XG5cdFxuXHRcdFx0XHRcdGlmICggYXJyYXlOb3RhdGlvbiApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0YVtpXSA9IGFbaV0ucmVwbGFjZShfX3JlQXJyYXksICcnKTtcblx0XHRcdFx0XHRcdGRhdGFbIGFbaV0gXSA9IFtdO1xuXHRcblx0XHRcdFx0XHRcdC8vIEdldCB0aGUgcmVtYWluZGVyIG9mIHRoZSBuZXN0ZWQgb2JqZWN0IHRvIHNldCBzbyB3ZSBjYW4gcmVjdXJzZVxuXHRcdFx0XHRcdFx0YiA9IGEuc2xpY2UoKTtcblx0XHRcdFx0XHRcdGIuc3BsaWNlKCAwLCBpKzEgKTtcblx0XHRcdFx0XHRcdGlubmVyU3JjID0gYi5qb2luKCcuJyk7XG5cdFxuXHRcdFx0XHRcdFx0Ly8gVHJhdmVyc2UgZWFjaCBlbnRyeSBpbiB0aGUgYXJyYXkgc2V0dGluZyB0aGUgcHJvcGVydGllcyByZXF1ZXN0ZWRcblx0XHRcdFx0XHRcdGZvciAoIHZhciBqPTAsIGpMZW49dmFsLmxlbmd0aCA7IGo8akxlbiA7IGorKyApXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdG8gPSB7fTtcblx0XHRcdFx0XHRcdFx0c2V0RGF0YSggbywgdmFsW2pdLCBpbm5lclNyYyApO1xuXHRcdFx0XHRcdFx0XHRkYXRhWyBhW2ldIF0ucHVzaCggbyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRcdC8vIFRoZSBpbm5lciBjYWxsIHRvIHNldERhdGEgaGFzIGFscmVhZHkgdHJhdmVyc2VkIHRocm91Z2ggdGhlIHJlbWFpbmRlclxuXHRcdFx0XHRcdFx0Ly8gb2YgdGhlIHNvdXJjZSBhbmQgaGFzIHNldCB0aGUgZGF0YSwgdGh1cyB3ZSBjYW4gZXhpdCBoZXJlXG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgaWYgKCBmdW5jTm90YXRpb24gKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdC8vIEZ1bmN0aW9uIGNhbGxcblx0XHRcdFx0XHRcdGFbaV0gPSBhW2ldLnJlcGxhY2UoX19yZUZuLCAnJyk7XG5cdFx0XHRcdFx0XHRkYXRhID0gZGF0YVsgYVtpXSBdKCB2YWwgKTtcblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdC8vIElmIHRoZSBuZXN0ZWQgb2JqZWN0IGRvZXNuJ3QgY3VycmVudGx5IGV4aXN0IC0gc2luY2Ugd2UgYXJlXG5cdFx0XHRcdFx0Ly8gdHJ5aW5nIHRvIHNldCB0aGUgdmFsdWUgLSBjcmVhdGUgaXRcblx0XHRcdFx0XHRpZiAoIGRhdGFbIGFbaV0gXSA9PT0gbnVsbCB8fCBkYXRhWyBhW2ldIF0gPT09IHVuZGVmaW5lZCApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0ZGF0YVsgYVtpXSBdID0ge307XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRhdGEgPSBkYXRhWyBhW2ldIF07XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdC8vIExhc3QgaXRlbSBpbiB0aGUgaW5wdXQgLSBpLmUsIHRoZSBhY3R1YWwgc2V0XG5cdFx0XHRcdGlmICggYUxhc3QubWF0Y2goX19yZUZuICkgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Ly8gRnVuY3Rpb24gY2FsbFxuXHRcdFx0XHRcdGRhdGEgPSBkYXRhWyBhTGFzdC5yZXBsYWNlKF9fcmVGbiwgJycpIF0oIHZhbCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0e1xuXHRcdFx0XHRcdC8vIElmIGFycmF5IG5vdGF0aW9uIGlzIHVzZWQsIHdlIGp1c3Qgd2FudCB0byBzdHJpcCBpdCBhbmQgdXNlIHRoZSBwcm9wZXJ0eSBuYW1lXG5cdFx0XHRcdFx0Ly8gYW5kIGFzc2lnbiB0aGUgdmFsdWUuIElmIGl0IGlzbid0IHVzZWQsIHRoZW4gd2UgZ2V0IHRoZSByZXN1bHQgd2Ugd2FudCBhbnl3YXlcblx0XHRcdFx0XHRkYXRhWyBhTGFzdC5yZXBsYWNlKF9fcmVBcnJheSwgJycpIF0gPSB2YWw7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChkYXRhLCB2YWwpIHsgLy8gbWV0YSBpcyBhbHNvIHBhc3NlZCBpbiwgYnV0IG5vdCB1c2VkXG5cdFx0XHRcdHJldHVybiBzZXREYXRhKCBkYXRhLCB2YWwsIG1Tb3VyY2UgKTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHQvKiBBcnJheSBvciBmbGF0IG9iamVjdCBtYXBwaW5nICovXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKGRhdGEsIHZhbCkgeyAvLyBtZXRhIGlzIGFsc28gcGFzc2VkIGluLCBidXQgbm90IHVzZWRcblx0XHRcdFx0ZGF0YVttU291cmNlXSA9IHZhbDtcblx0XHRcdH07XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIFJldHVybiBhbiBhcnJheSB3aXRoIHRoZSBmdWxsIHRhYmxlIGRhdGFcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEByZXR1cm5zIGFycmF5IHthcnJheX0gYURhdGEgTWFzdGVyIGRhdGEgYXJyYXlcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuR2V0RGF0YU1hc3RlciAoIHNldHRpbmdzIClcblx0e1xuXHRcdHJldHVybiBfcGx1Y2soIHNldHRpbmdzLmFvRGF0YSwgJ19hRGF0YScgKTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBOdWtlIHRoZSB0YWJsZVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5DbGVhclRhYmxlKCBzZXR0aW5ncyApXG5cdHtcblx0XHRzZXR0aW5ncy5hb0RhdGEubGVuZ3RoID0gMDtcblx0XHRzZXR0aW5ncy5haURpc3BsYXlNYXN0ZXIubGVuZ3RoID0gMDtcblx0XHRzZXR0aW5ncy5haURpc3BsYXkubGVuZ3RoID0gMDtcblx0fVxuXHRcblx0XG5cdCAvKipcblx0ICogVGFrZSBhbiBhcnJheSBvZiBpbnRlZ2VycyAoaW5kZXggYXJyYXkpIGFuZCByZW1vdmUgYSB0YXJnZXQgaW50ZWdlciAodmFsdWUgLSBub3Rcblx0ICogdGhlIGtleSEpXG5cdCAqICBAcGFyYW0ge2FycmF5fSBhIEluZGV4IGFycmF5IHRvIHRhcmdldFxuXHQgKiAgQHBhcmFtIHtpbnR9IGlUYXJnZXQgdmFsdWUgdG8gZmluZFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5EZWxldGVJbmRleCggYSwgaVRhcmdldCwgc3BsaWNlIClcblx0e1xuXHRcdHZhciBpVGFyZ2V0SW5kZXggPSAtMTtcblx0XG5cdFx0Zm9yICggdmFyIGk9MCwgaUxlbj1hLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApXG5cdFx0e1xuXHRcdFx0aWYgKCBhW2ldID09IGlUYXJnZXQgKVxuXHRcdFx0e1xuXHRcdFx0XHRpVGFyZ2V0SW5kZXggPSBpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIGFbaV0gPiBpVGFyZ2V0IClcblx0XHRcdHtcblx0XHRcdFx0YVtpXS0tO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0aWYgKCBpVGFyZ2V0SW5kZXggIT0gLTEgJiYgc3BsaWNlID09PSB1bmRlZmluZWQgKVxuXHRcdHtcblx0XHRcdGEuc3BsaWNlKCBpVGFyZ2V0SW5kZXgsIDEgKTtcblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogTWFyayBjYWNoZWQgZGF0YSBhcyBpbnZhbGlkIHN1Y2ggdGhhdCBhIHJlLXJlYWQgb2YgdGhlIGRhdGEgd2lsbCBvY2N1ciB3aGVuXG5cdCAqIHRoZSBjYWNoZWQgZGF0YSBpcyBuZXh0IHJlcXVlc3RlZC4gQWxzbyB1cGRhdGUgZnJvbSB0aGUgZGF0YSBzb3VyY2Ugb2JqZWN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogQHBhcmFtIHtpbnR9ICAgIHJvd0lkeCAgIFJvdyBpbmRleCB0byBpbnZhbGlkYXRlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbc3JjXSAgICBTb3VyY2UgdG8gaW52YWxpZGF0ZSBmcm9tOiB1bmRlZmluZWQsICdhdXRvJywgJ2RvbSdcblx0ICogICAgIG9yICdkYXRhJ1xuXHQgKiBAcGFyYW0ge2ludH0gICAgW2NvbElkeF0gQ29sdW1uIGluZGV4IHRvIGludmFsaWRhdGUuIElmIHVuZGVmaW5lZCB0aGUgd2hvbGVcblx0ICogICAgIHJvdyB3aWxsIGJlIGludmFsaWRhdGVkXG5cdCAqIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKlxuXHQgKiBAdG9kbyBGb3IgdGhlIG1vZHVsYXJpc2F0aW9uIG9mIHYxLjExIHRoaXMgd2lsbCBuZWVkIHRvIGJlY29tZSBhIGNhbGxiYWNrLCBzb1xuXHQgKiAgIHRoZSBzb3J0IGFuZCBmaWx0ZXIgbWV0aG9kcyBjYW4gc3Vic2NyaWJlIHRvIGl0LiBUaGF0IHdpbGwgcmVxdWlyZWRcblx0ICogICBpbml0aWFsaXNhdGlvbiBvcHRpb25zIGZvciBzb3J0aW5nLCB3aGljaCBpcyB3aHkgaXQgaXMgbm90IGFscmVhZHkgYmFrZWQgaW5cblx0ICovXG5cdGZ1bmN0aW9uIF9mbkludmFsaWRhdGUoIHNldHRpbmdzLCByb3dJZHgsIHNyYywgY29sSWR4IClcblx0e1xuXHRcdHZhciByb3cgPSBzZXR0aW5ncy5hb0RhdGFbIHJvd0lkeCBdO1xuXHRcdHZhciBpLCBpZW47XG5cdFx0dmFyIGNlbGxXcml0ZSA9IGZ1bmN0aW9uICggY2VsbCwgY29sICkge1xuXHRcdFx0Ly8gVGhpcyBpcyB2ZXJ5IGZydXN0cmF0aW5nLCBidXQgaW4gSUUgaWYgeW91IGp1c3Qgd3JpdGUgZGlyZWN0bHlcblx0XHRcdC8vIHRvIGlubmVySFRNTCwgYW5kIGVsZW1lbnRzIHRoYXQgYXJlIG92ZXJ3cml0dGVuIGFyZSBHQydlZCxcblx0XHRcdC8vIGV2ZW4gaWYgdGhlcmUgaXMgYSByZWZlcmVuY2UgdG8gdGhlbSBlbHNld2hlcmVcblx0XHRcdHdoaWxlICggY2VsbC5jaGlsZE5vZGVzLmxlbmd0aCApIHtcblx0XHRcdFx0Y2VsbC5yZW1vdmVDaGlsZCggY2VsbC5maXJzdENoaWxkICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Y2VsbC5pbm5lckhUTUwgPSBfZm5HZXRDZWxsRGF0YSggc2V0dGluZ3MsIHJvd0lkeCwgY29sLCAnZGlzcGxheScgKTtcblx0XHR9O1xuXHRcblx0XHQvLyBBcmUgd2UgcmVhZGluZyBsYXN0IGRhdGEgZnJvbSBET00gb3IgdGhlIGRhdGEgb2JqZWN0P1xuXHRcdGlmICggc3JjID09PSAnZG9tJyB8fCAoKCEgc3JjIHx8IHNyYyA9PT0gJ2F1dG8nKSAmJiByb3cuc3JjID09PSAnZG9tJykgKSB7XG5cdFx0XHQvLyBSZWFkIHRoZSBkYXRhIGZyb20gdGhlIERPTVxuXHRcdFx0cm93Ll9hRGF0YSA9IF9mbkdldFJvd0VsZW1lbnRzKFxuXHRcdFx0XHRcdHNldHRpbmdzLCByb3csIGNvbElkeCwgY29sSWR4ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByb3cuX2FEYXRhXG5cdFx0XHRcdClcblx0XHRcdFx0LmRhdGE7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gUmVhZGluZyBmcm9tIGRhdGEgb2JqZWN0LCB1cGRhdGUgdGhlIERPTVxuXHRcdFx0dmFyIGNlbGxzID0gcm93LmFuQ2VsbHM7XG5cdFxuXHRcdFx0aWYgKCBjZWxscyApIHtcblx0XHRcdFx0aWYgKCBjb2xJZHggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRjZWxsV3JpdGUoIGNlbGxzW2NvbElkeF0sIGNvbElkeCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGZvciAoIGk9MCwgaWVuPWNlbGxzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRcdFx0Y2VsbFdyaXRlKCBjZWxsc1tpXSwgaSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0Ly8gRm9yIGJvdGggcm93IGFuZCBjZWxsIGludmFsaWRhdGlvbiwgdGhlIGNhY2hlZCBkYXRhIGZvciBzb3J0aW5nIGFuZFxuXHRcdC8vIGZpbHRlcmluZyBpcyBudWxsZWQgb3V0XG5cdFx0cm93Ll9hU29ydERhdGEgPSBudWxsO1xuXHRcdHJvdy5fYUZpbHRlckRhdGEgPSBudWxsO1xuXHRcblx0XHQvLyBJbnZhbGlkYXRlIHRoZSB0eXBlIGZvciBhIHNwZWNpZmljIGNvbHVtbiAoaWYgZ2l2ZW4pIG9yIGFsbCBjb2x1bW5zIHNpbmNlXG5cdFx0Ly8gdGhlIGRhdGEgbWlnaHQgaGF2ZSBjaGFuZ2VkXG5cdFx0dmFyIGNvbHMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XG5cdFx0aWYgKCBjb2xJZHggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGNvbHNbIGNvbElkeCBdLnNUeXBlID0gbnVsbDtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRmb3IgKCBpPTAsIGllbj1jb2xzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRjb2xzW2ldLnNUeXBlID0gbnVsbDtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBVcGRhdGUgRGF0YVRhYmxlcyBzcGVjaWFsIGBEVF8qYCBhdHRyaWJ1dGVzIGZvciB0aGUgcm93XG5cdFx0XHRfZm5Sb3dBdHRyaWJ1dGVzKCByb3cgKTtcblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogQnVpbGQgYSBkYXRhIHNvdXJjZSBvYmplY3QgZnJvbSBhbiBIVE1MIHJvdywgcmVhZGluZyB0aGUgY29udGVudHMgb2YgdGhlXG5cdCAqIGNlbGxzIHRoYXQgYXJlIGluIHRoZSByb3cuXG5cdCAqXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiBAcGFyYW0ge25vZGV8b2JqZWN0fSBUUiBlbGVtZW50IGZyb20gd2hpY2ggdG8gcmVhZCBkYXRhIG9yIGV4aXN0aW5nIHJvd1xuXHQgKiAgIG9iamVjdCBmcm9tIHdoaWNoIHRvIHJlLXJlYWQgdGhlIGRhdGEgZnJvbSB0aGUgY2VsbHNcblx0ICogQHBhcmFtIHtpbnR9IFtjb2xJZHhdIE9wdGlvbmFsIGNvbHVtbiBpbmRleFxuXHQgKiBAcGFyYW0ge2FycmF5fG9iamVjdH0gW2RdIERhdGEgc291cmNlIG9iamVjdC4gSWYgYGNvbElkeGAgaXMgZ2l2ZW4gdGhlbiB0aGlzXG5cdCAqICAgcGFyYW1ldGVyIHNob3VsZCBhbHNvIGJlIGdpdmVuIGFuZCB3aWxsIGJlIHVzZWQgdG8gd3JpdGUgdGhlIGRhdGEgaW50by5cblx0ICogICBPbmx5IHRoZSBjb2x1bW4gaW4gcXVlc3Rpb24gd2lsbCBiZSB3cml0dGVuXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IE9iamVjdCB3aXRoIHR3byBwYXJhbWV0ZXJzOiBgZGF0YWAgdGhlIGRhdGEgcmVhZCwgaW5cblx0ICogICBkb2N1bWVudCBvcmRlciwgYW5kIGBjZWxsc2AgYW5kIGFycmF5IG9mIG5vZGVzICh0aGV5IGNhbiBiZSB1c2VmdWwgdG8gdGhlXG5cdCAqICAgY2FsbGVyLCBzbyByYXRoZXIgdGhhbiBuZWVkaW5nIGEgc2Vjb25kIHRyYXZlcnNhbCB0byBnZXQgdGhlbSwganVzdCByZXR1cm5cblx0ICogICB0aGVtIGZyb20gaGVyZSkuXG5cdCAqIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuR2V0Um93RWxlbWVudHMoIHNldHRpbmdzLCByb3csIGNvbElkeCwgZCApXG5cdHtcblx0XHR2YXJcblx0XHRcdHRkcyA9IFtdLFxuXHRcdFx0dGQgPSByb3cuZmlyc3RDaGlsZCxcblx0XHRcdG5hbWUsIGNvbCwgbywgaT0wLCBjb250ZW50cyxcblx0XHRcdGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnMsXG5cdFx0XHRvYmplY3RSZWFkID0gc2V0dGluZ3MuX3Jvd1JlYWRPYmplY3Q7XG5cdFxuXHRcdC8vIEFsbG93IHRoZSBkYXRhIG9iamVjdCB0byBiZSBwYXNzZWQgaW4sIG9yIGNvbnN0cnVjdFxuXHRcdGQgPSBkIHx8IG9iamVjdFJlYWQgPyB7fSA6IFtdO1xuXHRcblx0XHR2YXIgYXR0ciA9IGZ1bmN0aW9uICggc3RyLCB0ZCAgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHR2YXIgaWR4ID0gc3RyLmluZGV4T2YoJ0AnKTtcblx0XG5cdFx0XHRcdGlmICggaWR4ICE9PSAtMSApIHtcblx0XHRcdFx0XHR2YXIgYXR0ciA9IHN0ci5zdWJzdHJpbmcoIGlkeCsxICk7XG5cdFx0XHRcdFx0dmFyIHNldHRlciA9IF9mblNldE9iamVjdERhdGFGbiggc3RyICk7XG5cdFx0XHRcdFx0c2V0dGVyKCBkLCB0ZC5nZXRBdHRyaWJ1dGUoIGF0dHIgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XG5cdFx0Ly8gUmVhZCBkYXRhIGZyb20gYSBjZWxsIGFuZCBzdG9yZSBpbnRvIHRoZSBkYXRhIG9iamVjdFxuXHRcdHZhciBjZWxsUHJvY2VzcyA9IGZ1bmN0aW9uICggY2VsbCApIHtcblx0XHRcdGlmICggY29sSWR4ID09PSB1bmRlZmluZWQgfHwgY29sSWR4ID09PSBpICkge1xuXHRcdFx0XHRjb2wgPSBjb2x1bW5zW2ldO1xuXHRcdFx0XHRjb250ZW50cyA9ICQudHJpbShjZWxsLmlubmVySFRNTCk7XG5cdFxuXHRcdFx0XHRpZiAoIGNvbCAmJiBjb2wuX2JBdHRyU3JjICkge1xuXHRcdFx0XHRcdHZhciBzZXR0ZXIgPSBfZm5TZXRPYmplY3REYXRhRm4oIGNvbC5tRGF0YS5fICk7XG5cdFx0XHRcdFx0c2V0dGVyKCBkLCBjb250ZW50cyApO1xuXHRcblx0XHRcdFx0XHRhdHRyKCBjb2wubURhdGEuc29ydCwgY2VsbCApO1xuXHRcdFx0XHRcdGF0dHIoIGNvbC5tRGF0YS50eXBlLCBjZWxsICk7XG5cdFx0XHRcdFx0YXR0ciggY29sLm1EYXRhLmZpbHRlciwgY2VsbCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdC8vIERlcGVuZGluZyBvbiB0aGUgYGRhdGFgIG9wdGlvbiBmb3IgdGhlIGNvbHVtbnMgdGhlIGRhdGEgY2FuXG5cdFx0XHRcdFx0Ly8gYmUgcmVhZCB0byBlaXRoZXIgYW4gb2JqZWN0IG9yIGFuIGFycmF5LlxuXHRcdFx0XHRcdGlmICggb2JqZWN0UmVhZCApIHtcblx0XHRcdFx0XHRcdGlmICggISBjb2wuX3NldHRlciApIHtcblx0XHRcdFx0XHRcdFx0Ly8gQ2FjaGUgdGhlIHNldHRlciBmdW5jdGlvblxuXHRcdFx0XHRcdFx0XHRjb2wuX3NldHRlciA9IF9mblNldE9iamVjdERhdGFGbiggY29sLm1EYXRhICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjb2wuX3NldHRlciggZCwgY29udGVudHMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRkW2ldID0gY29udGVudHM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0aSsrO1xuXHRcdH07XG5cdFxuXHRcdGlmICggdGQgKSB7XG5cdFx0XHQvLyBgdHJgIGVsZW1lbnQgd2FzIHBhc3NlZCBpblxuXHRcdFx0d2hpbGUgKCB0ZCApIHtcblx0XHRcdFx0bmFtZSA9IHRkLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG5cdFxuXHRcdFx0XHRpZiAoIG5hbWUgPT0gXCJURFwiIHx8IG5hbWUgPT0gXCJUSFwiICkge1xuXHRcdFx0XHRcdGNlbGxQcm9jZXNzKCB0ZCApO1xuXHRcdFx0XHRcdHRkcy5wdXNoKCB0ZCApO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHR0ZCA9IHRkLm5leHRTaWJsaW5nO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIEV4aXN0aW5nIHJvdyBvYmplY3QgcGFzc2VkIGluXG5cdFx0XHR0ZHMgPSByb3cuYW5DZWxscztcblx0XHRcdFxuXHRcdFx0Zm9yICggdmFyIGo9MCwgamVuPXRkcy5sZW5ndGggOyBqPGplbiA7IGorKyApIHtcblx0XHRcdFx0Y2VsbFByb2Nlc3MoIHRkc1tqXSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0cmV0dXJuIHtcblx0XHRcdGRhdGE6IGQsXG5cdFx0XHRjZWxsczogdGRzXG5cdFx0fTtcblx0fVxuXHQvKipcblx0ICogQ3JlYXRlIGEgbmV3IFRSIGVsZW1lbnQgKGFuZCBpdCdzIFREIGNoaWxkcmVuKSBmb3IgYSByb3dcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7aW50fSBpUm93IFJvdyB0byBjb25zaWRlclxuXHQgKiAgQHBhcmFtIHtub2RlfSBbblRySW5dIFRSIGVsZW1lbnQgdG8gYWRkIHRvIHRoZSB0YWJsZSAtIG9wdGlvbmFsLiBJZiBub3QgZ2l2ZW4sXG5cdCAqICAgIERhdGFUYWJsZXMgd2lsbCBjcmVhdGUgYSByb3cgYXV0b21hdGljYWxseVxuXHQgKiAgQHBhcmFtIHthcnJheX0gW2FuVGRzXSBBcnJheSBvZiBURHxUSCBlbGVtZW50cyBmb3IgdGhlIHJvdyAtIG11c3QgYmUgZ2l2ZW5cblx0ICogICAgaWYgblRyIGlzLlxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5DcmVhdGVUciAoIG9TZXR0aW5ncywgaVJvdywgblRySW4sIGFuVGRzIClcblx0e1xuXHRcdHZhclxuXHRcdFx0cm93ID0gb1NldHRpbmdzLmFvRGF0YVtpUm93XSxcblx0XHRcdHJvd0RhdGEgPSByb3cuX2FEYXRhLFxuXHRcdFx0Y2VsbHMgPSBbXSxcblx0XHRcdG5UciwgblRkLCBvQ29sLFxuXHRcdFx0aSwgaUxlbjtcblx0XG5cdFx0aWYgKCByb3cublRyID09PSBudWxsIClcblx0XHR7XG5cdFx0XHRuVHIgPSBuVHJJbiB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xuXHRcblx0XHRcdHJvdy5uVHIgPSBuVHI7XG5cdFx0XHRyb3cuYW5DZWxscyA9IGNlbGxzO1xuXHRcblx0XHRcdC8qIFVzZSBhIHByaXZhdGUgcHJvcGVydHkgb24gdGhlIG5vZGUgdG8gYWxsb3cgcmVzZXJ2ZSBtYXBwaW5nIGZyb20gdGhlIG5vZGVcblx0XHRcdCAqIHRvIHRoZSBhb0RhdGEgYXJyYXkgZm9yIGZhc3QgbG9vayB1cFxuXHRcdFx0ICovXG5cdFx0XHRuVHIuX0RUX1Jvd0luZGV4ID0gaVJvdztcblx0XG5cdFx0XHQvKiBTcGVjaWFsIHBhcmFtZXRlcnMgY2FuIGJlIGdpdmVuIGJ5IHRoZSBkYXRhIHNvdXJjZSB0byBiZSB1c2VkIG9uIHRoZSByb3cgKi9cblx0XHRcdF9mblJvd0F0dHJpYnV0ZXMoIHJvdyApO1xuXHRcblx0XHRcdC8qIFByb2Nlc3MgZWFjaCBjb2x1bW4gKi9cblx0XHRcdGZvciAoIGk9MCwgaUxlbj1vU2V0dGluZ3MuYW9Db2x1bW5zLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApXG5cdFx0XHR7XG5cdFx0XHRcdG9Db2wgPSBvU2V0dGluZ3MuYW9Db2x1bW5zW2ldO1xuXHRcblx0XHRcdFx0blRkID0gblRySW4gPyBhblRkc1tpXSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIG9Db2wuc0NlbGxUeXBlICk7XG5cdFx0XHRcdGNlbGxzLnB1c2goIG5UZCApO1xuXHRcblx0XHRcdFx0Ly8gTmVlZCB0byBjcmVhdGUgdGhlIEhUTUwgaWYgbmV3LCBvciBpZiBhIHJlbmRlcmluZyBmdW5jdGlvbiBpcyBkZWZpbmVkXG5cdFx0XHRcdGlmICggIW5UckluIHx8IG9Db2wubVJlbmRlciB8fCBvQ29sLm1EYXRhICE9PSBpIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG5UZC5pbm5lckhUTUwgPSBfZm5HZXRDZWxsRGF0YSggb1NldHRpbmdzLCBpUm93LCBpLCAnZGlzcGxheScgKTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0LyogQWRkIHVzZXIgZGVmaW5lZCBjbGFzcyAqL1xuXHRcdFx0XHRpZiAoIG9Db2wuc0NsYXNzIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG5UZC5jbGFzc05hbWUgKz0gJyAnK29Db2wuc0NsYXNzO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHQvLyBWaXNpYmlsaXR5IC0gYWRkIG9yIHJlbW92ZSBhcyByZXF1aXJlZFxuXHRcdFx0XHRpZiAoIG9Db2wuYlZpc2libGUgJiYgISBuVHJJbiApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuVHIuYXBwZW5kQ2hpbGQoIG5UZCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKCAhIG9Db2wuYlZpc2libGUgJiYgblRySW4gKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0blRkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIG5UZCApO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRpZiAoIG9Db2wuZm5DcmVhdGVkQ2VsbCApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRvQ29sLmZuQ3JlYXRlZENlbGwuY2FsbCggb1NldHRpbmdzLm9JbnN0YW5jZSxcblx0XHRcdFx0XHRcdG5UZCwgX2ZuR2V0Q2VsbERhdGEoIG9TZXR0aW5ncywgaVJvdywgaSApLCByb3dEYXRhLCBpUm93LCBpXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdF9mbkNhbGxiYWNrRmlyZSggb1NldHRpbmdzLCAnYW9Sb3dDcmVhdGVkQ2FsbGJhY2snLCBudWxsLCBbblRyLCByb3dEYXRhLCBpUm93XSApO1xuXHRcdH1cblx0XG5cdFx0Ly8gUmVtb3ZlIG9uY2Ugd2Via2l0IGJ1ZyAxMzE4MTkgYW5kIENocm9taXVtIGJ1ZyAzNjU2MTkgaGF2ZSBiZWVuIHJlc29sdmVkXG5cdFx0Ly8gYW5kIGRlcGxveWVkXG5cdFx0cm93Lm5Uci5zZXRBdHRyaWJ1dGUoICdyb2xlJywgJ3JvdycgKTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBBZGQgYXR0cmlidXRlcyB0byBhIHJvdyBiYXNlZCBvbiB0aGUgc3BlY2lhbCBgRFRfKmAgcGFyYW1ldGVycyBpbiBhIGRhdGFcblx0ICogc291cmNlIG9iamVjdC5cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBEYXRhVGFibGVzIHJvdyBvYmplY3QgZm9yIHRoZSByb3cgdG8gYmUgbW9kaWZpZWRcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuUm93QXR0cmlidXRlcyggcm93IClcblx0e1xuXHRcdHZhciB0ciA9IHJvdy5uVHI7XG5cdFx0dmFyIGRhdGEgPSByb3cuX2FEYXRhO1xuXHRcblx0XHRpZiAoIHRyICkge1xuXHRcdFx0aWYgKCBkYXRhLkRUX1Jvd0lkICkge1xuXHRcdFx0XHR0ci5pZCA9IGRhdGEuRFRfUm93SWQ7XG5cdFx0XHR9XG5cdFxuXHRcdFx0aWYgKCBkYXRhLkRUX1Jvd0NsYXNzICkge1xuXHRcdFx0XHQvLyBSZW1vdmUgYW55IGNsYXNzZXMgYWRkZWQgYnkgRFRfUm93Q2xhc3MgYmVmb3JlXG5cdFx0XHRcdHZhciBhID0gZGF0YS5EVF9Sb3dDbGFzcy5zcGxpdCgnICcpO1xuXHRcdFx0XHRyb3cuX19yb3djID0gcm93Ll9fcm93YyA/XG5cdFx0XHRcdFx0X3VuaXF1ZSggcm93Ll9fcm93Yy5jb25jYXQoIGEgKSApIDpcblx0XHRcdFx0XHRhO1xuXHRcblx0XHRcdFx0JCh0cilcblx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoIHJvdy5fX3Jvd2Muam9pbignICcpIClcblx0XHRcdFx0XHQuYWRkQ2xhc3MoIGRhdGEuRFRfUm93Q2xhc3MgKTtcblx0XHRcdH1cblx0XG5cdFx0XHRpZiAoIGRhdGEuRFRfUm93QXR0ciApIHtcblx0XHRcdFx0JCh0cikuYXR0ciggZGF0YS5EVF9Sb3dBdHRyICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0aWYgKCBkYXRhLkRUX1Jvd0RhdGEgKSB7XG5cdFx0XHRcdCQodHIpLmRhdGEoIGRhdGEuRFRfUm93RGF0YSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBDcmVhdGUgdGhlIEhUTUwgaGVhZGVyIGZvciB0aGUgdGFibGVcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQnVpbGRIZWFkKCBvU2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyIGksIGllbiwgY2VsbCwgcm93LCBjb2x1bW47XG5cdFx0dmFyIHRoZWFkID0gb1NldHRpbmdzLm5USGVhZDtcblx0XHR2YXIgdGZvb3QgPSBvU2V0dGluZ3MublRGb290O1xuXHRcdHZhciBjcmVhdGVIZWFkZXIgPSAkKCd0aCwgdGQnLCB0aGVhZCkubGVuZ3RoID09PSAwO1xuXHRcdHZhciBjbGFzc2VzID0gb1NldHRpbmdzLm9DbGFzc2VzO1xuXHRcdHZhciBjb2x1bW5zID0gb1NldHRpbmdzLmFvQ29sdW1ucztcblx0XG5cdFx0aWYgKCBjcmVhdGVIZWFkZXIgKSB7XG5cdFx0XHRyb3cgPSAkKCc8dHIvPicpLmFwcGVuZFRvKCB0aGVhZCApO1xuXHRcdH1cblx0XG5cdFx0Zm9yICggaT0wLCBpZW49Y29sdW1ucy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdGNvbHVtbiA9IGNvbHVtbnNbaV07XG5cdFx0XHRjZWxsID0gJCggY29sdW1uLm5UaCApLmFkZENsYXNzKCBjb2x1bW4uc0NsYXNzICk7XG5cdFxuXHRcdFx0aWYgKCBjcmVhdGVIZWFkZXIgKSB7XG5cdFx0XHRcdGNlbGwuYXBwZW5kVG8oIHJvdyApO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIDEuMTEgbW92ZSBpbnRvIHNvcnRpbmdcblx0XHRcdGlmICggb1NldHRpbmdzLm9GZWF0dXJlcy5iU29ydCApIHtcblx0XHRcdFx0Y2VsbC5hZGRDbGFzcyggY29sdW1uLnNTb3J0aW5nQ2xhc3MgKTtcblx0XG5cdFx0XHRcdGlmICggY29sdW1uLmJTb3J0YWJsZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0Y2VsbFxuXHRcdFx0XHRcdFx0LmF0dHIoICd0YWJpbmRleCcsIG9TZXR0aW5ncy5pVGFiSW5kZXggKVxuXHRcdFx0XHRcdFx0LmF0dHIoICdhcmlhLWNvbnRyb2xzJywgb1NldHRpbmdzLnNUYWJsZUlkICk7XG5cdFxuXHRcdFx0XHRcdF9mblNvcnRBdHRhY2hMaXN0ZW5lciggb1NldHRpbmdzLCBjb2x1bW4ublRoLCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHRpZiAoIGNvbHVtbi5zVGl0bGUgIT0gY2VsbC5odG1sKCkgKSB7XG5cdFx0XHRcdGNlbGwuaHRtbCggY29sdW1uLnNUaXRsZSApO1xuXHRcdFx0fVxuXHRcblx0XHRcdF9mblJlbmRlcmVyKCBvU2V0dGluZ3MsICdoZWFkZXInICkoXG5cdFx0XHRcdG9TZXR0aW5ncywgY2VsbCwgY29sdW1uLCBjbGFzc2VzXG5cdFx0XHQpO1xuXHRcdH1cblx0XG5cdFx0aWYgKCBjcmVhdGVIZWFkZXIgKSB7XG5cdFx0XHRfZm5EZXRlY3RIZWFkZXIoIG9TZXR0aW5ncy5hb0hlYWRlciwgdGhlYWQgKTtcblx0XHR9XG5cdFx0XG5cdFx0LyogQVJJQSByb2xlIGZvciB0aGUgcm93cyAqL1xuXHQgXHQkKHRoZWFkKS5maW5kKCc+dHInKS5hdHRyKCdyb2xlJywgJ3JvdycpO1xuXHRcblx0XHQvKiBEZWFsIHdpdGggdGhlIGZvb3RlciAtIGFkZCBjbGFzc2VzIGlmIHJlcXVpcmVkICovXG5cdFx0JCh0aGVhZCkuZmluZCgnPnRyPnRoLCA+dHI+dGQnKS5hZGRDbGFzcyggY2xhc3Nlcy5zSGVhZGVyVEggKTtcblx0XHQkKHRmb290KS5maW5kKCc+dHI+dGgsID50cj50ZCcpLmFkZENsYXNzKCBjbGFzc2VzLnNGb290ZXJUSCApO1xuXHRcblx0XHQvLyBDYWNoZSB0aGUgZm9vdGVyIGNlbGxzLiBOb3RlIHRoYXQgd2Ugb25seSB0YWtlIHRoZSBjZWxscyBmcm9tIHRoZSBmaXJzdFxuXHRcdC8vIHJvdyBpbiB0aGUgZm9vdGVyLiBJZiB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIHJvdyB0aGUgdXNlciB3YW50cyB0b1xuXHRcdC8vIGludGVyYWN0IHdpdGgsIHRoZXkgbmVlZCB0byB1c2UgdGhlIHRhYmxlKCkuZm9vdCgpIG1ldGhvZC4gTm90ZSBhbHNvIHRoaXNcblx0XHQvLyBhbGxvd3MgY2VsbHMgdG8gYmUgdXNlZCBmb3IgbXVsdGlwbGUgY29sdW1ucyB1c2luZyBjb2xzcGFuXG5cdFx0aWYgKCB0Zm9vdCAhPT0gbnVsbCApIHtcblx0XHRcdHZhciBjZWxscyA9IG9TZXR0aW5ncy5hb0Zvb3RlclswXTtcblx0XG5cdFx0XHRmb3IgKCBpPTAsIGllbj1jZWxscy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0Y29sdW1uID0gY29sdW1uc1tpXTtcblx0XHRcdFx0Y29sdW1uLm5UZiA9IGNlbGxzW2ldLmNlbGw7XG5cdFxuXHRcdFx0XHRpZiAoIGNvbHVtbi5zQ2xhc3MgKSB7XG5cdFx0XHRcdFx0JChjb2x1bW4ublRmKS5hZGRDbGFzcyggY29sdW1uLnNDbGFzcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIERyYXcgdGhlIGhlYWRlciAob3IgZm9vdGVyKSBlbGVtZW50IGJhc2VkIG9uIHRoZSBjb2x1bW4gdmlzaWJpbGl0eSBzdGF0ZXMuIFRoZVxuXHQgKiBtZXRob2RvbG9neSBoZXJlIGlzIHRvIHVzZSB0aGUgbGF5b3V0IGFycmF5IGZyb20gX2ZuRGV0ZWN0SGVhZGVyLCBtb2RpZmllZCBmb3Jcblx0ICogdGhlIGluc3RhbnRhbmVvdXMgY29sdW1uIHZpc2liaWxpdHksIHRvIGNvbnN0cnVjdCB0aGUgbmV3IGxheW91dC4gVGhlIGdyaWQgaXNcblx0ICogdHJhdmVyc2VkIG92ZXIgY2VsbCBhdCBhIHRpbWUgaW4gYSByb3dzIHggY29sdW1ucyBncmlkIGZhc2hpb24sIGFsdGhvdWdoIGVhY2hcblx0ICogY2VsbCBpbnNlcnQgY2FuIGNvdmVyIG11bHRpcGxlIGVsZW1lbnRzIGluIHRoZSBncmlkIC0gd2hpY2ggaXMgdHJhY2tzIHVzaW5nIHRoZVxuXHQgKiBhQXBwbGllZCBhcnJheS4gQ2VsbCBpbnNlcnRzIGluIHRoZSBncmlkIHdpbGwgb25seSBvY2N1ciB3aGVyZSB0aGVyZSBpc24ndFxuXHQgKiBhbHJlYWR5IGEgY2VsbCBpbiB0aGF0IHBvc2l0aW9uLlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIGFycmF5IHtvYmplY3RzfSBhb1NvdXJjZSBMYXlvdXQgYXJyYXkgZnJvbSBfZm5EZXRlY3RIZWFkZXJcblx0ICogIEBwYXJhbSB7Ym9vbGVhbn0gW2JJbmNsdWRlSGlkZGVuPWZhbHNlXSBJZiB0cnVlIHRoZW4gaW5jbHVkZSB0aGUgaGlkZGVuIGNvbHVtbnMgaW4gdGhlIGNhbGMsXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkRyYXdIZWFkKCBvU2V0dGluZ3MsIGFvU291cmNlLCBiSW5jbHVkZUhpZGRlbiApXG5cdHtcblx0XHR2YXIgaSwgaUxlbiwgaiwgakxlbiwgaywga0xlbiwgbiwgbkxvY2FsVHI7XG5cdFx0dmFyIGFvTG9jYWwgPSBbXTtcblx0XHR2YXIgYUFwcGxpZWQgPSBbXTtcblx0XHR2YXIgaUNvbHVtbnMgPSBvU2V0dGluZ3MuYW9Db2x1bW5zLmxlbmd0aDtcblx0XHR2YXIgaVJvd3NwYW4sIGlDb2xzcGFuO1xuXHRcblx0XHRpZiAoICEgYW9Tb3VyY2UgKVxuXHRcdHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFxuXHRcdGlmICggIGJJbmNsdWRlSGlkZGVuID09PSB1bmRlZmluZWQgKVxuXHRcdHtcblx0XHRcdGJJbmNsdWRlSGlkZGVuID0gZmFsc2U7XG5cdFx0fVxuXHRcblx0XHQvKiBNYWtlIGEgY29weSBvZiB0aGUgbWFzdGVyIGxheW91dCBhcnJheSwgYnV0IHdpdGhvdXQgdGhlIHZpc2libGUgY29sdW1ucyBpbiBpdCAqL1xuXHRcdGZvciAoIGk9MCwgaUxlbj1hb1NvdXJjZS5sZW5ndGggOyBpPGlMZW4gOyBpKysgKVxuXHRcdHtcblx0XHRcdGFvTG9jYWxbaV0gPSBhb1NvdXJjZVtpXS5zbGljZSgpO1xuXHRcdFx0YW9Mb2NhbFtpXS5uVHIgPSBhb1NvdXJjZVtpXS5uVHI7XG5cdFxuXHRcdFx0LyogUmVtb3ZlIGFueSBjb2x1bW5zIHdoaWNoIGFyZSBjdXJyZW50bHkgaGlkZGVuICovXG5cdFx0XHRmb3IgKCBqPWlDb2x1bW5zLTEgOyBqPj0wIDsgai0tIClcblx0XHRcdHtcblx0XHRcdFx0aWYgKCAhb1NldHRpbmdzLmFvQ29sdW1uc1tqXS5iVmlzaWJsZSAmJiAhYkluY2x1ZGVIaWRkZW4gKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0YW9Mb2NhbFtpXS5zcGxpY2UoIGosIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdC8qIFByZXAgdGhlIGFwcGxpZWQgYXJyYXkgLSBpdCBuZWVkcyBhbiBlbGVtZW50IGZvciBlYWNoIHJvdyAqL1xuXHRcdFx0YUFwcGxpZWQucHVzaCggW10gKTtcblx0XHR9XG5cdFxuXHRcdGZvciAoIGk9MCwgaUxlbj1hb0xvY2FsLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApXG5cdFx0e1xuXHRcdFx0bkxvY2FsVHIgPSBhb0xvY2FsW2ldLm5Ucjtcblx0XG5cdFx0XHQvKiBBbGwgY2VsbHMgYXJlIGdvaW5nIHRvIGJlIHJlcGxhY2VkLCBzbyBlbXB0eSBvdXQgdGhlIHJvdyAqL1xuXHRcdFx0aWYgKCBuTG9jYWxUciApXG5cdFx0XHR7XG5cdFx0XHRcdHdoaWxlKCAobiA9IG5Mb2NhbFRyLmZpcnN0Q2hpbGQpIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG5Mb2NhbFRyLnJlbW92ZUNoaWxkKCBuICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHRmb3IgKCBqPTAsIGpMZW49YW9Mb2NhbFtpXS5sZW5ndGggOyBqPGpMZW4gOyBqKysgKVxuXHRcdFx0e1xuXHRcdFx0XHRpUm93c3BhbiA9IDE7XG5cdFx0XHRcdGlDb2xzcGFuID0gMTtcblx0XG5cdFx0XHRcdC8qIENoZWNrIHRvIHNlZSBpZiB0aGVyZSBpcyBhbHJlYWR5IGEgY2VsbCAocm93L2NvbHNwYW4pIGNvdmVyaW5nIG91ciB0YXJnZXRcblx0XHRcdFx0ICogaW5zZXJ0IHBvaW50LiBJZiB0aGVyZSBpcywgdGhlbiB0aGVyZSBpcyBub3RoaW5nIHRvIGRvLlxuXHRcdFx0XHQgKi9cblx0XHRcdFx0aWYgKCBhQXBwbGllZFtpXVtqXSA9PT0gdW5kZWZpbmVkIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG5Mb2NhbFRyLmFwcGVuZENoaWxkKCBhb0xvY2FsW2ldW2pdLmNlbGwgKTtcblx0XHRcdFx0XHRhQXBwbGllZFtpXVtqXSA9IDE7XG5cdFxuXHRcdFx0XHRcdC8qIEV4cGFuZCB0aGUgY2VsbCB0byBjb3ZlciBhcyBtYW55IHJvd3MgYXMgbmVlZGVkICovXG5cdFx0XHRcdFx0d2hpbGUgKCBhb0xvY2FsW2kraVJvd3NwYW5dICE9PSB1bmRlZmluZWQgJiZcblx0XHRcdFx0XHQgICAgICAgIGFvTG9jYWxbaV1bal0uY2VsbCA9PSBhb0xvY2FsW2kraVJvd3NwYW5dW2pdLmNlbGwgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGFBcHBsaWVkW2kraVJvd3NwYW5dW2pdID0gMTtcblx0XHRcdFx0XHRcdGlSb3dzcGFuKys7XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHQvKiBFeHBhbmQgdGhlIGNlbGwgdG8gY292ZXIgYXMgbWFueSBjb2x1bW5zIGFzIG5lZWRlZCAqL1xuXHRcdFx0XHRcdHdoaWxlICggYW9Mb2NhbFtpXVtqK2lDb2xzcGFuXSAhPT0gdW5kZWZpbmVkICYmXG5cdFx0XHRcdFx0ICAgICAgICBhb0xvY2FsW2ldW2pdLmNlbGwgPT0gYW9Mb2NhbFtpXVtqK2lDb2xzcGFuXS5jZWxsIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHQvKiBNdXN0IHVwZGF0ZSB0aGUgYXBwbGllZCBhcnJheSBvdmVyIHRoZSByb3dzIGZvciB0aGUgY29sdW1ucyAqL1xuXHRcdFx0XHRcdFx0Zm9yICggaz0wIDsgazxpUm93c3BhbiA7IGsrKyApXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGFBcHBsaWVkW2kra11baitpQ29sc3Bhbl0gPSAxO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aUNvbHNwYW4rKztcblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdC8qIERvIHRoZSBhY3R1YWwgZXhwYW5zaW9uIGluIHRoZSBET00gKi9cblx0XHRcdFx0XHQkKGFvTG9jYWxbaV1bal0uY2VsbClcblx0XHRcdFx0XHRcdC5hdHRyKCdyb3dzcGFuJywgaVJvd3NwYW4pXG5cdFx0XHRcdFx0XHQuYXR0cignY29sc3BhbicsIGlDb2xzcGFuKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBJbnNlcnQgdGhlIHJlcXVpcmVkIFRSIG5vZGVzIGludG8gdGhlIHRhYmxlIGZvciBkaXNwbGF5XG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkRyYXcoIG9TZXR0aW5ncyApXG5cdHtcblx0XHQvKiBQcm92aWRlIGEgcHJlLWNhbGxiYWNrIGZ1bmN0aW9uIHdoaWNoIGNhbiBiZSB1c2VkIHRvIGNhbmNlbCB0aGUgZHJhdyBpcyBmYWxzZSBpcyByZXR1cm5lZCAqL1xuXHRcdHZhciBhUHJlRHJhdyA9IF9mbkNhbGxiYWNrRmlyZSggb1NldHRpbmdzLCAnYW9QcmVEcmF3Q2FsbGJhY2snLCAncHJlRHJhdycsIFtvU2V0dGluZ3NdICk7XG5cdFx0aWYgKCAkLmluQXJyYXkoIGZhbHNlLCBhUHJlRHJhdyApICE9PSAtMSApXG5cdFx0e1xuXHRcdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIG9TZXR0aW5ncywgZmFsc2UgKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFxuXHRcdHZhciBpLCBpTGVuLCBuO1xuXHRcdHZhciBhblJvd3MgPSBbXTtcblx0XHR2YXIgaVJvd0NvdW50ID0gMDtcblx0XHR2YXIgYXNTdHJpcGVDbGFzc2VzID0gb1NldHRpbmdzLmFzU3RyaXBlQ2xhc3Nlcztcblx0XHR2YXIgaVN0cmlwZXMgPSBhc1N0cmlwZUNsYXNzZXMubGVuZ3RoO1xuXHRcdHZhciBpT3BlblJvd3MgPSBvU2V0dGluZ3MuYW9PcGVuUm93cy5sZW5ndGg7XG5cdFx0dmFyIG9MYW5nID0gb1NldHRpbmdzLm9MYW5ndWFnZTtcblx0XHR2YXIgaUluaXREaXNwbGF5U3RhcnQgPSBvU2V0dGluZ3MuaUluaXREaXNwbGF5U3RhcnQ7XG5cdFx0dmFyIGJTZXJ2ZXJTaWRlID0gX2ZuRGF0YVNvdXJjZSggb1NldHRpbmdzICkgPT0gJ3NzcCc7XG5cdFx0dmFyIGFpRGlzcGxheSA9IG9TZXR0aW5ncy5haURpc3BsYXk7XG5cdFxuXHRcdG9TZXR0aW5ncy5iRHJhd2luZyA9IHRydWU7XG5cdFxuXHRcdC8qIENoZWNrIGFuZCBzZWUgaWYgd2UgaGF2ZSBhbiBpbml0aWFsIGRyYXcgcG9zaXRpb24gZnJvbSBzdGF0ZSBzYXZpbmcgKi9cblx0XHRpZiAoIGlJbml0RGlzcGxheVN0YXJ0ICE9PSB1bmRlZmluZWQgJiYgaUluaXREaXNwbGF5U3RhcnQgIT09IC0xIClcblx0XHR7XG5cdFx0XHRvU2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgPSBiU2VydmVyU2lkZSA/XG5cdFx0XHRcdGlJbml0RGlzcGxheVN0YXJ0IDpcblx0XHRcdFx0aUluaXREaXNwbGF5U3RhcnQgPj0gb1NldHRpbmdzLmZuUmVjb3Jkc0Rpc3BsYXkoKSA/XG5cdFx0XHRcdFx0MCA6XG5cdFx0XHRcdFx0aUluaXREaXNwbGF5U3RhcnQ7XG5cdFxuXHRcdFx0b1NldHRpbmdzLmlJbml0RGlzcGxheVN0YXJ0ID0gLTE7XG5cdFx0fVxuXHRcblx0XHR2YXIgaURpc3BsYXlTdGFydCA9IG9TZXR0aW5ncy5faURpc3BsYXlTdGFydDtcblx0XHR2YXIgaURpc3BsYXlFbmQgPSBvU2V0dGluZ3MuZm5EaXNwbGF5RW5kKCk7XG5cdFxuXHRcdC8qIFNlcnZlci1zaWRlIHByb2Nlc3NpbmcgZHJhdyBpbnRlcmNlcHQgKi9cblx0XHRpZiAoIG9TZXR0aW5ncy5iRGVmZXJMb2FkaW5nIClcblx0XHR7XG5cdFx0XHRvU2V0dGluZ3MuYkRlZmVyTG9hZGluZyA9IGZhbHNlO1xuXHRcdFx0b1NldHRpbmdzLmlEcmF3Kys7XG5cdFx0XHRfZm5Qcm9jZXNzaW5nRGlzcGxheSggb1NldHRpbmdzLCBmYWxzZSApO1xuXHRcdH1cblx0XHRlbHNlIGlmICggIWJTZXJ2ZXJTaWRlIClcblx0XHR7XG5cdFx0XHRvU2V0dGluZ3MuaURyYXcrKztcblx0XHR9XG5cdFx0ZWxzZSBpZiAoICFvU2V0dGluZ3MuYkRlc3Ryb3lpbmcgJiYgIV9mbkFqYXhVcGRhdGUoIG9TZXR0aW5ncyApIClcblx0XHR7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcblx0XHRpZiAoIGFpRGlzcGxheS5sZW5ndGggIT09IDAgKVxuXHRcdHtcblx0XHRcdHZhciBpU3RhcnQgPSBiU2VydmVyU2lkZSA/IDAgOiBpRGlzcGxheVN0YXJ0O1xuXHRcdFx0dmFyIGlFbmQgPSBiU2VydmVyU2lkZSA/IG9TZXR0aW5ncy5hb0RhdGEubGVuZ3RoIDogaURpc3BsYXlFbmQ7XG5cdFxuXHRcdFx0Zm9yICggdmFyIGo9aVN0YXJ0IDsgajxpRW5kIDsgaisrIClcblx0XHRcdHtcblx0XHRcdFx0dmFyIGlEYXRhSW5kZXggPSBhaURpc3BsYXlbal07XG5cdFx0XHRcdHZhciBhb0RhdGEgPSBvU2V0dGluZ3MuYW9EYXRhWyBpRGF0YUluZGV4IF07XG5cdFx0XHRcdGlmICggYW9EYXRhLm5UciA9PT0gbnVsbCApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRfZm5DcmVhdGVUciggb1NldHRpbmdzLCBpRGF0YUluZGV4ICk7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdHZhciBuUm93ID0gYW9EYXRhLm5Ucjtcblx0XG5cdFx0XHRcdC8qIFJlbW92ZSB0aGUgb2xkIHN0cmlwaW5nIGNsYXNzZXMgYW5kIHRoZW4gYWRkIHRoZSBuZXcgb25lICovXG5cdFx0XHRcdGlmICggaVN0cmlwZXMgIT09IDAgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dmFyIHNTdHJpcGUgPSBhc1N0cmlwZUNsYXNzZXNbIGlSb3dDb3VudCAlIGlTdHJpcGVzIF07XG5cdFx0XHRcdFx0aWYgKCBhb0RhdGEuX3NSb3dTdHJpcGUgIT0gc1N0cmlwZSApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0JChuUm93KS5yZW1vdmVDbGFzcyggYW9EYXRhLl9zUm93U3RyaXBlICkuYWRkQ2xhc3MoIHNTdHJpcGUgKTtcblx0XHRcdFx0XHRcdGFvRGF0YS5fc1Jvd1N0cmlwZSA9IHNTdHJpcGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHQvLyBSb3cgY2FsbGJhY2sgZnVuY3Rpb25zIC0gbWlnaHQgd2FudCB0byBtYW5pcHVsYXRlIHRoZSByb3dcblx0XHRcdFx0Ly8gaVJvd0NvdW50IGFuZCBqIGFyZSBub3QgY3VycmVudGx5IGRvY3VtZW50ZWQuIEFyZSB0aGV5IGF0IGFsbFxuXHRcdFx0XHQvLyB1c2VmdWw/XG5cdFx0XHRcdF9mbkNhbGxiYWNrRmlyZSggb1NldHRpbmdzLCAnYW9Sb3dDYWxsYmFjaycsIG51bGwsXG5cdFx0XHRcdFx0W25Sb3csIGFvRGF0YS5fYURhdGEsIGlSb3dDb3VudCwgal0gKTtcblx0XG5cdFx0XHRcdGFuUm93cy5wdXNoKCBuUm93ICk7XG5cdFx0XHRcdGlSb3dDb3VudCsrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0LyogVGFibGUgaXMgZW1wdHkgLSBjcmVhdGUgYSByb3cgd2l0aCBhbiBlbXB0eSBtZXNzYWdlIGluIGl0ICovXG5cdFx0XHR2YXIgc1plcm8gPSBvTGFuZy5zWmVyb1JlY29yZHM7XG5cdFx0XHRpZiAoIG9TZXR0aW5ncy5pRHJhdyA9PSAxICYmICBfZm5EYXRhU291cmNlKCBvU2V0dGluZ3MgKSA9PSAnYWpheCcgKVxuXHRcdFx0e1xuXHRcdFx0XHRzWmVybyA9IG9MYW5nLnNMb2FkaW5nUmVjb3Jkcztcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBvTGFuZy5zRW1wdHlUYWJsZSAmJiBvU2V0dGluZ3MuZm5SZWNvcmRzVG90YWwoKSA9PT0gMCApXG5cdFx0XHR7XG5cdFx0XHRcdHNaZXJvID0gb0xhbmcuc0VtcHR5VGFibGU7XG5cdFx0XHR9XG5cdFxuXHRcdFx0YW5Sb3dzWyAwIF0gPSAkKCAnPHRyLz4nLCB7ICdjbGFzcyc6IGlTdHJpcGVzID8gYXNTdHJpcGVDbGFzc2VzWzBdIDogJycgfSApXG5cdFx0XHRcdC5hcHBlbmQoICQoJzx0ZCAvPicsIHtcblx0XHRcdFx0XHQndmFsaWduJzogICd0b3AnLFxuXHRcdFx0XHRcdCdjb2xTcGFuJzogX2ZuVmlzYmxlQ29sdW1ucyggb1NldHRpbmdzICksXG5cdFx0XHRcdFx0J2NsYXNzJzogICBvU2V0dGluZ3Mub0NsYXNzZXMuc1Jvd0VtcHR5XG5cdFx0XHRcdH0gKS5odG1sKCBzWmVybyApIClbMF07XG5cdFx0fVxuXHRcblx0XHQvKiBIZWFkZXIgYW5kIGZvb3RlciBjYWxsYmFja3MgKi9cblx0XHRfZm5DYWxsYmFja0ZpcmUoIG9TZXR0aW5ncywgJ2FvSGVhZGVyQ2FsbGJhY2snLCAnaGVhZGVyJywgWyAkKG9TZXR0aW5ncy5uVEhlYWQpLmNoaWxkcmVuKCd0cicpWzBdLFxuXHRcdFx0X2ZuR2V0RGF0YU1hc3Rlciggb1NldHRpbmdzICksIGlEaXNwbGF5U3RhcnQsIGlEaXNwbGF5RW5kLCBhaURpc3BsYXkgXSApO1xuXHRcblx0XHRfZm5DYWxsYmFja0ZpcmUoIG9TZXR0aW5ncywgJ2FvRm9vdGVyQ2FsbGJhY2snLCAnZm9vdGVyJywgWyAkKG9TZXR0aW5ncy5uVEZvb3QpLmNoaWxkcmVuKCd0cicpWzBdLFxuXHRcdFx0X2ZuR2V0RGF0YU1hc3Rlciggb1NldHRpbmdzICksIGlEaXNwbGF5U3RhcnQsIGlEaXNwbGF5RW5kLCBhaURpc3BsYXkgXSApO1xuXHRcblx0XHR2YXIgYm9keSA9ICQob1NldHRpbmdzLm5UQm9keSk7XG5cdFxuXHRcdGJvZHkuY2hpbGRyZW4oKS5kZXRhY2goKTtcblx0XHRib2R5LmFwcGVuZCggJChhblJvd3MpICk7XG5cdFxuXHRcdC8qIENhbGwgYWxsIHJlcXVpcmVkIGNhbGxiYWNrIGZ1bmN0aW9ucyBmb3IgdGhlIGVuZCBvZiBhIGRyYXcgKi9cblx0XHRfZm5DYWxsYmFja0ZpcmUoIG9TZXR0aW5ncywgJ2FvRHJhd0NhbGxiYWNrJywgJ2RyYXcnLCBbb1NldHRpbmdzXSApO1xuXHRcblx0XHQvKiBEcmF3IGlzIGNvbXBsZXRlLCBzb3J0aW5nIGFuZCBmaWx0ZXJpbmcgbXVzdCBiZSBhcyB3ZWxsICovXG5cdFx0b1NldHRpbmdzLmJTb3J0ZWQgPSBmYWxzZTtcblx0XHRvU2V0dGluZ3MuYkZpbHRlcmVkID0gZmFsc2U7XG5cdFx0b1NldHRpbmdzLmJEcmF3aW5nID0gZmFsc2U7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogUmVkcmF3IHRoZSB0YWJsZSAtIHRha2luZyBhY2NvdW50IG9mIHRoZSB2YXJpb3VzIGZlYXR1cmVzIHdoaWNoIGFyZSBlbmFibGVkXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge2Jvb2xlYW59IFtob2xkUG9zaXRpb25dIEtlZXAgdGhlIGN1cnJlbnQgcGFnaW5nIHBvc2l0aW9uLiBCeSBkZWZhdWx0XG5cdCAqICAgIHRoZSBwYWdpbmcgaXMgcmVzZXQgdG8gdGhlIGZpcnN0IHBhZ2Vcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuUmVEcmF3KCBzZXR0aW5ncywgaG9sZFBvc2l0aW9uIClcblx0e1xuXHRcdHZhclxuXHRcdFx0ZmVhdHVyZXMgPSBzZXR0aW5ncy5vRmVhdHVyZXMsXG5cdFx0XHRzb3J0ICAgICA9IGZlYXR1cmVzLmJTb3J0LFxuXHRcdFx0ZmlsdGVyICAgPSBmZWF0dXJlcy5iRmlsdGVyO1xuXHRcblx0XHRpZiAoIHNvcnQgKSB7XG5cdFx0XHRfZm5Tb3J0KCBzZXR0aW5ncyApO1xuXHRcdH1cblx0XG5cdFx0aWYgKCBmaWx0ZXIgKSB7XG5cdFx0XHRfZm5GaWx0ZXJDb21wbGV0ZSggc2V0dGluZ3MsIHNldHRpbmdzLm9QcmV2aW91c1NlYXJjaCApO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIE5vIGZpbHRlcmluZywgc28gd2Ugd2FudCB0byBqdXN0IHVzZSB0aGUgZGlzcGxheSBtYXN0ZXJcblx0XHRcdHNldHRpbmdzLmFpRGlzcGxheSA9IHNldHRpbmdzLmFpRGlzcGxheU1hc3Rlci5zbGljZSgpO1xuXHRcdH1cblx0XG5cdFx0aWYgKCBob2xkUG9zaXRpb24gIT09IHRydWUgKSB7XG5cdFx0XHRzZXR0aW5ncy5faURpc3BsYXlTdGFydCA9IDA7XG5cdFx0fVxuXHRcblx0XHQvLyBMZXQgYW55IG1vZHVsZXMga25vdyBhYm91dCB0aGUgZHJhdyBob2xkIHBvc2l0aW9uIHN0YXRlICh1c2VkIGJ5XG5cdFx0Ly8gc2Nyb2xsaW5nIGludGVybmFsbHkpXG5cdFx0c2V0dGluZ3MuX2RyYXdIb2xkID0gaG9sZFBvc2l0aW9uO1xuXHRcblx0XHRfZm5EcmF3KCBzZXR0aW5ncyApO1xuXHRcblx0XHRzZXR0aW5ncy5fZHJhd0hvbGQgPSBmYWxzZTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBBZGQgdGhlIG9wdGlvbnMgdG8gdGhlIHBhZ2UgSFRNTCBmb3IgdGhlIHRhYmxlXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkFkZE9wdGlvbnNIdG1sICggb1NldHRpbmdzIClcblx0e1xuXHRcdHZhciBjbGFzc2VzID0gb1NldHRpbmdzLm9DbGFzc2VzO1xuXHRcdHZhciB0YWJsZSA9ICQob1NldHRpbmdzLm5UYWJsZSk7XG5cdFx0dmFyIGhvbGRpbmcgPSAkKCc8ZGl2Lz4nKS5pbnNlcnRCZWZvcmUoIHRhYmxlICk7IC8vIEhvbGRpbmcgZWxlbWVudCBmb3Igc3BlZWRcblx0XHR2YXIgZmVhdHVyZXMgPSBvU2V0dGluZ3Mub0ZlYXR1cmVzO1xuXHRcblx0XHQvLyBBbGwgRGF0YVRhYmxlcyBhcmUgd3JhcHBlZCBpbiBhIGRpdlxuXHRcdHZhciBpbnNlcnQgPSAkKCc8ZGl2Lz4nLCB7XG5cdFx0XHRpZDogICAgICBvU2V0dGluZ3Muc1RhYmxlSWQrJ193cmFwcGVyJyxcblx0XHRcdCdjbGFzcyc6IGNsYXNzZXMuc1dyYXBwZXIgKyAob1NldHRpbmdzLm5URm9vdCA/ICcnIDogJyAnK2NsYXNzZXMuc05vRm9vdGVyKVxuXHRcdH0gKTtcblx0XG5cdFx0b1NldHRpbmdzLm5Ib2xkaW5nID0gaG9sZGluZ1swXTtcblx0XHRvU2V0dGluZ3MublRhYmxlV3JhcHBlciA9IGluc2VydFswXTtcblx0XHRvU2V0dGluZ3MublRhYmxlUmVpbnNlcnRCZWZvcmUgPSBvU2V0dGluZ3MublRhYmxlLm5leHRTaWJsaW5nO1xuXHRcblx0XHQvKiBMb29wIG92ZXIgdGhlIHVzZXIgc2V0IHBvc2l0aW9uaW5nIGFuZCBwbGFjZSB0aGUgZWxlbWVudHMgYXMgbmVlZGVkICovXG5cdFx0dmFyIGFEb20gPSBvU2V0dGluZ3Muc0RvbS5zcGxpdCgnJyk7XG5cdFx0dmFyIGZlYXR1cmVOb2RlLCBjT3B0aW9uLCBuTmV3Tm9kZSwgY05leHQsIHNBdHRyLCBqO1xuXHRcdGZvciAoIHZhciBpPTAgOyBpPGFEb20ubGVuZ3RoIDsgaSsrIClcblx0XHR7XG5cdFx0XHRmZWF0dXJlTm9kZSA9IG51bGw7XG5cdFx0XHRjT3B0aW9uID0gYURvbVtpXTtcblx0XG5cdFx0XHRpZiAoIGNPcHRpb24gPT0gJzwnIClcblx0XHRcdHtcblx0XHRcdFx0LyogTmV3IGNvbnRhaW5lciBkaXYgKi9cblx0XHRcdFx0bk5ld05vZGUgPSAkKCc8ZGl2Lz4nKVswXTtcblx0XG5cdFx0XHRcdC8qIENoZWNrIHRvIHNlZSBpZiB3ZSBzaG91bGQgYXBwZW5kIGFuIGlkIGFuZC9vciBhIGNsYXNzIG5hbWUgdG8gdGhlIGNvbnRhaW5lciAqL1xuXHRcdFx0XHRjTmV4dCA9IGFEb21baSsxXTtcblx0XHRcdFx0aWYgKCBjTmV4dCA9PSBcIidcIiB8fCBjTmV4dCA9PSAnXCInIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHNBdHRyID0gXCJcIjtcblx0XHRcdFx0XHRqID0gMjtcblx0XHRcdFx0XHR3aGlsZSAoIGFEb21baStqXSAhPSBjTmV4dCApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0c0F0dHIgKz0gYURvbVtpK2pdO1xuXHRcdFx0XHRcdFx0aisrO1xuXHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0LyogUmVwbGFjZSBqUXVlcnkgVUkgY29uc3RhbnRzIEB0b2RvIGRlcHJlY2lhdGVkICovXG5cdFx0XHRcdFx0aWYgKCBzQXR0ciA9PSBcIkhcIiApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0c0F0dHIgPSBjbGFzc2VzLnNKVUlIZWFkZXI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgaWYgKCBzQXR0ciA9PSBcIkZcIiApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0c0F0dHIgPSBjbGFzc2VzLnNKVUlGb290ZXI7XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHQvKiBUaGUgYXR0cmlidXRlIGNhbiBiZSBpbiB0aGUgZm9ybWF0IG9mIFwiI2lkLmNsYXNzXCIsIFwiI2lkXCIgb3IgXCJjbGFzc1wiIFRoaXMgbG9naWNcblx0XHRcdFx0XHQgKiBicmVha3MgdGhlIHN0cmluZyBpbnRvIHBhcnRzIGFuZCBhcHBsaWVzIHRoZW0gYXMgbmVlZGVkXG5cdFx0XHRcdFx0ICovXG5cdFx0XHRcdFx0aWYgKCBzQXR0ci5pbmRleE9mKCcuJykgIT0gLTEgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHZhciBhU3BsaXQgPSBzQXR0ci5zcGxpdCgnLicpO1xuXHRcdFx0XHRcdFx0bk5ld05vZGUuaWQgPSBhU3BsaXRbMF0uc3Vic3RyKDEsIGFTcGxpdFswXS5sZW5ndGgtMSk7XG5cdFx0XHRcdFx0XHRuTmV3Tm9kZS5jbGFzc05hbWUgPSBhU3BsaXRbMV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgaWYgKCBzQXR0ci5jaGFyQXQoMCkgPT0gXCIjXCIgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdG5OZXdOb2RlLmlkID0gc0F0dHIuc3Vic3RyKDEsIHNBdHRyLmxlbmd0aC0xKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdG5OZXdOb2RlLmNsYXNzTmFtZSA9IHNBdHRyO1xuXHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0aSArPSBqOyAvKiBNb3ZlIGFsb25nIHRoZSBwb3NpdGlvbiBhcnJheSAqL1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRpbnNlcnQuYXBwZW5kKCBuTmV3Tm9kZSApO1xuXHRcdFx0XHRpbnNlcnQgPSAkKG5OZXdOb2RlKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBjT3B0aW9uID09ICc+JyApXG5cdFx0XHR7XG5cdFx0XHRcdC8qIEVuZCBjb250YWluZXIgZGl2ICovXG5cdFx0XHRcdGluc2VydCA9IGluc2VydC5wYXJlbnQoKTtcblx0XHRcdH1cblx0XHRcdC8vIEB0b2RvIE1vdmUgb3B0aW9ucyBpbnRvIHRoZWlyIG93biBwbHVnaW5zP1xuXHRcdFx0ZWxzZSBpZiAoIGNPcHRpb24gPT0gJ2wnICYmIGZlYXR1cmVzLmJQYWdpbmF0ZSAmJiBmZWF0dXJlcy5iTGVuZ3RoQ2hhbmdlIClcblx0XHRcdHtcblx0XHRcdFx0LyogTGVuZ3RoICovXG5cdFx0XHRcdGZlYXR1cmVOb2RlID0gX2ZuRmVhdHVyZUh0bWxMZW5ndGgoIG9TZXR0aW5ncyApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIGNPcHRpb24gPT0gJ2YnICYmIGZlYXR1cmVzLmJGaWx0ZXIgKVxuXHRcdFx0e1xuXHRcdFx0XHQvKiBGaWx0ZXIgKi9cblx0XHRcdFx0ZmVhdHVyZU5vZGUgPSBfZm5GZWF0dXJlSHRtbEZpbHRlciggb1NldHRpbmdzICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggY09wdGlvbiA9PSAncicgJiYgZmVhdHVyZXMuYlByb2Nlc3NpbmcgKVxuXHRcdFx0e1xuXHRcdFx0XHQvKiBwUm9jZXNzaW5nICovXG5cdFx0XHRcdGZlYXR1cmVOb2RlID0gX2ZuRmVhdHVyZUh0bWxQcm9jZXNzaW5nKCBvU2V0dGluZ3MgKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBjT3B0aW9uID09ICd0JyApXG5cdFx0XHR7XG5cdFx0XHRcdC8qIFRhYmxlICovXG5cdFx0XHRcdGZlYXR1cmVOb2RlID0gX2ZuRmVhdHVyZUh0bWxUYWJsZSggb1NldHRpbmdzICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggY09wdGlvbiA9PSAgJ2knICYmIGZlYXR1cmVzLmJJbmZvIClcblx0XHRcdHtcblx0XHRcdFx0LyogSW5mbyAqL1xuXHRcdFx0XHRmZWF0dXJlTm9kZSA9IF9mbkZlYXR1cmVIdG1sSW5mbyggb1NldHRpbmdzICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggY09wdGlvbiA9PSAncCcgJiYgZmVhdHVyZXMuYlBhZ2luYXRlIClcblx0XHRcdHtcblx0XHRcdFx0LyogUGFnaW5hdGlvbiAqL1xuXHRcdFx0XHRmZWF0dXJlTm9kZSA9IF9mbkZlYXR1cmVIdG1sUGFnaW5hdGUoIG9TZXR0aW5ncyApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIERhdGFUYWJsZS5leHQuZmVhdHVyZS5sZW5ndGggIT09IDAgKVxuXHRcdFx0e1xuXHRcdFx0XHQvKiBQbHVnLWluIGZlYXR1cmVzICovXG5cdFx0XHRcdHZhciBhb0ZlYXR1cmVzID0gRGF0YVRhYmxlLmV4dC5mZWF0dXJlO1xuXHRcdFx0XHRmb3IgKCB2YXIgaz0wLCBrTGVuPWFvRmVhdHVyZXMubGVuZ3RoIDsgazxrTGVuIDsgaysrIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmICggY09wdGlvbiA9PSBhb0ZlYXR1cmVzW2tdLmNGZWF0dXJlIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRmZWF0dXJlTm9kZSA9IGFvRmVhdHVyZXNba10uZm5Jbml0KCBvU2V0dGluZ3MgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdC8qIEFkZCB0byB0aGUgMkQgZmVhdHVyZXMgYXJyYXkgKi9cblx0XHRcdGlmICggZmVhdHVyZU5vZGUgKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgYWFuRmVhdHVyZXMgPSBvU2V0dGluZ3MuYWFuRmVhdHVyZXM7XG5cdFxuXHRcdFx0XHRpZiAoICEgYWFuRmVhdHVyZXNbY09wdGlvbl0gKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0YWFuRmVhdHVyZXNbY09wdGlvbl0gPSBbXTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0YWFuRmVhdHVyZXNbY09wdGlvbl0ucHVzaCggZmVhdHVyZU5vZGUgKTtcblx0XHRcdFx0aW5zZXJ0LmFwcGVuZCggZmVhdHVyZU5vZGUgKTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdC8qIEJ1aWx0IG91ciBET00gc3RydWN0dXJlIC0gcmVwbGFjZSB0aGUgaG9sZGluZyBkaXYgd2l0aCB3aGF0IHdlIHdhbnQgKi9cblx0XHRob2xkaW5nLnJlcGxhY2VXaXRoKCBpbnNlcnQgKTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBVc2UgdGhlIERPTSBzb3VyY2UgdG8gY3JlYXRlIHVwIGFuIGFycmF5IG9mIGhlYWRlciBjZWxscy4gVGhlIGlkZWEgaGVyZSBpcyB0b1xuXHQgKiBjcmVhdGUgYSBsYXlvdXQgZ3JpZCAoYXJyYXkpIG9mIHJvd3MgeCBjb2x1bW5zLCB3aGljaCBjb250YWlucyBhIHJlZmVyZW5jZVxuXHQgKiB0byB0aGUgY2VsbCB0aGF0IHRoYXQgcG9pbnQgaW4gdGhlIGdyaWQgKHJlZ2FyZGxlc3Mgb2YgY29sL3Jvd3NwYW4pLCBzdWNoIHRoYXRcblx0ICogYW55IGNvbHVtbiAvIHJvdyBjb3VsZCBiZSByZW1vdmVkIGFuZCB0aGUgbmV3IGdyaWQgY29uc3RydWN0ZWRcblx0ICogIEBwYXJhbSBhcnJheSB7b2JqZWN0fSBhTGF5b3V0IEFycmF5IHRvIHN0b3JlIHRoZSBjYWxjdWxhdGVkIGxheW91dCBpblxuXHQgKiAgQHBhcmFtIHtub2RlfSBuVGhlYWQgVGhlIGhlYWRlci9mb290ZXIgZWxlbWVudCBmb3IgdGhlIHRhYmxlXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkRldGVjdEhlYWRlciAoIGFMYXlvdXQsIG5UaGVhZCApXG5cdHtcblx0XHR2YXIgblRycyA9ICQoblRoZWFkKS5jaGlsZHJlbigndHInKTtcblx0XHR2YXIgblRyLCBuQ2VsbDtcblx0XHR2YXIgaSwgaywgbCwgaUxlbiwgakxlbiwgaUNvbFNoaWZ0ZWQsIGlDb2x1bW4sIGlDb2xzcGFuLCBpUm93c3Bhbjtcblx0XHR2YXIgYlVuaXF1ZTtcblx0XHR2YXIgZm5TaGlmdENvbCA9IGZ1bmN0aW9uICggYSwgaSwgaiApIHtcblx0XHRcdHZhciBrID0gYVtpXTtcblx0ICAgICAgICAgICAgICAgIHdoaWxlICgga1tqXSApIHtcblx0XHRcdFx0aisrO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGo7XG5cdFx0fTtcblx0XG5cdFx0YUxheW91dC5zcGxpY2UoIDAsIGFMYXlvdXQubGVuZ3RoICk7XG5cdFxuXHRcdC8qIFdlIGtub3cgaG93IG1hbnkgcm93cyB0aGVyZSBhcmUgaW4gdGhlIGxheW91dCAtIHNvIHByZXAgaXQgKi9cblx0XHRmb3IgKCBpPTAsIGlMZW49blRycy5sZW5ndGggOyBpPGlMZW4gOyBpKysgKVxuXHRcdHtcblx0XHRcdGFMYXlvdXQucHVzaCggW10gKTtcblx0XHR9XG5cdFxuXHRcdC8qIENhbGN1bGF0ZSBhIGxheW91dCBhcnJheSAqL1xuXHRcdGZvciAoIGk9MCwgaUxlbj1uVHJzLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApXG5cdFx0e1xuXHRcdFx0blRyID0gblRyc1tpXTtcblx0XHRcdGlDb2x1bW4gPSAwO1xuXHRcblx0XHRcdC8qIEZvciBldmVyeSBjZWxsIGluIHRoZSByb3cuLi4gKi9cblx0XHRcdG5DZWxsID0gblRyLmZpcnN0Q2hpbGQ7XG5cdFx0XHR3aGlsZSAoIG5DZWxsICkge1xuXHRcdFx0XHRpZiAoIG5DZWxsLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT0gXCJURFwiIHx8XG5cdFx0XHRcdCAgICAgbkNlbGwubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PSBcIlRIXCIgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0LyogR2V0IHRoZSBjb2wgYW5kIHJvd3NwYW4gYXR0cmlidXRlcyBmcm9tIHRoZSBET00gYW5kIHNhbml0aXNlIHRoZW0gKi9cblx0XHRcdFx0XHRpQ29sc3BhbiA9IG5DZWxsLmdldEF0dHJpYnV0ZSgnY29sc3BhbicpICogMTtcblx0XHRcdFx0XHRpUm93c3BhbiA9IG5DZWxsLmdldEF0dHJpYnV0ZSgncm93c3BhbicpICogMTtcblx0XHRcdFx0XHRpQ29sc3BhbiA9ICghaUNvbHNwYW4gfHwgaUNvbHNwYW49PT0wIHx8IGlDb2xzcGFuPT09MSkgPyAxIDogaUNvbHNwYW47XG5cdFx0XHRcdFx0aVJvd3NwYW4gPSAoIWlSb3dzcGFuIHx8IGlSb3dzcGFuPT09MCB8fCBpUm93c3Bhbj09PTEpID8gMSA6IGlSb3dzcGFuO1xuXHRcblx0XHRcdFx0XHQvKiBUaGVyZSBtaWdodCBiZSBjb2xzcGFuIGNlbGxzIGFscmVhZHkgaW4gdGhpcyByb3csIHNvIHNoaWZ0IG91ciB0YXJnZXRcblx0XHRcdFx0XHQgKiBhY2NvcmRpbmdseVxuXHRcdFx0XHRcdCAqL1xuXHRcdFx0XHRcdGlDb2xTaGlmdGVkID0gZm5TaGlmdENvbCggYUxheW91dCwgaSwgaUNvbHVtbiApO1xuXHRcblx0XHRcdFx0XHQvKiBDYWNoZSBjYWxjdWxhdGlvbiBmb3IgdW5pcXVlIGNvbHVtbnMgKi9cblx0XHRcdFx0XHRiVW5pcXVlID0gaUNvbHNwYW4gPT09IDEgPyB0cnVlIDogZmFsc2U7XG5cdFxuXHRcdFx0XHRcdC8qIElmIHRoZXJlIGlzIGNvbCAvIHJvd3NwYW4sIGNvcHkgdGhlIGluZm9ybWF0aW9uIGludG8gdGhlIGxheW91dCBncmlkICovXG5cdFx0XHRcdFx0Zm9yICggbD0wIDsgbDxpQ29sc3BhbiA7IGwrKyApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Zm9yICggaz0wIDsgazxpUm93c3BhbiA7IGsrKyApXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGFMYXlvdXRbaStrXVtpQ29sU2hpZnRlZCtsXSA9IHtcblx0XHRcdFx0XHRcdFx0XHRcImNlbGxcIjogbkNlbGwsXG5cdFx0XHRcdFx0XHRcdFx0XCJ1bmlxdWVcIjogYlVuaXF1ZVxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHRhTGF5b3V0W2kra10ublRyID0gblRyO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRuQ2VsbCA9IG5DZWxsLm5leHRTaWJsaW5nO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBHZXQgYW4gYXJyYXkgb2YgdW5pcXVlIHRoIGVsZW1lbnRzLCBvbmUgZm9yIGVhY2ggY29sdW1uXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge25vZGV9IG5IZWFkZXIgYXV0b21hdGljYWxseSBkZXRlY3QgdGhlIGxheW91dCBmcm9tIHRoaXMgbm9kZSAtIG9wdGlvbmFsXG5cdCAqICBAcGFyYW0ge2FycmF5fSBhTGF5b3V0IHRoZWFkL3Rmb290IGxheW91dCBmcm9tIF9mbkRldGVjdEhlYWRlciAtIG9wdGlvbmFsXG5cdCAqICBAcmV0dXJucyBhcnJheSB7bm9kZX0gYVJldHVybiBsaXN0IG9mIHVuaXF1ZSB0aCdzXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkdldFVuaXF1ZVRocyAoIG9TZXR0aW5ncywgbkhlYWRlciwgYUxheW91dCApXG5cdHtcblx0XHR2YXIgYVJldHVybiA9IFtdO1xuXHRcdGlmICggIWFMYXlvdXQgKVxuXHRcdHtcblx0XHRcdGFMYXlvdXQgPSBvU2V0dGluZ3MuYW9IZWFkZXI7XG5cdFx0XHRpZiAoIG5IZWFkZXIgKVxuXHRcdFx0e1xuXHRcdFx0XHRhTGF5b3V0ID0gW107XG5cdFx0XHRcdF9mbkRldGVjdEhlYWRlciggYUxheW91dCwgbkhlYWRlciApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0Zm9yICggdmFyIGk9MCwgaUxlbj1hTGF5b3V0Lmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApXG5cdFx0e1xuXHRcdFx0Zm9yICggdmFyIGo9MCwgakxlbj1hTGF5b3V0W2ldLmxlbmd0aCA7IGo8akxlbiA7IGorKyApXG5cdFx0XHR7XG5cdFx0XHRcdGlmICggYUxheW91dFtpXVtqXS51bmlxdWUgJiZcblx0XHRcdFx0XHQgKCFhUmV0dXJuW2pdIHx8ICFvU2V0dGluZ3MuYlNvcnRDZWxsc1RvcCkgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0YVJldHVybltqXSA9IGFMYXlvdXRbaV1bal0uY2VsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0cmV0dXJuIGFSZXR1cm47XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBDcmVhdGUgYW4gQWpheCBjYWxsIGJhc2VkIG9uIHRoZSB0YWJsZSdzIHNldHRpbmdzLCB0YWtpbmcgaW50byBhY2NvdW50IHRoYXRcblx0ICogcGFyYW1ldGVycyBjYW4gaGF2ZSBtdWx0aXBsZSBmb3JtcywgYW5kIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqIEBwYXJhbSB7YXJyYXl9IGRhdGEgRGF0YSB0byBzZW5kIHRvIHRoZSBzZXJ2ZXIsIHJlcXVpcmVkIGJ5XG5cdCAqICAgICBEYXRhVGFibGVzIC0gbWF5IGJlIGF1Z21lbnRlZCBieSBkZXZlbG9wZXIgY2FsbGJhY2tzXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIENhbGxiYWNrIGZ1bmN0aW9uIHRvIHJ1biB3aGVuIGRhdGEgaXMgb2J0YWluZWRcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkJ1aWxkQWpheCggb1NldHRpbmdzLCBkYXRhLCBmbiApXG5cdHtcblx0XHQvLyBDb21wYXRpYmlsaXR5IHdpdGggMS45LSwgYWxsb3cgZm5TZXJ2ZXJEYXRhIGFuZCBldmVudCB0byBtYW5pcHVsYXRlXG5cdFx0X2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsICdhb1NlcnZlclBhcmFtcycsICdzZXJ2ZXJQYXJhbXMnLCBbZGF0YV0gKTtcblx0XG5cdFx0Ly8gQ29udmVydCB0byBvYmplY3QgYmFzZWQgZm9yIDEuMTArIGlmIHVzaW5nIHRoZSBvbGQgYXJyYXkgc2NoZW1lIHdoaWNoIGNhblxuXHRcdC8vIGNvbWUgZnJvbSBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIG9yIHNlcnZlclBhcmFtc1xuXHRcdGlmICggZGF0YSAmJiAkLmlzQXJyYXkoZGF0YSkgKSB7XG5cdFx0XHR2YXIgdG1wID0ge307XG5cdFx0XHR2YXIgcmJyYWNrZXQgPSAvKC4qPylcXFtcXF0kLztcblx0XG5cdFx0XHQkLmVhY2goIGRhdGEsIGZ1bmN0aW9uIChrZXksIHZhbCkge1xuXHRcdFx0XHR2YXIgbWF0Y2ggPSB2YWwubmFtZS5tYXRjaChyYnJhY2tldCk7XG5cdFxuXHRcdFx0XHRpZiAoIG1hdGNoICkge1xuXHRcdFx0XHRcdC8vIFN1cHBvcnQgZm9yIGFycmF5c1xuXHRcdFx0XHRcdHZhciBuYW1lID0gbWF0Y2hbMF07XG5cdFxuXHRcdFx0XHRcdGlmICggISB0bXBbIG5hbWUgXSApIHtcblx0XHRcdFx0XHRcdHRtcFsgbmFtZSBdID0gW107XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRtcFsgbmFtZSBdLnB1c2goIHZhbC52YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRtcFt2YWwubmFtZV0gPSB2YWwudmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHRcdGRhdGEgPSB0bXA7XG5cdFx0fVxuXHRcblx0XHR2YXIgYWpheERhdGE7XG5cdFx0dmFyIGFqYXggPSBvU2V0dGluZ3MuYWpheDtcblx0XHR2YXIgaW5zdGFuY2UgPSBvU2V0dGluZ3Mub0luc3RhbmNlO1xuXHRcdHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uICgganNvbiApIHtcblx0XHRcdF9mbkNhbGxiYWNrRmlyZSggb1NldHRpbmdzLCBudWxsLCAneGhyJywgW29TZXR0aW5ncywganNvbiwgb1NldHRpbmdzLmpxWEhSXSApO1xuXHRcdFx0Zm4oIGpzb24gKTtcblx0XHR9O1xuXHRcblx0XHRpZiAoICQuaXNQbGFpbk9iamVjdCggYWpheCApICYmIGFqYXguZGF0YSApXG5cdFx0e1xuXHRcdFx0YWpheERhdGEgPSBhamF4LmRhdGE7XG5cdFxuXHRcdFx0dmFyIG5ld0RhdGEgPSAkLmlzRnVuY3Rpb24oIGFqYXhEYXRhICkgP1xuXHRcdFx0XHRhamF4RGF0YSggZGF0YSwgb1NldHRpbmdzICkgOiAgLy8gZm4gY2FuIG1hbmlwdWxhdGUgZGF0YSBvciByZXR1cm5cblx0XHRcdFx0YWpheERhdGE7ICAgICAgICAgICAgICAgICAgICAgIC8vIGFuIG9iamVjdCBvYmplY3Qgb3IgYXJyYXkgdG8gbWVyZ2Vcblx0XG5cdFx0XHQvLyBJZiB0aGUgZnVuY3Rpb24gcmV0dXJuZWQgc29tZXRoaW5nLCB1c2UgdGhhdCBhbG9uZVxuXHRcdFx0ZGF0YSA9ICQuaXNGdW5jdGlvbiggYWpheERhdGEgKSAmJiBuZXdEYXRhID9cblx0XHRcdFx0bmV3RGF0YSA6XG5cdFx0XHRcdCQuZXh0ZW5kKCB0cnVlLCBkYXRhLCBuZXdEYXRhICk7XG5cdFxuXHRcdFx0Ly8gUmVtb3ZlIHRoZSBkYXRhIHByb3BlcnR5IGFzIHdlJ3ZlIHJlc29sdmVkIGl0IGFscmVhZHkgYW5kIGRvbid0IHdhbnRcblx0XHRcdC8vIGpRdWVyeSB0byBkbyBpdCBhZ2FpbiAoaXQgaXMgcmVzdG9yZWQgYXQgdGhlIGVuZCBvZiB0aGUgZnVuY3Rpb24pXG5cdFx0XHRkZWxldGUgYWpheC5kYXRhO1xuXHRcdH1cblx0XG5cdFx0dmFyIGJhc2VBamF4ID0ge1xuXHRcdFx0XCJkYXRhXCI6IGRhdGEsXG5cdFx0XHRcInN1Y2Nlc3NcIjogZnVuY3Rpb24gKGpzb24pIHtcblx0XHRcdFx0dmFyIGVycm9yID0ganNvbi5lcnJvciB8fCBqc29uLnNFcnJvcjtcblx0XHRcdFx0aWYgKCBlcnJvciApIHtcblx0XHRcdFx0XHRfZm5Mb2coIG9TZXR0aW5ncywgMCwgZXJyb3IgKTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0b1NldHRpbmdzLmpzb24gPSBqc29uO1xuXHRcdFx0XHRjYWxsYmFjaygganNvbiApO1xuXHRcdFx0fSxcblx0XHRcdFwiZGF0YVR5cGVcIjogXCJqc29uXCIsXG5cdFx0XHRcImNhY2hlXCI6IGZhbHNlLFxuXHRcdFx0XCJ0eXBlXCI6IG9TZXR0aW5ncy5zU2VydmVyTWV0aG9kLFxuXHRcdFx0XCJlcnJvclwiOiBmdW5jdGlvbiAoeGhyLCBlcnJvciwgdGhyb3duKSB7XG5cdFx0XHRcdHZhciByZXQgPSBfZm5DYWxsYmFja0ZpcmUoIG9TZXR0aW5ncywgbnVsbCwgJ3hocicsIFtvU2V0dGluZ3MsIG51bGwsIG9TZXR0aW5ncy5qcVhIUl0gKTtcblx0XG5cdFx0XHRcdGlmICggJC5pbkFycmF5KCB0cnVlLCByZXQgKSA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0aWYgKCBlcnJvciA9PSBcInBhcnNlcmVycm9yXCIgKSB7XG5cdFx0XHRcdFx0XHRfZm5Mb2coIG9TZXR0aW5ncywgMCwgJ0ludmFsaWQgSlNPTiByZXNwb25zZScsIDEgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xuXHRcdFx0XHRcdFx0X2ZuTG9nKCBvU2V0dGluZ3MsIDAsICdBamF4IGVycm9yJywgNyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIG9TZXR0aW5ncywgZmFsc2UgKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcblx0XHQvLyBTdG9yZSB0aGUgZGF0YSBzdWJtaXR0ZWQgZm9yIHRoZSBBUElcblx0XHRvU2V0dGluZ3Mub0FqYXhEYXRhID0gZGF0YTtcblx0XG5cdFx0Ly8gQWxsb3cgcGx1Zy1pbnMgYW5kIGV4dGVybmFsIHByb2Nlc3NlcyB0byBtb2RpZnkgdGhlIGRhdGFcblx0XHRfZm5DYWxsYmFja0ZpcmUoIG9TZXR0aW5ncywgbnVsbCwgJ3ByZVhocicsIFtvU2V0dGluZ3MsIGRhdGFdICk7XG5cdFxuXHRcdGlmICggb1NldHRpbmdzLmZuU2VydmVyRGF0YSApXG5cdFx0e1xuXHRcdFx0Ly8gRGF0YVRhYmxlcyAxLjktIGNvbXBhdGliaWxpdHlcblx0XHRcdG9TZXR0aW5ncy5mblNlcnZlckRhdGEuY2FsbCggaW5zdGFuY2UsXG5cdFx0XHRcdG9TZXR0aW5ncy5zQWpheFNvdXJjZSxcblx0XHRcdFx0JC5tYXAoIGRhdGEsIGZ1bmN0aW9uICh2YWwsIGtleSkgeyAvLyBOZWVkIHRvIGNvbnZlcnQgYmFjayB0byAxLjkgdHJhZCBmb3JtYXRcblx0XHRcdFx0XHRyZXR1cm4geyBuYW1lOiBrZXksIHZhbHVlOiB2YWwgfTtcblx0XHRcdFx0fSApLFxuXHRcdFx0XHRjYWxsYmFjayxcblx0XHRcdFx0b1NldHRpbmdzXG5cdFx0XHQpO1xuXHRcdH1cblx0XHRlbHNlIGlmICggb1NldHRpbmdzLnNBamF4U291cmNlIHx8IHR5cGVvZiBhamF4ID09PSAnc3RyaW5nJyApXG5cdFx0e1xuXHRcdFx0Ly8gRGF0YVRhYmxlcyAxLjktIGNvbXBhdGliaWxpdHlcblx0XHRcdG9TZXR0aW5ncy5qcVhIUiA9ICQuYWpheCggJC5leHRlbmQoIGJhc2VBamF4LCB7XG5cdFx0XHRcdHVybDogYWpheCB8fCBvU2V0dGluZ3Muc0FqYXhTb3VyY2Vcblx0XHRcdH0gKSApO1xuXHRcdH1cblx0XHRlbHNlIGlmICggJC5pc0Z1bmN0aW9uKCBhamF4ICkgKVxuXHRcdHtcblx0XHRcdC8vIElzIGEgZnVuY3Rpb24gLSBsZXQgdGhlIGNhbGxlciBkZWZpbmUgd2hhdCBuZWVkcyB0byBiZSBkb25lXG5cdFx0XHRvU2V0dGluZ3MuanFYSFIgPSBhamF4LmNhbGwoIGluc3RhbmNlLCBkYXRhLCBjYWxsYmFjaywgb1NldHRpbmdzICk7XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHQvLyBPYmplY3QgdG8gZXh0ZW5kIHRoZSBiYXNlIHNldHRpbmdzXG5cdFx0XHRvU2V0dGluZ3MuanFYSFIgPSAkLmFqYXgoICQuZXh0ZW5kKCBiYXNlQWpheCwgYWpheCApICk7XG5cdFxuXHRcdFx0Ly8gUmVzdG9yZSBmb3IgbmV4dCB0aW1lIGFyb3VuZFxuXHRcdFx0YWpheC5kYXRhID0gYWpheERhdGE7XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIFVwZGF0ZSB0aGUgdGFibGUgdXNpbmcgYW4gQWpheCBjYWxsXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEByZXR1cm5zIHtib29sZWFufSBCbG9jayB0aGUgdGFibGUgZHJhd2luZyBvciBub3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQWpheFVwZGF0ZSggc2V0dGluZ3MgKVxuXHR7XG5cdFx0aWYgKCBzZXR0aW5ncy5iQWpheERhdGFHZXQgKSB7XG5cdFx0XHRzZXR0aW5ncy5pRHJhdysrO1xuXHRcdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIHNldHRpbmdzLCB0cnVlICk7XG5cdFxuXHRcdFx0X2ZuQnVpbGRBamF4KFxuXHRcdFx0XHRzZXR0aW5ncyxcblx0XHRcdFx0X2ZuQWpheFBhcmFtZXRlcnMoIHNldHRpbmdzICksXG5cdFx0XHRcdGZ1bmN0aW9uKGpzb24pIHtcblx0XHRcdFx0XHRfZm5BamF4VXBkYXRlRHJhdyggc2V0dGluZ3MsIGpzb24gKTtcblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEJ1aWxkIHVwIHRoZSBwYXJhbWV0ZXJzIGluIGFuIG9iamVjdCBuZWVkZWQgZm9yIGEgc2VydmVyLXNpZGUgcHJvY2Vzc2luZ1xuXHQgKiByZXF1ZXN0LiBOb3RlIHRoYXQgdGhpcyBpcyBiYXNpY2FsbHkgZG9uZSB0d2ljZSwgaXMgZGlmZmVyZW50IHdheXMgLSBhIG1vZGVyblxuXHQgKiBtZXRob2Qgd2hpY2ggaXMgdXNlZCBieSBkZWZhdWx0IGluIERhdGFUYWJsZXMgMS4xMCB3aGljaCB1c2VzIG9iamVjdHMgYW5kXG5cdCAqIGFycmF5cywgb3IgdGhlIDEuOS0gbWV0aG9kIHdpdGggaXMgbmFtZSAvIHZhbHVlIHBhaXJzLiAxLjkgbWV0aG9kIGlzIHVzZWQgaWZcblx0ICogdGhlIHNBamF4U291cmNlIG9wdGlvbiBpcyB1c2VkIGluIHRoZSBpbml0aWFsaXNhdGlvbiwgb3IgdGhlIGxlZ2FjeUFqYXhcblx0ICogb3B0aW9uIGlzIHNldC5cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEByZXR1cm5zIHtib29sfSBibG9jayB0aGUgdGFibGUgZHJhd2luZyBvciBub3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQWpheFBhcmFtZXRlcnMoIHNldHRpbmdzIClcblx0e1xuXHRcdHZhclxuXHRcdFx0Y29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucyxcblx0XHRcdGNvbHVtbkNvdW50ID0gY29sdW1ucy5sZW5ndGgsXG5cdFx0XHRmZWF0dXJlcyA9IHNldHRpbmdzLm9GZWF0dXJlcyxcblx0XHRcdHByZVNlYXJjaCA9IHNldHRpbmdzLm9QcmV2aW91c1NlYXJjaCxcblx0XHRcdHByZUNvbFNlYXJjaCA9IHNldHRpbmdzLmFvUHJlU2VhcmNoQ29scyxcblx0XHRcdGksIGRhdGEgPSBbXSwgZGF0YVByb3AsIGNvbHVtbiwgY29sdW1uU2VhcmNoLFxuXHRcdFx0c29ydCA9IF9mblNvcnRGbGF0dGVuKCBzZXR0aW5ncyApLFxuXHRcdFx0ZGlzcGxheVN0YXJ0ID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQsXG5cdFx0XHRkaXNwbGF5TGVuZ3RoID0gZmVhdHVyZXMuYlBhZ2luYXRlICE9PSBmYWxzZSA/XG5cdFx0XHRcdHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aCA6XG5cdFx0XHRcdC0xO1xuXHRcblx0XHR2YXIgcGFyYW0gPSBmdW5jdGlvbiAoIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0ZGF0YS5wdXNoKCB7ICduYW1lJzogbmFtZSwgJ3ZhbHVlJzogdmFsdWUgfSApO1xuXHRcdH07XG5cdFxuXHRcdC8vIERhdGFUYWJsZXMgMS45LSBjb21wYXRpYmxlIG1ldGhvZFxuXHRcdHBhcmFtKCAnc0VjaG8nLCAgICAgICAgICBzZXR0aW5ncy5pRHJhdyApO1xuXHRcdHBhcmFtKCAnaUNvbHVtbnMnLCAgICAgICBjb2x1bW5Db3VudCApO1xuXHRcdHBhcmFtKCAnc0NvbHVtbnMnLCAgICAgICBfcGx1Y2soIGNvbHVtbnMsICdzTmFtZScgKS5qb2luKCcsJykgKTtcblx0XHRwYXJhbSggJ2lEaXNwbGF5U3RhcnQnLCAgZGlzcGxheVN0YXJ0ICk7XG5cdFx0cGFyYW0oICdpRGlzcGxheUxlbmd0aCcsIGRpc3BsYXlMZW5ndGggKTtcblx0XG5cdFx0Ly8gRGF0YVRhYmxlcyAxLjEwKyBtZXRob2Rcblx0XHR2YXIgZCA9IHtcblx0XHRcdGRyYXc6ICAgIHNldHRpbmdzLmlEcmF3LFxuXHRcdFx0Y29sdW1uczogW10sXG5cdFx0XHRvcmRlcjogICBbXSxcblx0XHRcdHN0YXJ0OiAgIGRpc3BsYXlTdGFydCxcblx0XHRcdGxlbmd0aDogIGRpc3BsYXlMZW5ndGgsXG5cdFx0XHRzZWFyY2g6ICB7XG5cdFx0XHRcdHZhbHVlOiBwcmVTZWFyY2guc1NlYXJjaCxcblx0XHRcdFx0cmVnZXg6IHByZVNlYXJjaC5iUmVnZXhcblx0XHRcdH1cblx0XHR9O1xuXHRcblx0XHRmb3IgKCBpPTAgOyBpPGNvbHVtbkNvdW50IDsgaSsrICkge1xuXHRcdFx0Y29sdW1uID0gY29sdW1uc1tpXTtcblx0XHRcdGNvbHVtblNlYXJjaCA9IHByZUNvbFNlYXJjaFtpXTtcblx0XHRcdGRhdGFQcm9wID0gdHlwZW9mIGNvbHVtbi5tRGF0YT09XCJmdW5jdGlvblwiID8gJ2Z1bmN0aW9uJyA6IGNvbHVtbi5tRGF0YSA7XG5cdFxuXHRcdFx0ZC5jb2x1bW5zLnB1c2goIHtcblx0XHRcdFx0ZGF0YTogICAgICAgZGF0YVByb3AsXG5cdFx0XHRcdG5hbWU6ICAgICAgIGNvbHVtbi5zTmFtZSxcblx0XHRcdFx0c2VhcmNoYWJsZTogY29sdW1uLmJTZWFyY2hhYmxlLFxuXHRcdFx0XHRvcmRlcmFibGU6ICBjb2x1bW4uYlNvcnRhYmxlLFxuXHRcdFx0XHRzZWFyY2g6ICAgICB7XG5cdFx0XHRcdFx0dmFsdWU6IGNvbHVtblNlYXJjaC5zU2VhcmNoLFxuXHRcdFx0XHRcdHJlZ2V4OiBjb2x1bW5TZWFyY2guYlJlZ2V4XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XG5cdFx0XHRwYXJhbSggXCJtRGF0YVByb3BfXCIraSwgZGF0YVByb3AgKTtcblx0XG5cdFx0XHRpZiAoIGZlYXR1cmVzLmJGaWx0ZXIgKSB7XG5cdFx0XHRcdHBhcmFtKCAnc1NlYXJjaF8nK2ksICAgICBjb2x1bW5TZWFyY2guc1NlYXJjaCApO1xuXHRcdFx0XHRwYXJhbSggJ2JSZWdleF8nK2ksICAgICAgY29sdW1uU2VhcmNoLmJSZWdleCApO1xuXHRcdFx0XHRwYXJhbSggJ2JTZWFyY2hhYmxlXycraSwgY29sdW1uLmJTZWFyY2hhYmxlICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0aWYgKCBmZWF0dXJlcy5iU29ydCApIHtcblx0XHRcdFx0cGFyYW0oICdiU29ydGFibGVfJytpLCBjb2x1bW4uYlNvcnRhYmxlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHRpZiAoIGZlYXR1cmVzLmJGaWx0ZXIgKSB7XG5cdFx0XHRwYXJhbSggJ3NTZWFyY2gnLCBwcmVTZWFyY2guc1NlYXJjaCApO1xuXHRcdFx0cGFyYW0oICdiUmVnZXgnLCBwcmVTZWFyY2guYlJlZ2V4ICk7XG5cdFx0fVxuXHRcblx0XHRpZiAoIGZlYXR1cmVzLmJTb3J0ICkge1xuXHRcdFx0JC5lYWNoKCBzb3J0LCBmdW5jdGlvbiAoIGksIHZhbCApIHtcblx0XHRcdFx0ZC5vcmRlci5wdXNoKCB7IGNvbHVtbjogdmFsLmNvbCwgZGlyOiB2YWwuZGlyIH0gKTtcblx0XG5cdFx0XHRcdHBhcmFtKCAnaVNvcnRDb2xfJytpLCB2YWwuY29sICk7XG5cdFx0XHRcdHBhcmFtKCAnc1NvcnREaXJfJytpLCB2YWwuZGlyICk7XG5cdFx0XHR9ICk7XG5cdFxuXHRcdFx0cGFyYW0oICdpU29ydGluZ0NvbHMnLCBzb3J0Lmxlbmd0aCApO1xuXHRcdH1cblx0XG5cdFx0Ly8gSWYgdGhlIGxlZ2FjeS5hamF4IHBhcmFtZXRlciBpcyBudWxsLCB0aGVuIHdlIGF1dG9tYXRpY2FsbHkgZGVjaWRlIHdoaWNoXG5cdFx0Ly8gZm9ybSB0byB1c2UsIGJhc2VkIG9uIHNBamF4U291cmNlXG5cdFx0dmFyIGxlZ2FjeSA9IERhdGFUYWJsZS5leHQubGVnYWN5LmFqYXg7XG5cdFx0aWYgKCBsZWdhY3kgPT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gc2V0dGluZ3Muc0FqYXhTb3VyY2UgPyBkYXRhIDogZDtcblx0XHR9XG5cdFxuXHRcdC8vIE90aGVyd2lzZSwgaWYgbGVnYWN5IGhhcyBiZWVuIHNwZWNpZmllZCB0aGVuIHdlIHVzZSB0aGF0IHRvIGRlY2lkZSBvbiB0aGVcblx0XHQvLyBmb3JtXG5cdFx0cmV0dXJuIGxlZ2FjeSA/IGRhdGEgOiBkO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIERhdGEgdGhlIGRhdGEgZnJvbSB0aGUgc2VydmVyIChudWtpbmcgdGhlIG9sZCkgYW5kIHJlZHJhdyB0aGUgdGFibGVcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBqc29uIGpzb24gZGF0YSByZXR1cm4gZnJvbSB0aGUgc2VydmVyLlxuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IGpzb24uc0VjaG8gVHJhY2tpbmcgZmxhZyBmb3IgRGF0YVRhYmxlcyB0byBtYXRjaCByZXF1ZXN0c1xuXHQgKiAgQHBhcmFtIHtpbnR9IGpzb24uaVRvdGFsUmVjb3JkcyBOdW1iZXIgb2YgcmVjb3JkcyBpbiB0aGUgZGF0YSBzZXQsIG5vdCBhY2NvdW50aW5nIGZvciBmaWx0ZXJpbmdcblx0ICogIEBwYXJhbSB7aW50fSBqc29uLmlUb3RhbERpc3BsYXlSZWNvcmRzIE51bWJlciBvZiByZWNvcmRzIGluIHRoZSBkYXRhIHNldCwgYWNjb3VudGluZyBmb3IgZmlsdGVyaW5nXG5cdCAqICBAcGFyYW0ge2FycmF5fSBqc29uLmFhRGF0YSBUaGUgZGF0YSB0byBkaXNwbGF5IG9uIHRoaXMgcGFnZVxuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IFtqc29uLnNDb2x1bW5zXSBDb2x1bW4gb3JkZXJpbmcgKHNOYW1lLCBjb21tYSBzZXBhcmF0ZWQpXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkFqYXhVcGRhdGVEcmF3ICggc2V0dGluZ3MsIGpzb24gKVxuXHR7XG5cdFx0Ly8gdjEuMTAgdXNlcyBjYW1lbENhc2UgdmFyaWFibGVzLCB3aGlsZSAxLjkgdXNlcyBIdW5nYXJpYW4gbm90YXRpb24uXG5cdFx0Ly8gU3VwcG9ydCBib3RoXG5cdFx0dmFyIGNvbXBhdCA9IGZ1bmN0aW9uICggb2xkLCBtb2Rlcm4gKSB7XG5cdFx0XHRyZXR1cm4ganNvbltvbGRdICE9PSB1bmRlZmluZWQgPyBqc29uW29sZF0gOiBqc29uW21vZGVybl07XG5cdFx0fTtcblx0XG5cdFx0dmFyIGRhdGEgPSBfZm5BamF4RGF0YVNyYyggc2V0dGluZ3MsIGpzb24gKTtcblx0XHR2YXIgZHJhdyAgICAgICAgICAgID0gY29tcGF0KCAnc0VjaG8nLCAgICAgICAgICAgICAgICAnZHJhdycgKTtcblx0XHR2YXIgcmVjb3Jkc1RvdGFsICAgID0gY29tcGF0KCAnaVRvdGFsUmVjb3JkcycsICAgICAgICAncmVjb3Jkc1RvdGFsJyApO1xuXHRcdHZhciByZWNvcmRzRmlsdGVyZWQgPSBjb21wYXQoICdpVG90YWxEaXNwbGF5UmVjb3JkcycsICdyZWNvcmRzRmlsdGVyZWQnICk7XG5cdFxuXHRcdGlmICggZHJhdyApIHtcblx0XHRcdC8vIFByb3RlY3QgYWdhaW5zdCBvdXQgb2Ygc2VxdWVuY2UgcmV0dXJuc1xuXHRcdFx0aWYgKCBkcmF3KjEgPCBzZXR0aW5ncy5pRHJhdyApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0c2V0dGluZ3MuaURyYXcgPSBkcmF3ICogMTtcblx0XHR9XG5cdFxuXHRcdF9mbkNsZWFyVGFibGUoIHNldHRpbmdzICk7XG5cdFx0c2V0dGluZ3MuX2lSZWNvcmRzVG90YWwgICA9IHBhcnNlSW50KHJlY29yZHNUb3RhbCwgMTApO1xuXHRcdHNldHRpbmdzLl9pUmVjb3Jkc0Rpc3BsYXkgPSBwYXJzZUludChyZWNvcmRzRmlsdGVyZWQsIDEwKTtcblx0XG5cdFx0Zm9yICggdmFyIGk9MCwgaWVuPWRhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRfZm5BZGREYXRhKCBzZXR0aW5ncywgZGF0YVtpXSApO1xuXHRcdH1cblx0XHRzZXR0aW5ncy5haURpc3BsYXkgPSBzZXR0aW5ncy5haURpc3BsYXlNYXN0ZXIuc2xpY2UoKTtcblx0XG5cdFx0c2V0dGluZ3MuYkFqYXhEYXRhR2V0ID0gZmFsc2U7XG5cdFx0X2ZuRHJhdyggc2V0dGluZ3MgKTtcblx0XG5cdFx0aWYgKCAhIHNldHRpbmdzLl9iSW5pdENvbXBsZXRlICkge1xuXHRcdFx0X2ZuSW5pdENvbXBsZXRlKCBzZXR0aW5ncywganNvbiApO1xuXHRcdH1cblx0XG5cdFx0c2V0dGluZ3MuYkFqYXhEYXRhR2V0ID0gdHJ1ZTtcblx0XHRfZm5Qcm9jZXNzaW5nRGlzcGxheSggc2V0dGluZ3MsIGZhbHNlICk7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogR2V0IHRoZSBkYXRhIGZyb20gdGhlIEpTT04gZGF0YSBzb3VyY2UgdG8gdXNlIGZvciBkcmF3aW5nIGEgdGFibGUuIFVzaW5nXG5cdCAqIGBfZm5HZXRPYmplY3REYXRhRm5gIGFsbG93cyB0aGUgZGF0YSB0byBiZSBzb3VyY2VkIGZyb20gYSBwcm9wZXJ0eSBvZiB0aGVcblx0ICogc291cmNlIG9iamVjdCwgb3IgZnJvbSBhIHByb2Nlc3NpbmcgZnVuY3Rpb24uXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0gIHtvYmplY3R9IGpzb24gRGF0YSBzb3VyY2Ugb2JqZWN0IC8gYXJyYXkgZnJvbSB0aGUgc2VydmVyXG5cdCAqICBAcmV0dXJuIHthcnJheX0gQXJyYXkgb2YgZGF0YSB0byB1c2Vcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkFqYXhEYXRhU3JjICggb1NldHRpbmdzLCBqc29uIClcblx0e1xuXHRcdHZhciBkYXRhU3JjID0gJC5pc1BsYWluT2JqZWN0KCBvU2V0dGluZ3MuYWpheCApICYmIG9TZXR0aW5ncy5hamF4LmRhdGFTcmMgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRvU2V0dGluZ3MuYWpheC5kYXRhU3JjIDpcblx0XHRcdG9TZXR0aW5ncy5zQWpheERhdGFQcm9wOyAvLyBDb21wYXRpYmlsaXR5IHdpdGggMS45LS5cblx0XG5cdFx0Ly8gQ29tcGF0aWJpbGl0eSB3aXRoIDEuOS0uIEluIG9yZGVyIHRvIHJlYWQgZnJvbSBhYURhdGEsIGNoZWNrIGlmIHRoZVxuXHRcdC8vIGRlZmF1bHQgaGFzIGJlZW4gY2hhbmdlZCwgaWYgbm90LCBjaGVjayBmb3IgYWFEYXRhXG5cdFx0aWYgKCBkYXRhU3JjID09PSAnZGF0YScgKSB7XG5cdFx0XHRyZXR1cm4ganNvbi5hYURhdGEgfHwganNvbltkYXRhU3JjXTtcblx0XHR9XG5cdFxuXHRcdHJldHVybiBkYXRhU3JjICE9PSBcIlwiID9cblx0XHRcdF9mbkdldE9iamVjdERhdGFGbiggZGF0YVNyYyApKCBqc29uICkgOlxuXHRcdFx0anNvbjtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEdlbmVyYXRlIHRoZSBub2RlIHJlcXVpcmVkIGZvciBmaWx0ZXJpbmcgdGV4dFxuXHQgKiAgQHJldHVybnMge25vZGV9IEZpbHRlciBjb250cm9sIGVsZW1lbnRcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuRmVhdHVyZUh0bWxGaWx0ZXIgKCBzZXR0aW5ncyApXG5cdHtcblx0XHR2YXIgY2xhc3NlcyA9IHNldHRpbmdzLm9DbGFzc2VzO1xuXHRcdHZhciB0YWJsZUlkID0gc2V0dGluZ3Muc1RhYmxlSWQ7XG5cdFx0dmFyIGxhbmd1YWdlID0gc2V0dGluZ3Mub0xhbmd1YWdlO1xuXHRcdHZhciBwcmV2aW91c1NlYXJjaCA9IHNldHRpbmdzLm9QcmV2aW91c1NlYXJjaDtcblx0XHR2YXIgZmVhdHVyZXMgPSBzZXR0aW5ncy5hYW5GZWF0dXJlcztcblx0XHR2YXIgaW5wdXQgPSAnPGlucHV0IHR5cGU9XCJzZWFyY2hcIiBjbGFzcz1cIicrY2xhc3Nlcy5zRmlsdGVySW5wdXQrJ1wiLz4nO1xuXHRcblx0XHR2YXIgc3RyID0gbGFuZ3VhZ2Uuc1NlYXJjaDtcblx0XHRzdHIgPSBzdHIubWF0Y2goL19JTlBVVF8vKSA/XG5cdFx0XHRzdHIucmVwbGFjZSgnX0lOUFVUXycsIGlucHV0KSA6XG5cdFx0XHRzdHIraW5wdXQ7XG5cdFxuXHRcdHZhciBmaWx0ZXIgPSAkKCc8ZGl2Lz4nLCB7XG5cdFx0XHRcdCdpZCc6ICEgZmVhdHVyZXMuZiA/IHRhYmxlSWQrJ19maWx0ZXInIDogbnVsbCxcblx0XHRcdFx0J2NsYXNzJzogY2xhc3Nlcy5zRmlsdGVyXG5cdFx0XHR9IClcblx0XHRcdC5hcHBlbmQoICQoJzxsYWJlbC8+JyApLmFwcGVuZCggc3RyICkgKTtcblx0XG5cdFx0dmFyIHNlYXJjaEZuID0gZnVuY3Rpb24oKSB7XG5cdFx0XHQvKiBVcGRhdGUgYWxsIG90aGVyIGZpbHRlciBpbnB1dCBlbGVtZW50cyBmb3IgdGhlIG5ldyBkaXNwbGF5ICovXG5cdFx0XHR2YXIgbiA9IGZlYXR1cmVzLmY7XG5cdFx0XHR2YXIgdmFsID0gIXRoaXMudmFsdWUgPyBcIlwiIDogdGhpcy52YWx1ZTsgLy8gbWVudGFsIElFOCBmaXggOi0oXG5cdFxuXHRcdFx0LyogTm93IGRvIHRoZSBmaWx0ZXIgKi9cblx0XHRcdGlmICggdmFsICE9IHByZXZpb3VzU2VhcmNoLnNTZWFyY2ggKSB7XG5cdFx0XHRcdF9mbkZpbHRlckNvbXBsZXRlKCBzZXR0aW5ncywge1xuXHRcdFx0XHRcdFwic1NlYXJjaFwiOiB2YWwsXG5cdFx0XHRcdFx0XCJiUmVnZXhcIjogcHJldmlvdXNTZWFyY2guYlJlZ2V4LFxuXHRcdFx0XHRcdFwiYlNtYXJ0XCI6IHByZXZpb3VzU2VhcmNoLmJTbWFydCAsXG5cdFx0XHRcdFx0XCJiQ2FzZUluc2Vuc2l0aXZlXCI6IHByZXZpb3VzU2VhcmNoLmJDYXNlSW5zZW5zaXRpdmVcblx0XHRcdFx0fSApO1xuXHRcblx0XHRcdFx0Ly8gTmVlZCB0byByZWRyYXcsIHdpdGhvdXQgcmVzb3J0aW5nXG5cdFx0XHRcdHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0ID0gMDtcblx0XHRcdFx0X2ZuRHJhdyggc2V0dGluZ3MgKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcblx0XHR2YXIgc2VhcmNoRGVsYXkgPSBzZXR0aW5ncy5zZWFyY2hEZWxheSAhPT0gbnVsbCA/XG5cdFx0XHRzZXR0aW5ncy5zZWFyY2hEZWxheSA6XG5cdFx0XHRfZm5EYXRhU291cmNlKCBzZXR0aW5ncyApID09PSAnc3NwJyA/XG5cdFx0XHRcdDQwMCA6XG5cdFx0XHRcdDA7XG5cdFxuXHRcdHZhciBqcUZpbHRlciA9ICQoJ2lucHV0JywgZmlsdGVyKVxuXHRcdFx0LnZhbCggcHJldmlvdXNTZWFyY2guc1NlYXJjaCApXG5cdFx0XHQuYXR0ciggJ3BsYWNlaG9sZGVyJywgbGFuZ3VhZ2Uuc1NlYXJjaFBsYWNlaG9sZGVyIClcblx0XHRcdC5iaW5kKFxuXHRcdFx0XHQna2V5dXAuRFQgc2VhcmNoLkRUIGlucHV0LkRUIHBhc3RlLkRUIGN1dC5EVCcsXG5cdFx0XHRcdHNlYXJjaERlbGF5ID9cblx0XHRcdFx0XHRfZm5UaHJvdHRsZSggc2VhcmNoRm4sIHNlYXJjaERlbGF5ICkgOlxuXHRcdFx0XHRcdHNlYXJjaEZuXG5cdFx0XHQpXG5cdFx0XHQuYmluZCggJ2tleXByZXNzLkRUJywgZnVuY3Rpb24oZSkge1xuXHRcdFx0XHQvKiBQcmV2ZW50IGZvcm0gc3VibWlzc2lvbiAqL1xuXHRcdFx0XHRpZiAoIGUua2V5Q29kZSA9PSAxMyApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0gKVxuXHRcdFx0LmF0dHIoJ2FyaWEtY29udHJvbHMnLCB0YWJsZUlkKTtcblx0XG5cdFx0Ly8gVXBkYXRlIHRoZSBpbnB1dCBlbGVtZW50cyB3aGVuZXZlciB0aGUgdGFibGUgaXMgZmlsdGVyZWRcblx0XHQkKHNldHRpbmdzLm5UYWJsZSkub24oICdzZWFyY2guZHQuRFQnLCBmdW5jdGlvbiAoIGV2LCBzICkge1xuXHRcdFx0aWYgKCBzZXR0aW5ncyA9PT0gcyApIHtcblx0XHRcdFx0Ly8gSUU5IHRocm93cyBhbiAndW5rbm93biBlcnJvcicgaWYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpcyB1c2VkXG5cdFx0XHRcdC8vIGluc2lkZSBhbiBpZnJhbWUgb3IgZnJhbWUuLi5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRpZiAoIGpxRmlsdGVyWzBdICE9PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICkge1xuXHRcdFx0XHRcdFx0anFGaWx0ZXIudmFsKCBwcmV2aW91c1NlYXJjaC5zU2VhcmNoICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGNhdGNoICggZSApIHt9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcblx0XHRyZXR1cm4gZmlsdGVyWzBdO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEZpbHRlciB0aGUgdGFibGUgdXNpbmcgYm90aCB0aGUgZ2xvYmFsIGZpbHRlciBhbmQgY29sdW1uIGJhc2VkIGZpbHRlcmluZ1xuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZWFyY2ggc2VhcmNoIGluZm9ybWF0aW9uXG5cdCAqICBAcGFyYW0ge2ludH0gW2lGb3JjZV0gZm9yY2UgYSByZXNlYXJjaCBvZiB0aGUgbWFzdGVyIGFycmF5ICgxKSBvciBub3QgKHVuZGVmaW5lZCBvciAwKVxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5GaWx0ZXJDb21wbGV0ZSAoIG9TZXR0aW5ncywgb0lucHV0LCBpRm9yY2UgKVxuXHR7XG5cdFx0dmFyIG9QcmV2U2VhcmNoID0gb1NldHRpbmdzLm9QcmV2aW91c1NlYXJjaDtcblx0XHR2YXIgYW9QcmV2U2VhcmNoID0gb1NldHRpbmdzLmFvUHJlU2VhcmNoQ29scztcblx0XHR2YXIgZm5TYXZlRmlsdGVyID0gZnVuY3Rpb24gKCBvRmlsdGVyICkge1xuXHRcdFx0LyogU2F2ZSB0aGUgZmlsdGVyaW5nIHZhbHVlcyAqL1xuXHRcdFx0b1ByZXZTZWFyY2guc1NlYXJjaCA9IG9GaWx0ZXIuc1NlYXJjaDtcblx0XHRcdG9QcmV2U2VhcmNoLmJSZWdleCA9IG9GaWx0ZXIuYlJlZ2V4O1xuXHRcdFx0b1ByZXZTZWFyY2guYlNtYXJ0ID0gb0ZpbHRlci5iU21hcnQ7XG5cdFx0XHRvUHJldlNlYXJjaC5iQ2FzZUluc2Vuc2l0aXZlID0gb0ZpbHRlci5iQ2FzZUluc2Vuc2l0aXZlO1xuXHRcdH07XG5cdFx0dmFyIGZuUmVnZXggPSBmdW5jdGlvbiAoIG8gKSB7XG5cdFx0XHQvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIHRoZSBiRXNjYXBlUmVnZXggb3B0aW9uXG5cdFx0XHRyZXR1cm4gby5iRXNjYXBlUmVnZXggIT09IHVuZGVmaW5lZCA/ICFvLmJFc2NhcGVSZWdleCA6IG8uYlJlZ2V4O1xuXHRcdH07XG5cdFxuXHRcdC8vIFJlc29sdmUgYW55IGNvbHVtbiB0eXBlcyB0aGF0IGFyZSB1bmtub3duIGR1ZSB0byBhZGRpdGlvbiBvciBpbnZhbGlkYXRpb25cblx0XHQvLyBAdG9kbyBBcyBwZXIgc29ydCAtIGNhbiB0aGlzIGJlIG1vdmVkIGludG8gYW4gZXZlbnQgaGFuZGxlcj9cblx0XHRfZm5Db2x1bW5UeXBlcyggb1NldHRpbmdzICk7XG5cdFxuXHRcdC8qIEluIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcgYWxsIGZpbHRlcmluZyBpcyBkb25lIGJ5IHRoZSBzZXJ2ZXIsIHNvIG5vIHBvaW50IGhhbmdpbmcgYXJvdW5kIGhlcmUgKi9cblx0XHRpZiAoIF9mbkRhdGFTb3VyY2UoIG9TZXR0aW5ncyApICE9ICdzc3AnIClcblx0XHR7XG5cdFx0XHQvKiBHbG9iYWwgZmlsdGVyICovXG5cdFx0XHRfZm5GaWx0ZXIoIG9TZXR0aW5ncywgb0lucHV0LnNTZWFyY2gsIGlGb3JjZSwgZm5SZWdleChvSW5wdXQpLCBvSW5wdXQuYlNtYXJ0LCBvSW5wdXQuYkNhc2VJbnNlbnNpdGl2ZSApO1xuXHRcdFx0Zm5TYXZlRmlsdGVyKCBvSW5wdXQgKTtcblx0XG5cdFx0XHQvKiBOb3cgZG8gdGhlIGluZGl2aWR1YWwgY29sdW1uIGZpbHRlciAqL1xuXHRcdFx0Zm9yICggdmFyIGk9MCA7IGk8YW9QcmV2U2VhcmNoLmxlbmd0aCA7IGkrKyApXG5cdFx0XHR7XG5cdFx0XHRcdF9mbkZpbHRlckNvbHVtbiggb1NldHRpbmdzLCBhb1ByZXZTZWFyY2hbaV0uc1NlYXJjaCwgaSwgZm5SZWdleChhb1ByZXZTZWFyY2hbaV0pLFxuXHRcdFx0XHRcdGFvUHJldlNlYXJjaFtpXS5iU21hcnQsIGFvUHJldlNlYXJjaFtpXS5iQ2FzZUluc2Vuc2l0aXZlICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0LyogQ3VzdG9tIGZpbHRlcmluZyAqL1xuXHRcdFx0X2ZuRmlsdGVyQ3VzdG9tKCBvU2V0dGluZ3MgKTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdGZuU2F2ZUZpbHRlciggb0lucHV0ICk7XG5cdFx0fVxuXHRcblx0XHQvKiBUZWxsIHRoZSBkcmF3IGZ1bmN0aW9uIHdlIGhhdmUgYmVlbiBmaWx0ZXJpbmcgKi9cblx0XHRvU2V0dGluZ3MuYkZpbHRlcmVkID0gdHJ1ZTtcblx0XHRfZm5DYWxsYmFja0ZpcmUoIG9TZXR0aW5ncywgbnVsbCwgJ3NlYXJjaCcsIFtvU2V0dGluZ3NdICk7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogQXBwbHkgY3VzdG9tIGZpbHRlcmluZyBmdW5jdGlvbnNcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuRmlsdGVyQ3VzdG9tKCBzZXR0aW5ncyApXG5cdHtcblx0XHR2YXIgZmlsdGVycyA9IERhdGFUYWJsZS5leHQuc2VhcmNoO1xuXHRcdHZhciBkaXNwbGF5Um93cyA9IHNldHRpbmdzLmFpRGlzcGxheTtcblx0XHR2YXIgcm93LCByb3dJZHg7XG5cdFxuXHRcdGZvciAoIHZhciBpPTAsIGllbj1maWx0ZXJzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0dmFyIHJvd3MgPSBbXTtcblx0XG5cdFx0XHQvLyBMb29wIG92ZXIgZWFjaCByb3cgYW5kIHNlZSBpZiBpdCBzaG91bGQgYmUgaW5jbHVkZWRcblx0XHRcdGZvciAoIHZhciBqPTAsIGplbj1kaXNwbGF5Um93cy5sZW5ndGggOyBqPGplbiA7IGorKyApIHtcblx0XHRcdFx0cm93SWR4ID0gZGlzcGxheVJvd3NbIGogXTtcblx0XHRcdFx0cm93ID0gc2V0dGluZ3MuYW9EYXRhWyByb3dJZHggXTtcblx0XG5cdFx0XHRcdGlmICggZmlsdGVyc1tpXSggc2V0dGluZ3MsIHJvdy5fYUZpbHRlckRhdGEsIHJvd0lkeCwgcm93Ll9hRGF0YSwgaiApICkge1xuXHRcdFx0XHRcdHJvd3MucHVzaCggcm93SWR4ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHQvLyBTbyB0aGUgYXJyYXkgcmVmZXJlbmNlIGRvZXNuJ3QgYnJlYWsgc2V0IHRoZSByZXN1bHRzIGludG8gdGhlXG5cdFx0XHQvLyBleGlzdGluZyBhcnJheVxuXHRcdFx0ZGlzcGxheVJvd3MubGVuZ3RoID0gMDtcblx0XHRcdGRpc3BsYXlSb3dzLnB1c2guYXBwbHkoIGRpc3BsYXlSb3dzLCByb3dzICk7XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEZpbHRlciB0aGUgdGFibGUgb24gYSBwZXItY29sdW1uIGJhc2lzXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge3N0cmluZ30gc0lucHV0IHN0cmluZyB0byBmaWx0ZXIgb25cblx0ICogIEBwYXJhbSB7aW50fSBpQ29sdW1uIGNvbHVtbiB0byBmaWx0ZXJcblx0ICogIEBwYXJhbSB7Ym9vbH0gYlJlZ2V4IHRyZWF0IHNlYXJjaCBzdHJpbmcgYXMgYSByZWd1bGFyIGV4cHJlc3Npb24gb3Igbm90XG5cdCAqICBAcGFyYW0ge2Jvb2x9IGJTbWFydCB1c2Ugc21hcnQgZmlsdGVyaW5nIG9yIG5vdFxuXHQgKiAgQHBhcmFtIHtib29sfSBiQ2FzZUluc2Vuc2l0aXZlIERvIGNhc2UgaW5zZW5zdGl2ZSBtYXRjaGluZyBvciBub3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuRmlsdGVyQ29sdW1uICggc2V0dGluZ3MsIHNlYXJjaFN0ciwgY29sSWR4LCByZWdleCwgc21hcnQsIGNhc2VJbnNlbnNpdGl2ZSApXG5cdHtcblx0XHRpZiAoIHNlYXJjaFN0ciA9PT0gJycgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcblx0XHR2YXIgZGF0YTtcblx0XHR2YXIgZGlzcGxheSA9IHNldHRpbmdzLmFpRGlzcGxheTtcblx0XHR2YXIgcnBTZWFyY2ggPSBfZm5GaWx0ZXJDcmVhdGVTZWFyY2goIHNlYXJjaFN0ciwgcmVnZXgsIHNtYXJ0LCBjYXNlSW5zZW5zaXRpdmUgKTtcblx0XG5cdFx0Zm9yICggdmFyIGk9ZGlzcGxheS5sZW5ndGgtMSA7IGk+PTAgOyBpLS0gKSB7XG5cdFx0XHRkYXRhID0gc2V0dGluZ3MuYW9EYXRhWyBkaXNwbGF5W2ldIF0uX2FGaWx0ZXJEYXRhWyBjb2xJZHggXTtcblx0XG5cdFx0XHRpZiAoICEgcnBTZWFyY2gudGVzdCggZGF0YSApICkge1xuXHRcdFx0XHRkaXNwbGF5LnNwbGljZSggaSwgMSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBGaWx0ZXIgdGhlIGRhdGEgdGFibGUgYmFzZWQgb24gdXNlciBpbnB1dCBhbmQgZHJhdyB0aGUgdGFibGVcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IGlucHV0IHN0cmluZyB0byBmaWx0ZXIgb25cblx0ICogIEBwYXJhbSB7aW50fSBmb3JjZSBvcHRpb25hbCAtIGZvcmNlIGEgcmVzZWFyY2ggb2YgdGhlIG1hc3RlciBhcnJheSAoMSkgb3Igbm90ICh1bmRlZmluZWQgb3IgMClcblx0ICogIEBwYXJhbSB7Ym9vbH0gcmVnZXggdHJlYXQgYXMgYSByZWd1bGFyIGV4cHJlc3Npb24gb3Igbm90XG5cdCAqICBAcGFyYW0ge2Jvb2x9IHNtYXJ0IHBlcmZvcm0gc21hcnQgZmlsdGVyaW5nIG9yIG5vdFxuXHQgKiAgQHBhcmFtIHtib29sfSBjYXNlSW5zZW5zaXRpdmUgRG8gY2FzZSBpbnNlbnN0aXZlIG1hdGNoaW5nIG9yIG5vdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5GaWx0ZXIoIHNldHRpbmdzLCBpbnB1dCwgZm9yY2UsIHJlZ2V4LCBzbWFydCwgY2FzZUluc2Vuc2l0aXZlIClcblx0e1xuXHRcdHZhciBycFNlYXJjaCA9IF9mbkZpbHRlckNyZWF0ZVNlYXJjaCggaW5wdXQsIHJlZ2V4LCBzbWFydCwgY2FzZUluc2Vuc2l0aXZlICk7XG5cdFx0dmFyIHByZXZTZWFyY2ggPSBzZXR0aW5ncy5vUHJldmlvdXNTZWFyY2guc1NlYXJjaDtcblx0XHR2YXIgZGlzcGxheU1hc3RlciA9IHNldHRpbmdzLmFpRGlzcGxheU1hc3Rlcjtcblx0XHR2YXIgZGlzcGxheSwgaW52YWxpZGF0ZWQsIGk7XG5cdFxuXHRcdC8vIE5lZWQgdG8gdGFrZSBhY2NvdW50IG9mIGN1c3RvbSBmaWx0ZXJpbmcgZnVuY3Rpb25zIC0gYWx3YXlzIGZpbHRlclxuXHRcdGlmICggRGF0YVRhYmxlLmV4dC5zZWFyY2gubGVuZ3RoICE9PSAwICkge1xuXHRcdFx0Zm9yY2UgPSB0cnVlO1xuXHRcdH1cblx0XG5cdFx0Ly8gQ2hlY2sgaWYgYW55IG9mIHRoZSByb3dzIHdlcmUgaW52YWxpZGF0ZWRcblx0XHRpbnZhbGlkYXRlZCA9IF9mbkZpbHRlckRhdGEoIHNldHRpbmdzICk7XG5cdFxuXHRcdC8vIElmIHRoZSBpbnB1dCBpcyBibGFuayAtIHdlIGp1c3Qgd2FudCB0aGUgZnVsbCBkYXRhIHNldFxuXHRcdGlmICggaW5wdXQubGVuZ3RoIDw9IDAgKSB7XG5cdFx0XHRzZXR0aW5ncy5haURpc3BsYXkgPSBkaXNwbGF5TWFzdGVyLnNsaWNlKCk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gTmV3IHNlYXJjaCAtIHN0YXJ0IGZyb20gdGhlIG1hc3RlciBhcnJheVxuXHRcdFx0aWYgKCBpbnZhbGlkYXRlZCB8fFxuXHRcdFx0XHQgZm9yY2UgfHxcblx0XHRcdFx0IHByZXZTZWFyY2gubGVuZ3RoID4gaW5wdXQubGVuZ3RoIHx8XG5cdFx0XHRcdCBpbnB1dC5pbmRleE9mKHByZXZTZWFyY2gpICE9PSAwIHx8XG5cdFx0XHRcdCBzZXR0aW5ncy5iU29ydGVkIC8vIE9uIHJlc29ydCwgdGhlIGRpc3BsYXkgbWFzdGVyIG5lZWRzIHRvIGJlXG5cdFx0XHRcdCAgICAgICAgICAgICAgICAgIC8vIHJlLWZpbHRlcmVkIHNpbmNlIGluZGV4ZXMgd2lsbCBoYXZlIGNoYW5nZWRcblx0XHRcdCkge1xuXHRcdFx0XHRzZXR0aW5ncy5haURpc3BsYXkgPSBkaXNwbGF5TWFzdGVyLnNsaWNlKCk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gU2VhcmNoIHRoZSBkaXNwbGF5IGFycmF5XG5cdFx0XHRkaXNwbGF5ID0gc2V0dGluZ3MuYWlEaXNwbGF5O1xuXHRcblx0XHRcdGZvciAoIGk9ZGlzcGxheS5sZW5ndGgtMSA7IGk+PTAgOyBpLS0gKSB7XG5cdFx0XHRcdGlmICggISBycFNlYXJjaC50ZXN0KCBzZXR0aW5ncy5hb0RhdGFbIGRpc3BsYXlbaV0gXS5fc0ZpbHRlclJvdyApICkge1xuXHRcdFx0XHRcdGRpc3BsYXkuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogQnVpbGQgYSByZWd1bGFyIGV4cHJlc3Npb24gb2JqZWN0IHN1aXRhYmxlIGZvciBzZWFyY2hpbmcgYSB0YWJsZVxuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IHNTZWFyY2ggc3RyaW5nIHRvIHNlYXJjaCBmb3Jcblx0ICogIEBwYXJhbSB7Ym9vbH0gYlJlZ2V4IHRyZWF0IGFzIGEgcmVndWxhciBleHByZXNzaW9uIG9yIG5vdFxuXHQgKiAgQHBhcmFtIHtib29sfSBiU21hcnQgcGVyZm9ybSBzbWFydCBmaWx0ZXJpbmcgb3Igbm90XG5cdCAqICBAcGFyYW0ge2Jvb2x9IGJDYXNlSW5zZW5zaXRpdmUgRG8gY2FzZSBpbnNlbnNpdGl2ZSBtYXRjaGluZyBvciBub3Rcblx0ICogIEByZXR1cm5zIHtSZWdFeHB9IGNvbnN0cnVjdGVkIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5GaWx0ZXJDcmVhdGVTZWFyY2goIHNlYXJjaCwgcmVnZXgsIHNtYXJ0LCBjYXNlSW5zZW5zaXRpdmUgKVxuXHR7XG5cdFx0c2VhcmNoID0gcmVnZXggP1xuXHRcdFx0c2VhcmNoIDpcblx0XHRcdF9mbkVzY2FwZVJlZ2V4KCBzZWFyY2ggKTtcblx0XHRcblx0XHRpZiAoIHNtYXJ0ICkge1xuXHRcdFx0LyogRm9yIHNtYXJ0IGZpbHRlcmluZyB3ZSB3YW50IHRvIGFsbG93IHRoZSBzZWFyY2ggdG8gd29yayByZWdhcmRsZXNzIG9mXG5cdFx0XHQgKiB3b3JkIG9yZGVyLiBXZSBhbHNvIHdhbnQgZG91YmxlIHF1b3RlZCB0ZXh0IHRvIGJlIHByZXNlcnZlZCwgc28gd29yZFxuXHRcdFx0ICogb3JkZXIgaXMgaW1wb3J0YW50IC0gYSBsYSBnb29nbGUuIFNvIHRoaXMgaXMgd2hhdCB3ZSB3YW50IHRvXG5cdFx0XHQgKiBnZW5lcmF0ZTpcblx0XHRcdCAqIFxuXHRcdFx0ICogXig/PS4qP1xcYm9uZVxcYikoPz0uKj9cXGJ0d28gdGhyZWVcXGIpKD89Lio/XFxiZm91clxcYikuKiRcblx0XHRcdCAqL1xuXHRcdFx0dmFyIGEgPSAkLm1hcCggc2VhcmNoLm1hdGNoKCAvXCJbXlwiXStcInxbXiBdKy9nICkgfHwgWycnXSwgZnVuY3Rpb24gKCB3b3JkICkge1xuXHRcdFx0XHRpZiAoIHdvcmQuY2hhckF0KDApID09PSAnXCInICkge1xuXHRcdFx0XHRcdHZhciBtID0gd29yZC5tYXRjaCggL15cIiguKilcIiQvICk7XG5cdFx0XHRcdFx0d29yZCA9IG0gPyBtWzFdIDogd29yZDtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0cmV0dXJuIHdvcmQucmVwbGFjZSgnXCInLCAnJyk7XG5cdFx0XHR9ICk7XG5cdFxuXHRcdFx0c2VhcmNoID0gJ14oPz0uKj8nK2Euam9pbiggJykoPz0uKj8nICkrJykuKiQnO1xuXHRcdH1cblx0XG5cdFx0cmV0dXJuIG5ldyBSZWdFeHAoIHNlYXJjaCwgY2FzZUluc2Vuc2l0aXZlID8gJ2knIDogJycgKTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBFc2NhcGUgYSBzdHJpbmcgc3VjaCB0aGF0IGl0IGNhbiBiZSB1c2VkIGluIGEgcmVndWxhciBleHByZXNzaW9uXG5cdCAqICBAcGFyYW0ge3N0cmluZ30gc1ZhbCBzdHJpbmcgdG8gZXNjYXBlXG5cdCAqICBAcmV0dXJucyB7c3RyaW5nfSBlc2NhcGVkIHN0cmluZ1xuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5Fc2NhcGVSZWdleCAoIHNWYWwgKVxuXHR7XG5cdFx0cmV0dXJuIHNWYWwucmVwbGFjZSggX3JlX2VzY2FwZV9yZWdleCwgJ1xcXFwkMScgKTtcblx0fVxuXHRcblx0XG5cdFxuXHR2YXIgX19maWx0ZXJfZGl2ID0gJCgnPGRpdj4nKVswXTtcblx0dmFyIF9fZmlsdGVyX2Rpdl90ZXh0Q29udGVudCA9IF9fZmlsdGVyX2Rpdi50ZXh0Q29udGVudCAhPT0gdW5kZWZpbmVkO1xuXHRcblx0Ly8gVXBkYXRlIHRoZSBmaWx0ZXJpbmcgZGF0YSBmb3IgZWFjaCByb3cgaWYgbmVlZGVkIChieSBpbnZhbGlkYXRpb24gb3IgZmlyc3QgcnVuKVxuXHRmdW5jdGlvbiBfZm5GaWx0ZXJEYXRhICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XG5cdFx0dmFyIGNvbHVtbjtcblx0XHR2YXIgaSwgaiwgaWVuLCBqZW4sIGZpbHRlckRhdGEsIGNlbGxEYXRhLCByb3c7XG5cdFx0dmFyIGZvbWF0dGVycyA9IERhdGFUYWJsZS5leHQudHlwZS5zZWFyY2g7XG5cdFx0dmFyIHdhc0ludmFsaWRhdGVkID0gZmFsc2U7XG5cdFxuXHRcdGZvciAoIGk9MCwgaWVuPXNldHRpbmdzLmFvRGF0YS5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdHJvdyA9IHNldHRpbmdzLmFvRGF0YVtpXTtcblx0XG5cdFx0XHRpZiAoICEgcm93Ll9hRmlsdGVyRGF0YSApIHtcblx0XHRcdFx0ZmlsdGVyRGF0YSA9IFtdO1xuXHRcblx0XHRcdFx0Zm9yICggaj0wLCBqZW49Y29sdW1ucy5sZW5ndGggOyBqPGplbiA7IGorKyApIHtcblx0XHRcdFx0XHRjb2x1bW4gPSBjb2x1bW5zW2pdO1xuXHRcblx0XHRcdFx0XHRpZiAoIGNvbHVtbi5iU2VhcmNoYWJsZSApIHtcblx0XHRcdFx0XHRcdGNlbGxEYXRhID0gX2ZuR2V0Q2VsbERhdGEoIHNldHRpbmdzLCBpLCBqLCAnZmlsdGVyJyApO1xuXHRcblx0XHRcdFx0XHRcdGlmICggZm9tYXR0ZXJzWyBjb2x1bW4uc1R5cGUgXSApIHtcblx0XHRcdFx0XHRcdFx0Y2VsbERhdGEgPSBmb21hdHRlcnNbIGNvbHVtbi5zVHlwZSBdKCBjZWxsRGF0YSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRcdC8vIFNlYXJjaCBpbiBEYXRhVGFibGVzIDEuMTAgaXMgc3RyaW5nIGJhc2VkLiBJbiAxLjExIHRoaXNcblx0XHRcdFx0XHRcdC8vIHNob3VsZCBiZSBhbHRlcmVkIHRvIGFsc28gYWxsb3cgc3RyaWN0IHR5cGUgY2hlY2tpbmcuXG5cdFx0XHRcdFx0XHRpZiAoIGNlbGxEYXRhID09PSBudWxsICkge1xuXHRcdFx0XHRcdFx0XHRjZWxsRGF0YSA9ICcnO1xuXHRcdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRcdGlmICggdHlwZW9mIGNlbGxEYXRhICE9PSAnc3RyaW5nJyAmJiBjZWxsRGF0YS50b1N0cmluZyApIHtcblx0XHRcdFx0XHRcdFx0Y2VsbERhdGEgPSBjZWxsRGF0YS50b1N0cmluZygpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGNlbGxEYXRhID0gJyc7XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHQvLyBJZiBpdCBsb29rcyBsaWtlIHRoZXJlIGlzIGFuIEhUTUwgZW50aXR5IGluIHRoZSBzdHJpbmcsXG5cdFx0XHRcdFx0Ly8gYXR0ZW1wdCB0byBkZWNvZGUgaXQgc28gc29ydGluZyB3b3JrcyBhcyBleHBlY3RlZC4gTm90ZSB0aGF0XG5cdFx0XHRcdFx0Ly8gd2UgY291bGQgdXNlIGEgc2luZ2xlIGxpbmUgb2YgalF1ZXJ5IHRvIGRvIHRoaXMsIGJ1dCB0aGUgRE9NXG5cdFx0XHRcdFx0Ly8gbWV0aG9kIHVzZWQgaGVyZSBpcyBtdWNoIGZhc3RlciBodHRwOi8vanNwZXJmLmNvbS9odG1sLWRlY29kZVxuXHRcdFx0XHRcdGlmICggY2VsbERhdGEuaW5kZXhPZiAmJiBjZWxsRGF0YS5pbmRleE9mKCcmJykgIT09IC0xICkge1xuXHRcdFx0XHRcdFx0X19maWx0ZXJfZGl2LmlubmVySFRNTCA9IGNlbGxEYXRhO1xuXHRcdFx0XHRcdFx0Y2VsbERhdGEgPSBfX2ZpbHRlcl9kaXZfdGV4dENvbnRlbnQgP1xuXHRcdFx0XHRcdFx0XHRfX2ZpbHRlcl9kaXYudGV4dENvbnRlbnQgOlxuXHRcdFx0XHRcdFx0XHRfX2ZpbHRlcl9kaXYuaW5uZXJUZXh0O1xuXHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0aWYgKCBjZWxsRGF0YS5yZXBsYWNlICkge1xuXHRcdFx0XHRcdFx0Y2VsbERhdGEgPSBjZWxsRGF0YS5yZXBsYWNlKC9bXFxyXFxuXS9nLCAnJyk7XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRmaWx0ZXJEYXRhLnB1c2goIGNlbGxEYXRhICk7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdHJvdy5fYUZpbHRlckRhdGEgPSBmaWx0ZXJEYXRhO1xuXHRcdFx0XHRyb3cuX3NGaWx0ZXJSb3cgPSBmaWx0ZXJEYXRhLmpvaW4oJyAgJyk7XG5cdFx0XHRcdHdhc0ludmFsaWRhdGVkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdHJldHVybiB3YXNJbnZhbGlkYXRlZDtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBDb252ZXJ0IGZyb20gdGhlIGludGVybmFsIEh1bmdhcmlhbiBub3RhdGlvbiB0byBjYW1lbENhc2UgZm9yIGV4dGVybmFsXG5cdCAqIGludGVyYWN0aW9uXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb2JqIE9iamVjdCB0byBjb252ZXJ0XG5cdCAqICBAcmV0dXJucyB7b2JqZWN0fSBJbnZlcnRlZCBvYmplY3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuU2VhcmNoVG9DYW1lbCAoIG9iaiApXG5cdHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VhcmNoOiAgICAgICAgICBvYmouc1NlYXJjaCxcblx0XHRcdHNtYXJ0OiAgICAgICAgICAgb2JqLmJTbWFydCxcblx0XHRcdHJlZ2V4OiAgICAgICAgICAgb2JqLmJSZWdleCxcblx0XHRcdGNhc2VJbnNlbnNpdGl2ZTogb2JqLmJDYXNlSW5zZW5zaXRpdmVcblx0XHR9O1xuXHR9XG5cdFxuXHRcblx0XG5cdC8qKlxuXHQgKiBDb252ZXJ0IGZyb20gY2FtZWxDYXNlIG5vdGF0aW9uIHRvIHRoZSBpbnRlcm5hbCBIdW5nYXJpYW4uIFdlIGNvdWxkIHVzZSB0aGVcblx0ICogSHVuZ2FyaWFuIGNvbnZlcnQgZnVuY3Rpb24gaGVyZSwgYnV0IHRoaXMgaXMgY2xlYW5lclxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9iaiBPYmplY3QgdG8gY29udmVydFxuXHQgKiAgQHJldHVybnMge29iamVjdH0gSW52ZXJ0ZWQgb2JqZWN0XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mblNlYXJjaFRvSHVuZyAoIG9iaiApXG5cdHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c1NlYXJjaDogICAgICAgICAgb2JqLnNlYXJjaCxcblx0XHRcdGJTbWFydDogICAgICAgICAgIG9iai5zbWFydCxcblx0XHRcdGJSZWdleDogICAgICAgICAgIG9iai5yZWdleCxcblx0XHRcdGJDYXNlSW5zZW5zaXRpdmU6IG9iai5jYXNlSW5zZW5zaXRpdmVcblx0XHR9O1xuXHR9XG5cdFxuXHQvKipcblx0ICogR2VuZXJhdGUgdGhlIG5vZGUgcmVxdWlyZWQgZm9yIHRoZSBpbmZvIGRpc3BsYXlcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEByZXR1cm5zIHtub2RlfSBJbmZvcm1hdGlvbiBlbGVtZW50XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkZlYXR1cmVIdG1sSW5mbyAoIHNldHRpbmdzIClcblx0e1xuXHRcdHZhclxuXHRcdFx0dGlkID0gc2V0dGluZ3Muc1RhYmxlSWQsXG5cdFx0XHRub2RlcyA9IHNldHRpbmdzLmFhbkZlYXR1cmVzLmksXG5cdFx0XHRuID0gJCgnPGRpdi8+Jywge1xuXHRcdFx0XHQnY2xhc3MnOiBzZXR0aW5ncy5vQ2xhc3Nlcy5zSW5mbyxcblx0XHRcdFx0J2lkJzogISBub2RlcyA/IHRpZCsnX2luZm8nIDogbnVsbFxuXHRcdFx0fSApO1xuXHRcblx0XHRpZiAoICEgbm9kZXMgKSB7XG5cdFx0XHQvLyBVcGRhdGUgZGlzcGxheSBvbiBlYWNoIGRyYXdcblx0XHRcdHNldHRpbmdzLmFvRHJhd0NhbGxiYWNrLnB1c2goIHtcblx0XHRcdFx0XCJmblwiOiBfZm5VcGRhdGVJbmZvLFxuXHRcdFx0XHRcInNOYW1lXCI6IFwiaW5mb3JtYXRpb25cIlxuXHRcdFx0fSApO1xuXHRcblx0XHRcdG5cblx0XHRcdFx0LmF0dHIoICdyb2xlJywgJ3N0YXR1cycgKVxuXHRcdFx0XHQuYXR0ciggJ2FyaWEtbGl2ZScsICdwb2xpdGUnICk7XG5cdFxuXHRcdFx0Ly8gVGFibGUgaXMgZGVzY3JpYmVkIGJ5IG91ciBpbmZvIGRpdlxuXHRcdFx0JChzZXR0aW5ncy5uVGFibGUpLmF0dHIoICdhcmlhLWRlc2NyaWJlZGJ5JywgdGlkKydfaW5mbycgKTtcblx0XHR9XG5cdFxuXHRcdHJldHVybiBuWzBdO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIFVwZGF0ZSB0aGUgaW5mb3JtYXRpb24gZWxlbWVudHMgaW4gdGhlIGRpc3BsYXlcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5VcGRhdGVJbmZvICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0LyogU2hvdyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdGFibGUgKi9cblx0XHR2YXIgbm9kZXMgPSBzZXR0aW5ncy5hYW5GZWF0dXJlcy5pO1xuXHRcdGlmICggbm9kZXMubGVuZ3RoID09PSAwICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XG5cdFx0dmFyXG5cdFx0XHRsYW5nICA9IHNldHRpbmdzLm9MYW5ndWFnZSxcblx0XHRcdHN0YXJ0ID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQrMSxcblx0XHRcdGVuZCAgID0gc2V0dGluZ3MuZm5EaXNwbGF5RW5kKCksXG5cdFx0XHRtYXggICA9IHNldHRpbmdzLmZuUmVjb3Jkc1RvdGFsKCksXG5cdFx0XHR0b3RhbCA9IHNldHRpbmdzLmZuUmVjb3Jkc0Rpc3BsYXkoKSxcblx0XHRcdG91dCAgID0gdG90YWwgP1xuXHRcdFx0XHRsYW5nLnNJbmZvIDpcblx0XHRcdFx0bGFuZy5zSW5mb0VtcHR5O1xuXHRcblx0XHRpZiAoIHRvdGFsICE9PSBtYXggKSB7XG5cdFx0XHQvKiBSZWNvcmQgc2V0IGFmdGVyIGZpbHRlcmluZyAqL1xuXHRcdFx0b3V0ICs9ICcgJyArIGxhbmcuc0luZm9GaWx0ZXJlZDtcblx0XHR9XG5cdFxuXHRcdC8vIENvbnZlcnQgdGhlIG1hY3Jvc1xuXHRcdG91dCArPSBsYW5nLnNJbmZvUG9zdEZpeDtcblx0XHRvdXQgPSBfZm5JbmZvTWFjcm9zKCBzZXR0aW5ncywgb3V0ICk7XG5cdFxuXHRcdHZhciBjYWxsYmFjayA9IGxhbmcuZm5JbmZvQ2FsbGJhY2s7XG5cdFx0aWYgKCBjYWxsYmFjayAhPT0gbnVsbCApIHtcblx0XHRcdG91dCA9IGNhbGxiYWNrLmNhbGwoIHNldHRpbmdzLm9JbnN0YW5jZSxcblx0XHRcdFx0c2V0dGluZ3MsIHN0YXJ0LCBlbmQsIG1heCwgdG90YWwsIG91dFxuXHRcdFx0KTtcblx0XHR9XG5cdFxuXHRcdCQobm9kZXMpLmh0bWwoIG91dCApO1xuXHR9XG5cdFxuXHRcblx0ZnVuY3Rpb24gX2ZuSW5mb01hY3JvcyAoIHNldHRpbmdzLCBzdHIgKVxuXHR7XG5cdFx0Ly8gV2hlbiBpbmZpbml0ZSBzY3JvbGxpbmcsIHdlIGFyZSBhbHdheXMgc3RhcnRpbmcgYXQgMS4gX2lEaXNwbGF5U3RhcnQgaXMgdXNlZCBvbmx5XG5cdFx0Ly8gaW50ZXJuYWxseVxuXHRcdHZhclxuXHRcdFx0Zm9ybWF0dGVyICA9IHNldHRpbmdzLmZuRm9ybWF0TnVtYmVyLFxuXHRcdFx0c3RhcnQgICAgICA9IHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0KzEsXG5cdFx0XHRsZW4gICAgICAgID0gc2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoLFxuXHRcdFx0dmlzICAgICAgICA9IHNldHRpbmdzLmZuUmVjb3Jkc0Rpc3BsYXkoKSxcblx0XHRcdGFsbCAgICAgICAgPSBsZW4gPT09IC0xO1xuXHRcblx0XHRyZXR1cm4gc3RyLlxuXHRcdFx0cmVwbGFjZSgvX1NUQVJUXy9nLCBmb3JtYXR0ZXIuY2FsbCggc2V0dGluZ3MsIHN0YXJ0ICkgKS5cblx0XHRcdHJlcGxhY2UoL19FTkRfL2csICAgZm9ybWF0dGVyLmNhbGwoIHNldHRpbmdzLCBzZXR0aW5ncy5mbkRpc3BsYXlFbmQoKSApICkuXG5cdFx0XHRyZXBsYWNlKC9fTUFYXy9nLCAgIGZvcm1hdHRlci5jYWxsKCBzZXR0aW5ncywgc2V0dGluZ3MuZm5SZWNvcmRzVG90YWwoKSApICkuXG5cdFx0XHRyZXBsYWNlKC9fVE9UQUxfL2csIGZvcm1hdHRlci5jYWxsKCBzZXR0aW5ncywgdmlzICkgKS5cblx0XHRcdHJlcGxhY2UoL19QQUdFXy9nLCAgZm9ybWF0dGVyLmNhbGwoIHNldHRpbmdzLCBhbGwgPyAxIDogTWF0aC5jZWlsKCBzdGFydCAvIGxlbiApICkgKS5cblx0XHRcdHJlcGxhY2UoL19QQUdFU18vZywgZm9ybWF0dGVyLmNhbGwoIHNldHRpbmdzLCBhbGwgPyAxIDogTWF0aC5jZWlsKCB2aXMgLyBsZW4gKSApICk7XG5cdH1cblx0XG5cdFxuXHRcblx0LyoqXG5cdCAqIERyYXcgdGhlIHRhYmxlIGZvciB0aGUgZmlyc3QgdGltZSwgYWRkaW5nIGFsbCByZXF1aXJlZCBmZWF0dXJlc1xuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkluaXRpYWxpc2UgKCBzZXR0aW5ncyApXG5cdHtcblx0XHR2YXIgaSwgaUxlbiwgaUFqYXhTdGFydD1zZXR0aW5ncy5pSW5pdERpc3BsYXlTdGFydDtcblx0XHR2YXIgY29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucywgY29sdW1uO1xuXHRcdHZhciBmZWF0dXJlcyA9IHNldHRpbmdzLm9GZWF0dXJlcztcblx0XG5cdFx0LyogRW5zdXJlIHRoYXQgdGhlIHRhYmxlIGRhdGEgaXMgZnVsbHkgaW5pdGlhbGlzZWQgKi9cblx0XHRpZiAoICEgc2V0dGluZ3MuYkluaXRpYWxpc2VkICkge1xuXHRcdFx0c2V0VGltZW91dCggZnVuY3Rpb24oKXsgX2ZuSW5pdGlhbGlzZSggc2V0dGluZ3MgKTsgfSwgMjAwICk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcblx0XHQvKiBTaG93IHRoZSBkaXNwbGF5IEhUTUwgb3B0aW9ucyAqL1xuXHRcdF9mbkFkZE9wdGlvbnNIdG1sKCBzZXR0aW5ncyApO1xuXHRcblx0XHQvKiBCdWlsZCBhbmQgZHJhdyB0aGUgaGVhZGVyIC8gZm9vdGVyIGZvciB0aGUgdGFibGUgKi9cblx0XHRfZm5CdWlsZEhlYWQoIHNldHRpbmdzICk7XG5cdFx0X2ZuRHJhd0hlYWQoIHNldHRpbmdzLCBzZXR0aW5ncy5hb0hlYWRlciApO1xuXHRcdF9mbkRyYXdIZWFkKCBzZXR0aW5ncywgc2V0dGluZ3MuYW9Gb290ZXIgKTtcblx0XG5cdFx0LyogT2theSB0byBzaG93IHRoYXQgc29tZXRoaW5nIGlzIGdvaW5nIG9uIG5vdyAqL1xuXHRcdF9mblByb2Nlc3NpbmdEaXNwbGF5KCBzZXR0aW5ncywgdHJ1ZSApO1xuXHRcblx0XHQvKiBDYWxjdWxhdGUgc2l6ZXMgZm9yIGNvbHVtbnMgKi9cblx0XHRpZiAoIGZlYXR1cmVzLmJBdXRvV2lkdGggKSB7XG5cdFx0XHRfZm5DYWxjdWxhdGVDb2x1bW5XaWR0aHMoIHNldHRpbmdzICk7XG5cdFx0fVxuXHRcblx0XHRmb3IgKCBpPTAsIGlMZW49Y29sdW1ucy5sZW5ndGggOyBpPGlMZW4gOyBpKysgKSB7XG5cdFx0XHRjb2x1bW4gPSBjb2x1bW5zW2ldO1xuXHRcblx0XHRcdGlmICggY29sdW1uLnNXaWR0aCApIHtcblx0XHRcdFx0Y29sdW1uLm5UaC5zdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKCBjb2x1bW4uc1dpZHRoICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHQvLyBJZiB0aGVyZSBpcyBkZWZhdWx0IHNvcnRpbmcgcmVxdWlyZWQgLSBsZXQncyBkbyBpdC4gVGhlIHNvcnQgZnVuY3Rpb25cblx0XHQvLyB3aWxsIGRvIHRoZSBkcmF3aW5nIGZvciB1cy4gT3RoZXJ3aXNlIHdlIGRyYXcgdGhlIHRhYmxlIHJlZ2FyZGxlc3Mgb2YgdGhlXG5cdFx0Ly8gQWpheCBzb3VyY2UgLSB0aGlzIGFsbG93cyB0aGUgdGFibGUgdG8gbG9vayBpbml0aWFsaXNlZCBmb3IgQWpheCBzb3VyY2luZ1xuXHRcdC8vIGRhdGEgKHNob3cgJ2xvYWRpbmcnIG1lc3NhZ2UgcG9zc2libHkpXG5cdFx0X2ZuUmVEcmF3KCBzZXR0aW5ncyApO1xuXHRcblx0XHQvLyBTZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIGluaXQgY29tcGxldGUgaXMgZG9uZSBieSBfZm5BamF4VXBkYXRlRHJhd1xuXHRcdHZhciBkYXRhU3JjID0gX2ZuRGF0YVNvdXJjZSggc2V0dGluZ3MgKTtcblx0XHRpZiAoIGRhdGFTcmMgIT0gJ3NzcCcgKSB7XG5cdFx0XHQvLyBpZiB0aGVyZSBpcyBhbiBhamF4IHNvdXJjZSBsb2FkIHRoZSBkYXRhXG5cdFx0XHRpZiAoIGRhdGFTcmMgPT0gJ2FqYXgnICkge1xuXHRcdFx0XHRfZm5CdWlsZEFqYXgoIHNldHRpbmdzLCBbXSwgZnVuY3Rpb24oanNvbikge1xuXHRcdFx0XHRcdHZhciBhRGF0YSA9IF9mbkFqYXhEYXRhU3JjKCBzZXR0aW5ncywganNvbiApO1xuXHRcblx0XHRcdFx0XHQvLyBHb3QgdGhlIGRhdGEgLSBhZGQgaXQgdG8gdGhlIHRhYmxlXG5cdFx0XHRcdFx0Zm9yICggaT0wIDsgaTxhRGF0YS5sZW5ndGggOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRfZm5BZGREYXRhKCBzZXR0aW5ncywgYURhdGFbaV0gKTtcblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdC8vIFJlc2V0IHRoZSBpbml0IGRpc3BsYXkgZm9yIGNvb2tpZSBzYXZpbmcuIFdlJ3ZlIGFscmVhZHkgZG9uZVxuXHRcdFx0XHRcdC8vIGEgZmlsdGVyLCBhbmQgdGhlcmVmb3JlIGNsZWFyZWQgaXQgYmVmb3JlLiBTbyB3ZSBuZWVkIHRvIG1ha2Vcblx0XHRcdFx0XHQvLyBpdCBhcHBlYXIgJ2ZyZXNoJ1xuXHRcdFx0XHRcdHNldHRpbmdzLmlJbml0RGlzcGxheVN0YXJ0ID0gaUFqYXhTdGFydDtcblx0XG5cdFx0XHRcdFx0X2ZuUmVEcmF3KCBzZXR0aW5ncyApO1xuXHRcblx0XHRcdFx0XHRfZm5Qcm9jZXNzaW5nRGlzcGxheSggc2V0dGluZ3MsIGZhbHNlICk7XG5cdFx0XHRcdFx0X2ZuSW5pdENvbXBsZXRlKCBzZXR0aW5ncywganNvbiApO1xuXHRcdFx0XHR9LCBzZXR0aW5ncyApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdF9mblByb2Nlc3NpbmdEaXNwbGF5KCBzZXR0aW5ncywgZmFsc2UgKTtcblx0XHRcdFx0X2ZuSW5pdENvbXBsZXRlKCBzZXR0aW5ncyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBEcmF3IHRoZSB0YWJsZSBmb3IgdGhlIGZpcnN0IHRpbWUsIGFkZGluZyBhbGwgcmVxdWlyZWQgZmVhdHVyZXNcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBbanNvbl0gSlNPTiBmcm9tIHRoZSBzZXJ2ZXIgdGhhdCBjb21wbGV0ZWQgdGhlIHRhYmxlLCBpZiB1c2luZyBBamF4IHNvdXJjZVxuXHQgKiAgICB3aXRoIGNsaWVudC1zaWRlIHByb2Nlc3NpbmcgKG9wdGlvbmFsKVxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5Jbml0Q29tcGxldGUgKCBzZXR0aW5ncywganNvbiApXG5cdHtcblx0XHRzZXR0aW5ncy5fYkluaXRDb21wbGV0ZSA9IHRydWU7XG5cdFxuXHRcdC8vIE9uIGFuIEFqYXggbG9hZCB3ZSBub3cgaGF2ZSBkYXRhIGFuZCB0aGVyZWZvcmUgd2FudCB0byBhcHBseSB0aGUgY29sdW1uXG5cdFx0Ly8gc2l6aW5nXG5cdFx0aWYgKCBqc29uICkge1xuXHRcdFx0X2ZuQWRqdXN0Q29sdW1uU2l6aW5nKCBzZXR0aW5ncyApO1xuXHRcdH1cblx0XG5cdFx0X2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgJ2FvSW5pdENvbXBsZXRlJywgJ2luaXQnLCBbc2V0dGluZ3MsIGpzb25dICk7XG5cdH1cblx0XG5cdFxuXHRmdW5jdGlvbiBfZm5MZW5ndGhDaGFuZ2UgKCBzZXR0aW5ncywgdmFsIClcblx0e1xuXHRcdHZhciBsZW4gPSBwYXJzZUludCggdmFsLCAxMCApO1xuXHRcdHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aCA9IGxlbjtcblx0XG5cdFx0X2ZuTGVuZ3RoT3ZlcmZsb3coIHNldHRpbmdzICk7XG5cdFxuXHRcdC8vIEZpcmUgbGVuZ3RoIGNoYW5nZSBldmVudFxuXHRcdF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsIG51bGwsICdsZW5ndGgnLCBbc2V0dGluZ3MsIGxlbl0gKTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSB0aGUgbm9kZSByZXF1aXJlZCBmb3IgdXNlciBkaXNwbGF5IGxlbmd0aCBjaGFuZ2luZ1xuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcmV0dXJucyB7bm9kZX0gRGlzcGxheSBsZW5ndGggZmVhdHVyZSBub2RlXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkZlYXR1cmVIdG1sTGVuZ3RoICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyXG5cdFx0XHRjbGFzc2VzICA9IHNldHRpbmdzLm9DbGFzc2VzLFxuXHRcdFx0dGFibGVJZCAgPSBzZXR0aW5ncy5zVGFibGVJZCxcblx0XHRcdG1lbnUgICAgID0gc2V0dGluZ3MuYUxlbmd0aE1lbnUsXG5cdFx0XHRkMiAgICAgICA9ICQuaXNBcnJheSggbWVudVswXSApLFxuXHRcdFx0bGVuZ3RocyAgPSBkMiA/IG1lbnVbMF0gOiBtZW51LFxuXHRcdFx0bGFuZ3VhZ2UgPSBkMiA/IG1lbnVbMV0gOiBtZW51O1xuXHRcblx0XHR2YXIgc2VsZWN0ID0gJCgnPHNlbGVjdC8+Jywge1xuXHRcdFx0J25hbWUnOiAgICAgICAgICB0YWJsZUlkKydfbGVuZ3RoJyxcblx0XHRcdCdhcmlhLWNvbnRyb2xzJzogdGFibGVJZCxcblx0XHRcdCdjbGFzcyc6ICAgICAgICAgY2xhc3Nlcy5zTGVuZ3RoU2VsZWN0XG5cdFx0fSApO1xuXHRcblx0XHRmb3IgKCB2YXIgaT0wLCBpZW49bGVuZ3Rocy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdHNlbGVjdFswXVsgaSBdID0gbmV3IE9wdGlvbiggbGFuZ3VhZ2VbaV0sIGxlbmd0aHNbaV0gKTtcblx0XHR9XG5cdFxuXHRcdHZhciBkaXYgPSAkKCc8ZGl2PjxsYWJlbC8+PC9kaXY+JykuYWRkQ2xhc3MoIGNsYXNzZXMuc0xlbmd0aCApO1xuXHRcdGlmICggISBzZXR0aW5ncy5hYW5GZWF0dXJlcy5sICkge1xuXHRcdFx0ZGl2WzBdLmlkID0gdGFibGVJZCsnX2xlbmd0aCc7XG5cdFx0fVxuXHRcblx0XHRkaXYuY2hpbGRyZW4oKS5hcHBlbmQoXG5cdFx0XHRzZXR0aW5ncy5vTGFuZ3VhZ2Uuc0xlbmd0aE1lbnUucmVwbGFjZSggJ19NRU5VXycsIHNlbGVjdFswXS5vdXRlckhUTUwgKVxuXHRcdCk7XG5cdFxuXHRcdC8vIENhbid0IHVzZSBgc2VsZWN0YCB2YXJpYWJsZSBhcyB1c2VyIG1pZ2h0IHByb3ZpZGUgdGhlaXIgb3duIGFuZCB0aGVcblx0XHQvLyByZWZlcmVuY2UgaXMgYnJva2VuIGJ5IHRoZSB1c2Ugb2Ygb3V0ZXJIVE1MXG5cdFx0JCgnc2VsZWN0JywgZGl2KVxuXHRcdFx0LnZhbCggc2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoIClcblx0XHRcdC5iaW5kKCAnY2hhbmdlLkRUJywgZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRfZm5MZW5ndGhDaGFuZ2UoIHNldHRpbmdzLCAkKHRoaXMpLnZhbCgpICk7XG5cdFx0XHRcdF9mbkRyYXcoIHNldHRpbmdzICk7XG5cdFx0XHR9ICk7XG5cdFxuXHRcdC8vIFVwZGF0ZSBub2RlIHZhbHVlIHdoZW5ldmVyIGFueXRoaW5nIGNoYW5nZXMgdGhlIHRhYmxlJ3MgbGVuZ3RoXG5cdFx0JChzZXR0aW5ncy5uVGFibGUpLmJpbmQoICdsZW5ndGguZHQuRFQnLCBmdW5jdGlvbiAoZSwgcywgbGVuKSB7XG5cdFx0XHRpZiAoIHNldHRpbmdzID09PSBzICkge1xuXHRcdFx0XHQkKCdzZWxlY3QnLCBkaXYpLnZhbCggbGVuICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcblx0XHRyZXR1cm4gZGl2WzBdO1xuXHR9XG5cdFxuXHRcblx0XG5cdC8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG5cdCAqIE5vdGUgdGhhdCBtb3N0IG9mIHRoZSBwYWdpbmcgbG9naWMgaXMgZG9uZSBpblxuXHQgKiBEYXRhVGFibGUuZXh0LnBhZ2VyXG5cdCAqL1xuXHRcblx0LyoqXG5cdCAqIEdlbmVyYXRlIHRoZSBub2RlIHJlcXVpcmVkIGZvciBkZWZhdWx0IHBhZ2luYXRpb25cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEByZXR1cm5zIHtub2RlfSBQYWdpbmF0aW9uIGZlYXR1cmUgbm9kZVxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5GZWF0dXJlSHRtbFBhZ2luYXRlICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyXG5cdFx0XHR0eXBlICAgPSBzZXR0aW5ncy5zUGFnaW5hdGlvblR5cGUsXG5cdFx0XHRwbHVnaW4gPSBEYXRhVGFibGUuZXh0LnBhZ2VyWyB0eXBlIF0sXG5cdFx0XHRtb2Rlcm4gPSB0eXBlb2YgcGx1Z2luID09PSAnZnVuY3Rpb24nLFxuXHRcdFx0cmVkcmF3ID0gZnVuY3Rpb24oIHNldHRpbmdzICkge1xuXHRcdFx0XHRfZm5EcmF3KCBzZXR0aW5ncyApO1xuXHRcdFx0fSxcblx0XHRcdG5vZGUgPSAkKCc8ZGl2Lz4nKS5hZGRDbGFzcyggc2V0dGluZ3Mub0NsYXNzZXMuc1BhZ2luZyArIHR5cGUgKVswXSxcblx0XHRcdGZlYXR1cmVzID0gc2V0dGluZ3MuYWFuRmVhdHVyZXM7XG5cdFxuXHRcdGlmICggISBtb2Rlcm4gKSB7XG5cdFx0XHRwbHVnaW4uZm5Jbml0KCBzZXR0aW5ncywgbm9kZSwgcmVkcmF3ICk7XG5cdFx0fVxuXHRcblx0XHQvKiBBZGQgYSBkcmF3IGNhbGxiYWNrIGZvciB0aGUgcGFnaW5hdGlvbiBvbiBmaXJzdCBpbnN0YW5jZSwgdG8gdXBkYXRlIHRoZSBwYWdpbmcgZGlzcGxheSAqL1xuXHRcdGlmICggISBmZWF0dXJlcy5wIClcblx0XHR7XG5cdFx0XHRub2RlLmlkID0gc2V0dGluZ3Muc1RhYmxlSWQrJ19wYWdpbmF0ZSc7XG5cdFxuXHRcdFx0c2V0dGluZ3MuYW9EcmF3Q2FsbGJhY2sucHVzaCgge1xuXHRcdFx0XHRcImZuXCI6IGZ1bmN0aW9uKCBzZXR0aW5ncyApIHtcblx0XHRcdFx0XHRpZiAoIG1vZGVybiApIHtcblx0XHRcdFx0XHRcdHZhclxuXHRcdFx0XHRcdFx0XHRzdGFydCAgICAgID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQsXG5cdFx0XHRcdFx0XHRcdGxlbiAgICAgICAgPSBzZXR0aW5ncy5faURpc3BsYXlMZW5ndGgsXG5cdFx0XHRcdFx0XHRcdHZpc1JlY29yZHMgPSBzZXR0aW5ncy5mblJlY29yZHNEaXNwbGF5KCksXG5cdFx0XHRcdFx0XHRcdGFsbCAgICAgICAgPSBsZW4gPT09IC0xLFxuXHRcdFx0XHRcdFx0XHRwYWdlID0gYWxsID8gMCA6IE1hdGguY2VpbCggc3RhcnQgLyBsZW4gKSxcblx0XHRcdFx0XHRcdFx0cGFnZXMgPSBhbGwgPyAxIDogTWF0aC5jZWlsKCB2aXNSZWNvcmRzIC8gbGVuICksXG5cdFx0XHRcdFx0XHRcdGJ1dHRvbnMgPSBwbHVnaW4ocGFnZSwgcGFnZXMpLFxuXHRcdFx0XHRcdFx0XHRpLCBpZW47XG5cdFxuXHRcdFx0XHRcdFx0Zm9yICggaT0wLCBpZW49ZmVhdHVyZXMucC5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0XHRcdFx0X2ZuUmVuZGVyZXIoIHNldHRpbmdzLCAncGFnZUJ1dHRvbicgKShcblx0XHRcdFx0XHRcdFx0XHRzZXR0aW5ncywgZmVhdHVyZXMucFtpXSwgaSwgYnV0dG9ucywgcGFnZSwgcGFnZXNcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRwbHVnaW4uZm5VcGRhdGUoIHNldHRpbmdzLCByZWRyYXcgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdFwic05hbWVcIjogXCJwYWdpbmF0aW9uXCJcblx0XHRcdH0gKTtcblx0XHR9XG5cdFxuXHRcdHJldHVybiBub2RlO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEFsdGVyIHRoZSBkaXNwbGF5IHNldHRpbmdzIHRvIGNoYW5nZSB0aGUgcGFnZVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge3N0cmluZ3xpbnR9IGFjdGlvbiBQYWdpbmcgYWN0aW9uIHRvIHRha2U6IFwiZmlyc3RcIiwgXCJwcmV2aW91c1wiLFxuXHQgKiAgICBcIm5leHRcIiBvciBcImxhc3RcIiBvciBwYWdlIG51bWJlciB0byBqdW1wIHRvIChpbnRlZ2VyKVxuXHQgKiAgQHBhcmFtIFtib29sXSByZWRyYXcgQXV0b21hdGljYWxseSBkcmF3IHRoZSB1cGRhdGUgb3Igbm90XG5cdCAqICBAcmV0dXJucyB7Ym9vbH0gdHJ1ZSBwYWdlIGhhcyBjaGFuZ2VkLCBmYWxzZSAtIG5vIGNoYW5nZVxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5QYWdlQ2hhbmdlICggc2V0dGluZ3MsIGFjdGlvbiwgcmVkcmF3IClcblx0e1xuXHRcdHZhclxuXHRcdFx0c3RhcnQgICAgID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQsXG5cdFx0XHRsZW4gICAgICAgPSBzZXR0aW5ncy5faURpc3BsYXlMZW5ndGgsXG5cdFx0XHRyZWNvcmRzICAgPSBzZXR0aW5ncy5mblJlY29yZHNEaXNwbGF5KCk7XG5cdFxuXHRcdGlmICggcmVjb3JkcyA9PT0gMCB8fCBsZW4gPT09IC0xIClcblx0XHR7XG5cdFx0XHRzdGFydCA9IDA7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCB0eXBlb2YgYWN0aW9uID09PSBcIm51bWJlclwiIClcblx0XHR7XG5cdFx0XHRzdGFydCA9IGFjdGlvbiAqIGxlbjtcblx0XG5cdFx0XHRpZiAoIHN0YXJ0ID4gcmVjb3JkcyApXG5cdFx0XHR7XG5cdFx0XHRcdHN0YXJ0ID0gMDtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZiAoIGFjdGlvbiA9PSBcImZpcnN0XCIgKVxuXHRcdHtcblx0XHRcdHN0YXJ0ID0gMDtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIGFjdGlvbiA9PSBcInByZXZpb3VzXCIgKVxuXHRcdHtcblx0XHRcdHN0YXJ0ID0gbGVuID49IDAgP1xuXHRcdFx0XHRzdGFydCAtIGxlbiA6XG5cdFx0XHRcdDA7XG5cdFxuXHRcdFx0aWYgKCBzdGFydCA8IDAgKVxuXHRcdFx0e1xuXHRcdFx0ICBzdGFydCA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBhY3Rpb24gPT0gXCJuZXh0XCIgKVxuXHRcdHtcblx0XHRcdGlmICggc3RhcnQgKyBsZW4gPCByZWNvcmRzIClcblx0XHRcdHtcblx0XHRcdFx0c3RhcnQgKz0gbGVuO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmICggYWN0aW9uID09IFwibGFzdFwiIClcblx0XHR7XG5cdFx0XHRzdGFydCA9IE1hdGguZmxvb3IoIChyZWNvcmRzLTEpIC8gbGVuKSAqIGxlbjtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdF9mbkxvZyggc2V0dGluZ3MsIDAsIFwiVW5rbm93biBwYWdpbmcgYWN0aW9uOiBcIithY3Rpb24sIDUgKTtcblx0XHR9XG5cdFxuXHRcdHZhciBjaGFuZ2VkID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgIT09IHN0YXJ0O1xuXHRcdHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0ID0gc3RhcnQ7XG5cdFxuXHRcdGlmICggY2hhbmdlZCApIHtcblx0XHRcdF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsIG51bGwsICdwYWdlJywgW3NldHRpbmdzXSApO1xuXHRcblx0XHRcdGlmICggcmVkcmF3ICkge1xuXHRcdFx0XHRfZm5EcmF3KCBzZXR0aW5ncyApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0cmV0dXJuIGNoYW5nZWQ7XG5cdH1cblx0XG5cdFxuXHRcblx0LyoqXG5cdCAqIEdlbmVyYXRlIHRoZSBub2RlIHJlcXVpcmVkIGZvciB0aGUgcHJvY2Vzc2luZyBub2RlXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEByZXR1cm5zIHtub2RlfSBQcm9jZXNzaW5nIGVsZW1lbnRcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuRmVhdHVyZUh0bWxQcm9jZXNzaW5nICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0cmV0dXJuICQoJzxkaXYvPicsIHtcblx0XHRcdFx0J2lkJzogISBzZXR0aW5ncy5hYW5GZWF0dXJlcy5yID8gc2V0dGluZ3Muc1RhYmxlSWQrJ19wcm9jZXNzaW5nJyA6IG51bGwsXG5cdFx0XHRcdCdjbGFzcyc6IHNldHRpbmdzLm9DbGFzc2VzLnNQcm9jZXNzaW5nXG5cdFx0XHR9IClcblx0XHRcdC5odG1sKCBzZXR0aW5ncy5vTGFuZ3VhZ2Uuc1Byb2Nlc3NpbmcgKVxuXHRcdFx0Lmluc2VydEJlZm9yZSggc2V0dGluZ3MublRhYmxlIClbMF07XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogRGlzcGxheSBvciBoaWRlIHRoZSBwcm9jZXNzaW5nIGluZGljYXRvclxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge2Jvb2x9IHNob3cgU2hvdyB0aGUgcHJvY2Vzc2luZyBpbmRpY2F0b3IgKHRydWUpIG9yIG5vdCAoZmFsc2UpXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mblByb2Nlc3NpbmdEaXNwbGF5ICggc2V0dGluZ3MsIHNob3cgKVxuXHR7XG5cdFx0aWYgKCBzZXR0aW5ncy5vRmVhdHVyZXMuYlByb2Nlc3NpbmcgKSB7XG5cdFx0XHQkKHNldHRpbmdzLmFhbkZlYXR1cmVzLnIpLmNzcyggJ2Rpc3BsYXknLCBzaG93ID8gJ2Jsb2NrJyA6ICdub25lJyApO1xuXHRcdH1cblx0XG5cdFx0X2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgbnVsbCwgJ3Byb2Nlc3NpbmcnLCBbc2V0dGluZ3MsIHNob3ddICk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBBZGQgYW55IGNvbnRyb2wgZWxlbWVudHMgZm9yIHRoZSB0YWJsZSAtIHNwZWNpZmljYWxseSBzY3JvbGxpbmdcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHJldHVybnMge25vZGV9IE5vZGUgdG8gYWRkIHRvIHRoZSBET01cblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuRmVhdHVyZUh0bWxUYWJsZSAoIHNldHRpbmdzIClcblx0e1xuXHRcdHZhciB0YWJsZSA9ICQoc2V0dGluZ3MublRhYmxlKTtcblx0XG5cdFx0Ly8gQWRkIHRoZSBBUklBIGdyaWQgcm9sZSB0byB0aGUgdGFibGVcblx0XHR0YWJsZS5hdHRyKCAncm9sZScsICdncmlkJyApO1xuXHRcblx0XHQvLyBTY3JvbGxpbmcgZnJvbSBoZXJlIG9uIGluXG5cdFx0dmFyIHNjcm9sbCA9IHNldHRpbmdzLm9TY3JvbGw7XG5cdFxuXHRcdGlmICggc2Nyb2xsLnNYID09PSAnJyAmJiBzY3JvbGwuc1kgPT09ICcnICkge1xuXHRcdFx0cmV0dXJuIHNldHRpbmdzLm5UYWJsZTtcblx0XHR9XG5cdFxuXHRcdHZhciBzY3JvbGxYID0gc2Nyb2xsLnNYO1xuXHRcdHZhciBzY3JvbGxZID0gc2Nyb2xsLnNZO1xuXHRcdHZhciBjbGFzc2VzID0gc2V0dGluZ3Mub0NsYXNzZXM7XG5cdFx0dmFyIGNhcHRpb24gPSB0YWJsZS5jaGlsZHJlbignY2FwdGlvbicpO1xuXHRcdHZhciBjYXB0aW9uU2lkZSA9IGNhcHRpb24ubGVuZ3RoID8gY2FwdGlvblswXS5fY2FwdGlvblNpZGUgOiBudWxsO1xuXHRcdHZhciBoZWFkZXJDbG9uZSA9ICQoIHRhYmxlWzBdLmNsb25lTm9kZShmYWxzZSkgKTtcblx0XHR2YXIgZm9vdGVyQ2xvbmUgPSAkKCB0YWJsZVswXS5jbG9uZU5vZGUoZmFsc2UpICk7XG5cdFx0dmFyIGZvb3RlciA9IHRhYmxlLmNoaWxkcmVuKCd0Zm9vdCcpO1xuXHRcdHZhciBfZGl2ID0gJzxkaXYvPic7XG5cdFx0dmFyIHNpemUgPSBmdW5jdGlvbiAoIHMgKSB7XG5cdFx0XHRyZXR1cm4gIXMgPyBudWxsIDogX2ZuU3RyaW5nVG9Dc3MoIHMgKTtcblx0XHR9O1xuXHRcblx0XHQvLyBUaGlzIGlzIGZhaXJseSBtZXNzeSwgYnV0IHdpdGggeCBzY3JvbGxpbmcgZW5hYmxlZCwgaWYgdGhlIHRhYmxlIGhhcyBhXG5cdFx0Ly8gd2lkdGggYXR0cmlidXRlLCByZWdhcmRsZXNzIG9mIGFueSB3aWR0aCBhcHBsaWVkIHVzaW5nIHRoZSBjb2x1bW4gd2lkdGhcblx0XHQvLyBvcHRpb25zLCB0aGUgYnJvd3NlciB3aWxsIHNocmluayBvciBncm93IHRoZSB0YWJsZSBhcyBuZWVkZWQgdG8gZml0IGludG9cblx0XHQvLyB0aGF0IDEwMCUuIFRoYXQgd291bGQgbWFrZSB0aGUgd2lkdGggb3B0aW9ucyB1c2VsZXNzLiBTbyB3ZSByZW1vdmUgaXQuXG5cdFx0Ly8gVGhpcyBpcyBva2F5LCB1bmRlciB0aGUgYXNzdW1wdGlvbiB0aGF0IHdpZHRoOjEwMCUgaXMgYXBwbGllZCB0byB0aGVcblx0XHQvLyB0YWJsZSBpbiBDU1MgKGl0IGlzIGluIHRoZSBkZWZhdWx0IHN0eWxlc2hlZXQpIHdoaWNoIHdpbGwgc2V0IHRoZSB0YWJsZVxuXHRcdC8vIHdpZHRoIGFzIGFwcHJvcHJpYXRlICh0aGUgYXR0cmlidXRlIGFuZCBjc3MgYmVoYXZlIGRpZmZlcmVudGx5Li4uKVxuXHRcdGlmICggc2Nyb2xsLnNYICYmIHRhYmxlLmF0dHIoJ3dpZHRoJykgPT09ICcxMDAlJyApIHtcblx0XHRcdHRhYmxlLnJlbW92ZUF0dHIoJ3dpZHRoJyk7XG5cdFx0fVxuXHRcblx0XHRpZiAoICEgZm9vdGVyLmxlbmd0aCApIHtcblx0XHRcdGZvb3RlciA9IG51bGw7XG5cdFx0fVxuXHRcblx0XHQvKlxuXHRcdCAqIFRoZSBIVE1MIHN0cnVjdHVyZSB0aGF0IHdlIHdhbnQgdG8gZ2VuZXJhdGUgaW4gdGhpcyBmdW5jdGlvbiBpczpcblx0XHQgKiAgZGl2IC0gc2Nyb2xsZXJcblx0XHQgKiAgICBkaXYgLSBzY3JvbGwgaGVhZFxuXHRcdCAqICAgICAgZGl2IC0gc2Nyb2xsIGhlYWQgaW5uZXJcblx0XHQgKiAgICAgICAgdGFibGUgLSBzY3JvbGwgaGVhZCB0YWJsZVxuXHRcdCAqICAgICAgICAgIHRoZWFkIC0gdGhlYWRcblx0XHQgKiAgICBkaXYgLSBzY3JvbGwgYm9keVxuXHRcdCAqICAgICAgdGFibGUgLSB0YWJsZSAobWFzdGVyIHRhYmxlKVxuXHRcdCAqICAgICAgICB0aGVhZCAtIHRoZWFkIGNsb25lIGZvciBzaXppbmdcblx0XHQgKiAgICAgICAgdGJvZHkgLSB0Ym9keVxuXHRcdCAqICAgIGRpdiAtIHNjcm9sbCBmb290XG5cdFx0ICogICAgICBkaXYgLSBzY3JvbGwgZm9vdCBpbm5lclxuXHRcdCAqICAgICAgICB0YWJsZSAtIHNjcm9sbCBmb290IHRhYmxlXG5cdFx0ICogICAgICAgICAgdGZvb3QgLSB0Zm9vdFxuXHRcdCAqL1xuXHRcdHZhciBzY3JvbGxlciA9ICQoIF9kaXYsIHsgJ2NsYXNzJzogY2xhc3Nlcy5zU2Nyb2xsV3JhcHBlciB9IClcblx0XHRcdC5hcHBlbmQoXG5cdFx0XHRcdCQoX2RpdiwgeyAnY2xhc3MnOiBjbGFzc2VzLnNTY3JvbGxIZWFkIH0gKVxuXHRcdFx0XHRcdC5jc3MoIHtcblx0XHRcdFx0XHRcdG92ZXJmbG93OiAnaGlkZGVuJyxcblx0XHRcdFx0XHRcdHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuXHRcdFx0XHRcdFx0Ym9yZGVyOiAwLFxuXHRcdFx0XHRcdFx0d2lkdGg6IHNjcm9sbFggPyBzaXplKHNjcm9sbFgpIDogJzEwMCUnXG5cdFx0XHRcdFx0fSApXG5cdFx0XHRcdFx0LmFwcGVuZChcblx0XHRcdFx0XHRcdCQoX2RpdiwgeyAnY2xhc3MnOiBjbGFzc2VzLnNTY3JvbGxIZWFkSW5uZXIgfSApXG5cdFx0XHRcdFx0XHRcdC5jc3MoIHtcblx0XHRcdFx0XHRcdFx0XHQnYm94LXNpemluZyc6ICdjb250ZW50LWJveCcsXG5cdFx0XHRcdFx0XHRcdFx0d2lkdGg6IHNjcm9sbC5zWElubmVyIHx8ICcxMDAlJ1xuXHRcdFx0XHRcdFx0XHR9IClcblx0XHRcdFx0XHRcdFx0LmFwcGVuZChcblx0XHRcdFx0XHRcdFx0XHRoZWFkZXJDbG9uZVxuXHRcdFx0XHRcdFx0XHRcdFx0LnJlbW92ZUF0dHIoJ2lkJylcblx0XHRcdFx0XHRcdFx0XHRcdC5jc3MoICdtYXJnaW4tbGVmdCcsIDAgKVxuXHRcdFx0XHRcdFx0XHRcdFx0LmFwcGVuZCggY2FwdGlvblNpZGUgPT09ICd0b3AnID8gY2FwdGlvbiA6IG51bGwgKVxuXHRcdFx0XHRcdFx0XHRcdFx0LmFwcGVuZChcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGFibGUuY2hpbGRyZW4oJ3RoZWFkJylcblx0XHRcdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdClcblx0XHRcdClcblx0XHRcdC5hcHBlbmQoXG5cdFx0XHRcdCQoX2RpdiwgeyAnY2xhc3MnOiBjbGFzc2VzLnNTY3JvbGxCb2R5IH0gKVxuXHRcdFx0XHRcdC5jc3MoIHtcblx0XHRcdFx0XHRcdG92ZXJmbG93OiAnYXV0bycsXG5cdFx0XHRcdFx0XHRoZWlnaHQ6IHNpemUoIHNjcm9sbFkgKSxcblx0XHRcdFx0XHRcdHdpZHRoOiBzaXplKCBzY3JvbGxYIClcblx0XHRcdFx0XHR9IClcblx0XHRcdFx0XHQuYXBwZW5kKCB0YWJsZSApXG5cdFx0XHQpO1xuXHRcblx0XHRpZiAoIGZvb3RlciApIHtcblx0XHRcdHNjcm9sbGVyLmFwcGVuZChcblx0XHRcdFx0JChfZGl2LCB7ICdjbGFzcyc6IGNsYXNzZXMuc1Njcm9sbEZvb3QgfSApXG5cdFx0XHRcdFx0LmNzcygge1xuXHRcdFx0XHRcdFx0b3ZlcmZsb3c6ICdoaWRkZW4nLFxuXHRcdFx0XHRcdFx0Ym9yZGVyOiAwLFxuXHRcdFx0XHRcdFx0d2lkdGg6IHNjcm9sbFggPyBzaXplKHNjcm9sbFgpIDogJzEwMCUnXG5cdFx0XHRcdFx0fSApXG5cdFx0XHRcdFx0LmFwcGVuZChcblx0XHRcdFx0XHRcdCQoX2RpdiwgeyAnY2xhc3MnOiBjbGFzc2VzLnNTY3JvbGxGb290SW5uZXIgfSApXG5cdFx0XHRcdFx0XHRcdC5hcHBlbmQoXG5cdFx0XHRcdFx0XHRcdFx0Zm9vdGVyQ2xvbmVcblx0XHRcdFx0XHRcdFx0XHRcdC5yZW1vdmVBdHRyKCdpZCcpXG5cdFx0XHRcdFx0XHRcdFx0XHQuY3NzKCAnbWFyZ2luLWxlZnQnLCAwIClcblx0XHRcdFx0XHRcdFx0XHRcdC5hcHBlbmQoIGNhcHRpb25TaWRlID09PSAnYm90dG9tJyA/IGNhcHRpb24gOiBudWxsIClcblx0XHRcdFx0XHRcdFx0XHRcdC5hcHBlbmQoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRhYmxlLmNoaWxkcmVuKCd0Zm9vdCcpXG5cdFx0XHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHQpXG5cdFx0XHQpO1xuXHRcdH1cblx0XG5cdFx0dmFyIGNoaWxkcmVuID0gc2Nyb2xsZXIuY2hpbGRyZW4oKTtcblx0XHR2YXIgc2Nyb2xsSGVhZCA9IGNoaWxkcmVuWzBdO1xuXHRcdHZhciBzY3JvbGxCb2R5ID0gY2hpbGRyZW5bMV07XG5cdFx0dmFyIHNjcm9sbEZvb3QgPSBmb290ZXIgPyBjaGlsZHJlblsyXSA6IG51bGw7XG5cdFxuXHRcdC8vIFdoZW4gdGhlIGJvZHkgaXMgc2Nyb2xsZWQsIHRoZW4gd2UgYWxzbyB3YW50IHRvIHNjcm9sbCB0aGUgaGVhZGVyc1xuXHRcdGlmICggc2Nyb2xsWCApIHtcblx0XHRcdCQoc2Nyb2xsQm9keSkub24oICdzY3JvbGwuRFQnLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHR2YXIgc2Nyb2xsTGVmdCA9IHRoaXMuc2Nyb2xsTGVmdDtcblx0XG5cdFx0XHRcdHNjcm9sbEhlYWQuc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQ7XG5cdFxuXHRcdFx0XHRpZiAoIGZvb3RlciApIHtcblx0XHRcdFx0XHRzY3JvbGxGb290LnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcblx0XHRzZXR0aW5ncy5uU2Nyb2xsSGVhZCA9IHNjcm9sbEhlYWQ7XG5cdFx0c2V0dGluZ3MublNjcm9sbEJvZHkgPSBzY3JvbGxCb2R5O1xuXHRcdHNldHRpbmdzLm5TY3JvbGxGb290ID0gc2Nyb2xsRm9vdDtcblx0XG5cdFx0Ly8gT24gcmVkcmF3IC0gYWxpZ24gY29sdW1uc1xuXHRcdHNldHRpbmdzLmFvRHJhd0NhbGxiYWNrLnB1c2goIHtcblx0XHRcdFwiZm5cIjogX2ZuU2Nyb2xsRHJhdyxcblx0XHRcdFwic05hbWVcIjogXCJzY3JvbGxpbmdcIlxuXHRcdH0gKTtcblx0XG5cdFx0cmV0dXJuIHNjcm9sbGVyWzBdO1xuXHR9XG5cdFxuXHRcblx0XG5cdC8qKlxuXHQgKiBVcGRhdGUgdGhlIGhlYWRlciwgZm9vdGVyIGFuZCBib2R5IHRhYmxlcyBmb3IgcmVzaXppbmcgLSBpLmUuIGNvbHVtblxuXHQgKiBhbGlnbm1lbnQuXG5cdCAqXG5cdCAqIFdlbGNvbWUgdG8gdGhlIG1vc3QgaG9ycmlibGUgZnVuY3Rpb24gRGF0YVRhYmxlcy4gVGhlIHByb2Nlc3MgdGhhdCB0aGlzXG5cdCAqIGZ1bmN0aW9uIGZvbGxvd3MgaXMgYmFzaWNhbGx5OlxuXHQgKiAgIDEuIFJlLWNyZWF0ZSB0aGUgdGFibGUgaW5zaWRlIHRoZSBzY3JvbGxpbmcgZGl2XG5cdCAqICAgMi4gVGFrZSBsaXZlIG1lYXN1cmVtZW50cyBmcm9tIHRoZSBET01cblx0ICogICAzLiBBcHBseSB0aGUgbWVhc3VyZW1lbnRzIHRvIGFsaWduIHRoZSBjb2x1bW5zXG5cdCAqICAgNC4gQ2xlYW4gdXBcblx0ICpcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5TY3JvbGxEcmF3ICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0Ly8gR2l2ZW4gdGhhdCB0aGlzIGlzIHN1Y2ggYSBtb25zdGVyIGZ1bmN0aW9uLCBhIGxvdCBvZiB2YXJpYWJsZXMgYXJlIHVzZVxuXHRcdC8vIHRvIHRyeSBhbmQga2VlcCB0aGUgbWluaW1pc2VkIHNpemUgYXMgc21hbGwgYXMgcG9zc2libGVcblx0XHR2YXJcblx0XHRcdHNjcm9sbCAgICAgICAgID0gc2V0dGluZ3Mub1Njcm9sbCxcblx0XHRcdHNjcm9sbFggICAgICAgID0gc2Nyb2xsLnNYLFxuXHRcdFx0c2Nyb2xsWElubmVyICAgPSBzY3JvbGwuc1hJbm5lcixcblx0XHRcdHNjcm9sbFkgICAgICAgID0gc2Nyb2xsLnNZLFxuXHRcdFx0YmFyV2lkdGggICAgICAgPSBzY3JvbGwuaUJhcldpZHRoLFxuXHRcdFx0ZGl2SGVhZGVyICAgICAgPSAkKHNldHRpbmdzLm5TY3JvbGxIZWFkKSxcblx0XHRcdGRpdkhlYWRlclN0eWxlID0gZGl2SGVhZGVyWzBdLnN0eWxlLFxuXHRcdFx0ZGl2SGVhZGVySW5uZXIgPSBkaXZIZWFkZXIuY2hpbGRyZW4oJ2RpdicpLFxuXHRcdFx0ZGl2SGVhZGVySW5uZXJTdHlsZSA9IGRpdkhlYWRlcklubmVyWzBdLnN0eWxlLFxuXHRcdFx0ZGl2SGVhZGVyVGFibGUgPSBkaXZIZWFkZXJJbm5lci5jaGlsZHJlbigndGFibGUnKSxcblx0XHRcdGRpdkJvZHlFbCAgICAgID0gc2V0dGluZ3MublNjcm9sbEJvZHksXG5cdFx0XHRkaXZCb2R5ICAgICAgICA9ICQoZGl2Qm9keUVsKSxcblx0XHRcdGRpdkJvZHlTdHlsZSAgID0gZGl2Qm9keUVsLnN0eWxlLFxuXHRcdFx0ZGl2Rm9vdGVyICAgICAgPSAkKHNldHRpbmdzLm5TY3JvbGxGb290KSxcblx0XHRcdGRpdkZvb3RlcklubmVyID0gZGl2Rm9vdGVyLmNoaWxkcmVuKCdkaXYnKSxcblx0XHRcdGRpdkZvb3RlclRhYmxlID0gZGl2Rm9vdGVySW5uZXIuY2hpbGRyZW4oJ3RhYmxlJyksXG5cdFx0XHRoZWFkZXIgICAgICAgICA9ICQoc2V0dGluZ3MublRIZWFkKSxcblx0XHRcdHRhYmxlICAgICAgICAgID0gJChzZXR0aW5ncy5uVGFibGUpLFxuXHRcdFx0dGFibGVFbCAgICAgICAgPSB0YWJsZVswXSxcblx0XHRcdHRhYmxlU3R5bGUgICAgID0gdGFibGVFbC5zdHlsZSxcblx0XHRcdGZvb3RlciAgICAgICAgID0gc2V0dGluZ3MublRGb290ID8gJChzZXR0aW5ncy5uVEZvb3QpIDogbnVsbCxcblx0XHRcdGJyb3dzZXIgICAgICAgID0gc2V0dGluZ3Mub0Jyb3dzZXIsXG5cdFx0XHRpZTY3ICAgICAgICAgICA9IGJyb3dzZXIuYlNjcm9sbE92ZXJzaXplLFxuXHRcdFx0aGVhZGVyVHJnRWxzLCBmb290ZXJUcmdFbHMsXG5cdFx0XHRoZWFkZXJTcmNFbHMsIGZvb3RlclNyY0Vscyxcblx0XHRcdGhlYWRlckNvcHksIGZvb3RlckNvcHksXG5cdFx0XHRoZWFkZXJXaWR0aHM9W10sIGZvb3RlcldpZHRocz1bXSxcblx0XHRcdGhlYWRlckNvbnRlbnQ9W10sXG5cdFx0XHRpZHgsIGNvcnJlY3Rpb24sIHNhbml0eVdpZHRoLFxuXHRcdFx0emVyb091dCA9IGZ1bmN0aW9uKG5TaXplcikge1xuXHRcdFx0XHR2YXIgc3R5bGUgPSBuU2l6ZXIuc3R5bGU7XG5cdFx0XHRcdHN0eWxlLnBhZGRpbmdUb3AgPSBcIjBcIjtcblx0XHRcdFx0c3R5bGUucGFkZGluZ0JvdHRvbSA9IFwiMFwiO1xuXHRcdFx0XHRzdHlsZS5ib3JkZXJUb3BXaWR0aCA9IFwiMFwiO1xuXHRcdFx0XHRzdHlsZS5ib3JkZXJCb3R0b21XaWR0aCA9IFwiMFwiO1xuXHRcdFx0XHRzdHlsZS5oZWlnaHQgPSAwO1xuXHRcdFx0fTtcblx0XG5cdFx0Lypcblx0XHQgKiAxLiBSZS1jcmVhdGUgdGhlIHRhYmxlIGluc2lkZSB0aGUgc2Nyb2xsaW5nIGRpdlxuXHRcdCAqL1xuXHRcblx0XHQvLyBSZW1vdmUgdGhlIG9sZCBtaW5pbWlzZWQgdGhlYWQgYW5kIHRmb290IGVsZW1lbnRzIGluIHRoZSBpbm5lciB0YWJsZVxuXHRcdHRhYmxlLmNoaWxkcmVuKCd0aGVhZCwgdGZvb3QnKS5yZW1vdmUoKTtcblx0XG5cdFx0Ly8gQ2xvbmUgdGhlIGN1cnJlbnQgaGVhZGVyIGFuZCBmb290ZXIgZWxlbWVudHMgYW5kIHRoZW4gcGxhY2UgaXQgaW50byB0aGUgaW5uZXIgdGFibGVcblx0XHRoZWFkZXJDb3B5ID0gaGVhZGVyLmNsb25lKCkucHJlcGVuZFRvKCB0YWJsZSApO1xuXHRcdGhlYWRlclRyZ0VscyA9IGhlYWRlci5maW5kKCd0cicpOyAvLyBvcmlnaW5hbCBoZWFkZXIgaXMgaW4gaXRzIG93biB0YWJsZVxuXHRcdGhlYWRlclNyY0VscyA9IGhlYWRlckNvcHkuZmluZCgndHInKTtcblx0XHRoZWFkZXJDb3B5LmZpbmQoJ3RoLCB0ZCcpLnJlbW92ZUF0dHIoJ3RhYmluZGV4Jyk7XG5cdFxuXHRcdGlmICggZm9vdGVyICkge1xuXHRcdFx0Zm9vdGVyQ29weSA9IGZvb3Rlci5jbG9uZSgpLnByZXBlbmRUbyggdGFibGUgKTtcblx0XHRcdGZvb3RlclRyZ0VscyA9IGZvb3Rlci5maW5kKCd0cicpOyAvLyB0aGUgb3JpZ2luYWwgdGZvb3QgaXMgaW4gaXRzIG93biB0YWJsZSBhbmQgbXVzdCBiZSBzaXplZFxuXHRcdFx0Zm9vdGVyU3JjRWxzID0gZm9vdGVyQ29weS5maW5kKCd0cicpO1xuXHRcdH1cblx0XG5cdFxuXHRcdC8qXG5cdFx0ICogMi4gVGFrZSBsaXZlIG1lYXN1cmVtZW50cyBmcm9tIHRoZSBET00gLSBkbyBub3QgYWx0ZXIgdGhlIERPTSBpdHNlbGYhXG5cdFx0ICovXG5cdFxuXHRcdC8vIFJlbW92ZSBvbGQgc2l6aW5nIGFuZCBhcHBseSB0aGUgY2FsY3VsYXRlZCBjb2x1bW4gd2lkdGhzXG5cdFx0Ly8gR2V0IHRoZSB1bmlxdWUgY29sdW1uIGhlYWRlcnMgaW4gdGhlIG5ld2x5IGNyZWF0ZWQgKGNsb25lZCkgaGVhZGVyLiBXZSB3YW50IHRvIGFwcGx5IHRoZVxuXHRcdC8vIGNhbGN1bGF0ZWQgc2l6ZXMgdG8gdGhpcyBoZWFkZXJcblx0XHRpZiAoICEgc2Nyb2xsWCApXG5cdFx0e1xuXHRcdFx0ZGl2Qm9keVN0eWxlLndpZHRoID0gJzEwMCUnO1xuXHRcdFx0ZGl2SGVhZGVyWzBdLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuXHRcdH1cblx0XG5cdFx0JC5lYWNoKCBfZm5HZXRVbmlxdWVUaHMoIHNldHRpbmdzLCBoZWFkZXJDb3B5ICksIGZ1bmN0aW9uICggaSwgZWwgKSB7XG5cdFx0XHRpZHggPSBfZm5WaXNpYmxlVG9Db2x1bW5JbmRleCggc2V0dGluZ3MsIGkgKTtcblx0XHRcdGVsLnN0eWxlLndpZHRoID0gc2V0dGluZ3MuYW9Db2x1bW5zW2lkeF0uc1dpZHRoO1xuXHRcdH0gKTtcblx0XG5cdFx0aWYgKCBmb290ZXIgKSB7XG5cdFx0XHRfZm5BcHBseVRvQ2hpbGRyZW4oIGZ1bmN0aW9uKG4pIHtcblx0XHRcdFx0bi5zdHlsZS53aWR0aCA9IFwiXCI7XG5cdFx0XHR9LCBmb290ZXJTcmNFbHMgKTtcblx0XHR9XG5cdFxuXHRcdC8vIElmIHNjcm9sbCBjb2xsYXBzZSBpcyBlbmFibGVkLCB3aGVuIHdlIHB1dCB0aGUgaGVhZGVycyBiYWNrIGludG8gdGhlIGJvZHkgZm9yIHNpemluZywgd2Vcblx0XHQvLyB3aWxsIGVuZCB1cCBmb3JjaW5nIHRoZSBzY3JvbGxiYXIgdG8gYXBwZWFyLCBtYWtpbmcgb3VyIG1lYXN1cmVtZW50cyB3cm9uZyBmb3Igd2hlbiB3ZVxuXHRcdC8vIHRoZW4gaGlkZSBpdCAoZW5kIG9mIHRoaXMgZnVuY3Rpb24pLCBzbyBhZGQgdGhlIGhlYWRlciBoZWlnaHQgdG8gdGhlIGJvZHkgc2Nyb2xsZXIuXG5cdFx0aWYgKCBzY3JvbGwuYkNvbGxhcHNlICYmIHNjcm9sbFkgIT09IFwiXCIgKSB7XG5cdFx0XHRkaXZCb2R5U3R5bGUuaGVpZ2h0ID0gKGRpdkJvZHlbMF0ub2Zmc2V0SGVpZ2h0ICsgaGVhZGVyWzBdLm9mZnNldEhlaWdodCkrXCJweFwiO1xuXHRcdH1cblx0XG5cdFx0Ly8gU2l6ZSB0aGUgdGFibGUgYXMgYSB3aG9sZVxuXHRcdHNhbml0eVdpZHRoID0gdGFibGUub3V0ZXJXaWR0aCgpO1xuXHRcdGlmICggc2Nyb2xsWCA9PT0gXCJcIiApIHtcblx0XHRcdC8vIE5vIHggc2Nyb2xsaW5nXG5cdFx0XHR0YWJsZVN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG5cdFxuXHRcdFx0Ly8gSUU3IHdpbGwgbWFrZSB0aGUgd2lkdGggb2YgdGhlIHRhYmxlIHdoZW4gMTAwJSBpbmNsdWRlIHRoZSBzY3JvbGxiYXJcblx0XHRcdC8vIC0gd2hpY2ggaXMgc2hvdWxkbid0LiBXaGVuIHRoZXJlIGlzIGEgc2Nyb2xsYmFyIHdlIG5lZWQgdG8gdGFrZSB0aGlzXG5cdFx0XHQvLyBpbnRvIGFjY291bnQuXG5cdFx0XHRpZiAoIGllNjcgJiYgKHRhYmxlLmZpbmQoJ3Rib2R5JykuaGVpZ2h0KCkgPiBkaXZCb2R5RWwub2Zmc2V0SGVpZ2h0IHx8XG5cdFx0XHRcdGRpdkJvZHkuY3NzKCdvdmVyZmxvdy15JykgPT0gXCJzY3JvbGxcIilcblx0XHRcdCkge1xuXHRcdFx0XHR0YWJsZVN0eWxlLndpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoIHRhYmxlLm91dGVyV2lkdGgoKSAtIGJhcldpZHRoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdC8vIHggc2Nyb2xsaW5nXG5cdFx0XHRpZiAoIHNjcm9sbFhJbm5lciAhPT0gXCJcIiApIHtcblx0XHRcdFx0Ly8geCBzY3JvbGwgaW5uZXIgaGFzIGJlZW4gZ2l2ZW4gLSB1c2UgaXRcblx0XHRcdFx0dGFibGVTdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKHNjcm9sbFhJbm5lcik7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggc2FuaXR5V2lkdGggPT0gZGl2Qm9keS53aWR0aCgpICYmIGRpdkJvZHkuaGVpZ2h0KCkgPCB0YWJsZS5oZWlnaHQoKSApIHtcblx0XHRcdFx0Ly8gVGhlcmUgaXMgeS1zY3JvbGxpbmcgLSB0cnkgdG8gdGFrZSBhY2NvdW50IG9mIHRoZSB5IHNjcm9sbCBiYXJcblx0XHRcdFx0dGFibGVTdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKCBzYW5pdHlXaWR0aC1iYXJXaWR0aCApO1xuXHRcdFx0XHRpZiAoIHRhYmxlLm91dGVyV2lkdGgoKSA+IHNhbml0eVdpZHRoLWJhcldpZHRoICkge1xuXHRcdFx0XHRcdC8vIE5vdCBwb3NzaWJsZSB0byB0YWtlIGFjY291bnQgb2YgaXRcblx0XHRcdFx0XHR0YWJsZVN0eWxlLndpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoIHNhbml0eVdpZHRoICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHQvLyBXaGVuIGFsbCBlbHNlIGZhaWxzXG5cdFx0XHRcdHRhYmxlU3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0Nzcyggc2FuaXR5V2lkdGggKTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdC8vIFJlY2FsY3VsYXRlIHRoZSBzYW5pdHkgd2lkdGggLSBub3cgdGhhdCB3ZSd2ZSBhcHBsaWVkIHRoZSByZXF1aXJlZCB3aWR0aCxcblx0XHQvLyBiZWZvcmUgaXQgd2FzIGEgdGVtcG9yYXJ5IHZhcmlhYmxlLiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2UgdGhlIGNvbHVtblxuXHRcdC8vIHdpZHRoIGNhbGN1bGF0aW9uIGlzIGRvbmUgYmVmb3JlIHRoaXMgdGFibGUgRE9NIGlzIGNyZWF0ZWQuXG5cdFx0c2FuaXR5V2lkdGggPSB0YWJsZS5vdXRlcldpZHRoKCk7XG5cdFxuXHRcdC8vIEhpZGRlbiBoZWFkZXIgc2hvdWxkIGhhdmUgemVybyBoZWlnaHQsIHNvIHJlbW92ZSBwYWRkaW5nIGFuZCBib3JkZXJzLiBUaGVuXG5cdFx0Ly8gc2V0IHRoZSB3aWR0aCBiYXNlZCBvbiB0aGUgcmVhbCBoZWFkZXJzXG5cdFxuXHRcdC8vIEFwcGx5IGFsbCBzdHlsZXMgaW4gb25lIHBhc3Ncblx0XHRfZm5BcHBseVRvQ2hpbGRyZW4oIHplcm9PdXQsIGhlYWRlclNyY0VscyApO1xuXHRcblx0XHQvLyBSZWFkIGFsbCB3aWR0aHMgaW4gbmV4dCBwYXNzXG5cdFx0X2ZuQXBwbHlUb0NoaWxkcmVuKCBmdW5jdGlvbihuU2l6ZXIpIHtcblx0XHRcdGhlYWRlckNvbnRlbnQucHVzaCggblNpemVyLmlubmVySFRNTCApO1xuXHRcdFx0aGVhZGVyV2lkdGhzLnB1c2goIF9mblN0cmluZ1RvQ3NzKCAkKG5TaXplcikuY3NzKCd3aWR0aCcpICkgKTtcblx0XHR9LCBoZWFkZXJTcmNFbHMgKTtcblx0XG5cdFx0Ly8gQXBwbHkgYWxsIHdpZHRocyBpbiBmaW5hbCBwYXNzXG5cdFx0X2ZuQXBwbHlUb0NoaWxkcmVuKCBmdW5jdGlvbihuVG9TaXplLCBpKSB7XG5cdFx0XHRuVG9TaXplLnN0eWxlLndpZHRoID0gaGVhZGVyV2lkdGhzW2ldO1xuXHRcdH0sIGhlYWRlclRyZ0VscyApO1xuXHRcblx0XHQkKGhlYWRlclNyY0VscykuaGVpZ2h0KDApO1xuXHRcblx0XHQvKiBTYW1lIGFnYWluIHdpdGggdGhlIGZvb3RlciBpZiB3ZSBoYXZlIG9uZSAqL1xuXHRcdGlmICggZm9vdGVyIClcblx0XHR7XG5cdFx0XHRfZm5BcHBseVRvQ2hpbGRyZW4oIHplcm9PdXQsIGZvb3RlclNyY0VscyApO1xuXHRcblx0XHRcdF9mbkFwcGx5VG9DaGlsZHJlbiggZnVuY3Rpb24oblNpemVyKSB7XG5cdFx0XHRcdGZvb3RlcldpZHRocy5wdXNoKCBfZm5TdHJpbmdUb0NzcyggJChuU2l6ZXIpLmNzcygnd2lkdGgnKSApICk7XG5cdFx0XHR9LCBmb290ZXJTcmNFbHMgKTtcblx0XG5cdFx0XHRfZm5BcHBseVRvQ2hpbGRyZW4oIGZ1bmN0aW9uKG5Ub1NpemUsIGkpIHtcblx0XHRcdFx0blRvU2l6ZS5zdHlsZS53aWR0aCA9IGZvb3RlcldpZHRoc1tpXTtcblx0XHRcdH0sIGZvb3RlclRyZ0VscyApO1xuXHRcblx0XHRcdCQoZm9vdGVyU3JjRWxzKS5oZWlnaHQoMCk7XG5cdFx0fVxuXHRcblx0XG5cdFx0Lypcblx0XHQgKiAzLiBBcHBseSB0aGUgbWVhc3VyZW1lbnRzXG5cdFx0ICovXG5cdFxuXHRcdC8vIFwiSGlkZVwiIHRoZSBoZWFkZXIgYW5kIGZvb3RlciB0aGF0IHdlIHVzZWQgZm9yIHRoZSBzaXppbmcuIFdlIG5lZWQgdG8ga2VlcFxuXHRcdC8vIHRoZSBjb250ZW50IG9mIHRoZSBjZWxsIHNvIHRoYXQgdGhlIHdpZHRoIGFwcGxpZWQgdG8gdGhlIGhlYWRlciBhbmQgYm9keVxuXHRcdC8vIGJvdGggbWF0Y2gsIGJ1dCB3ZSB3YW50IHRvIGhpZGUgaXQgY29tcGxldGVseS4gV2Ugd2FudCB0byBhbHNvIGZpeCB0aGVpclxuXHRcdC8vIHdpZHRoIHRvIHdoYXQgdGhleSBjdXJyZW50bHkgYXJlXG5cdFx0X2ZuQXBwbHlUb0NoaWxkcmVuKCBmdW5jdGlvbihuU2l6ZXIsIGkpIHtcblx0XHRcdG5TaXplci5pbm5lckhUTUwgPSAnPGRpdiBjbGFzcz1cImRhdGFUYWJsZXNfc2l6aW5nXCIgc3R5bGU9XCJoZWlnaHQ6MDtvdmVyZmxvdzpoaWRkZW47XCI+JytoZWFkZXJDb250ZW50W2ldKyc8L2Rpdj4nO1xuXHRcdFx0blNpemVyLnN0eWxlLndpZHRoID0gaGVhZGVyV2lkdGhzW2ldO1xuXHRcdH0sIGhlYWRlclNyY0VscyApO1xuXHRcblx0XHRpZiAoIGZvb3RlciApXG5cdFx0e1xuXHRcdFx0X2ZuQXBwbHlUb0NoaWxkcmVuKCBmdW5jdGlvbihuU2l6ZXIsIGkpIHtcblx0XHRcdFx0blNpemVyLmlubmVySFRNTCA9IFwiXCI7XG5cdFx0XHRcdG5TaXplci5zdHlsZS53aWR0aCA9IGZvb3RlcldpZHRoc1tpXTtcblx0XHRcdH0sIGZvb3RlclNyY0VscyApO1xuXHRcdH1cblx0XG5cdFx0Ly8gU2FuaXR5IGNoZWNrIHRoYXQgdGhlIHRhYmxlIGlzIG9mIGEgc2Vuc2libGUgd2lkdGguIElmIG5vdCB0aGVuIHdlIGFyZSBnb2luZyB0byBnZXRcblx0XHQvLyBtaXNhbGlnbm1lbnQgLSB0cnkgdG8gcHJldmVudCB0aGlzIGJ5IG5vdCBhbGxvd2luZyB0aGUgdGFibGUgdG8gc2hyaW5rIGJlbG93IGl0cyBtaW4gd2lkdGhcblx0XHRpZiAoIHRhYmxlLm91dGVyV2lkdGgoKSA8IHNhbml0eVdpZHRoIClcblx0XHR7XG5cdFx0XHQvLyBUaGUgbWluIHdpZHRoIGRlcGVuZHMgdXBvbiBpZiB3ZSBoYXZlIGEgdmVydGljYWwgc2Nyb2xsYmFyIHZpc2libGUgb3Igbm90ICovXG5cdFx0XHRjb3JyZWN0aW9uID0gKChkaXZCb2R5RWwuc2Nyb2xsSGVpZ2h0ID4gZGl2Qm9keUVsLm9mZnNldEhlaWdodCB8fFxuXHRcdFx0XHRkaXZCb2R5LmNzcygnb3ZlcmZsb3cteScpID09IFwic2Nyb2xsXCIpKSA/XG5cdFx0XHRcdFx0c2FuaXR5V2lkdGgrYmFyV2lkdGggOlxuXHRcdFx0XHRcdHNhbml0eVdpZHRoO1xuXHRcblx0XHRcdC8vIElFNi83IGFyZSBhIGxhdyB1bnRvIHRoZW1zZWx2ZXMuLi5cblx0XHRcdGlmICggaWU2NyAmJiAoZGl2Qm9keUVsLnNjcm9sbEhlaWdodCA+XG5cdFx0XHRcdGRpdkJvZHlFbC5vZmZzZXRIZWlnaHQgfHwgZGl2Qm9keS5jc3MoJ292ZXJmbG93LXknKSA9PSBcInNjcm9sbFwiKVxuXHRcdFx0KSB7XG5cdFx0XHRcdHRhYmxlU3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyggY29ycmVjdGlvbi1iYXJXaWR0aCApO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIEFuZCBnaXZlIHRoZSB1c2VyIGEgd2FybmluZyB0aGF0IHdlJ3ZlIHN0b3BwZWQgdGhlIHRhYmxlIGdldHRpbmcgdG9vIHNtYWxsXG5cdFx0XHRpZiAoIHNjcm9sbFggPT09IFwiXCIgfHwgc2Nyb2xsWElubmVyICE9PSBcIlwiICkge1xuXHRcdFx0XHRfZm5Mb2coIHNldHRpbmdzLCAxLCAnUG9zc2libGUgY29sdW1uIG1pc2FsaWdubWVudCcsIDYgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdGNvcnJlY3Rpb24gPSAnMTAwJSc7XG5cdFx0fVxuXHRcblx0XHQvLyBBcHBseSB0byB0aGUgY29udGFpbmVyIGVsZW1lbnRzXG5cdFx0ZGl2Qm9keVN0eWxlLndpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoIGNvcnJlY3Rpb24gKTtcblx0XHRkaXZIZWFkZXJTdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKCBjb3JyZWN0aW9uICk7XG5cdFxuXHRcdGlmICggZm9vdGVyICkge1xuXHRcdFx0c2V0dGluZ3MublNjcm9sbEZvb3Quc3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyggY29ycmVjdGlvbiApO1xuXHRcdH1cblx0XG5cdFxuXHRcdC8qXG5cdFx0ICogNC4gQ2xlYW4gdXBcblx0XHQgKi9cblx0XHRpZiAoICEgc2Nyb2xsWSApIHtcblx0XHRcdC8qIElFNzwgcHV0cyBhIHZlcnRpY2FsIHNjcm9sbGJhciBpbiBwbGFjZSAod2hlbiBpdCBzaG91bGRuJ3QgYmUpIGR1ZSB0byBzdWJ0cmFjdGluZ1xuXHRcdFx0ICogdGhlIHNjcm9sbGJhciBoZWlnaHQgZnJvbSB0aGUgdmlzaWJsZSBkaXNwbGF5LCByYXRoZXIgdGhhbiBhZGRpbmcgaXQgb24uIFdlIG5lZWQgdG9cblx0XHRcdCAqIHNldCB0aGUgaGVpZ2h0IGluIG9yZGVyIHRvIHNvcnQgdGhpcy4gRG9uJ3Qgd2FudCB0byBkbyBpdCBpbiBhbnkgb3RoZXIgYnJvd3NlcnMuXG5cdFx0XHQgKi9cblx0XHRcdGlmICggaWU2NyApIHtcblx0XHRcdFx0ZGl2Qm9keVN0eWxlLmhlaWdodCA9IF9mblN0cmluZ1RvQ3NzKCB0YWJsZUVsLm9mZnNldEhlaWdodCtiYXJXaWR0aCApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0aWYgKCBzY3JvbGxZICYmIHNjcm9sbC5iQ29sbGFwc2UgKSB7XG5cdFx0XHRkaXZCb2R5U3R5bGUuaGVpZ2h0ID0gX2ZuU3RyaW5nVG9Dc3MoIHNjcm9sbFkgKTtcblx0XG5cdFx0XHR2YXIgaUV4dHJhID0gKHNjcm9sbFggJiYgdGFibGVFbC5vZmZzZXRXaWR0aCA+IGRpdkJvZHlFbC5vZmZzZXRXaWR0aCkgP1xuXHRcdFx0XHRiYXJXaWR0aCA6XG5cdFx0XHRcdDA7XG5cdFxuXHRcdFx0aWYgKCB0YWJsZUVsLm9mZnNldEhlaWdodCA8IGRpdkJvZHlFbC5vZmZzZXRIZWlnaHQgKSB7XG5cdFx0XHRcdGRpdkJvZHlTdHlsZS5oZWlnaHQgPSBfZm5TdHJpbmdUb0NzcyggdGFibGVFbC5vZmZzZXRIZWlnaHQraUV4dHJhICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHQvKiBGaW5hbGx5IHNldCB0aGUgd2lkdGgncyBvZiB0aGUgaGVhZGVyIGFuZCBmb290ZXIgdGFibGVzICovXG5cdFx0dmFyIGlPdXRlcldpZHRoID0gdGFibGUub3V0ZXJXaWR0aCgpO1xuXHRcdGRpdkhlYWRlclRhYmxlWzBdLnN0eWxlLndpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoIGlPdXRlcldpZHRoICk7XG5cdFx0ZGl2SGVhZGVySW5uZXJTdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKCBpT3V0ZXJXaWR0aCApO1xuXHRcblx0XHQvLyBGaWd1cmUgb3V0IGlmIHRoZXJlIGFyZSBzY3JvbGxiYXIgcHJlc2VudCAtIGlmIHNvIHRoZW4gd2UgbmVlZCBhIHRoZSBoZWFkZXIgYW5kIGZvb3RlciB0b1xuXHRcdC8vIHByb3ZpZGUgYSBiaXQgbW9yZSBzcGFjZSB0byBhbGxvdyBcIm92ZXJmbG93XCIgc2Nyb2xsaW5nIChpLmUuIHBhc3QgdGhlIHNjcm9sbGJhcilcblx0XHR2YXIgYlNjcm9sbGluZyA9IHRhYmxlLmhlaWdodCgpID4gZGl2Qm9keUVsLmNsaWVudEhlaWdodCB8fCBkaXZCb2R5LmNzcygnb3ZlcmZsb3cteScpID09IFwic2Nyb2xsXCI7XG5cdFx0dmFyIHBhZGRpbmcgPSAncGFkZGluZycgKyAoYnJvd3Nlci5iU2Nyb2xsYmFyTGVmdCA/ICdMZWZ0JyA6ICdSaWdodCcgKTtcblx0XHRkaXZIZWFkZXJJbm5lclN0eWxlWyBwYWRkaW5nIF0gPSBiU2Nyb2xsaW5nID8gYmFyV2lkdGgrXCJweFwiIDogXCIwcHhcIjtcblx0XG5cdFx0aWYgKCBmb290ZXIgKSB7XG5cdFx0XHRkaXZGb290ZXJUYWJsZVswXS5zdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKCBpT3V0ZXJXaWR0aCApO1xuXHRcdFx0ZGl2Rm9vdGVySW5uZXJbMF0uc3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyggaU91dGVyV2lkdGggKTtcblx0XHRcdGRpdkZvb3RlcklubmVyWzBdLnN0eWxlW3BhZGRpbmddID0gYlNjcm9sbGluZyA/IGJhcldpZHRoK1wicHhcIiA6IFwiMHB4XCI7XG5cdFx0fVxuXHRcblx0XHQvKiBBZGp1c3QgdGhlIHBvc2l0aW9uIG9mIHRoZSBoZWFkZXIgaW4gY2FzZSB3ZSBsb29zZSB0aGUgeS1zY3JvbGxiYXIgKi9cblx0XHRkaXZCb2R5LnNjcm9sbCgpO1xuXHRcblx0XHQvLyBJZiBzb3J0aW5nIG9yIGZpbHRlcmluZyBoYXMgb2NjdXJyZWQsIGp1bXAgdGhlIHNjcm9sbGluZyBiYWNrIHRvIHRoZSB0b3Bcblx0XHQvLyBvbmx5IGlmIHdlIGFyZW4ndCBob2xkaW5nIHRoZSBwb3NpdGlvblxuXHRcdGlmICggKHNldHRpbmdzLmJTb3J0ZWQgfHwgc2V0dGluZ3MuYkZpbHRlcmVkKSAmJiAhIHNldHRpbmdzLl9kcmF3SG9sZCApIHtcblx0XHRcdGRpdkJvZHlFbC5zY3JvbGxUb3AgPSAwO1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdFxuXHQvKipcblx0ICogQXBwbHkgYSBnaXZlbiBmdW5jdGlvbiB0byB0aGUgZGlzcGxheSBjaGlsZCBub2RlcyBvZiBhbiBlbGVtZW50IGFycmF5ICh0eXBpY2FsbHlcblx0ICogVEQgY2hpbGRyZW4gb2YgVFIgcm93c1xuXHQgKiAgQHBhcmFtIHtmdW5jdGlvbn0gZm4gTWV0aG9kIHRvIGFwcGx5IHRvIHRoZSBvYmplY3RzXG5cdCAqICBAcGFyYW0gYXJyYXkge25vZGVzfSBhbjEgTGlzdCBvZiBlbGVtZW50cyB0byBsb29rIHRocm91Z2ggZm9yIGRpc3BsYXkgY2hpbGRyZW5cblx0ICogIEBwYXJhbSBhcnJheSB7bm9kZXN9IGFuMiBBbm90aGVyIGxpc3QgKGlkZW50aWNhbCBzdHJ1Y3R1cmUgdG8gdGhlIGZpcnN0KSAtIG9wdGlvbmFsXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkFwcGx5VG9DaGlsZHJlbiggZm4sIGFuMSwgYW4yIClcblx0e1xuXHRcdHZhciBpbmRleD0wLCBpPTAsIGlMZW49YW4xLmxlbmd0aDtcblx0XHR2YXIgbk5vZGUxLCBuTm9kZTI7XG5cdFxuXHRcdHdoaWxlICggaSA8IGlMZW4gKSB7XG5cdFx0XHRuTm9kZTEgPSBhbjFbaV0uZmlyc3RDaGlsZDtcblx0XHRcdG5Ob2RlMiA9IGFuMiA/IGFuMltpXS5maXJzdENoaWxkIDogbnVsbDtcblx0XG5cdFx0XHR3aGlsZSAoIG5Ob2RlMSApIHtcblx0XHRcdFx0aWYgKCBuTm9kZTEubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0aWYgKCBhbjIgKSB7XG5cdFx0XHRcdFx0XHRmbiggbk5vZGUxLCBuTm9kZTIsIGluZGV4ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0Zm4oIG5Ob2RlMSwgaW5kZXggKTtcblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdG5Ob2RlMSA9IG5Ob2RlMS5uZXh0U2libGluZztcblx0XHRcdFx0bk5vZGUyID0gYW4yID8gbk5vZGUyLm5leHRTaWJsaW5nIDogbnVsbDtcblx0XHRcdH1cblx0XG5cdFx0XHRpKys7XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0XG5cdHZhciBfX3JlX2h0bWxfcmVtb3ZlID0gLzwuKj8+L2c7XG5cdFxuXHRcblx0LyoqXG5cdCAqIENhbGN1bGF0ZSB0aGUgd2lkdGggb2YgY29sdW1ucyBmb3IgdGhlIHRhYmxlXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkNhbGN1bGF0ZUNvbHVtbldpZHRocyAoIG9TZXR0aW5ncyApXG5cdHtcblx0XHR2YXJcblx0XHRcdHRhYmxlID0gb1NldHRpbmdzLm5UYWJsZSxcblx0XHRcdGNvbHVtbnMgPSBvU2V0dGluZ3MuYW9Db2x1bW5zLFxuXHRcdFx0c2Nyb2xsID0gb1NldHRpbmdzLm9TY3JvbGwsXG5cdFx0XHRzY3JvbGxZID0gc2Nyb2xsLnNZLFxuXHRcdFx0c2Nyb2xsWCA9IHNjcm9sbC5zWCxcblx0XHRcdHNjcm9sbFhJbm5lciA9IHNjcm9sbC5zWElubmVyLFxuXHRcdFx0Y29sdW1uQ291bnQgPSBjb2x1bW5zLmxlbmd0aCxcblx0XHRcdHZpc2libGVDb2x1bW5zID0gX2ZuR2V0Q29sdW1ucyggb1NldHRpbmdzLCAnYlZpc2libGUnICksXG5cdFx0XHRoZWFkZXJDZWxscyA9ICQoJ3RoJywgb1NldHRpbmdzLm5USGVhZCksXG5cdFx0XHR0YWJsZVdpZHRoQXR0ciA9IHRhYmxlLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSwgLy8gZnJvbSBET00gZWxlbWVudFxuXHRcdFx0dGFibGVDb250YWluZXIgPSB0YWJsZS5wYXJlbnROb2RlLFxuXHRcdFx0dXNlcklucHV0cyA9IGZhbHNlLFxuXHRcdFx0aSwgY29sdW1uLCBjb2x1bW5JZHgsIHdpZHRoLCBvdXRlcldpZHRoO1xuXHRcblx0XHR2YXIgc3R5bGVXaWR0aCA9IHRhYmxlLnN0eWxlLndpZHRoO1xuXHRcdGlmICggc3R5bGVXaWR0aCAmJiBzdHlsZVdpZHRoLmluZGV4T2YoJyUnKSAhPT0gLTEgKSB7XG5cdFx0XHR0YWJsZVdpZHRoQXR0ciA9IHN0eWxlV2lkdGg7XG5cdFx0fVxuXHRcblx0XHQvKiBDb252ZXJ0IGFueSB1c2VyIGlucHV0IHNpemVzIGludG8gcGl4ZWwgc2l6ZXMgKi9cblx0XHRmb3IgKCBpPTAgOyBpPHZpc2libGVDb2x1bW5zLmxlbmd0aCA7IGkrKyApIHtcblx0XHRcdGNvbHVtbiA9IGNvbHVtbnNbIHZpc2libGVDb2x1bW5zW2ldIF07XG5cdFxuXHRcdFx0aWYgKCBjb2x1bW4uc1dpZHRoICE9PSBudWxsICkge1xuXHRcdFx0XHRjb2x1bW4uc1dpZHRoID0gX2ZuQ29udmVydFRvV2lkdGgoIGNvbHVtbi5zV2lkdGhPcmlnLCB0YWJsZUNvbnRhaW5lciApO1xuXHRcblx0XHRcdFx0dXNlcklucHV0cyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHQvKiBJZiB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIERPTSBlcXVhbHMgdGhlIG51bWJlciB0aGF0IHdlIGhhdmUgdG9cblx0XHQgKiBwcm9jZXNzIGluIERhdGFUYWJsZXMsIHRoZW4gd2UgY2FuIHVzZSB0aGUgb2Zmc2V0cyB0aGF0IGFyZSBjcmVhdGVkIGJ5XG5cdFx0ICogdGhlIHdlYi0gYnJvd3Nlci4gTm8gY3VzdG9tIHNpemVzIGNhbiBiZSBzZXQgaW4gb3JkZXIgZm9yIHRoaXMgdG8gaGFwcGVuLFxuXHRcdCAqIG5vciBzY3JvbGxpbmcgdXNlZFxuXHRcdCAqL1xuXHRcdGlmICggISB1c2VySW5wdXRzICYmICEgc2Nyb2xsWCAmJiAhIHNjcm9sbFkgJiZcblx0XHQgICAgY29sdW1uQ291bnQgPT0gX2ZuVmlzYmxlQ29sdW1ucyggb1NldHRpbmdzICkgJiZcblx0XHRcdGNvbHVtbkNvdW50ID09IGhlYWRlckNlbGxzLmxlbmd0aFxuXHRcdCkge1xuXHRcdFx0Zm9yICggaT0wIDsgaTxjb2x1bW5Db3VudCA7IGkrKyApIHtcblx0XHRcdFx0Y29sdW1uc1tpXS5zV2lkdGggPSBfZm5TdHJpbmdUb0NzcyggaGVhZGVyQ2VsbHMuZXEoaSkud2lkdGgoKSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0Ly8gT3RoZXJ3aXNlIGNvbnN0cnVjdCBhIHNpbmdsZSByb3csIHdvcnN0IGNhc2UsIHRhYmxlIHdpdGggdGhlIHdpZGVzdFxuXHRcdFx0Ly8gbm9kZSBpbiB0aGUgZGF0YSwgYXNzaWduIGFueSB1c2VyIGRlZmluZWQgd2lkdGhzLCB0aGVuIGluc2VydCBpdCBpbnRvXG5cdFx0XHQvLyB0aGUgRE9NIGFuZCBhbGxvdyB0aGUgYnJvd3NlciB0byBkbyBhbGwgdGhlIGhhcmQgd29yayBvZiBjYWxjdWxhdGluZ1xuXHRcdFx0Ly8gdGFibGUgd2lkdGhzXG5cdFx0XHR2YXIgdG1wVGFibGUgPSAkKHRhYmxlKS5jbG9uZSgpIC8vIGRvbid0IHVzZSBjbG9uZU5vZGUgLSBJRTggd2lsbCByZW1vdmUgZXZlbnRzIG9uIHRoZSBtYWluIHRhYmxlXG5cdFx0XHRcdC5jc3MoICd2aXNpYmlsaXR5JywgJ2hpZGRlbicgKVxuXHRcdFx0XHQucmVtb3ZlQXR0ciggJ2lkJyApO1xuXHRcblx0XHRcdC8vIENsZWFuIHVwIHRoZSB0YWJsZSBib2R5XG5cdFx0XHR0bXBUYWJsZS5maW5kKCd0Ym9keSB0cicpLnJlbW92ZSgpO1xuXHRcdFx0dmFyIHRyID0gJCgnPHRyLz4nKS5hcHBlbmRUbyggdG1wVGFibGUuZmluZCgndGJvZHknKSApO1xuXHRcblx0XHRcdC8vIFJlbW92ZSBhbnkgYXNzaWduZWQgd2lkdGhzIGZyb20gdGhlIGZvb3RlciAoZnJvbSBzY3JvbGxpbmcpXG5cdFx0XHR0bXBUYWJsZS5maW5kKCd0Zm9vdCB0aCwgdGZvb3QgdGQnKS5jc3MoJ3dpZHRoJywgJycpO1xuXHRcblx0XHRcdC8vIEFwcGx5IGN1c3RvbSBzaXppbmcgdG8gdGhlIGNsb25lZCBoZWFkZXJcblx0XHRcdGhlYWRlckNlbGxzID0gX2ZuR2V0VW5pcXVlVGhzKCBvU2V0dGluZ3MsIHRtcFRhYmxlLmZpbmQoJ3RoZWFkJylbMF0gKTtcblx0XG5cdFx0XHRmb3IgKCBpPTAgOyBpPHZpc2libGVDb2x1bW5zLmxlbmd0aCA7IGkrKyApIHtcblx0XHRcdFx0Y29sdW1uID0gY29sdW1uc1sgdmlzaWJsZUNvbHVtbnNbaV0gXTtcblx0XG5cdFx0XHRcdGhlYWRlckNlbGxzW2ldLnN0eWxlLndpZHRoID0gY29sdW1uLnNXaWR0aE9yaWcgIT09IG51bGwgJiYgY29sdW1uLnNXaWR0aE9yaWcgIT09ICcnID9cblx0XHRcdFx0XHRfZm5TdHJpbmdUb0NzcyggY29sdW1uLnNXaWR0aE9yaWcgKSA6XG5cdFx0XHRcdFx0Jyc7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gRmluZCB0aGUgd2lkZXN0IGNlbGwgZm9yIGVhY2ggY29sdW1uIGFuZCBwdXQgaXQgaW50byB0aGUgdGFibGVcblx0XHRcdGlmICggb1NldHRpbmdzLmFvRGF0YS5sZW5ndGggKSB7XG5cdFx0XHRcdGZvciAoIGk9MCA7IGk8dmlzaWJsZUNvbHVtbnMubGVuZ3RoIDsgaSsrICkge1xuXHRcdFx0XHRcdGNvbHVtbklkeCA9IHZpc2libGVDb2x1bW5zW2ldO1xuXHRcdFx0XHRcdGNvbHVtbiA9IGNvbHVtbnNbIGNvbHVtbklkeCBdO1xuXHRcblx0XHRcdFx0XHQkKCBfZm5HZXRXaWRlc3ROb2RlKCBvU2V0dGluZ3MsIGNvbHVtbklkeCApIClcblx0XHRcdFx0XHRcdC5jbG9uZSggZmFsc2UgKVxuXHRcdFx0XHRcdFx0LmFwcGVuZCggY29sdW1uLnNDb250ZW50UGFkZGluZyApXG5cdFx0XHRcdFx0XHQuYXBwZW5kVG8oIHRyICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHQvLyBUYWJsZSBoYXMgYmVlbiBidWlsdCwgYXR0YWNoIHRvIHRoZSBkb2N1bWVudCBzbyB3ZSBjYW4gd29yayB3aXRoIGl0XG5cdFx0XHR0bXBUYWJsZS5hcHBlbmRUbyggdGFibGVDb250YWluZXIgKTtcblx0XG5cdFx0XHQvLyBXaGVuIHNjcm9sbGluZyAoWCBvciBZKSB3ZSB3YW50IHRvIHNldCB0aGUgd2lkdGggb2YgdGhlIHRhYmxlIGFzIFxuXHRcdFx0Ly8gYXBwcm9wcmlhdGUuIEhvd2V2ZXIsIHdoZW4gbm90IHNjcm9sbGluZyBsZWF2ZSB0aGUgdGFibGUgd2lkdGggYXMgaXRcblx0XHRcdC8vIGlzLiBUaGlzIHJlc3VsdHMgaW4gc2xpZ2h0bHkgZGlmZmVyZW50LCBidXQgSSB0aGluayBjb3JyZWN0IGJlaGF2aW91clxuXHRcdFx0aWYgKCBzY3JvbGxYICYmIHNjcm9sbFhJbm5lciApIHtcblx0XHRcdFx0dG1wVGFibGUud2lkdGgoIHNjcm9sbFhJbm5lciApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHNjcm9sbFggKSB7XG5cdFx0XHRcdHRtcFRhYmxlLmNzcyggJ3dpZHRoJywgJ2F1dG8nICk7XG5cdFxuXHRcdFx0XHRpZiAoIHRtcFRhYmxlLndpZHRoKCkgPCB0YWJsZUNvbnRhaW5lci5vZmZzZXRXaWR0aCApIHtcblx0XHRcdFx0XHR0bXBUYWJsZS53aWR0aCggdGFibGVDb250YWluZXIub2Zmc2V0V2lkdGggKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHNjcm9sbFkgKSB7XG5cdFx0XHRcdHRtcFRhYmxlLndpZHRoKCB0YWJsZUNvbnRhaW5lci5vZmZzZXRXaWR0aCApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHRhYmxlV2lkdGhBdHRyICkge1xuXHRcdFx0XHR0bXBUYWJsZS53aWR0aCggdGFibGVXaWR0aEF0dHIgKTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBUYWtlIGludG8gYWNjb3VudCB0aGUgeSBzY3JvbGxiYXJcblx0XHRcdF9mblNjcm9sbGluZ1dpZHRoQWRqdXN0KCBvU2V0dGluZ3MsIHRtcFRhYmxlWzBdICk7XG5cdFxuXHRcdFx0Ly8gQnJvd3NlcnMgbmVlZCBhIGJpdCBvZiBhIGhhbmQgd2hlbiBhIHdpZHRoIGlzIGFzc2lnbmVkIHRvIGFueSBjb2x1bW5zXG5cdFx0XHQvLyB3aGVuIHgtc2Nyb2xsaW5nIGFzIHRoZXkgdGVuZCB0byBjb2xsYXBzZSB0aGUgdGFibGUgdG8gdGhlIG1pbi13aWR0aCxcblx0XHRcdC8vIGV2ZW4gaWYgd2Ugc2VudCB0aGUgY29sdW1uIHdpZHRocy4gU28gd2UgbmVlZCB0byBrZWVwIHRyYWNrIG9mIHdoYXRcblx0XHRcdC8vIHRoZSB0YWJsZSB3aWR0aCBzaG91bGQgYmUgYnkgc3VtbWluZyB0aGUgdXNlciBnaXZlbiB2YWx1ZXMsIGFuZCB0aGVcblx0XHRcdC8vIGF1dG9tYXRpYyB2YWx1ZXNcblx0XHRcdGlmICggc2Nyb2xsWCApXG5cdFx0XHR7XG5cdFx0XHRcdHZhciB0b3RhbCA9IDA7XG5cdFxuXHRcdFx0XHRmb3IgKCBpPTAgOyBpPHZpc2libGVDb2x1bW5zLmxlbmd0aCA7IGkrKyApIHtcblx0XHRcdFx0XHRjb2x1bW4gPSBjb2x1bW5zWyB2aXNpYmxlQ29sdW1uc1tpXSBdO1xuXHRcdFx0XHRcdG91dGVyV2lkdGggPSAkKGhlYWRlckNlbGxzW2ldKS5vdXRlcldpZHRoKCk7XG5cdFxuXHRcdFx0XHRcdHRvdGFsICs9IGNvbHVtbi5zV2lkdGhPcmlnID09PSBudWxsID9cblx0XHRcdFx0XHRcdG91dGVyV2lkdGggOlxuXHRcdFx0XHRcdFx0cGFyc2VJbnQoIGNvbHVtbi5zV2lkdGgsIDEwICkgKyBvdXRlcldpZHRoIC0gJChoZWFkZXJDZWxsc1tpXSkud2lkdGgoKTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0dG1wVGFibGUud2lkdGgoIF9mblN0cmluZ1RvQ3NzKCB0b3RhbCApICk7XG5cdFx0XHRcdHRhYmxlLnN0eWxlLndpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoIHRvdGFsICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gR2V0IHRoZSB3aWR0aCBvZiBlYWNoIGNvbHVtbiBpbiB0aGUgY29uc3RydWN0ZWQgdGFibGVcblx0XHRcdGZvciAoIGk9MCA7IGk8dmlzaWJsZUNvbHVtbnMubGVuZ3RoIDsgaSsrICkge1xuXHRcdFx0XHRjb2x1bW4gPSBjb2x1bW5zWyB2aXNpYmxlQ29sdW1uc1tpXSBdO1xuXHRcdFx0XHR3aWR0aCA9ICQoaGVhZGVyQ2VsbHNbaV0pLndpZHRoKCk7XG5cdFxuXHRcdFx0XHRpZiAoIHdpZHRoICkge1xuXHRcdFx0XHRcdGNvbHVtbi5zV2lkdGggPSBfZm5TdHJpbmdUb0Nzcyggd2lkdGggKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdHRhYmxlLnN0eWxlLndpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoIHRtcFRhYmxlLmNzcygnd2lkdGgnKSApO1xuXHRcblx0XHRcdC8vIEZpbmlzaGVkIHdpdGggdGhlIHRhYmxlIC0gZGl0Y2ggaXRcblx0XHRcdHRtcFRhYmxlLnJlbW92ZSgpO1xuXHRcdH1cblx0XG5cdFx0Ly8gSWYgdGhlcmUgaXMgYSB3aWR0aCBhdHRyLCB3ZSB3YW50IHRvIGF0dGFjaCBhbiBldmVudCBsaXN0ZW5lciB3aGljaFxuXHRcdC8vIGFsbG93cyB0aGUgdGFibGUgc2l6aW5nIHRvIGF1dG9tYXRpY2FsbHkgYWRqdXN0IHdoZW4gdGhlIHdpbmRvdyBpc1xuXHRcdC8vIHJlc2l6ZWQuIFVzZSB0aGUgd2lkdGggYXR0ciByYXRoZXIgdGhhbiBDU1MsIHNpbmNlIHdlIGNhbid0IGtub3cgaWYgdGhlXG5cdFx0Ly8gQ1NTIGlzIGEgcmVsYXRpdmUgdmFsdWUgb3IgYWJzb2x1dGUgLSBET00gcmVhZCBpcyBhbHdheXMgcHguXG5cdFx0aWYgKCB0YWJsZVdpZHRoQXR0ciApIHtcblx0XHRcdHRhYmxlLnN0eWxlLndpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoIHRhYmxlV2lkdGhBdHRyICk7XG5cdFx0fVxuXHRcblx0XHRpZiAoICh0YWJsZVdpZHRoQXR0ciB8fCBzY3JvbGxYKSAmJiAhIG9TZXR0aW5ncy5fcmVzekV2dCApIHtcblx0XHRcdHZhciBiaW5kUmVzaXplID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHQkKHdpbmRvdykuYmluZCgncmVzaXplLkRULScrb1NldHRpbmdzLnNJbnN0YW5jZSwgX2ZuVGhyb3R0bGUoIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRfZm5BZGp1c3RDb2x1bW5TaXppbmcoIG9TZXR0aW5ncyApO1xuXHRcdFx0XHR9ICkgKTtcblx0XHRcdH07XG5cdFxuXHRcdFx0Ly8gSUU2Lzcgd2lsbCBjcmFzaCBpZiB3ZSBiaW5kIGEgcmVzaXplIGV2ZW50IGhhbmRsZXIgb24gcGFnZSBsb2FkLlxuXHRcdFx0Ly8gVG8gYmUgcmVtb3ZlZCBpbiAxLjExIHdoaWNoIGRyb3BzIElFNi83IHN1cHBvcnRcblx0XHRcdGlmICggb1NldHRpbmdzLm9Ccm93c2VyLmJTY3JvbGxPdmVyc2l6ZSApIHtcblx0XHRcdFx0c2V0VGltZW91dCggYmluZFJlc2l6ZSwgMTAwMCApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGJpbmRSZXNpemUoKTtcblx0XHRcdH1cblx0XG5cdFx0XHRvU2V0dGluZ3MuX3Jlc3pFdnQgPSB0cnVlO1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBUaHJvdHRsZSB0aGUgY2FsbHMgdG8gYSBmdW5jdGlvbi4gQXJndW1lbnRzIGFuZCBjb250ZXh0IGFyZSBtYWludGFpbmVkIGZvclxuXHQgKiB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uXG5cdCAqICBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBiZSBjYWxsZWRcblx0ICogIEBwYXJhbSB7aW50fSBbZnJlcT0yMDBdIGNhbGwgZnJlcXVlbmN5IGluIG1TXG5cdCAqICBAcmV0dXJucyB7ZnVuY3Rpb259IHdyYXBwZWQgZnVuY3Rpb25cblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuVGhyb3R0bGUoIGZuLCBmcmVxICkge1xuXHRcdHZhclxuXHRcdFx0ZnJlcXVlbmN5ID0gZnJlcSAhPT0gdW5kZWZpbmVkID8gZnJlcSA6IDIwMCxcblx0XHRcdGxhc3QsXG5cdFx0XHR0aW1lcjtcblx0XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhclxuXHRcdFx0XHR0aGF0ID0gdGhpcyxcblx0XHRcdFx0bm93ICA9ICtuZXcgRGF0ZSgpLFxuXHRcdFx0XHRhcmdzID0gYXJndW1lbnRzO1xuXHRcblx0XHRcdGlmICggbGFzdCAmJiBub3cgPCBsYXN0ICsgZnJlcXVlbmN5ICkge1xuXHRcdFx0XHRjbGVhclRpbWVvdXQoIHRpbWVyICk7XG5cdFxuXHRcdFx0XHR0aW1lciA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRsYXN0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdGZuLmFwcGx5KCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdH0sIGZyZXF1ZW5jeSApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGxhc3QgPSBub3c7XG5cdFx0XHRcdGZuLmFwcGx5KCB0aGF0LCBhcmdzICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBDb252ZXJ0IGEgQ1NTIHVuaXQgd2lkdGggdG8gcGl4ZWxzIChlLmcuIDJlbSlcblx0ICogIEBwYXJhbSB7c3RyaW5nfSB3aWR0aCB3aWR0aCB0byBiZSBjb252ZXJ0ZWRcblx0ICogIEBwYXJhbSB7bm9kZX0gcGFyZW50IHBhcmVudCB0byBnZXQgdGhlIHdpdGggZm9yIChyZXF1aXJlZCBmb3IgcmVsYXRpdmUgd2lkdGhzKSAtIG9wdGlvbmFsXG5cdCAqICBAcmV0dXJucyB7aW50fSB3aWR0aCBpbiBwaXhlbHNcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQ29udmVydFRvV2lkdGggKCB3aWR0aCwgcGFyZW50IClcblx0e1xuXHRcdGlmICggISB3aWR0aCApIHtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblx0XG5cdFx0dmFyIG4gPSAkKCc8ZGl2Lz4nKVxuXHRcdFx0LmNzcyggJ3dpZHRoJywgX2ZuU3RyaW5nVG9Dc3MoIHdpZHRoICkgKVxuXHRcdFx0LmFwcGVuZFRvKCBwYXJlbnQgfHwgZG9jdW1lbnQuYm9keSApO1xuXHRcblx0XHR2YXIgdmFsID0gblswXS5vZmZzZXRXaWR0aDtcblx0XHRuLnJlbW92ZSgpO1xuXHRcblx0XHRyZXR1cm4gdmFsO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEFkanVzdCBhIHRhYmxlJ3Mgd2lkdGggdG8gdGFrZSBhY2NvdW50IG9mIHZlcnRpY2FsIHNjcm9sbCBiYXJcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7bm9kZX0gbiB0YWJsZSBub2RlXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdFxuXHRmdW5jdGlvbiBfZm5TY3JvbGxpbmdXaWR0aEFkanVzdCAoIHNldHRpbmdzLCBuIClcblx0e1xuXHRcdHZhciBzY3JvbGwgPSBzZXR0aW5ncy5vU2Nyb2xsO1xuXHRcblx0XHRpZiAoIHNjcm9sbC5zWCB8fCBzY3JvbGwuc1kgKSB7XG5cdFx0XHQvLyBXaGVuIHktc2Nyb2xsaW5nIG9ubHksIHdlIHdhbnQgdG8gcmVtb3ZlIHRoZSB3aWR0aCBvZiB0aGUgc2Nyb2xsIGJhclxuXHRcdFx0Ly8gc28gdGhlIHRhYmxlICsgc2Nyb2xsIGJhciB3aWxsIGZpdCBpbnRvIHRoZSBhcmVhIGF2YWlsYWJsZSwgb3RoZXJ3aXNlXG5cdFx0XHQvLyB3ZSBmaXggdGhlIHRhYmxlIGF0IGl0cyBjdXJyZW50IHNpemUgd2l0aCBubyBhZGp1c3RtZW50XG5cdFx0XHR2YXIgY29ycmVjdGlvbiA9ICEgc2Nyb2xsLnNYID8gc2Nyb2xsLmlCYXJXaWR0aCA6IDA7XG5cdFx0XHRuLnN0eWxlLndpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoICQobikub3V0ZXJXaWR0aCgpIC0gY29ycmVjdGlvbiApO1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBHZXQgdGhlIHdpZGVzdCBub2RlXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7aW50fSBjb2xJZHggY29sdW1uIG9mIGludGVyZXN0XG5cdCAqICBAcmV0dXJucyB7bm9kZX0gd2lkZXN0IHRhYmxlIG5vZGVcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuR2V0V2lkZXN0Tm9kZSggc2V0dGluZ3MsIGNvbElkeCApXG5cdHtcblx0XHR2YXIgaWR4ID0gX2ZuR2V0TWF4TGVuU3RyaW5nKCBzZXR0aW5ncywgY29sSWR4ICk7XG5cdFx0aWYgKCBpZHggPCAwICkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcblx0XHR2YXIgZGF0YSA9IHNldHRpbmdzLmFvRGF0YVsgaWR4IF07XG5cdFx0cmV0dXJuICEgZGF0YS5uVHIgPyAvLyBNaWdodCBub3QgaGF2ZSBiZWVuIGNyZWF0ZWQgd2hlbiBkZWZlcnJlZCByZW5kZXJpbmdcblx0XHRcdCQoJzx0ZC8+JykuaHRtbCggX2ZuR2V0Q2VsbERhdGEoIHNldHRpbmdzLCBpZHgsIGNvbElkeCwgJ2Rpc3BsYXknICkgKVswXSA6XG5cdFx0XHRkYXRhLmFuQ2VsbHNbIGNvbElkeCBdO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEdldCB0aGUgbWF4aW11bSBzdHJsZW4gZm9yIGVhY2ggZGF0YSBjb2x1bW5cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtpbnR9IGNvbElkeCBjb2x1bW4gb2YgaW50ZXJlc3Rcblx0ICogIEByZXR1cm5zIHtzdHJpbmd9IG1heCBzdHJpbmcgbGVuZ3RoIGZvciBlYWNoIGNvbHVtblxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5HZXRNYXhMZW5TdHJpbmcoIHNldHRpbmdzLCBjb2xJZHggKVxuXHR7XG5cdFx0dmFyIHMsIG1heD0tMSwgbWF4SWR4ID0gLTE7XG5cdFxuXHRcdGZvciAoIHZhciBpPTAsIGllbj1zZXR0aW5ncy5hb0RhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRzID0gX2ZuR2V0Q2VsbERhdGEoIHNldHRpbmdzLCBpLCBjb2xJZHgsICdkaXNwbGF5JyApKycnO1xuXHRcdFx0cyA9IHMucmVwbGFjZSggX19yZV9odG1sX3JlbW92ZSwgJycgKTtcblx0XG5cdFx0XHRpZiAoIHMubGVuZ3RoID4gbWF4ICkge1xuXHRcdFx0XHRtYXggPSBzLmxlbmd0aDtcblx0XHRcdFx0bWF4SWR4ID0gaTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdHJldHVybiBtYXhJZHg7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogQXBwZW5kIGEgQ1NTIHVuaXQgKG9ubHkgaWYgcmVxdWlyZWQpIHRvIGEgc3RyaW5nXG5cdCAqICBAcGFyYW0ge3N0cmluZ30gdmFsdWUgdG8gY3NzLWlmeVxuXHQgKiAgQHJldHVybnMge3N0cmluZ30gdmFsdWUgd2l0aCBjc3MgdW5pdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5TdHJpbmdUb0NzcyggcyApXG5cdHtcblx0XHRpZiAoIHMgPT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gJzBweCc7XG5cdFx0fVxuXHRcblx0XHRpZiAoIHR5cGVvZiBzID09ICdudW1iZXInICkge1xuXHRcdFx0cmV0dXJuIHMgPCAwID9cblx0XHRcdFx0JzBweCcgOlxuXHRcdFx0XHRzKydweCc7XG5cdFx0fVxuXHRcblx0XHQvLyBDaGVjayBpdCBoYXMgYSB1bml0IGNoYXJhY3RlciBhbHJlYWR5XG5cdFx0cmV0dXJuIHMubWF0Y2goL1xcZCQvKSA/XG5cdFx0XHRzKydweCcgOlxuXHRcdFx0cztcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBHZXQgdGhlIHdpZHRoIG9mIGEgc2Nyb2xsIGJhciBpbiB0aGlzIGJyb3dzZXIgYmVpbmcgdXNlZFxuXHQgKiAgQHJldHVybnMge2ludH0gd2lkdGggaW4gcGl4ZWxzXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mblNjcm9sbEJhcldpZHRoICgpXG5cdHtcblx0XHQvLyBPbiBmaXJzdCBydW4gYSBzdGF0aWMgdmFyaWFibGUgaXMgc2V0LCBzaW5jZSB0aGlzIGlzIG9ubHkgbmVlZGVkIG9uY2UuXG5cdFx0Ly8gU3Vic2VxdWVudCBydW5zIHdpbGwganVzdCB1c2UgdGhlIHByZXZpb3VzbHkgY2FsY3VsYXRlZCB2YWx1ZVxuXHRcdHZhciB3aWR0aCA9IERhdGFUYWJsZS5fX3Njcm9sbGJhcldpZHRoO1xuXHRcblx0XHRpZiAoIHdpZHRoID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YXIgc2l6ZXIgPSAkKCc8cC8+JykuY3NzKCB7XG5cdFx0XHRcdFx0cG9zaXRpb246ICdhYnNvbHV0ZScsXG5cdFx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRcdGxlZnQ6IDAsXG5cdFx0XHRcdFx0d2lkdGg6ICcxMDAlJyxcblx0XHRcdFx0XHRoZWlnaHQ6IDE1MCxcblx0XHRcdFx0XHRwYWRkaW5nOiAwLFxuXHRcdFx0XHRcdG92ZXJmbG93OiAnc2Nyb2xsJyxcblx0XHRcdFx0XHR2aXNpYmlsaXR5OiAnaGlkZGVuJ1xuXHRcdFx0XHR9IClcblx0XHRcdFx0LmFwcGVuZFRvKCdib2R5Jyk7XG5cdFxuXHRcdFx0d2lkdGggPSBzaXplclswXS5vZmZzZXRXaWR0aCAtIHNpemVyWzBdLmNsaWVudFdpZHRoO1xuXHRcdFx0RGF0YVRhYmxlLl9fc2Nyb2xsYmFyV2lkdGggPSB3aWR0aDtcblx0XG5cdFx0XHRzaXplci5yZW1vdmUoKTtcblx0XHR9XG5cdFxuXHRcdHJldHVybiB3aWR0aDtcblx0fVxuXHRcblx0XG5cdFxuXHRmdW5jdGlvbiBfZm5Tb3J0RmxhdHRlbiAoIHNldHRpbmdzIClcblx0e1xuXHRcdHZhclxuXHRcdFx0aSwgaUxlbiwgaywga0xlbixcblx0XHRcdGFTb3J0ID0gW10sXG5cdFx0XHRhaU9yaWcgPSBbXSxcblx0XHRcdGFvQ29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucyxcblx0XHRcdGFEYXRhU29ydCwgaUNvbCwgc1R5cGUsIHNyY0NvbCxcblx0XHRcdGZpeGVkID0gc2V0dGluZ3MuYWFTb3J0aW5nRml4ZWQsXG5cdFx0XHRmaXhlZE9iaiA9ICQuaXNQbGFpbk9iamVjdCggZml4ZWQgKSxcblx0XHRcdG5lc3RlZFNvcnQgPSBbXSxcblx0XHRcdGFkZCA9IGZ1bmN0aW9uICggYSApIHtcblx0XHRcdFx0aWYgKCBhLmxlbmd0aCAmJiAhICQuaXNBcnJheSggYVswXSApICkge1xuXHRcdFx0XHRcdC8vIDFEIGFycmF5XG5cdFx0XHRcdFx0bmVzdGVkU29ydC5wdXNoKCBhICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Ly8gMkQgYXJyYXlcblx0XHRcdFx0XHRuZXN0ZWRTb3J0LnB1c2guYXBwbHkoIG5lc3RlZFNvcnQsIGEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XG5cdFx0Ly8gQnVpbGQgdGhlIHNvcnQgYXJyYXksIHdpdGggcHJlLWZpeCBhbmQgcG9zdC1maXggb3B0aW9ucyBpZiB0aGV5IGhhdmUgYmVlblxuXHRcdC8vIHNwZWNpZmllZFxuXHRcdGlmICggJC5pc0FycmF5KCBmaXhlZCApICkge1xuXHRcdFx0YWRkKCBmaXhlZCApO1xuXHRcdH1cblx0XG5cdFx0aWYgKCBmaXhlZE9iaiAmJiBmaXhlZC5wcmUgKSB7XG5cdFx0XHRhZGQoIGZpeGVkLnByZSApO1xuXHRcdH1cblx0XG5cdFx0YWRkKCBzZXR0aW5ncy5hYVNvcnRpbmcgKTtcblx0XG5cdFx0aWYgKGZpeGVkT2JqICYmIGZpeGVkLnBvc3QgKSB7XG5cdFx0XHRhZGQoIGZpeGVkLnBvc3QgKTtcblx0XHR9XG5cdFxuXHRcdGZvciAoIGk9MCA7IGk8bmVzdGVkU29ydC5sZW5ndGggOyBpKysgKVxuXHRcdHtcblx0XHRcdHNyY0NvbCA9IG5lc3RlZFNvcnRbaV1bMF07XG5cdFx0XHRhRGF0YVNvcnQgPSBhb0NvbHVtbnNbIHNyY0NvbCBdLmFEYXRhU29ydDtcblx0XG5cdFx0XHRmb3IgKCBrPTAsIGtMZW49YURhdGFTb3J0Lmxlbmd0aCA7IGs8a0xlbiA7IGsrKyApXG5cdFx0XHR7XG5cdFx0XHRcdGlDb2wgPSBhRGF0YVNvcnRba107XG5cdFx0XHRcdHNUeXBlID0gYW9Db2x1bW5zWyBpQ29sIF0uc1R5cGUgfHwgJ3N0cmluZyc7XG5cdFxuXHRcdFx0XHRpZiAoIG5lc3RlZFNvcnRbaV0uX2lkeCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdG5lc3RlZFNvcnRbaV0uX2lkeCA9ICQuaW5BcnJheSggbmVzdGVkU29ydFtpXVsxXSwgYW9Db2x1bW5zW2lDb2xdLmFzU29ydGluZyApO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRhU29ydC5wdXNoKCB7XG5cdFx0XHRcdFx0c3JjOiAgICAgICBzcmNDb2wsXG5cdFx0XHRcdFx0Y29sOiAgICAgICBpQ29sLFxuXHRcdFx0XHRcdGRpcjogICAgICAgbmVzdGVkU29ydFtpXVsxXSxcblx0XHRcdFx0XHRpbmRleDogICAgIG5lc3RlZFNvcnRbaV0uX2lkeCxcblx0XHRcdFx0XHR0eXBlOiAgICAgIHNUeXBlLFxuXHRcdFx0XHRcdGZvcm1hdHRlcjogRGF0YVRhYmxlLmV4dC50eXBlLm9yZGVyWyBzVHlwZStcIi1wcmVcIiBdXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdHJldHVybiBhU29ydDtcblx0fVxuXHRcblx0LyoqXG5cdCAqIENoYW5nZSB0aGUgb3JkZXIgb2YgdGhlIHRhYmxlXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICogIEB0b2RvIFRoaXMgcmVhbGx5IG5lZWRzIHNwbGl0IHVwIVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuU29ydCAoIG9TZXR0aW5ncyApXG5cdHtcblx0XHR2YXJcblx0XHRcdGksIGllbiwgaUxlbiwgaiwgakxlbiwgaywga0xlbixcblx0XHRcdHNEYXRhVHlwZSwgblRoLFxuXHRcdFx0YWlPcmlnID0gW10sXG5cdFx0XHRvRXh0U29ydCA9IERhdGFUYWJsZS5leHQudHlwZS5vcmRlcixcblx0XHRcdGFvRGF0YSA9IG9TZXR0aW5ncy5hb0RhdGEsXG5cdFx0XHRhb0NvbHVtbnMgPSBvU2V0dGluZ3MuYW9Db2x1bW5zLFxuXHRcdFx0YURhdGFTb3J0LCBkYXRhLCBpQ29sLCBzVHlwZSwgb1NvcnQsXG5cdFx0XHRmb3JtYXR0ZXJzID0gMCxcblx0XHRcdHNvcnRDb2wsXG5cdFx0XHRkaXNwbGF5TWFzdGVyID0gb1NldHRpbmdzLmFpRGlzcGxheU1hc3Rlcixcblx0XHRcdGFTb3J0O1xuXHRcblx0XHQvLyBSZXNvbHZlIGFueSBjb2x1bW4gdHlwZXMgdGhhdCBhcmUgdW5rbm93biBkdWUgdG8gYWRkaXRpb24gb3IgaW52YWxpZGF0aW9uXG5cdFx0Ly8gQHRvZG8gQ2FuIHRoaXMgYmUgbW92ZWQgaW50byBhICdkYXRhLXJlYWR5JyBoYW5kbGVyIHdoaWNoIGlzIGNhbGxlZCB3aGVuXG5cdFx0Ly8gICBkYXRhIGlzIGdvaW5nIHRvIGJlIHVzZWQgaW4gdGhlIHRhYmxlP1xuXHRcdF9mbkNvbHVtblR5cGVzKCBvU2V0dGluZ3MgKTtcblx0XG5cdFx0YVNvcnQgPSBfZm5Tb3J0RmxhdHRlbiggb1NldHRpbmdzICk7XG5cdFxuXHRcdGZvciAoIGk9MCwgaWVuPWFTb3J0Lmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0c29ydENvbCA9IGFTb3J0W2ldO1xuXHRcblx0XHRcdC8vIFRyYWNrIGlmIHdlIGNhbiB1c2UgdGhlIGZhc3Qgc29ydCBhbGdvcml0aG1cblx0XHRcdGlmICggc29ydENvbC5mb3JtYXR0ZXIgKSB7XG5cdFx0XHRcdGZvcm1hdHRlcnMrKztcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBMb2FkIHRoZSBkYXRhIG5lZWRlZCBmb3IgdGhlIHNvcnQsIGZvciBlYWNoIGNlbGxcblx0XHRcdF9mblNvcnREYXRhKCBvU2V0dGluZ3MsIHNvcnRDb2wuY29sICk7XG5cdFx0fVxuXHRcblx0XHQvKiBObyBzb3J0aW5nIHJlcXVpcmVkIGlmIHNlcnZlci1zaWRlIG9yIG5vIHNvcnRpbmcgYXJyYXkgKi9cblx0XHRpZiAoIF9mbkRhdGFTb3VyY2UoIG9TZXR0aW5ncyApICE9ICdzc3AnICYmIGFTb3J0Lmxlbmd0aCAhPT0gMCApXG5cdFx0e1xuXHRcdFx0Ly8gQ3JlYXRlIGEgdmFsdWUgLSBrZXkgYXJyYXkgb2YgdGhlIGN1cnJlbnQgcm93IHBvc2l0aW9ucyBzdWNoIHRoYXQgd2UgY2FuIHVzZSB0aGVpclxuXHRcdFx0Ly8gY3VycmVudCBwb3NpdGlvbiBkdXJpbmcgdGhlIHNvcnQsIGlmIHZhbHVlcyBtYXRjaCwgaW4gb3JkZXIgdG8gcGVyZm9ybSBzdGFibGUgc29ydGluZ1xuXHRcdFx0Zm9yICggaT0wLCBpTGVuPWRpc3BsYXlNYXN0ZXIubGVuZ3RoIDsgaTxpTGVuIDsgaSsrICkge1xuXHRcdFx0XHRhaU9yaWdbIGRpc3BsYXlNYXN0ZXJbaV0gXSA9IGk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0LyogRG8gdGhlIHNvcnQgLSBoZXJlIHdlIHdhbnQgbXVsdGktY29sdW1uIHNvcnRpbmcgYmFzZWQgb24gYSBnaXZlbiBkYXRhIHNvdXJjZSAoY29sdW1uKVxuXHRcdFx0ICogYW5kIHNvcnRpbmcgZnVuY3Rpb24gKGZyb20gb1NvcnQpIGluIGEgY2VydGFpbiBkaXJlY3Rpb24uIEl0J3MgcmVhc29uYWJseSBjb21wbGV4IHRvXG5cdFx0XHQgKiBmb2xsb3cgb24gaXQncyBvd24sIGJ1dCB0aGlzIGlzIHdoYXQgd2Ugd2FudCAoZXhhbXBsZSB0d28gY29sdW1uIHNvcnRpbmcpOlxuXHRcdFx0ICogIGZuTG9jYWxTb3J0aW5nID0gZnVuY3Rpb24oYSxiKXtcblx0XHRcdCAqICAgIHZhciBpVGVzdDtcblx0XHRcdCAqICAgIGlUZXN0ID0gb1NvcnRbJ3N0cmluZy1hc2MnXSgnZGF0YTExJywgJ2RhdGExMicpO1xuXHRcdFx0ICogICAgICBpZiAoaVRlc3QgIT09IDApXG5cdFx0XHQgKiAgICAgICAgcmV0dXJuIGlUZXN0O1xuXHRcdFx0ICogICAgaVRlc3QgPSBvU29ydFsnbnVtZXJpYy1kZXNjJ10oJ2RhdGEyMScsICdkYXRhMjInKTtcblx0XHRcdCAqICAgIGlmIChpVGVzdCAhPT0gMClcblx0XHRcdCAqICAgICAgcmV0dXJuIGlUZXN0O1xuXHRcdFx0ICogICAgcmV0dXJuIG9Tb3J0WydudW1lcmljLWFzYyddKCBhaU9yaWdbYV0sIGFpT3JpZ1tiXSApO1xuXHRcdFx0ICogIH1cblx0XHRcdCAqIEJhc2ljYWxseSB3ZSBoYXZlIGEgdGVzdCBmb3IgZWFjaCBzb3J0aW5nIGNvbHVtbiwgaWYgdGhlIGRhdGEgaW4gdGhhdCBjb2x1bW4gaXMgZXF1YWwsXG5cdFx0XHQgKiB0ZXN0IHRoZSBuZXh0IGNvbHVtbi4gSWYgYWxsIGNvbHVtbnMgbWF0Y2gsIHRoZW4gd2UgdXNlIGEgbnVtZXJpYyBzb3J0IG9uIHRoZSByb3dcblx0XHRcdCAqIHBvc2l0aW9ucyBpbiB0aGUgb3JpZ2luYWwgZGF0YSBhcnJheSB0byBwcm92aWRlIGEgc3RhYmxlIHNvcnQuXG5cdFx0XHQgKlxuXHRcdFx0ICogTm90ZSAtIEkga25vdyBpdCBzZWVtcyBleGNlc3NpdmUgdG8gaGF2ZSB0d28gc29ydGluZyBtZXRob2RzLCBidXQgdGhlIGZpcnN0IGlzIGFyb3VuZFxuXHRcdFx0ICogMTUlIGZhc3Rlciwgc28gdGhlIHNlY29uZCBpcyBvbmx5IG1haW50YWluZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggc29ydGluZ1xuXHRcdFx0ICogbWV0aG9kcyB3aGljaCBkbyBub3QgaGF2ZSBhIHByZS1zb3J0IGZvcm1hdHRpbmcgZnVuY3Rpb24uXG5cdFx0XHQgKi9cblx0XHRcdGlmICggZm9ybWF0dGVycyA9PT0gYVNvcnQubGVuZ3RoICkge1xuXHRcdFx0XHQvLyBBbGwgc29ydCB0eXBlcyBoYXZlIGZvcm1hdHRpbmcgZnVuY3Rpb25zXG5cdFx0XHRcdGRpc3BsYXlNYXN0ZXIuc29ydCggZnVuY3Rpb24gKCBhLCBiICkge1xuXHRcdFx0XHRcdHZhclxuXHRcdFx0XHRcdFx0eCwgeSwgaywgdGVzdCwgc29ydCxcblx0XHRcdFx0XHRcdGxlbj1hU29ydC5sZW5ndGgsXG5cdFx0XHRcdFx0XHRkYXRhQSA9IGFvRGF0YVthXS5fYVNvcnREYXRhLFxuXHRcdFx0XHRcdFx0ZGF0YUIgPSBhb0RhdGFbYl0uX2FTb3J0RGF0YTtcblx0XG5cdFx0XHRcdFx0Zm9yICggaz0wIDsgazxsZW4gOyBrKysgKSB7XG5cdFx0XHRcdFx0XHRzb3J0ID0gYVNvcnRba107XG5cdFxuXHRcdFx0XHRcdFx0eCA9IGRhdGFBWyBzb3J0LmNvbCBdO1xuXHRcdFx0XHRcdFx0eSA9IGRhdGFCWyBzb3J0LmNvbCBdO1xuXHRcblx0XHRcdFx0XHRcdHRlc3QgPSB4PHkgPyAtMSA6IHg+eSA/IDEgOiAwO1xuXHRcdFx0XHRcdFx0aWYgKCB0ZXN0ICE9PSAwICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gc29ydC5kaXIgPT09ICdhc2MnID8gdGVzdCA6IC10ZXN0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0eCA9IGFpT3JpZ1thXTtcblx0XHRcdFx0XHR5ID0gYWlPcmlnW2JdO1xuXHRcdFx0XHRcdHJldHVybiB4PHkgPyAtMSA6IHg+eSA/IDEgOiAwO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Ly8gRGVwcmVjaWF0ZWQgLSByZW1vdmUgaW4gMS4xMSAocHJvdmlkaW5nIGEgcGx1Zy1pbiBvcHRpb24pXG5cdFx0XHRcdC8vIE5vdCBhbGwgc29ydCB0eXBlcyBoYXZlIGZvcm1hdHRpbmcgbWV0aG9kcywgc28gd2UgaGF2ZSB0byBjYWxsIHRoZWlyIHNvcnRpbmdcblx0XHRcdFx0Ly8gbWV0aG9kcy5cblx0XHRcdFx0ZGlzcGxheU1hc3Rlci5zb3J0KCBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cdFx0XHRcdFx0dmFyXG5cdFx0XHRcdFx0XHR4LCB5LCBrLCBsLCB0ZXN0LCBzb3J0LCBmbixcblx0XHRcdFx0XHRcdGxlbj1hU29ydC5sZW5ndGgsXG5cdFx0XHRcdFx0XHRkYXRhQSA9IGFvRGF0YVthXS5fYVNvcnREYXRhLFxuXHRcdFx0XHRcdFx0ZGF0YUIgPSBhb0RhdGFbYl0uX2FTb3J0RGF0YTtcblx0XG5cdFx0XHRcdFx0Zm9yICggaz0wIDsgazxsZW4gOyBrKysgKSB7XG5cdFx0XHRcdFx0XHRzb3J0ID0gYVNvcnRba107XG5cdFxuXHRcdFx0XHRcdFx0eCA9IGRhdGFBWyBzb3J0LmNvbCBdO1xuXHRcdFx0XHRcdFx0eSA9IGRhdGFCWyBzb3J0LmNvbCBdO1xuXHRcblx0XHRcdFx0XHRcdGZuID0gb0V4dFNvcnRbIHNvcnQudHlwZStcIi1cIitzb3J0LmRpciBdIHx8IG9FeHRTb3J0WyBcInN0cmluZy1cIitzb3J0LmRpciBdO1xuXHRcdFx0XHRcdFx0dGVzdCA9IGZuKCB4LCB5ICk7XG5cdFx0XHRcdFx0XHRpZiAoIHRlc3QgIT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0ZXN0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0eCA9IGFpT3JpZ1thXTtcblx0XHRcdFx0XHR5ID0gYWlPcmlnW2JdO1xuXHRcdFx0XHRcdHJldHVybiB4PHkgPyAtMSA6IHg+eSA/IDEgOiAwO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHQvKiBUZWxsIHRoZSBkcmF3IGZ1bmN0aW9uIHRoYXQgd2UgaGF2ZSBzb3J0ZWQgdGhlIGRhdGEgKi9cblx0XHRvU2V0dGluZ3MuYlNvcnRlZCA9IHRydWU7XG5cdH1cblx0XG5cdFxuXHRmdW5jdGlvbiBfZm5Tb3J0QXJpYSAoIHNldHRpbmdzIClcblx0e1xuXHRcdHZhciBsYWJlbDtcblx0XHR2YXIgbmV4dFNvcnQ7XG5cdFx0dmFyIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XG5cdFx0dmFyIGFTb3J0ID0gX2ZuU29ydEZsYXR0ZW4oIHNldHRpbmdzICk7XG5cdFx0dmFyIG9BcmlhID0gc2V0dGluZ3Mub0xhbmd1YWdlLm9BcmlhO1xuXHRcblx0XHQvLyBBUklBIGF0dHJpYnV0ZXMgLSBuZWVkIHRvIGxvb3AgYWxsIGNvbHVtbnMsIHRvIHVwZGF0ZSBhbGwgKHJlbW92aW5nIG9sZFxuXHRcdC8vIGF0dHJpYnV0ZXMgYXMgbmVlZGVkKVxuXHRcdGZvciAoIHZhciBpPTAsIGlMZW49Y29sdW1ucy5sZW5ndGggOyBpPGlMZW4gOyBpKysgKVxuXHRcdHtcblx0XHRcdHZhciBjb2wgPSBjb2x1bW5zW2ldO1xuXHRcdFx0dmFyIGFzU29ydGluZyA9IGNvbC5hc1NvcnRpbmc7XG5cdFx0XHR2YXIgc1RpdGxlID0gY29sLnNUaXRsZS5yZXBsYWNlKCAvPC4qPz4vZywgXCJcIiApO1xuXHRcdFx0dmFyIHRoID0gY29sLm5UaDtcblx0XG5cdFx0XHQvLyBJRTcgaXMgdGhyb3dpbmcgYW4gZXJyb3Igd2hlbiBzZXR0aW5nIHRoZXNlIHByb3BlcnRpZXMgd2l0aCBqUXVlcnknc1xuXHRcdFx0Ly8gYXR0cigpIGFuZCByZW1vdmVBdHRyKCkgbWV0aG9kcy4uLlxuXHRcdFx0dGgucmVtb3ZlQXR0cmlidXRlKCdhcmlhLXNvcnQnKTtcblx0XG5cdFx0XHQvKiBJbiBBUklBIG9ubHkgdGhlIGZpcnN0IHNvcnRpbmcgY29sdW1uIGNhbiBiZSBtYXJrZWQgYXMgc29ydGluZyAtIG5vIG11bHRpLXNvcnQgb3B0aW9uICovXG5cdFx0XHRpZiAoIGNvbC5iU29ydGFibGUgKSB7XG5cdFx0XHRcdGlmICggYVNvcnQubGVuZ3RoID4gMCAmJiBhU29ydFswXS5jb2wgPT0gaSApIHtcblx0XHRcdFx0XHR0aC5zZXRBdHRyaWJ1dGUoJ2FyaWEtc29ydCcsIGFTb3J0WzBdLmRpcj09XCJhc2NcIiA/IFwiYXNjZW5kaW5nXCIgOiBcImRlc2NlbmRpbmdcIiApO1xuXHRcdFx0XHRcdG5leHRTb3J0ID0gYXNTb3J0aW5nWyBhU29ydFswXS5pbmRleCsxIF0gfHwgYXNTb3J0aW5nWzBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdG5leHRTb3J0ID0gYXNTb3J0aW5nWzBdO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRsYWJlbCA9IHNUaXRsZSArICggbmV4dFNvcnQgPT09IFwiYXNjXCIgP1xuXHRcdFx0XHRcdG9BcmlhLnNTb3J0QXNjZW5kaW5nIDpcblx0XHRcdFx0XHRvQXJpYS5zU29ydERlc2NlbmRpbmdcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRsYWJlbCA9IHNUaXRsZTtcblx0XHRcdH1cblx0XG5cdFx0XHR0aC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCBsYWJlbCk7XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEZ1bmN0aW9uIHRvIHJ1biBvbiB1c2VyIHNvcnQgcmVxdWVzdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge25vZGV9IGF0dGFjaFRvIG5vZGUgdG8gYXR0YWNoIHRoZSBoYW5kbGVyIHRvXG5cdCAqICBAcGFyYW0ge2ludH0gY29sSWR4IGNvbHVtbiBzb3J0aW5nIGluZGV4XG5cdCAqICBAcGFyYW0ge2Jvb2xlYW59IFthcHBlbmQ9ZmFsc2VdIEFwcGVuZCB0aGUgcmVxdWVzdGVkIHNvcnQgdG8gdGhlIGV4aXN0aW5nXG5cdCAqICAgIHNvcnQgaWYgdHJ1ZSAoaS5lLiBtdWx0aS1jb2x1bW4gc29ydClcblx0ICogIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gY2FsbGJhY2sgZnVuY3Rpb25cblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuU29ydExpc3RlbmVyICggc2V0dGluZ3MsIGNvbElkeCwgYXBwZW5kLCBjYWxsYmFjayApXG5cdHtcblx0XHR2YXIgY29sID0gc2V0dGluZ3MuYW9Db2x1bW5zWyBjb2xJZHggXTtcblx0XHR2YXIgc29ydGluZyA9IHNldHRpbmdzLmFhU29ydGluZztcblx0XHR2YXIgYXNTb3J0aW5nID0gY29sLmFzU29ydGluZztcblx0XHR2YXIgbmV4dFNvcnRJZHg7XG5cdFx0dmFyIG5leHQgPSBmdW5jdGlvbiAoIGEsIG92ZXJmbG93ICkge1xuXHRcdFx0dmFyIGlkeCA9IGEuX2lkeDtcblx0XHRcdGlmICggaWR4ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGlkeCA9ICQuaW5BcnJheSggYVsxXSwgYXNTb3J0aW5nICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0cmV0dXJuIGlkeCsxIDwgYXNTb3J0aW5nLmxlbmd0aCA/XG5cdFx0XHRcdGlkeCsxIDpcblx0XHRcdFx0b3ZlcmZsb3cgP1xuXHRcdFx0XHRcdG51bGwgOlxuXHRcdFx0XHRcdDA7XG5cdFx0fTtcblx0XG5cdFx0Ly8gQ29udmVydCB0byAyRCBhcnJheSBpZiBuZWVkZWRcblx0XHRpZiAoIHR5cGVvZiBzb3J0aW5nWzBdID09PSAnbnVtYmVyJyApIHtcblx0XHRcdHNvcnRpbmcgPSBzZXR0aW5ncy5hYVNvcnRpbmcgPSBbIHNvcnRpbmcgXTtcblx0XHR9XG5cdFxuXHRcdC8vIElmIGFwcGVuZGluZyB0aGUgc29ydCB0aGVuIHdlIGFyZSBtdWx0aS1jb2x1bW4gc29ydGluZ1xuXHRcdGlmICggYXBwZW5kICYmIHNldHRpbmdzLm9GZWF0dXJlcy5iU29ydE11bHRpICkge1xuXHRcdFx0Ly8gQXJlIHdlIGFscmVhZHkgZG9pbmcgc29tZSBraW5kIG9mIHNvcnQgb24gdGhpcyBjb2x1bW4/XG5cdFx0XHR2YXIgc29ydElkeCA9ICQuaW5BcnJheSggY29sSWR4LCBfcGx1Y2soc29ydGluZywgJzAnKSApO1xuXHRcblx0XHRcdGlmICggc29ydElkeCAhPT0gLTEgKSB7XG5cdFx0XHRcdC8vIFllcywgbW9kaWZ5IHRoZSBzb3J0XG5cdFx0XHRcdG5leHRTb3J0SWR4ID0gbmV4dCggc29ydGluZ1tzb3J0SWR4XSwgdHJ1ZSApO1xuXHRcblx0XHRcdFx0aWYgKCBuZXh0U29ydElkeCA9PT0gbnVsbCAmJiBzb3J0aW5nLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdFx0XHRuZXh0U29ydElkeCA9IDA7IC8vIGNhbid0IHJlbW92ZSBzb3J0aW5nIGNvbXBsZXRlbHlcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0aWYgKCBuZXh0U29ydElkeCA9PT0gbnVsbCApIHtcblx0XHRcdFx0XHRzb3J0aW5nLnNwbGljZSggc29ydElkeCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHNvcnRpbmdbc29ydElkeF1bMV0gPSBhc1NvcnRpbmdbIG5leHRTb3J0SWR4IF07XG5cdFx0XHRcdFx0c29ydGluZ1tzb3J0SWR4XS5faWR4ID0gbmV4dFNvcnRJZHg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHQvLyBObyBzb3J0IG9uIHRoaXMgY29sdW1uIHlldFxuXHRcdFx0XHRzb3J0aW5nLnB1c2goIFsgY29sSWR4LCBhc1NvcnRpbmdbMF0sIDAgXSApO1xuXHRcdFx0XHRzb3J0aW5nW3NvcnRpbmcubGVuZ3RoLTFdLl9pZHggPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmICggc29ydGluZy5sZW5ndGggJiYgc29ydGluZ1swXVswXSA9PSBjb2xJZHggKSB7XG5cdFx0XHQvLyBTaW5nbGUgY29sdW1uIC0gYWxyZWFkeSBzb3J0aW5nIG9uIHRoaXMgY29sdW1uLCBtb2RpZnkgdGhlIHNvcnRcblx0XHRcdG5leHRTb3J0SWR4ID0gbmV4dCggc29ydGluZ1swXSApO1xuXHRcblx0XHRcdHNvcnRpbmcubGVuZ3RoID0gMTtcblx0XHRcdHNvcnRpbmdbMF1bMV0gPSBhc1NvcnRpbmdbIG5leHRTb3J0SWR4IF07XG5cdFx0XHRzb3J0aW5nWzBdLl9pZHggPSBuZXh0U29ydElkeDtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBTaW5nbGUgY29sdW1uIC0gc29ydCBvbmx5IG9uIHRoaXMgY29sdW1uXG5cdFx0XHRzb3J0aW5nLmxlbmd0aCA9IDA7XG5cdFx0XHRzb3J0aW5nLnB1c2goIFsgY29sSWR4LCBhc1NvcnRpbmdbMF0gXSApO1xuXHRcdFx0c29ydGluZ1swXS5faWR4ID0gMDtcblx0XHR9XG5cdFxuXHRcdC8vIFJ1biB0aGUgc29ydCBieSBjYWxsaW5nIGEgZnVsbCByZWRyYXdcblx0XHRfZm5SZURyYXcoIHNldHRpbmdzICk7XG5cdFxuXHRcdC8vIGNhbGxiYWNrIHVzZWQgZm9yIGFzeW5jIHVzZXIgaW50ZXJhY3Rpb25cblx0XHRpZiAoIHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0Y2FsbGJhY2soIHNldHRpbmdzICk7XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEF0dGFjaCBhIHNvcnQgaGFuZGxlciAoY2xpY2spIHRvIGEgbm9kZVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge25vZGV9IGF0dGFjaFRvIG5vZGUgdG8gYXR0YWNoIHRoZSBoYW5kbGVyIHRvXG5cdCAqICBAcGFyYW0ge2ludH0gY29sSWR4IGNvbHVtbiBzb3J0aW5nIGluZGV4XG5cdCAqICBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIGNhbGxiYWNrIGZ1bmN0aW9uXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mblNvcnRBdHRhY2hMaXN0ZW5lciAoIHNldHRpbmdzLCBhdHRhY2hUbywgY29sSWR4LCBjYWxsYmFjayApXG5cdHtcblx0XHR2YXIgY29sID0gc2V0dGluZ3MuYW9Db2x1bW5zWyBjb2xJZHggXTtcblx0XG5cdFx0X2ZuQmluZEFjdGlvbiggYXR0YWNoVG8sIHt9LCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0LyogSWYgdGhlIGNvbHVtbiBpcyBub3Qgc29ydGFibGUgLSBkb24ndCB0byBhbnl0aGluZyAqL1xuXHRcdFx0aWYgKCBjb2wuYlNvcnRhYmxlID09PSBmYWxzZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIElmIHByb2Nlc3NpbmcgaXMgZW5hYmxlZCB1c2UgYSB0aW1lb3V0IHRvIGFsbG93IHRoZSBwcm9jZXNzaW5nXG5cdFx0XHQvLyBkaXNwbGF5IHRvIGJlIHNob3duIC0gb3RoZXJ3aXNlIHRvIGl0IHN5bmNocm9ub3VzbHlcblx0XHRcdGlmICggc2V0dGluZ3Mub0ZlYXR1cmVzLmJQcm9jZXNzaW5nICkge1xuXHRcdFx0XHRfZm5Qcm9jZXNzaW5nRGlzcGxheSggc2V0dGluZ3MsIHRydWUgKTtcblx0XG5cdFx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdF9mblNvcnRMaXN0ZW5lciggc2V0dGluZ3MsIGNvbElkeCwgZS5zaGlmdEtleSwgY2FsbGJhY2sgKTtcblx0XG5cdFx0XHRcdFx0Ly8gSW4gc2VydmVyLXNpZGUgcHJvY2Vzc2luZywgdGhlIGRyYXcgY2FsbGJhY2sgd2lsbCByZW1vdmUgdGhlXG5cdFx0XHRcdFx0Ly8gcHJvY2Vzc2luZyBkaXNwbGF5XG5cdFx0XHRcdFx0aWYgKCBfZm5EYXRhU291cmNlKCBzZXR0aW5ncyApICE9PSAnc3NwJyApIHtcblx0XHRcdFx0XHRcdF9mblByb2Nlc3NpbmdEaXNwbGF5KCBzZXR0aW5ncywgZmFsc2UgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sIDAgKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRfZm5Tb3J0TGlzdGVuZXIoIHNldHRpbmdzLCBjb2xJZHgsIGUuc2hpZnRLZXksIGNhbGxiYWNrICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIFNldCB0aGUgc29ydGluZyBjbGFzc2VzIG9uIHRhYmxlJ3MgYm9keSwgTm90ZTogaXQgaXMgc2FmZSB0byBjYWxsIHRoaXMgZnVuY3Rpb25cblx0ICogd2hlbiBiU29ydCBhbmQgYlNvcnRDbGFzc2VzIGFyZSBmYWxzZVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5Tb3J0aW5nQ2xhc3Nlcyggc2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyIG9sZFNvcnQgPSBzZXR0aW5ncy5hTGFzdFNvcnQ7XG5cdFx0dmFyIHNvcnRDbGFzcyA9IHNldHRpbmdzLm9DbGFzc2VzLnNTb3J0Q29sdW1uO1xuXHRcdHZhciBzb3J0ID0gX2ZuU29ydEZsYXR0ZW4oIHNldHRpbmdzICk7XG5cdFx0dmFyIGZlYXR1cmVzID0gc2V0dGluZ3Mub0ZlYXR1cmVzO1xuXHRcdHZhciBpLCBpZW4sIGNvbElkeDtcblx0XG5cdFx0aWYgKCBmZWF0dXJlcy5iU29ydCAmJiBmZWF0dXJlcy5iU29ydENsYXNzZXMgKSB7XG5cdFx0XHQvLyBSZW1vdmUgb2xkIHNvcnRpbmcgY2xhc3Nlc1xuXHRcdFx0Zm9yICggaT0wLCBpZW49b2xkU29ydC5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0Y29sSWR4ID0gb2xkU29ydFtpXS5zcmM7XG5cdFxuXHRcdFx0XHQvLyBSZW1vdmUgY29sdW1uIHNvcnRpbmdcblx0XHRcdFx0JCggX3BsdWNrKCBzZXR0aW5ncy5hb0RhdGEsICdhbkNlbGxzJywgY29sSWR4ICkgKVxuXHRcdFx0XHRcdC5yZW1vdmVDbGFzcyggc29ydENsYXNzICsgKGk8MiA/IGkrMSA6IDMpICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gQWRkIG5ldyBjb2x1bW4gc29ydGluZ1xuXHRcdFx0Zm9yICggaT0wLCBpZW49c29ydC5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0Y29sSWR4ID0gc29ydFtpXS5zcmM7XG5cdFxuXHRcdFx0XHQkKCBfcGx1Y2soIHNldHRpbmdzLmFvRGF0YSwgJ2FuQ2VsbHMnLCBjb2xJZHggKSApXG5cdFx0XHRcdFx0LmFkZENsYXNzKCBzb3J0Q2xhc3MgKyAoaTwyID8gaSsxIDogMykgKTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdHNldHRpbmdzLmFMYXN0U29ydCA9IHNvcnQ7XG5cdH1cblx0XG5cdFxuXHQvLyBHZXQgdGhlIGRhdGEgdG8gc29ydCBhIGNvbHVtbiwgYmUgaXQgZnJvbSBjYWNoZSwgZnJlc2ggKHBvcHVsYXRpbmcgdGhlXG5cdC8vIGNhY2hlKSwgb3IgZnJvbSBhIHNvcnQgZm9ybWF0dGVyXG5cdGZ1bmN0aW9uIF9mblNvcnREYXRhKCBzZXR0aW5ncywgaWR4IClcblx0e1xuXHRcdC8vIEN1c3RvbSBzb3J0aW5nIGZ1bmN0aW9uIC0gcHJvdmlkZWQgYnkgdGhlIHNvcnQgZGF0YSB0eXBlXG5cdFx0dmFyIGNvbHVtbiA9IHNldHRpbmdzLmFvQ29sdW1uc1sgaWR4IF07XG5cdFx0dmFyIGN1c3RvbVNvcnQgPSBEYXRhVGFibGUuZXh0Lm9yZGVyWyBjb2x1bW4uc1NvcnREYXRhVHlwZSBdO1xuXHRcdHZhciBjdXN0b21EYXRhO1xuXHRcblx0XHRpZiAoIGN1c3RvbVNvcnQgKSB7XG5cdFx0XHRjdXN0b21EYXRhID0gY3VzdG9tU29ydC5jYWxsKCBzZXR0aW5ncy5vSW5zdGFuY2UsIHNldHRpbmdzLCBpZHgsXG5cdFx0XHRcdF9mbkNvbHVtbkluZGV4VG9WaXNpYmxlKCBzZXR0aW5ncywgaWR4IClcblx0XHRcdCk7XG5cdFx0fVxuXHRcblx0XHQvLyBVc2UgLyBwb3B1bGF0ZSBjYWNoZVxuXHRcdHZhciByb3csIGNlbGxEYXRhO1xuXHRcdHZhciBmb3JtYXR0ZXIgPSBEYXRhVGFibGUuZXh0LnR5cGUub3JkZXJbIGNvbHVtbi5zVHlwZStcIi1wcmVcIiBdO1xuXHRcblx0XHRmb3IgKCB2YXIgaT0wLCBpZW49c2V0dGluZ3MuYW9EYXRhLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0cm93ID0gc2V0dGluZ3MuYW9EYXRhW2ldO1xuXHRcblx0XHRcdGlmICggISByb3cuX2FTb3J0RGF0YSApIHtcblx0XHRcdFx0cm93Ll9hU29ydERhdGEgPSBbXTtcblx0XHRcdH1cblx0XG5cdFx0XHRpZiAoICEgcm93Ll9hU29ydERhdGFbaWR4XSB8fCBjdXN0b21Tb3J0ICkge1xuXHRcdFx0XHRjZWxsRGF0YSA9IGN1c3RvbVNvcnQgP1xuXHRcdFx0XHRcdGN1c3RvbURhdGFbaV0gOiAvLyBJZiB0aGVyZSB3YXMgYSBjdXN0b20gc29ydCBmdW5jdGlvbiwgdXNlIGRhdGEgZnJvbSB0aGVyZVxuXHRcdFx0XHRcdF9mbkdldENlbGxEYXRhKCBzZXR0aW5ncywgaSwgaWR4LCAnc29ydCcgKTtcblx0XG5cdFx0XHRcdHJvdy5fYVNvcnREYXRhWyBpZHggXSA9IGZvcm1hdHRlciA/XG5cdFx0XHRcdFx0Zm9ybWF0dGVyKCBjZWxsRGF0YSApIDpcblx0XHRcdFx0XHRjZWxsRGF0YTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0XG5cdFxuXHRcblx0LyoqXG5cdCAqIFNhdmUgdGhlIHN0YXRlIG9mIGEgdGFibGVcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuU2F2ZVN0YXRlICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0aWYgKCAhc2V0dGluZ3Mub0ZlYXR1cmVzLmJTdGF0ZVNhdmUgfHwgc2V0dGluZ3MuYkRlc3Ryb3lpbmcgKVxuXHRcdHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFxuXHRcdC8qIFN0b3JlIHRoZSBpbnRlcmVzdGluZyB2YXJpYWJsZXMgKi9cblx0XHR2YXIgc3RhdGUgPSB7XG5cdFx0XHR0aW1lOiAgICArbmV3IERhdGUoKSxcblx0XHRcdHN0YXJ0OiAgIHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0LFxuXHRcdFx0bGVuZ3RoOiAgc2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoLFxuXHRcdFx0b3JkZXI6ICAgJC5leHRlbmQoIHRydWUsIFtdLCBzZXR0aW5ncy5hYVNvcnRpbmcgKSxcblx0XHRcdHNlYXJjaDogIF9mblNlYXJjaFRvQ2FtZWwoIHNldHRpbmdzLm9QcmV2aW91c1NlYXJjaCApLFxuXHRcdFx0Y29sdW1uczogJC5tYXAoIHNldHRpbmdzLmFvQ29sdW1ucywgZnVuY3Rpb24gKCBjb2wsIGkgKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dmlzaWJsZTogY29sLmJWaXNpYmxlLFxuXHRcdFx0XHRcdHNlYXJjaDogX2ZuU2VhcmNoVG9DYW1lbCggc2V0dGluZ3MuYW9QcmVTZWFyY2hDb2xzW2ldIClcblx0XHRcdFx0fTtcblx0XHRcdH0gKVxuXHRcdH07XG5cdFxuXHRcdF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsIFwiYW9TdGF0ZVNhdmVQYXJhbXNcIiwgJ3N0YXRlU2F2ZVBhcmFtcycsIFtzZXR0aW5ncywgc3RhdGVdICk7XG5cdFxuXHRcdHNldHRpbmdzLm9TYXZlZFN0YXRlID0gc3RhdGU7XG5cdFx0c2V0dGluZ3MuZm5TdGF0ZVNhdmVDYWxsYmFjay5jYWxsKCBzZXR0aW5ncy5vSW5zdGFuY2UsIHNldHRpbmdzLCBzdGF0ZSApO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEF0dGVtcHQgdG8gbG9hZCBhIHNhdmVkIHRhYmxlIHN0YXRlXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0gb0luaXQgRGF0YVRhYmxlcyBpbml0IG9iamVjdCBzbyB3ZSBjYW4gb3ZlcnJpZGUgc2V0dGluZ3Ncblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuTG9hZFN0YXRlICggc2V0dGluZ3MsIG9Jbml0IClcblx0e1xuXHRcdHZhciBpLCBpZW47XG5cdFx0dmFyIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XG5cdFxuXHRcdGlmICggISBzZXR0aW5ncy5vRmVhdHVyZXMuYlN0YXRlU2F2ZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFxuXHRcdHZhciBzdGF0ZSA9IHNldHRpbmdzLmZuU3RhdGVMb2FkQ2FsbGJhY2suY2FsbCggc2V0dGluZ3Mub0luc3RhbmNlLCBzZXR0aW5ncyApO1xuXHRcdGlmICggISBzdGF0ZSB8fCAhIHN0YXRlLnRpbWUgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcblx0XHQvKiBBbGxvdyBjdXN0b20gYW5kIHBsdWctaW4gbWFuaXB1bGF0aW9uIGZ1bmN0aW9ucyB0byBhbHRlciB0aGUgc2F2ZWQgZGF0YSBzZXQgYW5kXG5cdFx0ICogY2FuY2VsbGluZyBvZiBsb2FkaW5nIGJ5IHJldHVybmluZyBmYWxzZVxuXHRcdCAqL1xuXHRcdHZhciBhYlN0YXRlTG9hZCA9IF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsICdhb1N0YXRlTG9hZFBhcmFtcycsICdzdGF0ZUxvYWRQYXJhbXMnLCBbc2V0dGluZ3MsIHN0YXRlXSApO1xuXHRcdGlmICggJC5pbkFycmF5KCBmYWxzZSwgYWJTdGF0ZUxvYWQgKSAhPT0gLTEgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcblx0XHQvKiBSZWplY3Qgb2xkIGRhdGEgKi9cblx0XHR2YXIgZHVyYXRpb24gPSBzZXR0aW5ncy5pU3RhdGVEdXJhdGlvbjtcblx0XHRpZiAoIGR1cmF0aW9uID4gMCAmJiBzdGF0ZS50aW1lIDwgK25ldyBEYXRlKCkgLSAoZHVyYXRpb24qMTAwMCkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcblx0XHQvLyBOdW1iZXIgb2YgY29sdW1ucyBoYXZlIGNoYW5nZWQgLSBhbGwgYmV0cyBhcmUgb2ZmLCBubyByZXN0b3JlIG9mIHNldHRpbmdzXG5cdFx0aWYgKCBjb2x1bW5zLmxlbmd0aCAhPT0gc3RhdGUuY29sdW1ucy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcblx0XHQvLyBTdG9yZSB0aGUgc2F2ZWQgc3RhdGUgc28gaXQgbWlnaHQgYmUgYWNjZXNzZWQgYXQgYW55IHRpbWVcblx0XHRzZXR0aW5ncy5vTG9hZGVkU3RhdGUgPSAkLmV4dGVuZCggdHJ1ZSwge30sIHN0YXRlICk7XG5cdFxuXHRcdC8vIFJlc3RvcmUga2V5IGZlYXR1cmVzIC0gdG9kbyAtIGZvciAxLjExIHRoaXMgbmVlZHMgdG8gYmUgZG9uZSBieVxuXHRcdC8vIHN1YnNjcmliZWQgZXZlbnRzXG5cdFx0aWYgKCBzdGF0ZS5zdGFydCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0c2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgICAgPSBzdGF0ZS5zdGFydDtcblx0XHRcdHNldHRpbmdzLmlJbml0RGlzcGxheVN0YXJ0ID0gc3RhdGUuc3RhcnQ7XG5cdFx0fVxuXHRcdGlmICggc3RhdGUubGVuZ3RoICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRzZXR0aW5ncy5faURpc3BsYXlMZW5ndGggICA9IHN0YXRlLmxlbmd0aDtcblx0XHR9XG5cdFxuXHRcdC8vIE9yZGVyXG5cdFx0aWYgKCBzdGF0ZS5vcmRlciAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0c2V0dGluZ3MuYWFTb3J0aW5nID0gW107XG5cdFx0XHQkLmVhY2goIHN0YXRlLm9yZGVyLCBmdW5jdGlvbiAoIGksIGNvbCApIHtcblx0XHRcdFx0c2V0dGluZ3MuYWFTb3J0aW5nLnB1c2goIGNvbFswXSA+PSBjb2x1bW5zLmxlbmd0aCA/XG5cdFx0XHRcdFx0WyAwLCBjb2xbMV0gXSA6XG5cdFx0XHRcdFx0Y29sXG5cdFx0XHRcdCk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcblx0XHQvLyBTZWFyY2hcblx0XHRpZiAoIHN0YXRlLnNlYXJjaCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0JC5leHRlbmQoIHNldHRpbmdzLm9QcmV2aW91c1NlYXJjaCwgX2ZuU2VhcmNoVG9IdW5nKCBzdGF0ZS5zZWFyY2ggKSApO1xuXHRcdH1cblx0XG5cdFx0Ly8gQ29sdW1uc1xuXHRcdGZvciAoIGk9MCwgaWVuPXN0YXRlLmNvbHVtbnMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHR2YXIgY29sID0gc3RhdGUuY29sdW1uc1tpXTtcblx0XG5cdFx0XHQvLyBWaXNpYmlsaXR5XG5cdFx0XHRpZiAoIGNvbC52aXNpYmxlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGNvbHVtbnNbaV0uYlZpc2libGUgPSBjb2wudmlzaWJsZTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBTZWFyY2hcblx0XHRcdGlmICggY29sLnNlYXJjaCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHQkLmV4dGVuZCggc2V0dGluZ3MuYW9QcmVTZWFyY2hDb2xzW2ldLCBfZm5TZWFyY2hUb0h1bmcoIGNvbC5zZWFyY2ggKSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0X2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgJ2FvU3RhdGVMb2FkZWQnLCAnc3RhdGVMb2FkZWQnLCBbc2V0dGluZ3MsIHN0YXRlXSApO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIFJldHVybiB0aGUgc2V0dGluZ3Mgb2JqZWN0IGZvciBhIHBhcnRpY3VsYXIgdGFibGVcblx0ICogIEBwYXJhbSB7bm9kZX0gdGFibGUgdGFibGUgd2UgYXJlIHVzaW5nIGFzIGEgZGF0YVRhYmxlXG5cdCAqICBAcmV0dXJucyB7b2JqZWN0fSBTZXR0aW5ncyBvYmplY3QgLSBvciBudWxsIGlmIG5vdCBmb3VuZFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5TZXR0aW5nc0Zyb21Ob2RlICggdGFibGUgKVxuXHR7XG5cdFx0dmFyIHNldHRpbmdzID0gRGF0YVRhYmxlLnNldHRpbmdzO1xuXHRcdHZhciBpZHggPSAkLmluQXJyYXkoIHRhYmxlLCBfcGx1Y2soIHNldHRpbmdzLCAnblRhYmxlJyApICk7XG5cdFxuXHRcdHJldHVybiBpZHggIT09IC0xID9cblx0XHRcdHNldHRpbmdzWyBpZHggXSA6XG5cdFx0XHRudWxsO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIExvZyBhbiBlcnJvciBtZXNzYWdlXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7aW50fSBsZXZlbCBsb2cgZXJyb3IgbWVzc2FnZXMsIG9yIGRpc3BsYXkgdGhlbSB0byB0aGUgdXNlclxuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IG1zZyBlcnJvciBtZXNzYWdlXG5cdCAqICBAcGFyYW0ge2ludH0gdG4gVGVjaG5pY2FsIG5vdGUgaWQgdG8gZ2V0IG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGVycm9yLlxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5Mb2coIHNldHRpbmdzLCBsZXZlbCwgbXNnLCB0biApXG5cdHtcblx0XHRtc2cgPSAnRGF0YVRhYmxlcyB3YXJuaW5nOiAnK1xuXHRcdFx0KHNldHRpbmdzIT09bnVsbCA/ICd0YWJsZSBpZD0nK3NldHRpbmdzLnNUYWJsZUlkKycgLSAnIDogJycpK21zZztcblx0XG5cdFx0aWYgKCB0biApIHtcblx0XHRcdG1zZyArPSAnLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGlzIGVycm9yLCBwbGVhc2Ugc2VlICcrXG5cdFx0XHQnaHR0cDovL2RhdGF0YWJsZXMubmV0L3RuLycrdG47XG5cdFx0fVxuXHRcblx0XHRpZiAoICEgbGV2ZWwgICkge1xuXHRcdFx0Ly8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgcHJlIDEuMTBcblx0XHRcdHZhciBleHQgPSBEYXRhVGFibGUuZXh0O1xuXHRcdFx0dmFyIHR5cGUgPSBleHQuc0Vyck1vZGUgfHwgZXh0LmVyck1vZGU7XG5cdFxuXHRcdFx0X2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgbnVsbCwgJ2Vycm9yJywgWyBzZXR0aW5ncywgdG4sIG1zZyBdICk7XG5cdFxuXHRcdFx0aWYgKCB0eXBlID09ICdhbGVydCcgKSB7XG5cdFx0XHRcdGFsZXJ0KCBtc2cgKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCB0eXBlID09ICd0aHJvdycgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihtc2cpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHR5cGVvZiB0eXBlID09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdHR5cGUoIHNldHRpbmdzLCB0biwgbXNnICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCB3aW5kb3cuY29uc29sZSAmJiBjb25zb2xlLmxvZyApIHtcblx0XHRcdGNvbnNvbGUubG9nKCBtc2cgKTtcblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogU2VlIGlmIGEgcHJvcGVydHkgaXMgZGVmaW5lZCBvbiBvbmUgb2JqZWN0LCBpZiBzbyBhc3NpZ24gaXQgdG8gdGhlIG90aGVyIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHJldCB0YXJnZXQgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0gc3JjIHNvdXJjZSBvYmplY3Rcblx0ICogIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHByb3BlcnR5XG5cdCAqICBAcGFyYW0ge3N0cmluZ30gW21hcHBlZE5hbWVdIG5hbWUgdG8gbWFwIHRvbyAtIG9wdGlvbmFsLCBuYW1lIHVzZWQgaWYgbm90IGdpdmVuXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbk1hcCggcmV0LCBzcmMsIG5hbWUsIG1hcHBlZE5hbWUgKVxuXHR7XG5cdFx0aWYgKCAkLmlzQXJyYXkoIG5hbWUgKSApIHtcblx0XHRcdCQuZWFjaCggbmFtZSwgZnVuY3Rpb24gKGksIHZhbCkge1xuXHRcdFx0XHRpZiAoICQuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdFx0X2ZuTWFwKCByZXQsIHNyYywgdmFsWzBdLCB2YWxbMV0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRfZm5NYXAoIHJldCwgc3JjLCB2YWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFxuXHRcdGlmICggbWFwcGVkTmFtZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0bWFwcGVkTmFtZSA9IG5hbWU7XG5cdFx0fVxuXHRcblx0XHRpZiAoIHNyY1tuYW1lXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0W21hcHBlZE5hbWVdID0gc3JjW25hbWVdO1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBFeHRlbmQgb2JqZWN0cyAtIHZlcnkgc2ltaWxhciB0byBqUXVlcnkuZXh0ZW5kLCBidXQgZGVlcCBjb3B5IG9iamVjdHMsIGFuZFxuXHQgKiBzaGFsbG93IGNvcHkgYXJyYXlzLiBUaGUgcmVhc29uIHdlIG5lZWQgdG8gZG8gdGhpcywgaXMgdGhhdCB3ZSBkb24ndCB3YW50IHRvXG5cdCAqIGRlZXAgY29weSBhcnJheSBpbml0IHZhbHVlcyAoc3VjaCBhcyBhYVNvcnRpbmcpIHNpbmNlIHRoZSBkZXYgd291bGRuJ3QgYmVcblx0ICogYWJsZSB0byBvdmVycmlkZSB0aGVtLCBidXQgd2UgZG8gd2FudCB0byBkZWVwIGNvcHkgYXJyYXlzLlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG91dCBPYmplY3QgdG8gZXh0ZW5kXG5cdCAqICBAcGFyYW0ge29iamVjdH0gZXh0ZW5kZXIgT2JqZWN0IGZyb20gd2hpY2ggdGhlIHByb3BlcnRpZXMgd2lsbCBiZSBhcHBsaWVkIHRvXG5cdCAqICAgICAgb3V0XG5cdCAqICBAcGFyYW0ge2Jvb2xlYW59IGJyZWFrUmVmcyBJZiB0cnVlLCB0aGVuIGFycmF5cyB3aWxsIGJlIHNsaWNlZCB0byB0YWtlIGFuXG5cdCAqICAgICAgaW5kZXBlbmRlbnQgY29weSB3aXRoIHRoZSBleGNlcHRpb24gb2YgdGhlIGBkYXRhYCBvciBgYWFEYXRhYCBwYXJhbWV0ZXJzXG5cdCAqICAgICAgaWYgdGhleSBhcmUgcHJlc2VudC4gVGhpcyBpcyBzbyB5b3UgY2FuIHBhc3MgaW4gYSBjb2xsZWN0aW9uIHRvXG5cdCAqICAgICAgRGF0YVRhYmxlcyBhbmQgaGF2ZSB0aGF0IHVzZWQgYXMgeW91ciBkYXRhIHNvdXJjZSB3aXRob3V0IGJyZWFraW5nIHRoZVxuXHQgKiAgICAgIHJlZmVyZW5jZXNcblx0ICogIEByZXR1cm5zIHtvYmplY3R9IG91dCBSZWZlcmVuY2UsIGp1c3QgZm9yIGNvbnZlbmllbmNlIC0gb3V0ID09PSB0aGUgcmV0dXJuLlxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqICBAdG9kbyBUaGlzIGRvZXNuJ3QgdGFrZSBhY2NvdW50IG9mIGFycmF5cyBpbnNpZGUgdGhlIGRlZXAgY29waWVkIG9iamVjdHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5FeHRlbmQoIG91dCwgZXh0ZW5kZXIsIGJyZWFrUmVmcyApXG5cdHtcblx0XHR2YXIgdmFsO1xuXHRcblx0XHRmb3IgKCB2YXIgcHJvcCBpbiBleHRlbmRlciApIHtcblx0XHRcdGlmICggZXh0ZW5kZXIuaGFzT3duUHJvcGVydHkocHJvcCkgKSB7XG5cdFx0XHRcdHZhbCA9IGV4dGVuZGVyW3Byb3BdO1xuXHRcblx0XHRcdFx0aWYgKCAkLmlzUGxhaW5PYmplY3QoIHZhbCApICkge1xuXHRcdFx0XHRcdGlmICggISAkLmlzUGxhaW5PYmplY3QoIG91dFtwcm9wXSApICkge1xuXHRcdFx0XHRcdFx0b3V0W3Byb3BdID0ge307XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCQuZXh0ZW5kKCB0cnVlLCBvdXRbcHJvcF0sIHZhbCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKCBicmVha1JlZnMgJiYgcHJvcCAhPT0gJ2RhdGEnICYmIHByb3AgIT09ICdhYURhdGEnICYmICQuaXNBcnJheSh2YWwpICkge1xuXHRcdFx0XHRcdG91dFtwcm9wXSA9IHZhbC5zbGljZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdG91dFtwcm9wXSA9IHZhbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0cmV0dXJuIG91dDtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBCaW5kIGFuIGV2ZW50IGhhbmRlcnMgdG8gYWxsb3cgYSBjbGljayBvciByZXR1cm4ga2V5IHRvIGFjdGl2YXRlIHRoZSBjYWxsYmFjay5cblx0ICogVGhpcyBpcyBnb29kIGZvciBhY2Nlc3NpYmlsaXR5IHNpbmNlIGEgcmV0dXJuIG9uIHRoZSBrZXlib2FyZCB3aWxsIGhhdmUgdGhlXG5cdCAqIHNhbWUgZWZmZWN0IGFzIGEgY2xpY2ssIGlmIHRoZSBlbGVtZW50IGhhcyBmb2N1cy5cblx0ICogIEBwYXJhbSB7ZWxlbWVudH0gbiBFbGVtZW50IHRvIGJpbmQgdGhlIGFjdGlvbiB0b1xuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9EYXRhIERhdGEgb2JqZWN0IHRvIHBhc3MgdG8gdGhlIHRyaWdnZXJlZCBmdW5jdGlvblxuXHQgKiAgQHBhcmFtIHtmdW5jdGlvbn0gZm4gQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHdoZW4gdGhlIGV2ZW50IGlzIHRyaWdnZXJlZFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5CaW5kQWN0aW9uKCBuLCBvRGF0YSwgZm4gKVxuXHR7XG5cdFx0JChuKVxuXHRcdFx0LmJpbmQoICdjbGljay5EVCcsIG9EYXRhLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdG4uYmx1cigpOyAvLyBSZW1vdmUgZm9jdXMgb3V0bGluZSBmb3IgbW91c2UgdXNlcnNcblx0XHRcdFx0XHRmbihlKTtcblx0XHRcdFx0fSApXG5cdFx0XHQuYmluZCggJ2tleXByZXNzLkRUJywgb0RhdGEsIGZ1bmN0aW9uIChlKXtcblx0XHRcdFx0XHRpZiAoIGUud2hpY2ggPT09IDEzICkge1xuXHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0Zm4oZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IClcblx0XHRcdC5iaW5kKCAnc2VsZWN0c3RhcnQuRFQnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0LyogVGFrZSB0aGUgYnJ1dGFsIGFwcHJvYWNoIHRvIGNhbmNlbGxpbmcgdGV4dCBzZWxlY3Rpb24gKi9cblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH0gKTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBSZWdpc3RlciBhIGNhbGxiYWNrIGZ1bmN0aW9uLiBFYXNpbHkgYWxsb3dzIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgYWRkZWQgdG9cblx0ICogYW4gYXJyYXkgc3RvcmUgb2YgY2FsbGJhY2sgZnVuY3Rpb25zIHRoYXQgY2FuIHRoZW4gYWxsIGJlIGNhbGxlZCB0b2dldGhlci5cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7c3RyaW5nfSBzU3RvcmUgTmFtZSBvZiB0aGUgYXJyYXkgc3RvcmFnZSBmb3IgdGhlIGNhbGxiYWNrcyBpbiBvU2V0dGluZ3Ncblx0ICogIEBwYXJhbSB7ZnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBiYWNrXG5cdCAqICBAcGFyYW0ge3N0cmluZ30gc05hbWUgSWRlbnRpZnlpbmcgbmFtZSBmb3IgdGhlIGNhbGxiYWNrIChpLmUuIGEgbGFiZWwpXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsIHNTdG9yZSwgZm4sIHNOYW1lIClcblx0e1xuXHRcdGlmICggZm4gKVxuXHRcdHtcblx0XHRcdG9TZXR0aW5nc1tzU3RvcmVdLnB1c2goIHtcblx0XHRcdFx0XCJmblwiOiBmbixcblx0XHRcdFx0XCJzTmFtZVwiOiBzTmFtZVxuXHRcdFx0fSApO1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBGaXJlIGNhbGxiYWNrIGZ1bmN0aW9ucyBhbmQgdHJpZ2dlciBldmVudHMuIE5vdGUgdGhhdCB0aGUgbG9vcCBvdmVyIHRoZVxuXHQgKiBjYWxsYmFjayBhcnJheSBzdG9yZSBpcyBkb25lIGJhY2t3YXJkcyEgRnVydGhlciBub3RlIHRoYXQgeW91IGRvIG5vdCB3YW50IHRvXG5cdCAqIGZpcmUgb2ZmIHRyaWdnZXJzIGluIHRpbWUgc2Vuc2l0aXZlIGFwcGxpY2F0aW9ucyAoZm9yIGV4YW1wbGUgY2VsbCBjcmVhdGlvbilcblx0ICogYXMgaXRzIHNsb3cuXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7c3RyaW5nfSBjYWxsYmFja0FyciBOYW1lIG9mIHRoZSBhcnJheSBzdG9yYWdlIGZvciB0aGUgY2FsbGJhY2tzIGluXG5cdCAqICAgICAgb1NldHRpbmdzXG5cdCAqICBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIE5hbWUgb2YgdGhlIGpRdWVyeSBjdXN0b20gZXZlbnQgdG8gdHJpZ2dlci4gSWZcblx0ICogICAgICBudWxsIG5vIHRyaWdnZXIgaXMgZmlyZWRcblx0ICogIEBwYXJhbSB7YXJyYXl9IGFyZ3MgQXJyYXkgb2YgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIC9cblx0ICogICAgICB0cmlnZ2VyXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsIGNhbGxiYWNrQXJyLCBldmVudE5hbWUsIGFyZ3MgKVxuXHR7XG5cdFx0dmFyIHJldCA9IFtdO1xuXHRcblx0XHRpZiAoIGNhbGxiYWNrQXJyICkge1xuXHRcdFx0cmV0ID0gJC5tYXAoIHNldHRpbmdzW2NhbGxiYWNrQXJyXS5zbGljZSgpLnJldmVyc2UoKSwgZnVuY3Rpb24gKHZhbCwgaSkge1xuXHRcdFx0XHRyZXR1cm4gdmFsLmZuLmFwcGx5KCBzZXR0aW5ncy5vSW5zdGFuY2UsIGFyZ3MgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdFxuXHRcdGlmICggZXZlbnROYW1lICE9PSBudWxsICkge1xuXHRcdFx0dmFyIGUgPSAkLkV2ZW50KCBldmVudE5hbWUrJy5kdCcgKTtcblx0XG5cdFx0XHQkKHNldHRpbmdzLm5UYWJsZSkudHJpZ2dlciggZSwgYXJncyApO1xuXHRcblx0XHRcdHJldC5wdXNoKCBlLnJlc3VsdCApO1xuXHRcdH1cblx0XG5cdFx0cmV0dXJuIHJldDtcblx0fVxuXHRcblx0XG5cdGZ1bmN0aW9uIF9mbkxlbmd0aE92ZXJmbG93ICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyXG5cdFx0XHRzdGFydCA9IHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0LFxuXHRcdFx0ZW5kID0gc2V0dGluZ3MuZm5EaXNwbGF5RW5kKCksXG5cdFx0XHRsZW4gPSBzZXR0aW5ncy5faURpc3BsYXlMZW5ndGg7XG5cdFxuXHRcdC8qIElmIHdlIGhhdmUgc3BhY2UgdG8gc2hvdyBleHRyYSByb3dzIChiYWNraW5nIHVwIGZyb20gdGhlIGVuZCBwb2ludCAtIHRoZW4gZG8gc28gKi9cblx0XHRpZiAoIHN0YXJ0ID49IGVuZCApXG5cdFx0e1xuXHRcdFx0c3RhcnQgPSBlbmQgLSBsZW47XG5cdFx0fVxuXHRcblx0XHQvLyBLZWVwIHRoZSBzdGFydCByZWNvcmQgb24gdGhlIGN1cnJlbnQgcGFnZVxuXHRcdHN0YXJ0IC09IChzdGFydCAlIGxlbik7XG5cdFxuXHRcdGlmICggbGVuID09PSAtMSB8fCBzdGFydCA8IDAgKVxuXHRcdHtcblx0XHRcdHN0YXJ0ID0gMDtcblx0XHR9XG5cdFxuXHRcdHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0ID0gc3RhcnQ7XG5cdH1cblx0XG5cdFxuXHRmdW5jdGlvbiBfZm5SZW5kZXJlciggc2V0dGluZ3MsIHR5cGUgKVxuXHR7XG5cdFx0dmFyIHJlbmRlcmVyID0gc2V0dGluZ3MucmVuZGVyZXI7XG5cdFx0dmFyIGhvc3QgPSBEYXRhVGFibGUuZXh0LnJlbmRlcmVyW3R5cGVdO1xuXHRcblx0XHRpZiAoICQuaXNQbGFpbk9iamVjdCggcmVuZGVyZXIgKSAmJiByZW5kZXJlclt0eXBlXSApIHtcblx0XHRcdC8vIFNwZWNpZmljIHJlbmRlcmVyIGZvciB0aGlzIHR5cGUuIElmIGF2YWlsYWJsZSB1c2UgaXQsIG90aGVyd2lzZSB1c2Vcblx0XHRcdC8vIHRoZSBkZWZhdWx0LlxuXHRcdFx0cmV0dXJuIGhvc3RbcmVuZGVyZXJbdHlwZV1dIHx8IGhvc3QuXztcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHR5cGVvZiByZW5kZXJlciA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHQvLyBDb21tb24gcmVuZGVyZXIgLSBpZiB0aGVyZSBpcyBvbmUgYXZhaWxhYmxlIGZvciB0aGlzIHR5cGUgdXNlIGl0LFxuXHRcdFx0Ly8gb3RoZXJ3aXNlIHVzZSB0aGUgZGVmYXVsdFxuXHRcdFx0cmV0dXJuIGhvc3RbcmVuZGVyZXJdIHx8IGhvc3QuXztcblx0XHR9XG5cdFxuXHRcdC8vIFVzZSB0aGUgZGVmYXVsdFxuXHRcdHJldHVybiBob3N0Ll87XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogRGV0ZWN0IHRoZSBkYXRhIHNvdXJjZSBiZWluZyB1c2VkIGZvciB0aGUgdGFibGUuIFVzZWQgdG8gc2ltcGxpZnkgdGhlIGNvZGVcblx0ICogYSBsaXR0bGUgKGFqYXgpIGFuZCB0byBtYWtlIGl0IGNvbXByZXNzIGEgbGl0dGxlIHNtYWxsZXIuXG5cdCAqXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEByZXR1cm5zIHtzdHJpbmd9IERhdGEgc291cmNlXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkRhdGFTb3VyY2UgKCBzZXR0aW5ncyApXG5cdHtcblx0XHRpZiAoIHNldHRpbmdzLm9GZWF0dXJlcy5iU2VydmVyU2lkZSApIHtcblx0XHRcdHJldHVybiAnc3NwJztcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHNldHRpbmdzLmFqYXggfHwgc2V0dGluZ3Muc0FqYXhTb3VyY2UgKSB7XG5cdFx0XHRyZXR1cm4gJ2FqYXgnO1xuXHRcdH1cblx0XHRyZXR1cm4gJ2RvbSc7XG5cdH1cblx0XG5cblx0RGF0YVRhYmxlID0gZnVuY3Rpb24oIG9wdGlvbnMgKVxuXHR7XG5cdFx0LyoqXG5cdFx0ICogUGVyZm9ybSBhIGpRdWVyeSBzZWxlY3RvciBhY3Rpb24gb24gdGhlIHRhYmxlJ3MgVFIgZWxlbWVudHMgKGZyb20gdGhlIHRib2R5KSBhbmRcblx0XHQgKiByZXR1cm4gdGhlIHJlc3VsdGluZyBqUXVlcnkgb2JqZWN0LlxuXHRcdCAqICBAcGFyYW0ge3N0cmluZ3xub2RlfGpRdWVyeX0gc1NlbGVjdG9yIGpRdWVyeSBzZWxlY3RvciBvciBub2RlIGNvbGxlY3Rpb24gdG8gYWN0IG9uXG5cdFx0ICogIEBwYXJhbSB7b2JqZWN0fSBbb09wdHNdIE9wdGlvbmFsIHBhcmFtZXRlcnMgZm9yIG1vZGlmeWluZyB0aGUgcm93cyB0byBiZSBpbmNsdWRlZFxuXHRcdCAqICBAcGFyYW0ge3N0cmluZ30gW29PcHRzLmZpbHRlcj1ub25lXSBTZWxlY3QgVFIgZWxlbWVudHMgdGhhdCBtZWV0IHRoZSBjdXJyZW50IGZpbHRlclxuXHRcdCAqICAgIGNyaXRlcmlvbiAoXCJhcHBsaWVkXCIpIG9yIGFsbCBUUiBlbGVtZW50cyAoaS5lLiBubyBmaWx0ZXIpLlxuXHRcdCAqICBAcGFyYW0ge3N0cmluZ30gW29PcHRzLm9yZGVyPWN1cnJlbnRdIE9yZGVyIG9mIHRoZSBUUiBlbGVtZW50cyBpbiB0aGUgcHJvY2Vzc2VkIGFycmF5LlxuXHRcdCAqICAgIENhbiBiZSBlaXRoZXIgJ2N1cnJlbnQnLCB3aGVyZWJ5IHRoZSBjdXJyZW50IHNvcnRpbmcgb2YgdGhlIHRhYmxlIGlzIHVzZWQsIG9yXG5cdFx0ICogICAgJ29yaWdpbmFsJyB3aGVyZWJ5IHRoZSBvcmlnaW5hbCBvcmRlciB0aGUgZGF0YSB3YXMgcmVhZCBpbnRvIHRoZSB0YWJsZSBpcyB1c2VkLlxuXHRcdCAqICBAcGFyYW0ge3N0cmluZ30gW29PcHRzLnBhZ2U9YWxsXSBMaW1pdCB0aGUgc2VsZWN0aW9uIHRvIHRoZSBjdXJyZW50bHkgZGlzcGxheWVkIHBhZ2Vcblx0XHQgKiAgICAoXCJjdXJyZW50XCIpIG9yIG5vdCAoXCJhbGxcIikuIElmICdjdXJyZW50JyBpcyBnaXZlbiwgdGhlbiBvcmRlciBpcyBhc3N1bWVkIHRvIGJlXG5cdFx0ICogICAgJ2N1cnJlbnQnIGFuZCBmaWx0ZXIgaXMgJ2FwcGxpZWQnLCByZWdhcmRsZXNzIG9mIHdoYXQgdGhleSBtaWdodCBiZSBnaXZlbiBhcy5cblx0XHQgKiAgQHJldHVybnMge29iamVjdH0galF1ZXJ5IG9iamVjdCwgZmlsdGVyZWQgYnkgdGhlIGdpdmVuIHNlbGVjdG9yLlxuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqXG5cdFx0ICogICAgICAvLyBIaWdobGlnaHQgZXZlcnkgc2Vjb25kIHJvd1xuXHRcdCAqICAgICAgb1RhYmxlLiQoJ3RyOm9kZCcpLmNzcygnYmFja2dyb3VuZENvbG9yJywgJ2JsdWUnKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqXG5cdFx0ICogICAgICAvLyBGaWx0ZXIgdG8gcm93cyB3aXRoICdXZWJraXQnIGluIHRoZW0sIGFkZCBhIGJhY2tncm91bmQgY29sb3VyIGFuZCB0aGVuXG5cdFx0ICogICAgICAvLyByZW1vdmUgdGhlIGZpbHRlciwgdGh1cyBoaWdobGlnaHRpbmcgdGhlICdXZWJraXQnIHJvd3Mgb25seS5cblx0XHQgKiAgICAgIG9UYWJsZS5mbkZpbHRlcignV2Via2l0Jyk7XG5cdFx0ICogICAgICBvVGFibGUuJCgndHInLCB7XCJzZWFyY2hcIjogXCJhcHBsaWVkXCJ9KS5jc3MoJ2JhY2tncm91bmRDb2xvcicsICdibHVlJyk7XG5cdFx0ICogICAgICBvVGFibGUuZm5GaWx0ZXIoJycpO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHR0aGlzLiQgPSBmdW5jdGlvbiAoIHNTZWxlY3Rvciwgb09wdHMgKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLmFwaSh0cnVlKS4kKCBzU2VsZWN0b3IsIG9PcHRzICk7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBBbG1vc3QgaWRlbnRpY2FsIHRvICQgaW4gb3BlcmF0aW9uLCBidXQgaW4gdGhpcyBjYXNlIHJldHVybnMgdGhlIGRhdGEgZm9yIHRoZSBtYXRjaGVkXG5cdFx0ICogcm93cyAtIGFzIHN1Y2gsIHRoZSBqUXVlcnkgc2VsZWN0b3IgdXNlZCBzaG91bGQgbWF0Y2ggVFIgcm93IG5vZGVzIG9yIFREL1RIIGNlbGwgbm9kZXNcblx0XHQgKiByYXRoZXIgdGhhbiBhbnkgZGVzY2VuZGFudHMsIHNvIHRoZSBkYXRhIGNhbiBiZSBvYnRhaW5lZCBmb3IgdGhlIHJvdy9jZWxsLiBJZiBtYXRjaGluZ1xuXHRcdCAqIHJvd3MgYXJlIGZvdW5kLCB0aGUgZGF0YSByZXR1cm5lZCBpcyB0aGUgb3JpZ2luYWwgZGF0YSBhcnJheS9vYmplY3QgdGhhdCB3YXMgdXNlZCB0b1xuXHRcdCAqIGNyZWF0ZSB0aGUgcm93IChvciBhIGdlbmVyYXRlZCBhcnJheSBpZiBmcm9tIGEgRE9NIHNvdXJjZSkuXG5cdFx0ICpcblx0XHQgKiBUaGlzIG1ldGhvZCBpcyBvZnRlbiB1c2VmdWwgaW4tY29tYmluYXRpb24gd2l0aCAkIHdoZXJlIGJvdGggZnVuY3Rpb25zIGFyZSBnaXZlbiB0aGVcblx0XHQgKiBzYW1lIHBhcmFtZXRlcnMgYW5kIHRoZSBhcnJheSBpbmRleGVzIHdpbGwgbWF0Y2ggaWRlbnRpY2FsbHkuXG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nfG5vZGV8alF1ZXJ5fSBzU2VsZWN0b3IgalF1ZXJ5IHNlbGVjdG9yIG9yIG5vZGUgY29sbGVjdGlvbiB0byBhY3Qgb25cblx0XHQgKiAgQHBhcmFtIHtvYmplY3R9IFtvT3B0c10gT3B0aW9uYWwgcGFyYW1ldGVycyBmb3IgbW9kaWZ5aW5nIHRoZSByb3dzIHRvIGJlIGluY2x1ZGVkXG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nfSBbb09wdHMuZmlsdGVyPW5vbmVdIFNlbGVjdCBlbGVtZW50cyB0aGF0IG1lZXQgdGhlIGN1cnJlbnQgZmlsdGVyXG5cdFx0ICogICAgY3JpdGVyaW9uIChcImFwcGxpZWRcIikgb3IgYWxsIGVsZW1lbnRzIChpLmUuIG5vIGZpbHRlcikuXG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nfSBbb09wdHMub3JkZXI9Y3VycmVudF0gT3JkZXIgb2YgdGhlIGRhdGEgaW4gdGhlIHByb2Nlc3NlZCBhcnJheS5cblx0XHQgKiAgICBDYW4gYmUgZWl0aGVyICdjdXJyZW50Jywgd2hlcmVieSB0aGUgY3VycmVudCBzb3J0aW5nIG9mIHRoZSB0YWJsZSBpcyB1c2VkLCBvclxuXHRcdCAqICAgICdvcmlnaW5hbCcgd2hlcmVieSB0aGUgb3JpZ2luYWwgb3JkZXIgdGhlIGRhdGEgd2FzIHJlYWQgaW50byB0aGUgdGFibGUgaXMgdXNlZC5cblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd9IFtvT3B0cy5wYWdlPWFsbF0gTGltaXQgdGhlIHNlbGVjdGlvbiB0byB0aGUgY3VycmVudGx5IGRpc3BsYXllZCBwYWdlXG5cdFx0ICogICAgKFwiY3VycmVudFwiKSBvciBub3QgKFwiYWxsXCIpLiBJZiAnY3VycmVudCcgaXMgZ2l2ZW4sIHRoZW4gb3JkZXIgaXMgYXNzdW1lZCB0byBiZVxuXHRcdCAqICAgICdjdXJyZW50JyBhbmQgZmlsdGVyIGlzICdhcHBsaWVkJywgcmVnYXJkbGVzcyBvZiB3aGF0IHRoZXkgbWlnaHQgYmUgZ2l2ZW4gYXMuXG5cdFx0ICogIEByZXR1cm5zIHthcnJheX0gRGF0YSBmb3IgdGhlIG1hdGNoZWQgZWxlbWVudHMuIElmIGFueSBlbGVtZW50cywgYXMgYSByZXN1bHQgb2YgdGhlXG5cdFx0ICogICAgc2VsZWN0b3IsIHdlcmUgbm90IFRSLCBURCBvciBUSCBlbGVtZW50cyBpbiB0aGUgRGF0YVRhYmxlLCB0aGV5IHdpbGwgaGF2ZSBhIG51bGxcblx0XHQgKiAgICBlbnRyeSBpbiB0aGUgYXJyYXkuXG5cdFx0ICogIEBkdG9wdCBBUElcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdFx0ICpcblx0XHQgKiAgICAgIC8vIEdldCB0aGUgZGF0YSBmcm9tIHRoZSBmaXJzdCByb3cgaW4gdGhlIHRhYmxlXG5cdFx0ICogICAgICB2YXIgZGF0YSA9IG9UYWJsZS5fKCd0cjpmaXJzdCcpO1xuXHRcdCAqXG5cdFx0ICogICAgICAvLyBEbyBzb21ldGhpbmcgdXNlZnVsIHdpdGggdGhlIGRhdGFcblx0XHQgKiAgICAgIGFsZXJ0KCBcIkZpcnN0IGNlbGwgaXM6IFwiK2RhdGFbMF0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqXG5cdFx0ICogICAgICAvLyBGaWx0ZXIgdG8gJ1dlYmtpdCcgYW5kIGdldCBhbGwgZGF0YSBmb3Jcblx0XHQgKiAgICAgIG9UYWJsZS5mbkZpbHRlcignV2Via2l0Jyk7XG5cdFx0ICogICAgICB2YXIgZGF0YSA9IG9UYWJsZS5fKCd0cicsIHtcInNlYXJjaFwiOiBcImFwcGxpZWRcIn0pO1xuXHRcdCAqXG5cdFx0ICogICAgICAvLyBEbyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YVxuXHRcdCAqICAgICAgYWxlcnQoIGRhdGEubGVuZ3RoK1wiIHJvd3MgbWF0Y2hlZCB0aGUgc2VhcmNoXCIgKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy5fID0gZnVuY3Rpb24gKCBzU2VsZWN0b3IsIG9PcHRzIClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5hcGkodHJ1ZSkucm93cyggc1NlbGVjdG9yLCBvT3B0cyApLmRhdGEoKTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZSBhIERhdGFUYWJsZXMgQXBpIGluc3RhbmNlLCB3aXRoIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgdGFibGVzIGZvclxuXHRcdCAqIHRoZSBBcGkncyBjb250ZXh0LlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3RyYWRpdGlvbmFsPWZhbHNlXSBTZXQgdGhlIEFQSSBpbnN0YW5jZSdzIGNvbnRleHQgdG8gYmVcblx0XHQgKiAgIG9ubHkgdGhlIHRhYmxlIHJlZmVycmVkIHRvIGJ5IHRoZSBgRGF0YVRhYmxlLmV4dC5pQXBpSW5kZXhgIG9wdGlvbiwgYXMgd2FzXG5cdFx0ICogICB1c2VkIGluIHRoZSBBUEkgcHJlc2VudGVkIGJ5IERhdGFUYWJsZXMgMS45LSAoaS5lLiB0aGUgdHJhZGl0aW9uYWwgbW9kZSksXG5cdFx0ICogICBvciBpZiBhbGwgdGFibGVzIGNhcHR1cmVkIGluIHRoZSBqUXVlcnkgb2JqZWN0IHNob3VsZCBiZSB1c2VkLlxuXHRcdCAqIEByZXR1cm4ge0RhdGFUYWJsZXMuQXBpfVxuXHRcdCAqL1xuXHRcdHRoaXMuYXBpID0gZnVuY3Rpb24gKCB0cmFkaXRpb25hbCApXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRyYWRpdGlvbmFsID9cblx0XHRcdFx0bmV3IF9BcGkoXG5cdFx0XHRcdFx0X2ZuU2V0dGluZ3NGcm9tTm9kZSggdGhpc1sgX2V4dC5pQXBpSW5kZXggXSApXG5cdFx0XHRcdCkgOlxuXHRcdFx0XHRuZXcgX0FwaSggdGhpcyApO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQWRkIGEgc2luZ2xlIG5ldyByb3cgb3IgbXVsdGlwbGUgcm93cyBvZiBkYXRhIHRvIHRoZSB0YWJsZS4gUGxlYXNlIG5vdGVcblx0XHQgKiB0aGF0IHRoaXMgaXMgc3VpdGFibGUgZm9yIGNsaWVudC1zaWRlIHByb2Nlc3Npbmcgb25seSAtIGlmIHlvdSBhcmUgdXNpbmdcblx0XHQgKiBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIChpLmUuIFwiYlNlcnZlclNpZGVcIjogdHJ1ZSksIHRoZW4gdG8gYWRkIGRhdGEsIHlvdVxuXHRcdCAqIG11c3QgYWRkIGl0IHRvIHRoZSBkYXRhIHNvdXJjZSwgaS5lLiB0aGUgc2VydmVyLXNpZGUsIHRocm91Z2ggYW4gQWpheCBjYWxsLlxuXHRcdCAqICBAcGFyYW0ge2FycmF5fG9iamVjdH0gZGF0YSBUaGUgZGF0YSB0byBiZSBhZGRlZCB0byB0aGUgdGFibGUuIFRoaXMgY2FuIGJlOlxuXHRcdCAqICAgIDx1bD5cblx0XHQgKiAgICAgIDxsaT4xRCBhcnJheSBvZiBkYXRhIC0gYWRkIGEgc2luZ2xlIHJvdyB3aXRoIHRoZSBkYXRhIHByb3ZpZGVkPC9saT5cblx0XHQgKiAgICAgIDxsaT4yRCBhcnJheSBvZiBhcnJheXMgLSBhZGQgbXVsdGlwbGUgcm93cyBpbiBhIHNpbmdsZSBjYWxsPC9saT5cblx0XHQgKiAgICAgIDxsaT5vYmplY3QgLSBkYXRhIG9iamVjdCB3aGVuIHVzaW5nIDxpPm1EYXRhPC9pPjwvbGk+XG5cdFx0ICogICAgICA8bGk+YXJyYXkgb2Ygb2JqZWN0cyAtIG11bHRpcGxlIGRhdGEgb2JqZWN0cyB3aGVuIHVzaW5nIDxpPm1EYXRhPC9pPjwvbGk+XG5cdFx0ICogICAgPC91bD5cblx0XHQgKiAgQHBhcmFtIHtib29sfSBbcmVkcmF3PXRydWVdIHJlZHJhdyB0aGUgdGFibGUgb3Igbm90XG5cdFx0ICogIEByZXR1cm5zIHthcnJheX0gQW4gYXJyYXkgb2YgaW50ZWdlcnMsIHJlcHJlc2VudGluZyB0aGUgbGlzdCBvZiBpbmRleGVzIGluXG5cdFx0ICogICAgPGk+YW9EYXRhPC9pPiAoe0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzfSkgdGhhdCBoYXZlIGJlZW4gYWRkZWQgdG9cblx0XHQgKiAgICB0aGUgdGFibGUuXG5cdFx0ICogIEBkdG9wdCBBUElcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIEdsb2JhbCB2YXIgZm9yIGNvdW50ZXJcblx0XHQgKiAgICB2YXIgZ2lDb3VudCA9IDI7XG5cdFx0ICpcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogICAgZnVuY3Rpb24gZm5DbGlja0FkZFJvdygpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCkuZm5BZGREYXRhKCBbXG5cdFx0ICogICAgICAgIGdpQ291bnQrXCIuMVwiLFxuXHRcdCAqICAgICAgICBnaUNvdW50K1wiLjJcIixcblx0XHQgKiAgICAgICAgZ2lDb3VudCtcIi4zXCIsXG5cdFx0ICogICAgICAgIGdpQ291bnQrXCIuNFwiIF1cblx0XHQgKiAgICAgICk7XG5cdFx0ICpcblx0XHQgKiAgICAgIGdpQ291bnQrKztcblx0XHQgKiAgICB9XG5cdFx0ICovXG5cdFx0dGhpcy5mbkFkZERhdGEgPSBmdW5jdGlvbiggZGF0YSwgcmVkcmF3IClcblx0XHR7XG5cdFx0XHR2YXIgYXBpID0gdGhpcy5hcGkoIHRydWUgKTtcblx0XHRcblx0XHRcdC8qIENoZWNrIGlmIHdlIHdhbnQgdG8gYWRkIG11bHRpcGxlIHJvd3Mgb3Igbm90ICovXG5cdFx0XHR2YXIgcm93cyA9ICQuaXNBcnJheShkYXRhKSAmJiAoICQuaXNBcnJheShkYXRhWzBdKSB8fCAkLmlzUGxhaW5PYmplY3QoZGF0YVswXSkgKSA/XG5cdFx0XHRcdGFwaS5yb3dzLmFkZCggZGF0YSApIDpcblx0XHRcdFx0YXBpLnJvdy5hZGQoIGRhdGEgKTtcblx0XHRcblx0XHRcdGlmICggcmVkcmF3ID09PSB1bmRlZmluZWQgfHwgcmVkcmF3ICkge1xuXHRcdFx0XHRhcGkuZHJhdygpO1xuXHRcdFx0fVxuXHRcdFxuXHRcdFx0cmV0dXJuIHJvd3MuZmxhdHRlbigpLnRvQXJyYXkoKTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZnVuY3Rpb24gd2lsbCBtYWtlIERhdGFUYWJsZXMgcmVjYWxjdWxhdGUgdGhlIGNvbHVtbiBzaXplcywgYmFzZWQgb24gdGhlIGRhdGFcblx0XHQgKiBjb250YWluZWQgaW4gdGhlIHRhYmxlIGFuZCB0aGUgc2l6ZXMgYXBwbGllZCB0byB0aGUgY29sdW1ucyAoaW4gdGhlIERPTSwgQ1NTIG9yXG5cdFx0ICogdGhyb3VnaCB0aGUgc1dpZHRoIHBhcmFtZXRlcikuIFRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuIHRoZSB3aWR0aCBvZiB0aGUgdGFibGUnc1xuXHRcdCAqIHBhcmVudCBlbGVtZW50IGNoYW5nZXMgKGZvciBleGFtcGxlIGEgd2luZG93IHJlc2l6ZSkuXG5cdFx0ICogIEBwYXJhbSB7Ym9vbGVhbn0gW2JSZWRyYXc9dHJ1ZV0gUmVkcmF3IHRoZSB0YWJsZSBvciBub3QsIHlvdSB3aWxsIHR5cGljYWxseSB3YW50IHRvXG5cdFx0ICogIEBkdG9wdCBBUElcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwic1Njcm9sbFlcIjogXCIyMDBweFwiLFxuXHRcdCAqICAgICAgICBcImJQYWdpbmF0ZVwiOiBmYWxzZVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqXG5cdFx0ICogICAgICAkKHdpbmRvdykuYmluZCgncmVzaXplJywgZnVuY3Rpb24gKCkge1xuXHRcdCAqICAgICAgICBvVGFibGUuZm5BZGp1c3RDb2x1bW5TaXppbmcoKTtcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy5mbkFkanVzdENvbHVtblNpemluZyA9IGZ1bmN0aW9uICggYlJlZHJhdyApXG5cdFx0e1xuXHRcdFx0dmFyIGFwaSA9IHRoaXMuYXBpKCB0cnVlICkuY29sdW1ucy5hZGp1c3QoKTtcblx0XHRcdHZhciBzZXR0aW5ncyA9IGFwaS5zZXR0aW5ncygpWzBdO1xuXHRcdFx0dmFyIHNjcm9sbCA9IHNldHRpbmdzLm9TY3JvbGw7XG5cdFx0XG5cdFx0XHRpZiAoIGJSZWRyYXcgPT09IHVuZGVmaW5lZCB8fCBiUmVkcmF3ICkge1xuXHRcdFx0XHRhcGkuZHJhdyggZmFsc2UgKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBzY3JvbGwuc1ggIT09IFwiXCIgfHwgc2Nyb2xsLnNZICE9PSBcIlwiICkge1xuXHRcdFx0XHQvKiBJZiBub3QgcmVkcmF3aW5nLCBidXQgc2Nyb2xsaW5nLCB3ZSB3YW50IHRvIGFwcGx5IHRoZSBuZXcgY29sdW1uIHNpemVzIGFueXdheSAqL1xuXHRcdFx0XHRfZm5TY3JvbGxEcmF3KCBzZXR0aW5ncyApO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUXVpY2tseSBhbmQgc2ltcGx5IGNsZWFyIGEgdGFibGVcblx0XHQgKiAgQHBhcmFtIHtib29sfSBbYlJlZHJhdz10cnVlXSByZWRyYXcgdGhlIHRhYmxlIG9yIG5vdFxuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqXG5cdFx0ICogICAgICAvLyBJbW1lZGlhdGVseSAnbnVrZScgdGhlIGN1cnJlbnQgcm93cyAocGVyaGFwcyB3YWl0aW5nIGZvciBhbiBBamF4IGNhbGxiYWNrLi4uKVxuXHRcdCAqICAgICAgb1RhYmxlLmZuQ2xlYXJUYWJsZSgpO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHR0aGlzLmZuQ2xlYXJUYWJsZSA9IGZ1bmN0aW9uKCBiUmVkcmF3IClcblx0XHR7XG5cdFx0XHR2YXIgYXBpID0gdGhpcy5hcGkoIHRydWUgKS5jbGVhcigpO1xuXHRcdFxuXHRcdFx0aWYgKCBiUmVkcmF3ID09PSB1bmRlZmluZWQgfHwgYlJlZHJhdyApIHtcblx0XHRcdFx0YXBpLmRyYXcoKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBleGFjdCBvcHBvc2l0ZSBvZiAnb3BlbmluZycgYSByb3csIHRoaXMgZnVuY3Rpb24gd2lsbCBjbG9zZSBhbnkgcm93cyB3aGljaFxuXHRcdCAqIGFyZSBjdXJyZW50bHkgJ29wZW4nLlxuXHRcdCAqICBAcGFyYW0ge25vZGV9IG5UciB0aGUgdGFibGUgcm93IHRvICdjbG9zZSdcblx0XHQgKiAgQHJldHVybnMge2ludH0gMCBvbiBzdWNjZXNzLCBvciAxIGlmIGZhaWxlZCAoY2FuJ3QgZmluZCB0aGUgcm93KVxuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIHZhciBvVGFibGU7XG5cdFx0ICpcblx0XHQgKiAgICAgIC8vICdvcGVuJyBhbiBpbmZvcm1hdGlvbiByb3cgd2hlbiBhIHJvdyBpcyBjbGlja2VkIG9uXG5cdFx0ICogICAgICAkKCcjZXhhbXBsZSB0Ym9keSB0cicpLmNsaWNrKCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAgIGlmICggb1RhYmxlLmZuSXNPcGVuKHRoaXMpICkge1xuXHRcdCAqICAgICAgICAgIG9UYWJsZS5mbkNsb3NlKCB0aGlzICk7XG5cdFx0ICogICAgICAgIH0gZWxzZSB7XG5cdFx0ICogICAgICAgICAgb1RhYmxlLmZuT3BlbiggdGhpcywgXCJUZW1wb3Jhcnkgcm93IG9wZW5lZFwiLCBcImluZm9fcm93XCIgKTtcblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqXG5cdFx0ICogICAgICBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHR0aGlzLmZuQ2xvc2UgPSBmdW5jdGlvbiggblRyIClcblx0XHR7XG5cdFx0XHR0aGlzLmFwaSggdHJ1ZSApLnJvdyggblRyICkuY2hpbGQuaGlkZSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlIGEgcm93IGZvciB0aGUgdGFibGVcblx0XHQgKiAgQHBhcmFtIHttaXhlZH0gdGFyZ2V0IFRoZSBpbmRleCBvZiB0aGUgcm93IGZyb20gYW9EYXRhIHRvIGJlIGRlbGV0ZWQsIG9yXG5cdFx0ICogICAgdGhlIFRSIGVsZW1lbnQgeW91IHdhbnQgdG8gZGVsZXRlXG5cdFx0ICogIEBwYXJhbSB7ZnVuY3Rpb258bnVsbH0gW2NhbGxCYWNrXSBDYWxsYmFjayBmdW5jdGlvblxuXHRcdCAqICBAcGFyYW0ge2Jvb2x9IFtyZWRyYXc9dHJ1ZV0gUmVkcmF3IHRoZSB0YWJsZSBvciBub3Rcblx0XHQgKiAgQHJldHVybnMge2FycmF5fSBUaGUgcm93IHRoYXQgd2FzIGRlbGV0ZWRcblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gSW1tZWRpYXRlbHkgcmVtb3ZlIHRoZSBmaXJzdCByb3dcblx0XHQgKiAgICAgIG9UYWJsZS5mbkRlbGV0ZVJvdyggMCApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHR0aGlzLmZuRGVsZXRlUm93ID0gZnVuY3Rpb24oIHRhcmdldCwgY2FsbGJhY2ssIHJlZHJhdyApXG5cdFx0e1xuXHRcdFx0dmFyIGFwaSA9IHRoaXMuYXBpKCB0cnVlICk7XG5cdFx0XHR2YXIgcm93cyA9IGFwaS5yb3dzKCB0YXJnZXQgKTtcblx0XHRcdHZhciBzZXR0aW5ncyA9IHJvd3Muc2V0dGluZ3MoKVswXTtcblx0XHRcdHZhciBkYXRhID0gc2V0dGluZ3MuYW9EYXRhWyByb3dzWzBdWzBdIF07XG5cdFx0XG5cdFx0XHRyb3dzLnJlbW92ZSgpO1xuXHRcdFxuXHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0Y2FsbGJhY2suY2FsbCggdGhpcywgc2V0dGluZ3MsIGRhdGEgKTtcblx0XHRcdH1cblx0XHRcblx0XHRcdGlmICggcmVkcmF3ID09PSB1bmRlZmluZWQgfHwgcmVkcmF3ICkge1xuXHRcdFx0XHRhcGkuZHJhdygpO1xuXHRcdFx0fVxuXHRcdFxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXN0b3JlIHRoZSB0YWJsZSB0byBpdCdzIG9yaWdpbmFsIHN0YXRlIGluIHRoZSBET00gYnkgcmVtb3ZpbmcgYWxsIG9mIERhdGFUYWJsZXNcblx0XHQgKiBlbmhhbmNlbWVudHMsIGFsdGVyYXRpb25zIHRvIHRoZSBET00gc3RydWN0dXJlIG9mIHRoZSB0YWJsZSBhbmQgZXZlbnQgbGlzdGVuZXJzLlxuXHRcdCAqICBAcGFyYW0ge2Jvb2xlYW59IFtyZW1vdmU9ZmFsc2VdIENvbXBsZXRlbHkgcmVtb3ZlIHRoZSB0YWJsZSBmcm9tIHRoZSBET01cblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAvLyBUaGlzIGV4YW1wbGUgaXMgZmFpcmx5IHBvaW50bGVzcyBpbiByZWFsaXR5LCBidXQgc2hvd3MgaG93IGZuRGVzdHJveSBjYW4gYmUgdXNlZFxuXHRcdCAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdFx0ICogICAgICBvVGFibGUuZm5EZXN0cm95KCk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuZm5EZXN0cm95ID0gZnVuY3Rpb24gKCByZW1vdmUgKVxuXHRcdHtcblx0XHRcdHRoaXMuYXBpKCB0cnVlICkuZGVzdHJveSggcmVtb3ZlICk7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZWRyYXcgdGhlIHRhYmxlXG5cdFx0ICogIEBwYXJhbSB7Ym9vbH0gW2NvbXBsZXRlPXRydWVdIFJlLWZpbHRlciBhbmQgcmVzb3J0IChpZiBlbmFibGVkKSB0aGUgdGFibGUgYmVmb3JlIHRoZSBkcmF3LlxuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqXG5cdFx0ICogICAgICAvLyBSZS1kcmF3IHRoZSB0YWJsZSAtIHlvdSB3b3VsZG4ndCB3YW50IHRvIGRvIGl0IGhlcmUsIGJ1dCBpdCdzIGFuIGV4YW1wbGUgOi0pXG5cdFx0ICogICAgICBvVGFibGUuZm5EcmF3KCk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuZm5EcmF3ID0gZnVuY3Rpb24oIGNvbXBsZXRlIClcblx0XHR7XG5cdFx0XHQvLyBOb3RlIHRoYXQgdGhpcyBpc24ndCBhbiBleGFjdCBtYXRjaCB0byB0aGUgb2xkIGNhbGwgdG8gX2ZuRHJhdyAtIGl0IHRha2VzXG5cdFx0XHQvLyBpbnRvIGFjY291bnQgdGhlIG5ldyBkYXRhLCBidXQgY2FuIGhvbGQgcG9zaXRpb24uXG5cdFx0XHR0aGlzLmFwaSggdHJ1ZSApLmRyYXcoIGNvbXBsZXRlICk7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBGaWx0ZXIgdGhlIGlucHV0IGJhc2VkIG9uIGRhdGFcblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd9IHNJbnB1dCBTdHJpbmcgdG8gZmlsdGVyIHRoZSB0YWJsZSBvblxuXHRcdCAqICBAcGFyYW0ge2ludHxudWxsfSBbaUNvbHVtbl0gQ29sdW1uIHRvIGxpbWl0IGZpbHRlcmluZyB0b1xuXHRcdCAqICBAcGFyYW0ge2Jvb2x9IFtiUmVnZXg9ZmFsc2VdIFRyZWF0IGFzIHJlZ3VsYXIgZXhwcmVzc2lvbiBvciBub3Rcblx0XHQgKiAgQHBhcmFtIHtib29sfSBbYlNtYXJ0PXRydWVdIFBlcmZvcm0gc21hcnQgZmlsdGVyaW5nIG9yIG5vdFxuXHRcdCAqICBAcGFyYW0ge2Jvb2x9IFtiU2hvd0dsb2JhbD10cnVlXSBTaG93IHRoZSBpbnB1dCBnbG9iYWwgZmlsdGVyIGluIGl0J3MgaW5wdXQgYm94KGVzKVxuXHRcdCAqICBAcGFyYW0ge2Jvb2x9IFtiQ2FzZUluc2Vuc2l0aXZlPXRydWVdIERvIGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2hpbmcgKHRydWUpIG9yIG5vdCAoZmFsc2UpXG5cdFx0ICogIEBkdG9wdCBBUElcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdFx0ICpcblx0XHQgKiAgICAgIC8vIFNvbWV0aW1lIGxhdGVyIC0gZmlsdGVyLi4uXG5cdFx0ICogICAgICBvVGFibGUuZm5GaWx0ZXIoICd0ZXN0IHN0cmluZycgKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy5mbkZpbHRlciA9IGZ1bmN0aW9uKCBzSW5wdXQsIGlDb2x1bW4sIGJSZWdleCwgYlNtYXJ0LCBiU2hvd0dsb2JhbCwgYkNhc2VJbnNlbnNpdGl2ZSApXG5cdFx0e1xuXHRcdFx0dmFyIGFwaSA9IHRoaXMuYXBpKCB0cnVlICk7XG5cdFx0XG5cdFx0XHRpZiAoIGlDb2x1bW4gPT09IG51bGwgfHwgaUNvbHVtbiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRhcGkuc2VhcmNoKCBzSW5wdXQsIGJSZWdleCwgYlNtYXJ0LCBiQ2FzZUluc2Vuc2l0aXZlICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0YXBpLmNvbHVtbiggaUNvbHVtbiApLnNlYXJjaCggc0lucHV0LCBiUmVnZXgsIGJTbWFydCwgYkNhc2VJbnNlbnNpdGl2ZSApO1xuXHRcdFx0fVxuXHRcdFxuXHRcdFx0YXBpLmRyYXcoKTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgZGF0YSBmb3IgdGhlIHdob2xlIHRhYmxlLCBhbiBpbmRpdmlkdWFsIHJvdyBvciBhbiBpbmRpdmlkdWFsIGNlbGwgYmFzZWQgb24gdGhlXG5cdFx0ICogcHJvdmlkZWQgcGFyYW1ldGVycy5cblx0XHQgKiAgQHBhcmFtIHtpbnR8bm9kZX0gW3NyY10gQSBUUiByb3cgbm9kZSwgVEQvVEggY2VsbCBub2RlIG9yIGFuIGludGVnZXIuIElmIGdpdmVuIGFzXG5cdFx0ICogICAgYSBUUiBub2RlIHRoZW4gdGhlIGRhdGEgc291cmNlIGZvciB0aGUgd2hvbGUgcm93IHdpbGwgYmUgcmV0dXJuZWQuIElmIGdpdmVuIGFzIGFcblx0XHQgKiAgICBURC9USCBjZWxsIG5vZGUgdGhlbiBpQ29sIHdpbGwgYmUgYXV0b21hdGljYWxseSBjYWxjdWxhdGVkIGFuZCB0aGUgZGF0YSBmb3IgdGhlXG5cdFx0ICogICAgY2VsbCByZXR1cm5lZC4gSWYgZ2l2ZW4gYXMgYW4gaW50ZWdlciwgdGhlbiB0aGlzIGlzIHRyZWF0ZWQgYXMgdGhlIGFvRGF0YSBpbnRlcm5hbFxuXHRcdCAqICAgIGRhdGEgaW5kZXggZm9yIHRoZSByb3cgKHNlZSBmbkdldFBvc2l0aW9uKSBhbmQgdGhlIGRhdGEgZm9yIHRoYXQgcm93IHVzZWQuXG5cdFx0ICogIEBwYXJhbSB7aW50fSBbY29sXSBPcHRpb25hbCBjb2x1bW4gaW5kZXggdGhhdCB5b3Ugd2FudCB0aGUgZGF0YSBvZi5cblx0XHQgKiAgQHJldHVybnMge2FycmF5fG9iamVjdHxzdHJpbmd9IElmIG1Sb3cgaXMgdW5kZWZpbmVkLCB0aGVuIHRoZSBkYXRhIGZvciBhbGwgcm93cyBpc1xuXHRcdCAqICAgIHJldHVybmVkLiBJZiBtUm93IGlzIGRlZmluZWQsIGp1c3QgZGF0YSBmb3IgdGhhdCByb3csIGFuZCBpcyBpQ29sIGlzXG5cdFx0ICogICAgZGVmaW5lZCwgb25seSBkYXRhIGZvciB0aGUgZGVzaWduYXRlZCBjZWxsIGlzIHJldHVybmVkLlxuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBSb3cgZGF0YVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKlxuXHRcdCAqICAgICAgb1RhYmxlLiQoJ3RyJykuY2xpY2soIGZ1bmN0aW9uICgpIHtcblx0XHQgKiAgICAgICAgdmFyIGRhdGEgPSBvVGFibGUuZm5HZXREYXRhKCB0aGlzICk7XG5cdFx0ICogICAgICAgIC8vIC4uLiBkbyBzb21ldGhpbmcgd2l0aCB0aGUgYXJyYXkgLyBvYmplY3Qgb2YgZGF0YSBmb3IgdGhlIHJvd1xuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIEluZGl2aWR1YWwgY2VsbCBkYXRhXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqXG5cdFx0ICogICAgICBvVGFibGUuJCgndGQnKS5jbGljayggZnVuY3Rpb24gKCkge1xuXHRcdCAqICAgICAgICB2YXIgc0RhdGEgPSBvVGFibGUuZm5HZXREYXRhKCB0aGlzICk7XG5cdFx0ICogICAgICAgIGFsZXJ0KCAnVGhlIGNlbGwgY2xpY2tlZCBvbiBoYWQgdGhlIHZhbHVlIG9mICcrc0RhdGEgKTtcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy5mbkdldERhdGEgPSBmdW5jdGlvbiggc3JjLCBjb2wgKVxuXHRcdHtcblx0XHRcdHZhciBhcGkgPSB0aGlzLmFwaSggdHJ1ZSApO1xuXHRcdFxuXHRcdFx0aWYgKCBzcmMgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0dmFyIHR5cGUgPSBzcmMubm9kZU5hbWUgPyBzcmMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA6ICcnO1xuXHRcdFxuXHRcdFx0XHRyZXR1cm4gY29sICE9PSB1bmRlZmluZWQgfHwgdHlwZSA9PSAndGQnIHx8IHR5cGUgPT0gJ3RoJyA/XG5cdFx0XHRcdFx0YXBpLmNlbGwoIHNyYywgY29sICkuZGF0YSgpIDpcblx0XHRcdFx0XHRhcGkucm93KCBzcmMgKS5kYXRhKCkgfHwgbnVsbDtcblx0XHRcdH1cblx0XHRcblx0XHRcdHJldHVybiBhcGkuZGF0YSgpLnRvQXJyYXkoKTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldCBhbiBhcnJheSBvZiB0aGUgVFIgbm9kZXMgdGhhdCBhcmUgdXNlZCBpbiB0aGUgdGFibGUncyBib2R5LiBOb3RlIHRoYXQgeW91IHdpbGxcblx0XHQgKiB0eXBpY2FsbHkgd2FudCB0byB1c2UgdGhlICckJyBBUEkgbWV0aG9kIGluIHByZWZlcmVuY2UgdG8gdGhpcyBhcyBpdCBpcyBtb3JlXG5cdFx0ICogZmxleGlibGUuXG5cdFx0ICogIEBwYXJhbSB7aW50fSBbaVJvd10gT3B0aW9uYWwgcm93IGluZGV4IGZvciB0aGUgVFIgZWxlbWVudCB5b3Ugd2FudFxuXHRcdCAqICBAcmV0dXJucyB7YXJyYXl8bm9kZX0gSWYgaVJvdyBpcyB1bmRlZmluZWQsIHJldHVybnMgYW4gYXJyYXkgb2YgYWxsIFRSIGVsZW1lbnRzXG5cdFx0ICogICAgaW4gdGhlIHRhYmxlJ3MgYm9keSwgb3IgaVJvdyBpcyBkZWZpbmVkLCBqdXN0IHRoZSBUUiBlbGVtZW50IHJlcXVlc3RlZC5cblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gR2V0IHRoZSBub2RlcyBmcm9tIHRoZSB0YWJsZVxuXHRcdCAqICAgICAgdmFyIG5Ob2RlcyA9IG9UYWJsZS5mbkdldE5vZGVzKCApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHR0aGlzLmZuR2V0Tm9kZXMgPSBmdW5jdGlvbiggaVJvdyApXG5cdFx0e1xuXHRcdFx0dmFyIGFwaSA9IHRoaXMuYXBpKCB0cnVlICk7XG5cdFx0XG5cdFx0XHRyZXR1cm4gaVJvdyAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0YXBpLnJvdyggaVJvdyApLm5vZGUoKSA6XG5cdFx0XHRcdGFwaS5yb3dzKCkubm9kZXMoKS5mbGF0dGVuKCkudG9BcnJheSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0IHRoZSBhcnJheSBpbmRleGVzIG9mIGEgcGFydGljdWxhciBjZWxsIGZyb20gaXQncyBET00gZWxlbWVudFxuXHRcdCAqIGFuZCBjb2x1bW4gaW5kZXggaW5jbHVkaW5nIGhpZGRlbiBjb2x1bW5zXG5cdFx0ICogIEBwYXJhbSB7bm9kZX0gbm9kZSB0aGlzIGNhbiBlaXRoZXIgYmUgYSBUUiwgVEQgb3IgVEggaW4gdGhlIHRhYmxlJ3MgYm9keVxuXHRcdCAqICBAcmV0dXJucyB7aW50fSBJZiBuTm9kZSBpcyBnaXZlbiBhcyBhIFRSLCB0aGVuIGEgc2luZ2xlIGluZGV4IGlzIHJldHVybmVkLCBvclxuXHRcdCAqICAgIGlmIGdpdmVuIGFzIGEgY2VsbCwgYW4gYXJyYXkgb2YgW3JvdyBpbmRleCwgY29sdW1uIGluZGV4ICh2aXNpYmxlKSxcblx0XHQgKiAgICBjb2x1bW4gaW5kZXggKGFsbCldIGlzIGdpdmVuLlxuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlIHRib2R5IHRkJykuY2xpY2soIGZ1bmN0aW9uICgpIHtcblx0XHQgKiAgICAgICAgLy8gR2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgY3VycmVudCBkYXRhIGZyb20gdGhlIG5vZGVcblx0XHQgKiAgICAgICAgdmFyIGFQb3MgPSBvVGFibGUuZm5HZXRQb3NpdGlvbiggdGhpcyApO1xuXHRcdCAqXG5cdFx0ICogICAgICAgIC8vIEdldCB0aGUgZGF0YSBhcnJheSBmb3IgdGhpcyByb3dcblx0XHQgKiAgICAgICAgdmFyIGFEYXRhID0gb1RhYmxlLmZuR2V0RGF0YSggYVBvc1swXSApO1xuXHRcdCAqXG5cdFx0ICogICAgICAgIC8vIFVwZGF0ZSB0aGUgZGF0YSBhcnJheSBhbmQgcmV0dXJuIHRoZSB2YWx1ZVxuXHRcdCAqICAgICAgICBhRGF0YVsgYVBvc1sxXSBdID0gJ2NsaWNrZWQnO1xuXHRcdCAqICAgICAgICB0aGlzLmlubmVySFRNTCA9ICdjbGlja2VkJztcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gSW5pdCBEYXRhVGFibGVzXG5cdFx0ICogICAgICBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHR0aGlzLmZuR2V0UG9zaXRpb24gPSBmdW5jdGlvbiggbm9kZSApXG5cdFx0e1xuXHRcdFx0dmFyIGFwaSA9IHRoaXMuYXBpKCB0cnVlICk7XG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBub2RlLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG5cdFx0XG5cdFx0XHRpZiAoIG5vZGVOYW1lID09ICdUUicgKSB7XG5cdFx0XHRcdHJldHVybiBhcGkucm93KCBub2RlICkuaW5kZXgoKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBub2RlTmFtZSA9PSAnVEQnIHx8IG5vZGVOYW1lID09ICdUSCcgKSB7XG5cdFx0XHRcdHZhciBjZWxsID0gYXBpLmNlbGwoIG5vZGUgKS5pbmRleCgpO1xuXHRcdFxuXHRcdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRcdGNlbGwucm93LFxuXHRcdFx0XHRcdGNlbGwuY29sdW1uVmlzaWJsZSxcblx0XHRcdFx0XHRjZWxsLmNvbHVtblxuXHRcdFx0XHRdO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBDaGVjayB0byBzZWUgaWYgYSByb3cgaXMgJ29wZW4nIG9yIG5vdC5cblx0XHQgKiAgQHBhcmFtIHtub2RlfSBuVHIgdGhlIHRhYmxlIHJvdyB0byBjaGVja1xuXHRcdCAqICBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgcm93IGlzIGN1cnJlbnRseSBvcGVuLCBmYWxzZSBvdGhlcndpc2Vcblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlO1xuXHRcdCAqXG5cdFx0ICogICAgICAvLyAnb3BlbicgYW4gaW5mb3JtYXRpb24gcm93IHdoZW4gYSByb3cgaXMgY2xpY2tlZCBvblxuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUgdGJvZHkgdHInKS5jbGljayggZnVuY3Rpb24gKCkge1xuXHRcdCAqICAgICAgICBpZiAoIG9UYWJsZS5mbklzT3Blbih0aGlzKSApIHtcblx0XHQgKiAgICAgICAgICBvVGFibGUuZm5DbG9zZSggdGhpcyApO1xuXHRcdCAqICAgICAgICB9IGVsc2Uge1xuXHRcdCAqICAgICAgICAgIG9UYWJsZS5mbk9wZW4oIHRoaXMsIFwiVGVtcG9yYXJ5IHJvdyBvcGVuZWRcIiwgXCJpbmZvX3Jvd1wiICk7XG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICAgICAgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy5mbklzT3BlbiA9IGZ1bmN0aW9uKCBuVHIgKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLmFwaSggdHJ1ZSApLnJvdyggblRyICkuY2hpbGQuaXNTaG93bigpO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmdW5jdGlvbiB3aWxsIHBsYWNlIGEgbmV3IHJvdyBkaXJlY3RseSBhZnRlciBhIHJvdyB3aGljaCBpcyBjdXJyZW50bHlcblx0XHQgKiBvbiBkaXNwbGF5IG9uIHRoZSBwYWdlLCB3aXRoIHRoZSBIVE1MIGNvbnRlbnRzIHRoYXQgaXMgcGFzc2VkIGludG8gdGhlXG5cdFx0ICogZnVuY3Rpb24uIFRoaXMgY2FuIGJlIHVzZWQsIGZvciBleGFtcGxlLCB0byBhc2sgZm9yIGNvbmZpcm1hdGlvbiB0aGF0IGFcblx0XHQgKiBwYXJ0aWN1bGFyIHJlY29yZCBzaG91bGQgYmUgZGVsZXRlZC5cblx0XHQgKiAgQHBhcmFtIHtub2RlfSBuVHIgVGhlIHRhYmxlIHJvdyB0byAnb3Blbidcblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd8bm9kZXxqUXVlcnl9IG1IdG1sIFRoZSBIVE1MIHRvIHB1dCBpbnRvIHRoZSByb3dcblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd9IHNDbGFzcyBDbGFzcyB0byBnaXZlIHRoZSBuZXcgVEQgY2VsbFxuXHRcdCAqICBAcmV0dXJucyB7bm9kZX0gVGhlIHJvdyBvcGVuZWQuIE5vdGUgdGhhdCBpZiB0aGUgdGFibGUgcm93IHBhc3NlZCBpbiBhcyB0aGVcblx0XHQgKiAgICBmaXJzdCBwYXJhbWV0ZXIsIGlzIG5vdCBmb3VuZCBpbiB0aGUgdGFibGUsIHRoaXMgbWV0aG9kIHdpbGwgc2lsZW50bHlcblx0XHQgKiAgICByZXR1cm4uXG5cdFx0ICogIEBkdG9wdCBBUElcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgdmFyIG9UYWJsZTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gJ29wZW4nIGFuIGluZm9ybWF0aW9uIHJvdyB3aGVuIGEgcm93IGlzIGNsaWNrZWQgb25cblx0XHQgKiAgICAgICQoJyNleGFtcGxlIHRib2R5IHRyJykuY2xpY2soIGZ1bmN0aW9uICgpIHtcblx0XHQgKiAgICAgICAgaWYgKCBvVGFibGUuZm5Jc09wZW4odGhpcykgKSB7XG5cdFx0ICogICAgICAgICAgb1RhYmxlLmZuQ2xvc2UoIHRoaXMgKTtcblx0XHQgKiAgICAgICAgfSBlbHNlIHtcblx0XHQgKiAgICAgICAgICBvVGFibGUuZm5PcGVuKCB0aGlzLCBcIlRlbXBvcmFyeSByb3cgb3BlbmVkXCIsIFwiaW5mb19yb3dcIiApO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgICAgIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuZm5PcGVuID0gZnVuY3Rpb24oIG5UciwgbUh0bWwsIHNDbGFzcyApXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuYXBpKCB0cnVlIClcblx0XHRcdFx0LnJvdyggblRyIClcblx0XHRcdFx0LmNoaWxkKCBtSHRtbCwgc0NsYXNzIClcblx0XHRcdFx0LnNob3coKVxuXHRcdFx0XHQuY2hpbGQoKVswXTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENoYW5nZSB0aGUgcGFnaW5hdGlvbiAtIHByb3ZpZGVzIHRoZSBpbnRlcm5hbCBsb2dpYyBmb3IgcGFnaW5hdGlvbiBpbiBhIHNpbXBsZSBBUElcblx0XHQgKiBmdW5jdGlvbi4gV2l0aCB0aGlzIGZ1bmN0aW9uIHlvdSBjYW4gaGF2ZSBhIERhdGFUYWJsZXMgdGFibGUgZ28gdG8gdGhlIG5leHQsXG5cdFx0ICogcHJldmlvdXMsIGZpcnN0IG9yIGxhc3QgcGFnZXMuXG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nfGludH0gbUFjdGlvbiBQYWdpbmcgYWN0aW9uIHRvIHRha2U6IFwiZmlyc3RcIiwgXCJwcmV2aW91c1wiLCBcIm5leHRcIiBvciBcImxhc3RcIlxuXHRcdCAqICAgIG9yIHBhZ2UgbnVtYmVyIHRvIGp1bXAgdG8gKGludGVnZXIpLCBub3RlIHRoYXQgcGFnZSAwIGlzIHRoZSBmaXJzdCBwYWdlLlxuXHRcdCAqICBAcGFyYW0ge2Jvb2x9IFtiUmVkcmF3PXRydWVdIFJlZHJhdyB0aGUgdGFibGUgb3Igbm90XG5cdFx0ICogIEBkdG9wdCBBUElcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdFx0ICogICAgICBvVGFibGUuZm5QYWdlQ2hhbmdlKCAnbmV4dCcgKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy5mblBhZ2VDaGFuZ2UgPSBmdW5jdGlvbiAoIG1BY3Rpb24sIGJSZWRyYXcgKVxuXHRcdHtcblx0XHRcdHZhciBhcGkgPSB0aGlzLmFwaSggdHJ1ZSApLnBhZ2UoIG1BY3Rpb24gKTtcblx0XHRcblx0XHRcdGlmICggYlJlZHJhdyA9PT0gdW5kZWZpbmVkIHx8IGJSZWRyYXcgKSB7XG5cdFx0XHRcdGFwaS5kcmF3KGZhbHNlKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFNob3cgYSBwYXJ0aWN1bGFyIGNvbHVtblxuXHRcdCAqICBAcGFyYW0ge2ludH0gaUNvbCBUaGUgY29sdW1uIHdob3NlIGRpc3BsYXkgc2hvdWxkIGJlIGNoYW5nZWRcblx0XHQgKiAgQHBhcmFtIHtib29sfSBiU2hvdyBTaG93ICh0cnVlKSBvciBoaWRlIChmYWxzZSkgdGhlIGNvbHVtblxuXHRcdCAqICBAcGFyYW0ge2Jvb2x9IFtiUmVkcmF3PXRydWVdIFJlZHJhdyB0aGUgdGFibGUgb3Igbm90XG5cdFx0ICogIEBkdG9wdCBBUElcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdFx0ICpcblx0XHQgKiAgICAgIC8vIEhpZGUgdGhlIHNlY29uZCBjb2x1bW4gYWZ0ZXIgaW5pdGlhbGlzYXRpb25cblx0XHQgKiAgICAgIG9UYWJsZS5mblNldENvbHVtblZpcyggMSwgZmFsc2UgKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy5mblNldENvbHVtblZpcyA9IGZ1bmN0aW9uICggaUNvbCwgYlNob3csIGJSZWRyYXcgKVxuXHRcdHtcblx0XHRcdHZhciBhcGkgPSB0aGlzLmFwaSggdHJ1ZSApLmNvbHVtbiggaUNvbCApLnZpc2libGUoIGJTaG93ICk7XG5cdFx0XG5cdFx0XHRpZiAoIGJSZWRyYXcgPT09IHVuZGVmaW5lZCB8fCBiUmVkcmF3ICkge1xuXHRcdFx0XHRhcGkuY29sdW1ucy5hZGp1c3QoKS5kcmF3KCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXQgdGhlIHNldHRpbmdzIGZvciBhIHBhcnRpY3VsYXIgdGFibGUgZm9yIGV4dGVybmFsIG1hbmlwdWxhdGlvblxuXHRcdCAqICBAcmV0dXJucyB7b2JqZWN0fSBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdC4gU2VlXG5cdFx0ICogICAge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzfVxuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqICAgICAgdmFyIG9TZXR0aW5ncyA9IG9UYWJsZS5mblNldHRpbmdzKCk7XG5cdFx0ICpcblx0XHQgKiAgICAgIC8vIFNob3cgYW4gZXhhbXBsZSBwYXJhbWV0ZXIgZnJvbSB0aGUgc2V0dGluZ3Ncblx0XHQgKiAgICAgIGFsZXJ0KCBvU2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy5mblNldHRpbmdzID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdHJldHVybiBfZm5TZXR0aW5nc0Zyb21Ob2RlKCB0aGlzW19leHQuaUFwaUluZGV4XSApO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU29ydCB0aGUgdGFibGUgYnkgYSBwYXJ0aWN1bGFyIGNvbHVtblxuXHRcdCAqICBAcGFyYW0ge2ludH0gaUNvbCB0aGUgZGF0YSBpbmRleCB0byBzb3J0IG9uLiBOb3RlIHRoYXQgdGhpcyB3aWxsIG5vdCBtYXRjaCB0aGVcblx0XHQgKiAgICAnZGlzcGxheSBpbmRleCcgaWYgeW91IGhhdmUgaGlkZGVuIGRhdGEgZW50cmllc1xuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqXG5cdFx0ICogICAgICAvLyBTb3J0IGltbWVkaWF0ZWx5IHdpdGggY29sdW1ucyAwIGFuZCAxXG5cdFx0ICogICAgICBvVGFibGUuZm5Tb3J0KCBbIFswLCdhc2MnXSwgWzEsJ2FzYyddIF0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy5mblNvcnQgPSBmdW5jdGlvbiggYWFTb3J0IClcblx0XHR7XG5cdFx0XHR0aGlzLmFwaSggdHJ1ZSApLm9yZGVyKCBhYVNvcnQgKS5kcmF3KCk7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBBdHRhY2ggYSBzb3J0IGxpc3RlbmVyIHRvIGFuIGVsZW1lbnQgZm9yIGEgZ2l2ZW4gY29sdW1uXG5cdFx0ICogIEBwYXJhbSB7bm9kZX0gbk5vZGUgdGhlIGVsZW1lbnQgdG8gYXR0YWNoIHRoZSBzb3J0IGxpc3RlbmVyIHRvXG5cdFx0ICogIEBwYXJhbSB7aW50fSBpQ29sdW1uIHRoZSBjb2x1bW4gdGhhdCBhIGNsaWNrIG9uIHRoaXMgbm9kZSB3aWxsIHNvcnQgb25cblx0XHQgKiAgQHBhcmFtIHtmdW5jdGlvbn0gW2ZuQ2FsbGJhY2tdIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gc29ydCBpcyBydW5cblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gU29ydCBvbiBjb2x1bW4gMSwgd2hlbiAnc29ydGVyJyBpcyBjbGlja2VkIG9uXG5cdFx0ICogICAgICBvVGFibGUuZm5Tb3J0TGlzdGVuZXIoIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzb3J0ZXInKSwgMSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHR0aGlzLmZuU29ydExpc3RlbmVyID0gZnVuY3Rpb24oIG5Ob2RlLCBpQ29sdW1uLCBmbkNhbGxiYWNrIClcblx0XHR7XG5cdFx0XHR0aGlzLmFwaSggdHJ1ZSApLm9yZGVyLmxpc3RlbmVyKCBuTm9kZSwgaUNvbHVtbiwgZm5DYWxsYmFjayApO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogVXBkYXRlIGEgdGFibGUgY2VsbCBvciByb3cgLSB0aGlzIG1ldGhvZCB3aWxsIGFjY2VwdCBlaXRoZXIgYSBzaW5nbGUgdmFsdWUgdG9cblx0XHQgKiB1cGRhdGUgdGhlIGNlbGwgd2l0aCwgYW4gYXJyYXkgb2YgdmFsdWVzIHdpdGggb25lIGVsZW1lbnQgZm9yIGVhY2ggY29sdW1uIG9yXG5cdFx0ICogYW4gb2JqZWN0IGluIHRoZSBzYW1lIGZvcm1hdCBhcyB0aGUgb3JpZ2luYWwgZGF0YSBzb3VyY2UuIFRoZSBmdW5jdGlvbiBpc1xuXHRcdCAqIHNlbGYtcmVmZXJlbmNpbmcgaW4gb3JkZXIgdG8gbWFrZSB0aGUgbXVsdGkgY29sdW1uIHVwZGF0ZXMgZWFzaWVyLlxuXHRcdCAqICBAcGFyYW0ge29iamVjdHxhcnJheXxzdHJpbmd9IG1EYXRhIERhdGEgdG8gdXBkYXRlIHRoZSBjZWxsL3JvdyB3aXRoXG5cdFx0ICogIEBwYXJhbSB7bm9kZXxpbnR9IG1Sb3cgVFIgZWxlbWVudCB5b3Ugd2FudCB0byB1cGRhdGUgb3IgdGhlIGFvRGF0YSBpbmRleFxuXHRcdCAqICBAcGFyYW0ge2ludH0gW2lDb2x1bW5dIFRoZSBjb2x1bW4gdG8gdXBkYXRlLCBnaXZlIGFzIG51bGwgb3IgdW5kZWZpbmVkIHRvXG5cdFx0ICogICAgdXBkYXRlIGEgd2hvbGUgcm93LlxuXHRcdCAqICBAcGFyYW0ge2Jvb2x9IFtiUmVkcmF3PXRydWVdIFJlZHJhdyB0aGUgdGFibGUgb3Igbm90XG5cdFx0ICogIEBwYXJhbSB7Ym9vbH0gW2JBY3Rpb249dHJ1ZV0gUGVyZm9ybSBwcmUtZHJhdyBhY3Rpb25zIG9yIG5vdFxuXHRcdCAqICBAcmV0dXJucyB7aW50fSAwIG9uIHN1Y2Nlc3MsIDEgb24gZXJyb3Jcblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKiAgICAgIG9UYWJsZS5mblVwZGF0ZSggJ0V4YW1wbGUgdXBkYXRlJywgMCwgMCApOyAvLyBTaW5nbGUgY2VsbFxuXHRcdCAqICAgICAgb1RhYmxlLmZuVXBkYXRlKCBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddLCAkKCd0Ym9keSB0cicpWzBdICk7IC8vIFJvd1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHR0aGlzLmZuVXBkYXRlID0gZnVuY3Rpb24oIG1EYXRhLCBtUm93LCBpQ29sdW1uLCBiUmVkcmF3LCBiQWN0aW9uIClcblx0XHR7XG5cdFx0XHR2YXIgYXBpID0gdGhpcy5hcGkoIHRydWUgKTtcblx0XHRcblx0XHRcdGlmICggaUNvbHVtbiA9PT0gdW5kZWZpbmVkIHx8IGlDb2x1bW4gPT09IG51bGwgKSB7XG5cdFx0XHRcdGFwaS5yb3coIG1Sb3cgKS5kYXRhKCBtRGF0YSApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGFwaS5jZWxsKCBtUm93LCBpQ29sdW1uICkuZGF0YSggbURhdGEgKTtcblx0XHRcdH1cblx0XHRcblx0XHRcdGlmICggYkFjdGlvbiA9PT0gdW5kZWZpbmVkIHx8IGJBY3Rpb24gKSB7XG5cdFx0XHRcdGFwaS5jb2x1bW5zLmFkanVzdCgpO1xuXHRcdFx0fVxuXHRcdFxuXHRcdFx0aWYgKCBiUmVkcmF3ID09PSB1bmRlZmluZWQgfHwgYlJlZHJhdyApIHtcblx0XHRcdFx0YXBpLmRyYXcoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAwO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUHJvdmlkZSBhIGNvbW1vbiBtZXRob2QgZm9yIHBsdWctaW5zIHRvIGNoZWNrIHRoZSB2ZXJzaW9uIG9mIERhdGFUYWJsZXMgYmVpbmcgdXNlZCwgaW4gb3JkZXJcblx0XHQgKiB0byBlbnN1cmUgY29tcGF0aWJpbGl0eS5cblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd9IHNWZXJzaW9uIFZlcnNpb24gc3RyaW5nIHRvIGNoZWNrIGZvciwgaW4gdGhlIGZvcm1hdCBcIlguWS5aXCIuIE5vdGUgdGhhdCB0aGVcblx0XHQgKiAgICBmb3JtYXRzIFwiWFwiIGFuZCBcIlguWVwiIGFyZSBhbHNvIGFjY2VwdGFibGUuXG5cdFx0ICogIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoaXMgdmVyc2lvbiBvZiBEYXRhVGFibGVzIGlzIGdyZWF0ZXIgb3IgZXF1YWwgdG8gdGhlIHJlcXVpcmVkXG5cdFx0ICogICAgdmVyc2lvbiwgb3IgZmFsc2UgaWYgdGhpcyB2ZXJzaW9uIG9mIERhdGFUYWxlcyBpcyBub3Qgc3VpdGFibGVcblx0XHQgKiAgQG1ldGhvZFxuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqICAgICAgYWxlcnQoIG9UYWJsZS5mblZlcnNpb25DaGVjayggJzEuOS4wJyApICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuZm5WZXJzaW9uQ2hlY2sgPSBfZXh0LmZuVmVyc2lvbkNoZWNrO1xuXHRcdFxuXG5cdFx0dmFyIF90aGF0ID0gdGhpcztcblx0XHR2YXIgZW1wdHlJbml0ID0gb3B0aW9ucyA9PT0gdW5kZWZpbmVkO1xuXHRcdHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcblxuXHRcdGlmICggZW1wdHlJbml0ICkge1xuXHRcdFx0b3B0aW9ucyA9IHt9O1xuXHRcdH1cblxuXHRcdHRoaXMub0FwaSA9IHRoaXMuaW50ZXJuYWwgPSBfZXh0LmludGVybmFsO1xuXG5cdFx0Ly8gRXh0ZW5kIHdpdGggb2xkIHN0eWxlIHBsdWctaW4gQVBJIG1ldGhvZHNcblx0XHRmb3IgKCB2YXIgZm4gaW4gRGF0YVRhYmxlLmV4dC5pbnRlcm5hbCApIHtcblx0XHRcdGlmICggZm4gKSB7XG5cdFx0XHRcdHRoaXNbZm5dID0gX2ZuRXh0ZXJuQXBpRnVuYyhmbik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gRm9yIGVhY2ggaW5pdGlhbGlzYXRpb24gd2Ugd2FudCB0byBnaXZlIGl0IGEgY2xlYW4gaW5pdGlhbGlzYXRpb25cblx0XHRcdC8vIG9iamVjdCB0aGF0IGNhbiBiZSBiYXNoZWQgYXJvdW5kXG5cdFx0XHR2YXIgbyA9IHt9O1xuXHRcdFx0dmFyIG9Jbml0ID0gbGVuID4gMSA/IC8vIG9wdGltaXNhdGlvbiBmb3Igc2luZ2xlIHRhYmxlIGNhc2Vcblx0XHRcdFx0X2ZuRXh0ZW5kKCBvLCBvcHRpb25zLCB0cnVlICkgOlxuXHRcdFx0XHRvcHRpb25zO1xuXG5cdFx0XHQvKmdsb2JhbCBvSW5pdCxfdGhhdCxlbXB0eUluaXQqL1xuXHRcdFx0dmFyIGk9MCwgaUxlbiwgaiwgakxlbiwgaywga0xlbjtcblx0XHRcdHZhciBzSWQgPSB0aGlzLmdldEF0dHJpYnV0ZSggJ2lkJyApO1xuXHRcdFx0dmFyIGJJbml0SGFuZGVkT2ZmID0gZmFsc2U7XG5cdFx0XHR2YXIgZGVmYXVsdHMgPSBEYXRhVGFibGUuZGVmYXVsdHM7XG5cdFx0XHR2YXIgJHRoaXMgPSAkKHRoaXMpO1xuXHRcdFx0XG5cdFx0XHRcblx0XHRcdC8qIFNhbml0eSBjaGVjayAqL1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT0gJ3RhYmxlJyApXG5cdFx0XHR7XG5cdFx0XHRcdF9mbkxvZyggbnVsbCwgMCwgJ05vbi10YWJsZSBub2RlIGluaXRpYWxpc2F0aW9uICgnK3RoaXMubm9kZU5hbWUrJyknLCAyICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0LyogQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZm9yIHRoZSBkZWZhdWx0cyAqL1xuXHRcdFx0X2ZuQ29tcGF0T3B0cyggZGVmYXVsdHMgKTtcblx0XHRcdF9mbkNvbXBhdENvbHMoIGRlZmF1bHRzLmNvbHVtbiApO1xuXHRcdFx0XG5cdFx0XHQvKiBDb252ZXJ0IHRoZSBjYW1lbC1jYXNlIGRlZmF1bHRzIHRvIEh1bmdhcmlhbiAqL1xuXHRcdFx0X2ZuQ2FtZWxUb0h1bmdhcmlhbiggZGVmYXVsdHMsIGRlZmF1bHRzLCB0cnVlICk7XG5cdFx0XHRfZm5DYW1lbFRvSHVuZ2FyaWFuKCBkZWZhdWx0cy5jb2x1bW4sIGRlZmF1bHRzLmNvbHVtbiwgdHJ1ZSApO1xuXHRcdFx0XG5cdFx0XHQvKiBTZXR0aW5nIHVwIHRoZSBpbml0aWFsaXNhdGlvbiBvYmplY3QgKi9cblx0XHRcdF9mbkNhbWVsVG9IdW5nYXJpYW4oIGRlZmF1bHRzLCAkLmV4dGVuZCggb0luaXQsICR0aGlzLmRhdGEoKSApICk7XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0XG5cdFx0XHQvKiBDaGVjayB0byBzZWUgaWYgd2UgYXJlIHJlLWluaXRpYWxpc2luZyBhIHRhYmxlICovXG5cdFx0XHR2YXIgYWxsU2V0dGluZ3MgPSBEYXRhVGFibGUuc2V0dGluZ3M7XG5cdFx0XHRmb3IgKCBpPTAsIGlMZW49YWxsU2V0dGluZ3MubGVuZ3RoIDsgaTxpTGVuIDsgaSsrIClcblx0XHRcdHtcblx0XHRcdFx0dmFyIHMgPSBhbGxTZXR0aW5nc1tpXTtcblx0XHRcdFxuXHRcdFx0XHQvKiBCYXNlIGNoZWNrIG9uIHRhYmxlIG5vZGUgKi9cblx0XHRcdFx0aWYgKCBzLm5UYWJsZSA9PSB0aGlzIHx8IHMublRIZWFkLnBhcmVudE5vZGUgPT0gdGhpcyB8fCAocy5uVEZvb3QgJiYgcy5uVEZvb3QucGFyZW50Tm9kZSA9PSB0aGlzKSApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR2YXIgYlJldHJpZXZlID0gb0luaXQuYlJldHJpZXZlICE9PSB1bmRlZmluZWQgPyBvSW5pdC5iUmV0cmlldmUgOiBkZWZhdWx0cy5iUmV0cmlldmU7XG5cdFx0XHRcdFx0dmFyIGJEZXN0cm95ID0gb0luaXQuYkRlc3Ryb3kgIT09IHVuZGVmaW5lZCA/IG9Jbml0LmJEZXN0cm95IDogZGVmYXVsdHMuYkRlc3Ryb3k7XG5cdFx0XHRcblx0XHRcdFx0XHRpZiAoIGVtcHR5SW5pdCB8fCBiUmV0cmlldmUgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHJldHVybiBzLm9JbnN0YW5jZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIGJEZXN0cm95IClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRzLm9JbnN0YW5jZS5mbkRlc3Ryb3koKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0X2ZuTG9nKCBzLCAwLCAnQ2Fubm90IHJlaW5pdGlhbGlzZSBEYXRhVGFibGUnLCAzICk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcblx0XHRcdFx0LyogSWYgdGhlIGVsZW1lbnQgd2UgYXJlIGluaXRpYWxpc2luZyBoYXMgdGhlIHNhbWUgSUQgYXMgYSB0YWJsZSB3aGljaCB3YXMgcHJldmlvdXNseVxuXHRcdFx0XHQgKiBpbml0aWFsaXNlZCwgYnV0IHRoZSB0YWJsZSBub2RlcyBkb24ndCBtYXRjaCAoZnJvbSBiZWZvcmUpIHRoZW4gd2UgZGVzdHJveSB0aGUgb2xkXG5cdFx0XHRcdCAqIGluc3RhbmNlIGJ5IHNpbXBseSBkZWxldGluZyBpdC4gVGhpcyBpcyB1bmRlciB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoZSB0YWJsZSBoYXMgYmVlblxuXHRcdFx0XHQgKiBkZXN0cm95ZWQgYnkgb3RoZXIgbWV0aG9kcy4gQW55b25lIHVzaW5nIG5vbi1pZCBzZWxlY3RvcnMgd2lsbCBuZWVkIHRvIGRvIHRoaXMgbWFudWFsbHlcblx0XHRcdFx0ICovXG5cdFx0XHRcdGlmICggcy5zVGFibGVJZCA9PSB0aGlzLmlkIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGFsbFNldHRpbmdzLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qIEVuc3VyZSB0aGUgdGFibGUgaGFzIGFuIElEIC0gcmVxdWlyZWQgZm9yIGFjY2Vzc2liaWxpdHkgKi9cblx0XHRcdGlmICggc0lkID09PSBudWxsIHx8IHNJZCA9PT0gXCJcIiApXG5cdFx0XHR7XG5cdFx0XHRcdHNJZCA9IFwiRGF0YVRhYmxlc19UYWJsZV9cIisoRGF0YVRhYmxlLmV4dC5fdW5pcXVlKyspO1xuXHRcdFx0XHR0aGlzLmlkID0gc0lkO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvKiBDcmVhdGUgdGhlIHNldHRpbmdzIG9iamVjdCBmb3IgdGhpcyB0YWJsZSBhbmQgc2V0IHNvbWUgb2YgdGhlIGRlZmF1bHQgcGFyYW1ldGVycyAqL1xuXHRcdFx0dmFyIG9TZXR0aW5ncyA9ICQuZXh0ZW5kKCB0cnVlLCB7fSwgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3MsIHtcblx0XHRcdFx0XCJzRGVzdHJveVdpZHRoXCI6ICR0aGlzWzBdLnN0eWxlLndpZHRoLFxuXHRcdFx0XHRcInNJbnN0YW5jZVwiOiAgICAgc0lkLFxuXHRcdFx0XHRcInNUYWJsZUlkXCI6ICAgICAgc0lkXG5cdFx0XHR9ICk7XG5cdFx0XHRvU2V0dGluZ3MublRhYmxlID0gdGhpcztcblx0XHRcdG9TZXR0aW5ncy5vQXBpICAgPSBfdGhhdC5pbnRlcm5hbDtcblx0XHRcdG9TZXR0aW5ncy5vSW5pdCAgPSBvSW5pdDtcblx0XHRcdFxuXHRcdFx0YWxsU2V0dGluZ3MucHVzaCggb1NldHRpbmdzICk7XG5cdFx0XHRcblx0XHRcdC8vIE5lZWQgdG8gYWRkIHRoZSBpbnN0YW5jZSBhZnRlciB0aGUgaW5zdGFuY2UgYWZ0ZXIgdGhlIHNldHRpbmdzIG9iamVjdCBoYXMgYmVlbiBhZGRlZFxuXHRcdFx0Ly8gdG8gdGhlIHNldHRpbmdzIGFycmF5LCBzbyB3ZSBjYW4gc2VsZiByZWZlcmVuY2UgdGhlIHRhYmxlIGluc3RhbmNlIGlmIG1vcmUgdGhhbiBvbmVcblx0XHRcdG9TZXR0aW5ncy5vSW5zdGFuY2UgPSAoX3RoYXQubGVuZ3RoPT09MSkgPyBfdGhhdCA6ICR0aGlzLmRhdGFUYWJsZSgpO1xuXHRcdFx0XG5cdFx0XHQvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgYmVmb3JlIHdlIGFwcGx5IGFsbCB0aGUgZGVmYXVsdHNcblx0XHRcdF9mbkNvbXBhdE9wdHMoIG9Jbml0ICk7XG5cdFx0XHRcblx0XHRcdGlmICggb0luaXQub0xhbmd1YWdlIClcblx0XHRcdHtcblx0XHRcdFx0X2ZuTGFuZ3VhZ2VDb21wYXQoIG9Jbml0Lm9MYW5ndWFnZSApO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBJZiB0aGUgbGVuZ3RoIG1lbnUgaXMgZ2l2ZW4sIGJ1dCB0aGUgaW5pdCBkaXNwbGF5IGxlbmd0aCBpcyBub3QsIHVzZSB0aGUgbGVuZ3RoIG1lbnVcblx0XHRcdGlmICggb0luaXQuYUxlbmd0aE1lbnUgJiYgISBvSW5pdC5pRGlzcGxheUxlbmd0aCApXG5cdFx0XHR7XG5cdFx0XHRcdG9Jbml0LmlEaXNwbGF5TGVuZ3RoID0gJC5pc0FycmF5KCBvSW5pdC5hTGVuZ3RoTWVudVswXSApID9cblx0XHRcdFx0XHRvSW5pdC5hTGVuZ3RoTWVudVswXVswXSA6IG9Jbml0LmFMZW5ndGhNZW51WzBdO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBBcHBseSB0aGUgZGVmYXVsdHMgYW5kIGluaXQgb3B0aW9ucyB0byBtYWtlIGEgc2luZ2xlIGluaXQgb2JqZWN0IHdpbGwgYWxsXG5cdFx0XHQvLyBvcHRpb25zIGRlZmluZWQgZnJvbSBkZWZhdWx0cyBhbmQgaW5zdGFuY2Ugb3B0aW9ucy5cblx0XHRcdG9Jbml0ID0gX2ZuRXh0ZW5kKCAkLmV4dGVuZCggdHJ1ZSwge30sIGRlZmF1bHRzICksIG9Jbml0ICk7XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0Ly8gTWFwIHRoZSBpbml0aWFsaXNhdGlvbiBvcHRpb25zIG9udG8gdGhlIHNldHRpbmdzIG9iamVjdFxuXHRcdFx0X2ZuTWFwKCBvU2V0dGluZ3Mub0ZlYXR1cmVzLCBvSW5pdCwgW1xuXHRcdFx0XHRcImJQYWdpbmF0ZVwiLFxuXHRcdFx0XHRcImJMZW5ndGhDaGFuZ2VcIixcblx0XHRcdFx0XCJiRmlsdGVyXCIsXG5cdFx0XHRcdFwiYlNvcnRcIixcblx0XHRcdFx0XCJiU29ydE11bHRpXCIsXG5cdFx0XHRcdFwiYkluZm9cIixcblx0XHRcdFx0XCJiUHJvY2Vzc2luZ1wiLFxuXHRcdFx0XHRcImJBdXRvV2lkdGhcIixcblx0XHRcdFx0XCJiU29ydENsYXNzZXNcIixcblx0XHRcdFx0XCJiU2VydmVyU2lkZVwiLFxuXHRcdFx0XHRcImJEZWZlclJlbmRlclwiXG5cdFx0XHRdICk7XG5cdFx0XHRfZm5NYXAoIG9TZXR0aW5ncywgb0luaXQsIFtcblx0XHRcdFx0XCJhc1N0cmlwZUNsYXNzZXNcIixcblx0XHRcdFx0XCJhamF4XCIsXG5cdFx0XHRcdFwiZm5TZXJ2ZXJEYXRhXCIsXG5cdFx0XHRcdFwiZm5Gb3JtYXROdW1iZXJcIixcblx0XHRcdFx0XCJzU2VydmVyTWV0aG9kXCIsXG5cdFx0XHRcdFwiYWFTb3J0aW5nXCIsXG5cdFx0XHRcdFwiYWFTb3J0aW5nRml4ZWRcIixcblx0XHRcdFx0XCJhTGVuZ3RoTWVudVwiLFxuXHRcdFx0XHRcInNQYWdpbmF0aW9uVHlwZVwiLFxuXHRcdFx0XHRcInNBamF4U291cmNlXCIsXG5cdFx0XHRcdFwic0FqYXhEYXRhUHJvcFwiLFxuXHRcdFx0XHRcImlTdGF0ZUR1cmF0aW9uXCIsXG5cdFx0XHRcdFwic0RvbVwiLFxuXHRcdFx0XHRcImJTb3J0Q2VsbHNUb3BcIixcblx0XHRcdFx0XCJpVGFiSW5kZXhcIixcblx0XHRcdFx0XCJmblN0YXRlTG9hZENhbGxiYWNrXCIsXG5cdFx0XHRcdFwiZm5TdGF0ZVNhdmVDYWxsYmFja1wiLFxuXHRcdFx0XHRcInJlbmRlcmVyXCIsXG5cdFx0XHRcdFwic2VhcmNoRGVsYXlcIixcblx0XHRcdFx0WyBcImlDb29raWVEdXJhdGlvblwiLCBcImlTdGF0ZUR1cmF0aW9uXCIgXSwgLy8gYmFja3dhcmRzIGNvbXBhdFxuXHRcdFx0XHRbIFwib1NlYXJjaFwiLCBcIm9QcmV2aW91c1NlYXJjaFwiIF0sXG5cdFx0XHRcdFsgXCJhb1NlYXJjaENvbHNcIiwgXCJhb1ByZVNlYXJjaENvbHNcIiBdLFxuXHRcdFx0XHRbIFwiaURpc3BsYXlMZW5ndGhcIiwgXCJfaURpc3BsYXlMZW5ndGhcIiBdLFxuXHRcdFx0XHRbIFwiYkpRdWVyeVVJXCIsIFwiYkpVSVwiIF1cblx0XHRcdF0gKTtcblx0XHRcdF9mbk1hcCggb1NldHRpbmdzLm9TY3JvbGwsIG9Jbml0LCBbXG5cdFx0XHRcdFsgXCJzU2Nyb2xsWFwiLCBcInNYXCIgXSxcblx0XHRcdFx0WyBcInNTY3JvbGxYSW5uZXJcIiwgXCJzWElubmVyXCIgXSxcblx0XHRcdFx0WyBcInNTY3JvbGxZXCIsIFwic1lcIiBdLFxuXHRcdFx0XHRbIFwiYlNjcm9sbENvbGxhcHNlXCIsIFwiYkNvbGxhcHNlXCIgXVxuXHRcdFx0XSApO1xuXHRcdFx0X2ZuTWFwKCBvU2V0dGluZ3Mub0xhbmd1YWdlLCBvSW5pdCwgXCJmbkluZm9DYWxsYmFja1wiICk7XG5cdFx0XHRcblx0XHRcdC8qIENhbGxiYWNrIGZ1bmN0aW9ucyB3aGljaCBhcmUgYXJyYXkgZHJpdmVuICovXG5cdFx0XHRfZm5DYWxsYmFja1JlZyggb1NldHRpbmdzLCAnYW9EcmF3Q2FsbGJhY2snLCAgICAgICBvSW5pdC5mbkRyYXdDYWxsYmFjaywgICAgICAndXNlcicgKTtcblx0XHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb1NlcnZlclBhcmFtcycsICAgICAgIG9Jbml0LmZuU2VydmVyUGFyYW1zLCAgICAgICd1c2VyJyApO1xuXHRcdFx0X2ZuQ2FsbGJhY2tSZWcoIG9TZXR0aW5ncywgJ2FvU3RhdGVTYXZlUGFyYW1zJywgICAgb0luaXQuZm5TdGF0ZVNhdmVQYXJhbXMsICAgJ3VzZXInICk7XG5cdFx0XHRfZm5DYWxsYmFja1JlZyggb1NldHRpbmdzLCAnYW9TdGF0ZUxvYWRQYXJhbXMnLCAgICBvSW5pdC5mblN0YXRlTG9hZFBhcmFtcywgICAndXNlcicgKTtcblx0XHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb1N0YXRlTG9hZGVkJywgICAgICAgIG9Jbml0LmZuU3RhdGVMb2FkZWQsICAgICAgICd1c2VyJyApO1xuXHRcdFx0X2ZuQ2FsbGJhY2tSZWcoIG9TZXR0aW5ncywgJ2FvUm93Q2FsbGJhY2snLCAgICAgICAgb0luaXQuZm5Sb3dDYWxsYmFjaywgICAgICAgJ3VzZXInICk7XG5cdFx0XHRfZm5DYWxsYmFja1JlZyggb1NldHRpbmdzLCAnYW9Sb3dDcmVhdGVkQ2FsbGJhY2snLCBvSW5pdC5mbkNyZWF0ZWRSb3csICAgICAgICAndXNlcicgKTtcblx0XHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb0hlYWRlckNhbGxiYWNrJywgICAgIG9Jbml0LmZuSGVhZGVyQ2FsbGJhY2ssICAgICd1c2VyJyApO1xuXHRcdFx0X2ZuQ2FsbGJhY2tSZWcoIG9TZXR0aW5ncywgJ2FvRm9vdGVyQ2FsbGJhY2snLCAgICAgb0luaXQuZm5Gb290ZXJDYWxsYmFjaywgICAgJ3VzZXInICk7XG5cdFx0XHRfZm5DYWxsYmFja1JlZyggb1NldHRpbmdzLCAnYW9Jbml0Q29tcGxldGUnLCAgICAgICBvSW5pdC5mbkluaXRDb21wbGV0ZSwgICAgICAndXNlcicgKTtcblx0XHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb1ByZURyYXdDYWxsYmFjaycsICAgIG9Jbml0LmZuUHJlRHJhd0NhbGxiYWNrLCAgICd1c2VyJyApO1xuXHRcdFx0XG5cdFx0XHR2YXIgb0NsYXNzZXMgPSBvU2V0dGluZ3Mub0NsYXNzZXM7XG5cdFx0XHRcblx0XHRcdC8vIEB0b2RvIFJlbW92ZSBpbiAxLjExXG5cdFx0XHRpZiAoIG9Jbml0LmJKUXVlcnlVSSApXG5cdFx0XHR7XG5cdFx0XHRcdC8qIFVzZSB0aGUgSlVJIGNsYXNzZXMgb2JqZWN0IGZvciBkaXNwbGF5LiBZb3UgY291bGQgY2xvbmUgdGhlIG9TdGRDbGFzc2VzIG9iamVjdCBpZlxuXHRcdFx0XHQgKiB5b3Ugd2FudCB0byBoYXZlIG11bHRpcGxlIHRhYmxlcyB3aXRoIG11bHRpcGxlIGluZGVwZW5kZW50IGNsYXNzZXNcblx0XHRcdFx0ICovXG5cdFx0XHRcdCQuZXh0ZW5kKCBvQ2xhc3NlcywgRGF0YVRhYmxlLmV4dC5vSlVJQ2xhc3Nlcywgb0luaXQub0NsYXNzZXMgKTtcblx0XHRcdFxuXHRcdFx0XHRpZiAoIG9Jbml0LnNEb20gPT09IGRlZmF1bHRzLnNEb20gJiYgZGVmYXVsdHMuc0RvbSA9PT0gXCJsZnJ0aXBcIiApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHQvKiBTZXQgdGhlIERPTSB0byB1c2UgYSBsYXlvdXQgc3VpdGFibGUgZm9yIGpRdWVyeSBVSSdzIHRoZW1pbmcgKi9cblx0XHRcdFx0XHRvU2V0dGluZ3Muc0RvbSA9ICc8XCJIXCJsZnI+dDxcIkZcImlwPic7XG5cdFx0XHRcdH1cblx0XHRcdFxuXHRcdFx0XHRpZiAoICEgb1NldHRpbmdzLnJlbmRlcmVyICkge1xuXHRcdFx0XHRcdG9TZXR0aW5ncy5yZW5kZXJlciA9ICdqcXVlcnl1aSc7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoICQuaXNQbGFpbk9iamVjdCggb1NldHRpbmdzLnJlbmRlcmVyICkgJiYgISBvU2V0dGluZ3MucmVuZGVyZXIuaGVhZGVyICkge1xuXHRcdFx0XHRcdG9TZXR0aW5ncy5yZW5kZXJlci5oZWFkZXIgPSAnanF1ZXJ5dWknO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdCQuZXh0ZW5kKCBvQ2xhc3NlcywgRGF0YVRhYmxlLmV4dC5jbGFzc2VzLCBvSW5pdC5vQ2xhc3NlcyApO1xuXHRcdFx0fVxuXHRcdFx0JHRoaXMuYWRkQ2xhc3MoIG9DbGFzc2VzLnNUYWJsZSApO1xuXHRcdFx0XG5cdFx0XHQvKiBDYWxjdWxhdGUgdGhlIHNjcm9sbCBiYXIgd2lkdGggYW5kIGNhY2hlIGl0IGZvciB1c2UgbGF0ZXIgb24gKi9cblx0XHRcdGlmICggb1NldHRpbmdzLm9TY3JvbGwuc1ggIT09IFwiXCIgfHwgb1NldHRpbmdzLm9TY3JvbGwuc1kgIT09IFwiXCIgKVxuXHRcdFx0e1xuXHRcdFx0XHRvU2V0dGluZ3Mub1Njcm9sbC5pQmFyV2lkdGggPSBfZm5TY3JvbGxCYXJXaWR0aCgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBvU2V0dGluZ3Mub1Njcm9sbC5zWCA9PT0gdHJ1ZSApIHsgLy8gRWFzeSBpbml0aWFsaXNhdGlvbiBvZiB4LXNjcm9sbGluZ1xuXHRcdFx0XHRvU2V0dGluZ3Mub1Njcm9sbC5zWCA9ICcxMDAlJztcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKCBvU2V0dGluZ3MuaUluaXREaXNwbGF5U3RhcnQgPT09IHVuZGVmaW5lZCApXG5cdFx0XHR7XG5cdFx0XHRcdC8qIERpc3BsYXkgc3RhcnQgcG9pbnQsIHRha2luZyBpbnRvIGFjY291bnQgdGhlIHNhdmUgc2F2aW5nICovXG5cdFx0XHRcdG9TZXR0aW5ncy5pSW5pdERpc3BsYXlTdGFydCA9IG9Jbml0LmlEaXNwbGF5U3RhcnQ7XG5cdFx0XHRcdG9TZXR0aW5ncy5faURpc3BsYXlTdGFydCA9IG9Jbml0LmlEaXNwbGF5U3RhcnQ7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmICggb0luaXQuaURlZmVyTG9hZGluZyAhPT0gbnVsbCApXG5cdFx0XHR7XG5cdFx0XHRcdG9TZXR0aW5ncy5iRGVmZXJMb2FkaW5nID0gdHJ1ZTtcblx0XHRcdFx0dmFyIHRtcCA9ICQuaXNBcnJheSggb0luaXQuaURlZmVyTG9hZGluZyApO1xuXHRcdFx0XHRvU2V0dGluZ3MuX2lSZWNvcmRzRGlzcGxheSA9IHRtcCA/IG9Jbml0LmlEZWZlckxvYWRpbmdbMF0gOiBvSW5pdC5pRGVmZXJMb2FkaW5nO1xuXHRcdFx0XHRvU2V0dGluZ3MuX2lSZWNvcmRzVG90YWwgPSB0bXAgPyBvSW5pdC5pRGVmZXJMb2FkaW5nWzFdIDogb0luaXQuaURlZmVyTG9hZGluZztcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0LyogTGFuZ3VhZ2UgZGVmaW5pdGlvbnMgKi9cblx0XHRcdHZhciBvTGFuZ3VhZ2UgPSBvU2V0dGluZ3Mub0xhbmd1YWdlO1xuXHRcdFx0JC5leHRlbmQoIHRydWUsIG9MYW5ndWFnZSwgb0luaXQub0xhbmd1YWdlICk7XG5cdFx0XHRcblx0XHRcdGlmICggb0xhbmd1YWdlLnNVcmwgIT09IFwiXCIgKVxuXHRcdFx0e1xuXHRcdFx0XHQvKiBHZXQgdGhlIGxhbmd1YWdlIGRlZmluaXRpb25zIGZyb20gYSBmaWxlIC0gYmVjYXVzZSB0aGlzIEFqYXggY2FsbCBtYWtlcyB0aGUgbGFuZ3VhZ2Vcblx0XHRcdFx0ICogZ2V0IGFzeW5jIHRvIHRoZSByZW1haW5kZXIgb2YgdGhpcyBmdW5jdGlvbiB3ZSB1c2UgYkluaXRIYW5kZWRPZmYgdG8gaW5kaWNhdGUgdGhhdFxuXHRcdFx0XHQgKiBfZm5Jbml0aWFsaXNlIHdpbGwgYmUgZmlyZWQgYnkgdGhlIHJldHVybmVkIEFqYXggaGFuZGxlciwgcmF0aGVyIHRoYW4gdGhlIGNvbnN0cnVjdG9yXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHQkLmFqYXgoIHtcblx0XHRcdFx0XHRkYXRhVHlwZTogJ2pzb24nLFxuXHRcdFx0XHRcdHVybDogb0xhbmd1YWdlLnNVcmwsXG5cdFx0XHRcdFx0c3VjY2VzczogZnVuY3Rpb24gKCBqc29uICkge1xuXHRcdFx0XHRcdFx0X2ZuTGFuZ3VhZ2VDb21wYXQoIGpzb24gKTtcblx0XHRcdFx0XHRcdF9mbkNhbWVsVG9IdW5nYXJpYW4oIGRlZmF1bHRzLm9MYW5ndWFnZSwganNvbiApO1xuXHRcdFx0XHRcdFx0JC5leHRlbmQoIHRydWUsIG9MYW5ndWFnZSwganNvbiApO1xuXHRcdFx0XHRcdFx0X2ZuSW5pdGlhbGlzZSggb1NldHRpbmdzICk7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRlcnJvcjogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0Ly8gRXJyb3Igb2NjdXJyZWQgbG9hZGluZyBsYW5ndWFnZSBmaWxlLCBjb250aW51ZSBvbiBhcyBiZXN0IHdlIGNhblxuXHRcdFx0XHRcdFx0X2ZuSW5pdGlhbGlzZSggb1NldHRpbmdzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdGJJbml0SGFuZGVkT2ZmID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Lypcblx0XHRcdCAqIFN0cmlwZXNcblx0XHRcdCAqL1xuXHRcdFx0aWYgKCBvSW5pdC5hc1N0cmlwZUNsYXNzZXMgPT09IG51bGwgKVxuXHRcdFx0e1xuXHRcdFx0XHRvU2V0dGluZ3MuYXNTdHJpcGVDbGFzc2VzID1bXG5cdFx0XHRcdFx0b0NsYXNzZXMuc1N0cmlwZU9kZCxcblx0XHRcdFx0XHRvQ2xhc3Nlcy5zU3RyaXBlRXZlblxuXHRcdFx0XHRdO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvKiBSZW1vdmUgcm93IHN0cmlwZSBjbGFzc2VzIGlmIHRoZXkgYXJlIGFscmVhZHkgb24gdGhlIHRhYmxlIHJvdyAqL1xuXHRcdFx0dmFyIHN0cmlwZUNsYXNzZXMgPSBvU2V0dGluZ3MuYXNTdHJpcGVDbGFzc2VzO1xuXHRcdFx0dmFyIHJvd09uZSA9ICR0aGlzLmNoaWxkcmVuKCd0Ym9keScpLmZpbmQoJ3RyJykuZXEoMCk7XG5cdFx0XHRpZiAoICQuaW5BcnJheSggdHJ1ZSwgJC5tYXAoIHN0cmlwZUNsYXNzZXMsIGZ1bmN0aW9uKGVsLCBpKSB7XG5cdFx0XHRcdHJldHVybiByb3dPbmUuaGFzQ2xhc3MoZWwpO1xuXHRcdFx0fSApICkgIT09IC0xICkge1xuXHRcdFx0XHQkKCd0Ym9keSB0cicsIHRoaXMpLnJlbW92ZUNsYXNzKCBzdHJpcGVDbGFzc2VzLmpvaW4oJyAnKSApO1xuXHRcdFx0XHRvU2V0dGluZ3MuYXNEZXN0cm95U3RyaXBlcyA9IHN0cmlwZUNsYXNzZXMuc2xpY2UoKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Lypcblx0XHRcdCAqIENvbHVtbnNcblx0XHRcdCAqIFNlZSBpZiB3ZSBzaG91bGQgbG9hZCBjb2x1bW5zIGF1dG9tYXRpY2FsbHkgb3IgdXNlIGRlZmluZWQgb25lc1xuXHRcdFx0ICovXG5cdFx0XHR2YXIgYW5UaHMgPSBbXTtcblx0XHRcdHZhciBhb0NvbHVtbnNJbml0O1xuXHRcdFx0dmFyIG5UaGVhZCA9IHRoaXMuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3RoZWFkJyk7XG5cdFx0XHRpZiAoIG5UaGVhZC5sZW5ndGggIT09IDAgKVxuXHRcdFx0e1xuXHRcdFx0XHRfZm5EZXRlY3RIZWFkZXIoIG9TZXR0aW5ncy5hb0hlYWRlciwgblRoZWFkWzBdICk7XG5cdFx0XHRcdGFuVGhzID0gX2ZuR2V0VW5pcXVlVGhzKCBvU2V0dGluZ3MgKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0LyogSWYgbm90IGdpdmVuIGEgY29sdW1uIGFycmF5LCBnZW5lcmF0ZSBvbmUgd2l0aCBudWxscyAqL1xuXHRcdFx0aWYgKCBvSW5pdC5hb0NvbHVtbnMgPT09IG51bGwgKVxuXHRcdFx0e1xuXHRcdFx0XHRhb0NvbHVtbnNJbml0ID0gW107XG5cdFx0XHRcdGZvciAoIGk9MCwgaUxlbj1hblRocy5sZW5ndGggOyBpPGlMZW4gOyBpKysgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0YW9Db2x1bW5zSW5pdC5wdXNoKCBudWxsICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0YW9Db2x1bW5zSW5pdCA9IG9Jbml0LmFvQ29sdW1ucztcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0LyogQWRkIHRoZSBjb2x1bW5zICovXG5cdFx0XHRmb3IgKCBpPTAsIGlMZW49YW9Db2x1bW5zSW5pdC5sZW5ndGggOyBpPGlMZW4gOyBpKysgKVxuXHRcdFx0e1xuXHRcdFx0XHRfZm5BZGRDb2x1bW4oIG9TZXR0aW5ncywgYW5UaHMgPyBhblRoc1tpXSA6IG51bGwgKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0LyogQXBwbHkgdGhlIGNvbHVtbiBkZWZpbml0aW9ucyAqL1xuXHRcdFx0X2ZuQXBwbHlDb2x1bW5EZWZzKCBvU2V0dGluZ3MsIG9Jbml0LmFvQ29sdW1uRGVmcywgYW9Db2x1bW5zSW5pdCwgZnVuY3Rpb24gKGlDb2wsIG9EZWYpIHtcblx0XHRcdFx0X2ZuQ29sdW1uT3B0aW9ucyggb1NldHRpbmdzLCBpQ29sLCBvRGVmICk7XG5cdFx0XHR9ICk7XG5cdFx0XHRcblx0XHRcdC8qIEhUTUw1IGF0dHJpYnV0ZSBkZXRlY3Rpb24gLSBidWlsZCBhbiBtRGF0YSBvYmplY3QgYXV0b21hdGljYWxseSBpZiB0aGVcblx0XHRcdCAqIGF0dHJpYnV0ZXMgYXJlIGZvdW5kXG5cdFx0XHQgKi9cblx0XHRcdGlmICggcm93T25lLmxlbmd0aCApIHtcblx0XHRcdFx0dmFyIGEgPSBmdW5jdGlvbiAoIGNlbGwsIG5hbWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNlbGwuZ2V0QXR0cmlidXRlKCAnZGF0YS0nK25hbWUgKSAhPT0gbnVsbCA/IG5hbWUgOiBudWxsO1xuXHRcdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRcdCQuZWFjaCggX2ZuR2V0Um93RWxlbWVudHMoIG9TZXR0aW5ncywgcm93T25lWzBdICkuY2VsbHMsIGZ1bmN0aW9uIChpLCBjZWxsKSB7XG5cdFx0XHRcdFx0dmFyIGNvbCA9IG9TZXR0aW5ncy5hb0NvbHVtbnNbaV07XG5cdFx0XHRcblx0XHRcdFx0XHRpZiAoIGNvbC5tRGF0YSA9PT0gaSApIHtcblx0XHRcdFx0XHRcdHZhciBzb3J0ID0gYSggY2VsbCwgJ3NvcnQnICkgfHwgYSggY2VsbCwgJ29yZGVyJyApO1xuXHRcdFx0XHRcdFx0dmFyIGZpbHRlciA9IGEoIGNlbGwsICdmaWx0ZXInICkgfHwgYSggY2VsbCwgJ3NlYXJjaCcgKTtcblx0XHRcdFxuXHRcdFx0XHRcdFx0aWYgKCBzb3J0ICE9PSBudWxsIHx8IGZpbHRlciAhPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdFx0Y29sLm1EYXRhID0ge1xuXHRcdFx0XHRcdFx0XHRcdF86ICAgICAgaSsnLmRpc3BsYXknLFxuXHRcdFx0XHRcdFx0XHRcdHNvcnQ6ICAgc29ydCAhPT0gbnVsbCAgID8gaSsnLkBkYXRhLScrc29ydCAgIDogdW5kZWZpbmVkLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6ICAgc29ydCAhPT0gbnVsbCAgID8gaSsnLkBkYXRhLScrc29ydCAgIDogdW5kZWZpbmVkLFxuXHRcdFx0XHRcdFx0XHRcdGZpbHRlcjogZmlsdGVyICE9PSBudWxsID8gaSsnLkBkYXRhLScrZmlsdGVyIDogdW5kZWZpbmVkXG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcblx0XHRcdFx0XHRcdFx0X2ZuQ29sdW1uT3B0aW9ucyggb1NldHRpbmdzLCBpICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHZhciBmZWF0dXJlcyA9IG9TZXR0aW5ncy5vRmVhdHVyZXM7XG5cdFx0XHRcblx0XHRcdC8qIE11c3QgYmUgZG9uZSBhZnRlciBldmVyeXRoaW5nIHdoaWNoIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSBzdGF0ZSBzYXZpbmchICovXG5cdFx0XHRpZiAoIG9Jbml0LmJTdGF0ZVNhdmUgKVxuXHRcdFx0e1xuXHRcdFx0XHRmZWF0dXJlcy5iU3RhdGVTYXZlID0gdHJ1ZTtcblx0XHRcdFx0X2ZuTG9hZFN0YXRlKCBvU2V0dGluZ3MsIG9Jbml0ICk7XG5cdFx0XHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb0RyYXdDYWxsYmFjaycsIF9mblNhdmVTdGF0ZSwgJ3N0YXRlX3NhdmUnICk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0Lypcblx0XHRcdCAqIFNvcnRpbmdcblx0XHRcdCAqIEB0b2RvIEZvciBtb2R1bGFyaXNhdGlvbiAoMS4xMSkgdGhpcyBuZWVkcyB0byBkbyBpbnRvIGEgc29ydCBzdGFydCB1cCBoYW5kbGVyXG5cdFx0XHQgKi9cblx0XHRcdFxuXHRcdFx0Ly8gSWYgYWFTb3J0aW5nIGlzIG5vdCBkZWZpbmVkLCB0aGVuIHdlIHVzZSB0aGUgZmlyc3QgaW5kaWNhdG9yIGluIGFzU29ydGluZ1xuXHRcdFx0Ly8gaW4gY2FzZSB0aGF0IGhhcyBiZWVuIGFsdGVyZWQsIHNvIHRoZSBkZWZhdWx0IHNvcnQgcmVmbGVjdHMgdGhhdCBvcHRpb25cblx0XHRcdGlmICggb0luaXQuYWFTb3J0aW5nID09PSB1bmRlZmluZWQgKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgc29ydGluZyA9IG9TZXR0aW5ncy5hYVNvcnRpbmc7XG5cdFx0XHRcdGZvciAoIGk9MCwgaUxlbj1zb3J0aW5nLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRzb3J0aW5nW2ldWzFdID0gb1NldHRpbmdzLmFvQ29sdW1uc1sgaSBdLmFzU29ydGluZ1swXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvKiBEbyBhIGZpcnN0IHBhc3Mgb24gdGhlIHNvcnRpbmcgY2xhc3NlcyAoYWxsb3dzIGFueSBzaXplIGNoYW5nZXMgdG8gYmUgdGFrZW4gaW50b1xuXHRcdFx0ICogYWNjb3VudCwgYW5kIGFsc28gd2lsbCBhcHBseSBzb3J0aW5nIGRpc2FibGVkIGNsYXNzZXMgaWYgZGlzYWJsZWRcblx0XHRcdCAqL1xuXHRcdFx0X2ZuU29ydGluZ0NsYXNzZXMoIG9TZXR0aW5ncyApO1xuXHRcdFx0XG5cdFx0XHRpZiAoIGZlYXR1cmVzLmJTb3J0IClcblx0XHRcdHtcblx0XHRcdFx0X2ZuQ2FsbGJhY2tSZWcoIG9TZXR0aW5ncywgJ2FvRHJhd0NhbGxiYWNrJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGlmICggb1NldHRpbmdzLmJTb3J0ZWQgKSB7XG5cdFx0XHRcdFx0XHR2YXIgYVNvcnQgPSBfZm5Tb3J0RmxhdHRlbiggb1NldHRpbmdzICk7XG5cdFx0XHRcdFx0XHR2YXIgc29ydGVkQ29sdW1ucyA9IHt9O1xuXHRcdFx0XG5cdFx0XHRcdFx0XHQkLmVhY2goIGFTb3J0LCBmdW5jdGlvbiAoaSwgdmFsKSB7XG5cdFx0XHRcdFx0XHRcdHNvcnRlZENvbHVtbnNbIHZhbC5zcmMgXSA9IHZhbC5kaXI7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcblx0XHRcdFx0XHRcdF9mbkNhbGxiYWNrRmlyZSggb1NldHRpbmdzLCBudWxsLCAnb3JkZXInLCBbb1NldHRpbmdzLCBhU29ydCwgc29ydGVkQ29sdW1uc10gKTtcblx0XHRcdFx0XHRcdF9mblNvcnRBcmlhKCBvU2V0dGluZ3MgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0X2ZuQ2FsbGJhY2tSZWcoIG9TZXR0aW5ncywgJ2FvRHJhd0NhbGxiYWNrJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAoIG9TZXR0aW5ncy5iU29ydGVkIHx8IF9mbkRhdGFTb3VyY2UoIG9TZXR0aW5ncyApID09PSAnc3NwJyB8fCBmZWF0dXJlcy5iRGVmZXJSZW5kZXIgKSB7XG5cdFx0XHRcdFx0X2ZuU29ydGluZ0NsYXNzZXMoIG9TZXR0aW5ncyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCAnc2MnICk7XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0Lypcblx0XHRcdCAqIEZpbmFsIGluaXRcblx0XHRcdCAqIENhY2hlIHRoZSBoZWFkZXIsIGJvZHkgYW5kIGZvb3RlciBhcyByZXF1aXJlZCwgY3JlYXRpbmcgdGhlbSBpZiBuZWVkZWRcblx0XHRcdCAqL1xuXHRcdFx0XG5cdFx0XHQvKiBCcm93c2VyIHN1cHBvcnQgZGV0ZWN0aW9uICovXG5cdFx0XHRfZm5Ccm93c2VyRGV0ZWN0KCBvU2V0dGluZ3MgKTtcblx0XHRcdFxuXHRcdFx0Ly8gV29yayBhcm91bmQgZm9yIFdlYmtpdCBidWcgODM4NjcgLSBzdG9yZSB0aGUgY2FwdGlvbi1zaWRlIGJlZm9yZSByZW1vdmluZyBmcm9tIGRvY1xuXHRcdFx0dmFyIGNhcHRpb25zID0gJHRoaXMuY2hpbGRyZW4oJ2NhcHRpb24nKS5lYWNoKCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRoaXMuX2NhcHRpb25TaWRlID0gJHRoaXMuY3NzKCdjYXB0aW9uLXNpZGUnKTtcblx0XHRcdH0gKTtcblx0XHRcdFxuXHRcdFx0dmFyIHRoZWFkID0gJHRoaXMuY2hpbGRyZW4oJ3RoZWFkJyk7XG5cdFx0XHRpZiAoIHRoZWFkLmxlbmd0aCA9PT0gMCApXG5cdFx0XHR7XG5cdFx0XHRcdHRoZWFkID0gJCgnPHRoZWFkLz4nKS5hcHBlbmRUbyh0aGlzKTtcblx0XHRcdH1cblx0XHRcdG9TZXR0aW5ncy5uVEhlYWQgPSB0aGVhZFswXTtcblx0XHRcdFxuXHRcdFx0dmFyIHRib2R5ID0gJHRoaXMuY2hpbGRyZW4oJ3Rib2R5Jyk7XG5cdFx0XHRpZiAoIHRib2R5Lmxlbmd0aCA9PT0gMCApXG5cdFx0XHR7XG5cdFx0XHRcdHRib2R5ID0gJCgnPHRib2R5Lz4nKS5hcHBlbmRUbyh0aGlzKTtcblx0XHRcdH1cblx0XHRcdG9TZXR0aW5ncy5uVEJvZHkgPSB0Ym9keVswXTtcblx0XHRcdFxuXHRcdFx0dmFyIHRmb290ID0gJHRoaXMuY2hpbGRyZW4oJ3Rmb290Jyk7XG5cdFx0XHRpZiAoIHRmb290Lmxlbmd0aCA9PT0gMCAmJiBjYXB0aW9ucy5sZW5ndGggPiAwICYmIChvU2V0dGluZ3Mub1Njcm9sbC5zWCAhPT0gXCJcIiB8fCBvU2V0dGluZ3Mub1Njcm9sbC5zWSAhPT0gXCJcIikgKVxuXHRcdFx0e1xuXHRcdFx0XHQvLyBJZiB3ZSBhcmUgYSBzY3JvbGxpbmcgdGFibGUsIGFuZCBubyBmb290ZXIgaGFzIGJlZW4gZ2l2ZW4sIHRoZW4gd2UgbmVlZCB0byBjcmVhdGVcblx0XHRcdFx0Ly8gYSB0Zm9vdCBlbGVtZW50IGZvciB0aGUgY2FwdGlvbiBlbGVtZW50IHRvIGJlIGFwcGVuZGVkIHRvXG5cdFx0XHRcdHRmb290ID0gJCgnPHRmb290Lz4nKS5hcHBlbmRUbyh0aGlzKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKCB0Zm9vdC5sZW5ndGggPT09IDAgfHwgdGZvb3QuY2hpbGRyZW4oKS5sZW5ndGggPT09IDAgKSB7XG5cdFx0XHRcdCR0aGlzLmFkZENsYXNzKCBvQ2xhc3Nlcy5zTm9Gb290ZXIgKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCB0Zm9vdC5sZW5ndGggPiAwICkge1xuXHRcdFx0XHRvU2V0dGluZ3MublRGb290ID0gdGZvb3RbMF07XG5cdFx0XHRcdF9mbkRldGVjdEhlYWRlciggb1NldHRpbmdzLmFvRm9vdGVyLCBvU2V0dGluZ3MublRGb290ICk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qIENoZWNrIGlmIHRoZXJlIGlzIGRhdGEgcGFzc2luZyBpbnRvIHRoZSBjb25zdHJ1Y3RvciAqL1xuXHRcdFx0aWYgKCBvSW5pdC5hYURhdGEgKVxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKCBpPTAgOyBpPG9Jbml0LmFhRGF0YS5sZW5ndGggOyBpKysgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0X2ZuQWRkRGF0YSggb1NldHRpbmdzLCBvSW5pdC5hYURhdGFbIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggb1NldHRpbmdzLmJEZWZlckxvYWRpbmcgfHwgX2ZuRGF0YVNvdXJjZSggb1NldHRpbmdzICkgPT0gJ2RvbScgKVxuXHRcdFx0e1xuXHRcdFx0XHQvKiBHcmFiIHRoZSBkYXRhIGZyb20gdGhlIHBhZ2UgLSBvbmx5IGRvIHRoaXMgd2hlbiBkZWZlcnJlZCBsb2FkaW5nIG9yIG5vIEFqYXhcblx0XHRcdFx0ICogc291cmNlIHNpbmNlIHRoZXJlIGlzIG5vIHBvaW50IGluIHJlYWRpbmcgdGhlIERPTSBkYXRhIGlmIHdlIGFyZSB0aGVuIGdvaW5nXG5cdFx0XHRcdCAqIHRvIHJlcGxhY2UgaXQgd2l0aCBBamF4IGRhdGFcblx0XHRcdFx0ICovXG5cdFx0XHRcdF9mbkFkZFRyKCBvU2V0dGluZ3MsICQob1NldHRpbmdzLm5UQm9keSkuY2hpbGRyZW4oJ3RyJykgKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0LyogQ29weSB0aGUgZGF0YSBpbmRleCBhcnJheSAqL1xuXHRcdFx0b1NldHRpbmdzLmFpRGlzcGxheSA9IG9TZXR0aW5ncy5haURpc3BsYXlNYXN0ZXIuc2xpY2UoKTtcblx0XHRcdFxuXHRcdFx0LyogSW5pdGlhbGlzYXRpb24gY29tcGxldGUgLSB0YWJsZSBjYW4gYmUgZHJhd24gKi9cblx0XHRcdG9TZXR0aW5ncy5iSW5pdGlhbGlzZWQgPSB0cnVlO1xuXHRcdFx0XG5cdFx0XHQvKiBDaGVjayBpZiB3ZSBuZWVkIHRvIGluaXRpYWxpc2UgdGhlIHRhYmxlIChpdCBtaWdodCBub3QgaGF2ZSBiZWVuIGhhbmRlZCBvZmYgdG8gdGhlXG5cdFx0XHQgKiBsYW5ndWFnZSBwcm9jZXNzb3IpXG5cdFx0XHQgKi9cblx0XHRcdGlmICggYkluaXRIYW5kZWRPZmYgPT09IGZhbHNlIClcblx0XHRcdHtcblx0XHRcdFx0X2ZuSW5pdGlhbGlzZSggb1NldHRpbmdzICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdF90aGF0ID0gbnVsbDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHRcblx0XG5cdC8qKlxuXHQgKiBDb21wdXRlZCBzdHJ1Y3R1cmUgb2YgdGhlIERhdGFUYWJsZXMgQVBJLCBkZWZpbmVkIGJ5IHRoZSBvcHRpb25zIHBhc3NlZCB0b1xuXHQgKiBgRGF0YVRhYmxlLkFwaS5yZWdpc3RlcigpYCB3aGVuIGJ1aWxkaW5nIHRoZSBBUEkuXG5cdCAqXG5cdCAqIFRoZSBzdHJ1Y3R1cmUgaXMgYnVpbHQgaW4gb3JkZXIgdG8gc3BlZWQgY3JlYXRpb24gYW5kIGV4dGVuc2lvbiBvZiB0aGUgQXBpXG5cdCAqIG9iamVjdHMgc2luY2UgdGhlIGV4dGVuc2lvbnMgYXJlIGVmZmVjdGl2ZWx5IHByZS1wYXJzZWQuXG5cdCAqXG5cdCAqIFRoZSBhcnJheSBpcyBhbiBhcnJheSBvZiBvYmplY3RzIHdpdGggdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmUsIHdoZXJlIHRoaXNcblx0ICogYmFzZSBhcnJheSByZXByZXNlbnRzIHRoZSBBcGkgcHJvdG90eXBlIGJhc2U6XG5cdCAqXG5cdCAqICAgICBbXG5cdCAqICAgICAgIHtcblx0ICogICAgICAgICBuYW1lOiAgICAgICdkYXRhJyAgICAgICAgICAgICAgICAtLSBzdHJpbmcgICAtIFByb3BlcnR5IG5hbWVcblx0ICogICAgICAgICB2YWw6ICAgICAgIGZ1bmN0aW9uICgpIHt9LCAgICAgICAtLSBmdW5jdGlvbiAtIEFwaSBtZXRob2QgKG9yIHVuZGVmaW5lZCBpZiBqdXN0IGFuIG9iamVjdFxuXHQgKiAgICAgICAgIG1ldGhvZEV4dDogWyAuLi4gXSwgICAgICAgICAgICAgIC0tIGFycmF5ICAgIC0gQXJyYXkgb2YgQXBpIG9iamVjdCBkZWZpbml0aW9ucyB0byBleHRlbmQgdGhlIG1ldGhvZCByZXN1bHRcblx0ICogICAgICAgICBwcm9wRXh0OiAgIFsgLi4uIF0gICAgICAgICAgICAgICAtLSBhcnJheSAgICAtIEFycmF5IG9mIEFwaSBvYmplY3QgZGVmaW5pdGlvbnMgdG8gZXh0ZW5kIHRoZSBwcm9wZXJ0eVxuXHQgKiAgICAgICB9LFxuXHQgKiAgICAgICB7XG5cdCAqICAgICAgICAgbmFtZTogICAgICdyb3cnXG5cdCAqICAgICAgICAgdmFsOiAgICAgICB7fSxcblx0ICogICAgICAgICBtZXRob2RFeHQ6IFsgLi4uIF0sXG5cdCAqICAgICAgICAgcHJvcEV4dDogICBbXG5cdCAqICAgICAgICAgICB7XG5cdCAqICAgICAgICAgICAgIG5hbWU6ICAgICAgJ2RhdGEnXG5cdCAqICAgICAgICAgICAgIHZhbDogICAgICAgZnVuY3Rpb24gKCkge30sXG5cdCAqICAgICAgICAgICAgIG1ldGhvZEV4dDogWyAuLi4gXSxcblx0ICogICAgICAgICAgICAgcHJvcEV4dDogICBbIC4uLiBdXG5cdCAqICAgICAgICAgICB9LFxuXHQgKiAgICAgICAgICAgLi4uXG5cdCAqICAgICAgICAgXVxuXHQgKiAgICAgICB9XG5cdCAqICAgICBdXG5cdCAqXG5cdCAqIEB0eXBlIHtBcnJheX1cblx0ICogQGlnbm9yZVxuXHQgKi9cblx0dmFyIF9fYXBpU3RydWN0ID0gW107XG5cdFxuXHRcblx0LyoqXG5cdCAqIGBBcnJheS5wcm90b3R5cGVgIHJlZmVyZW5jZS5cblx0ICpcblx0ICogQHR5cGUgb2JqZWN0XG5cdCAqIEBpZ25vcmVcblx0ICovXG5cdHZhciBfX2FycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cdFxuXHRcblx0LyoqXG5cdCAqIEFic3RyYWN0aW9uIGZvciBgY29udGV4dGAgcGFyYW1ldGVyIG9mIHRoZSBgQXBpYCBjb25zdHJ1Y3RvciB0byBhbGxvdyBpdCB0b1xuXHQgKiB0YWtlIHNldmVyYWwgZGlmZmVyZW50IGZvcm1zIGZvciBlYXNlIG9mIHVzZS5cblx0ICpcblx0ICogRWFjaCBvZiB0aGUgaW5wdXQgcGFyYW1ldGVyIHR5cGVzIHdpbGwgYmUgY29udmVydGVkIHRvIGEgRGF0YVRhYmxlcyBzZXR0aW5nc1xuXHQgKiBvYmplY3Qgd2hlcmUgcG9zc2libGUuXG5cdCAqXG5cdCAqIEBwYXJhbSAge3N0cmluZ3xub2RlfGpRdWVyeXxvYmplY3R9IG1peGVkIERhdGFUYWJsZSBpZGVudGlmaWVyLiBDYW4gYmUgb25lXG5cdCAqICAgb2Y6XG5cdCAqXG5cdCAqICAgKiBgc3RyaW5nYCAtIGpRdWVyeSBzZWxlY3Rvci4gQW55IERhdGFUYWJsZXMnIG1hdGNoaW5nIHRoZSBnaXZlbiBzZWxlY3RvclxuXHQgKiAgICAgd2l0aCBiZSBmb3VuZCBhbmQgdXNlZC5cblx0ICogICAqIGBub2RlYCAtIGBUQUJMRWAgbm9kZSB3aGljaCBoYXMgYWxyZWFkeSBiZWVuIGZvcm1lZCBpbnRvIGEgRGF0YVRhYmxlLlxuXHQgKiAgICogYGpRdWVyeWAgLSBBIGpRdWVyeSBvYmplY3Qgb2YgYFRBQkxFYCBub2Rlcy5cblx0ICogICAqIGBvYmplY3RgIC0gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogICAqIGBEYXRhVGFibGVzLkFwaWAgLSBBUEkgaW5zdGFuY2Vcblx0ICogQHJldHVybiB7YXJyYXl8bnVsbH0gTWF0Y2hpbmcgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RzLiBgbnVsbGAgb3Jcblx0ICogICBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZCBpZiBubyBtYXRjaGluZyBEYXRhVGFibGUgaXMgZm91bmQuXG5cdCAqIEBpZ25vcmVcblx0ICovXG5cdHZhciBfdG9TZXR0aW5ncyA9IGZ1bmN0aW9uICggbWl4ZWQgKVxuXHR7XG5cdFx0dmFyIGlkeCwganE7XG5cdFx0dmFyIHNldHRpbmdzID0gRGF0YVRhYmxlLnNldHRpbmdzO1xuXHRcdHZhciB0YWJsZXMgPSAkLm1hcCggc2V0dGluZ3MsIGZ1bmN0aW9uIChlbCwgaSkge1xuXHRcdFx0cmV0dXJuIGVsLm5UYWJsZTtcblx0XHR9ICk7XG5cdFxuXHRcdGlmICggISBtaXhlZCApIHtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIG1peGVkLm5UYWJsZSAmJiBtaXhlZC5vQXBpICkge1xuXHRcdFx0Ly8gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0XHRcdHJldHVybiBbIG1peGVkIF07XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBtaXhlZC5ub2RlTmFtZSAmJiBtaXhlZC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAndGFibGUnICkge1xuXHRcdFx0Ly8gVGFibGUgbm9kZVxuXHRcdFx0aWR4ID0gJC5pbkFycmF5KCBtaXhlZCwgdGFibGVzICk7XG5cdFx0XHRyZXR1cm4gaWR4ICE9PSAtMSA/IFsgc2V0dGluZ3NbaWR4XSBdIDogbnVsbDtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIG1peGVkICYmIHR5cGVvZiBtaXhlZC5zZXR0aW5ncyA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdHJldHVybiBtaXhlZC5zZXR0aW5ncygpLnRvQXJyYXkoKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHR5cGVvZiBtaXhlZCA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHQvLyBqUXVlcnkgc2VsZWN0b3Jcblx0XHRcdGpxID0gJChtaXhlZCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBtaXhlZCBpbnN0YW5jZW9mICQgKSB7XG5cdFx0XHQvLyBqUXVlcnkgb2JqZWN0IChhbHNvIERhdGFUYWJsZXMgaW5zdGFuY2UpXG5cdFx0XHRqcSA9IG1peGVkO1xuXHRcdH1cblx0XG5cdFx0aWYgKCBqcSApIHtcblx0XHRcdHJldHVybiBqcS5tYXAoIGZ1bmN0aW9uKGkpIHtcblx0XHRcdFx0aWR4ID0gJC5pbkFycmF5KCB0aGlzLCB0YWJsZXMgKTtcblx0XHRcdFx0cmV0dXJuIGlkeCAhPT0gLTEgPyBzZXR0aW5nc1tpZHhdIDogbnVsbDtcblx0XHRcdH0gKS50b0FycmF5KCk7XG5cdFx0fVxuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHQgKiBEYXRhVGFibGVzIEFQSSBjbGFzcyAtIHVzZWQgdG8gY29udHJvbCBhbmQgaW50ZXJmYWNlIHdpdGggIG9uZSBvciBtb3JlXG5cdCAqIERhdGFUYWJsZXMgZW5oYW5jZWQgdGFibGVzLlxuXHQgKlxuXHQgKiBUaGUgQVBJIGNsYXNzIGlzIGhlYXZpbHkgYmFzZWQgb24galF1ZXJ5LCBwcmVzZW50aW5nIGEgY2hhaW5hYmxlIGludGVyZmFjZVxuXHQgKiB0aGF0IHlvdSBjYW4gdXNlIHRvIGludGVyYWN0IHdpdGggdGFibGVzLiBFYWNoIGluc3RhbmNlIG9mIHRoZSBBUEkgY2xhc3MgaGFzXG5cdCAqIGEgXCJjb250ZXh0XCIgLSBpLmUuIHRoZSB0YWJsZXMgdGhhdCBpdCB3aWxsIG9wZXJhdGUgb24uIFRoaXMgY291bGQgYmUgYSBzaW5nbGVcblx0ICogdGFibGUsIGFsbCB0YWJsZXMgb24gYSBwYWdlIG9yIGEgc3ViLXNldCB0aGVyZW9mLlxuXHQgKlxuXHQgKiBBZGRpdGlvbmFsbHkgdGhlIEFQSSBpcyBkZXNpZ25lZCB0byBhbGxvdyB5b3UgdG8gZWFzaWx5IHdvcmsgd2l0aCB0aGUgZGF0YSBpblxuXHQgKiB0aGUgdGFibGVzLCByZXRyaWV2aW5nIGFuZCBtYW5pcHVsYXRpbmcgaXQgYXMgcmVxdWlyZWQuIFRoaXMgaXMgZG9uZSBieVxuXHQgKiBwcmVzZW50aW5nIHRoZSBBUEkgY2xhc3MgYXMgYW4gYXJyYXkgbGlrZSBpbnRlcmZhY2UuIFRoZSBjb250ZW50cyBvZiB0aGVcblx0ICogYXJyYXkgZGVwZW5kIHVwb24gdGhlIGFjdGlvbnMgcmVxdWVzdGVkIGJ5IGVhY2ggbWV0aG9kIChmb3IgZXhhbXBsZVxuXHQgKiBgcm93cygpLm5vZGVzKClgIHdpbGwgcmV0dXJuIGFuIGFycmF5IG9mIG5vZGVzLCB3aGlsZSBgcm93cygpLmRhdGEoKWAgd2lsbFxuXHQgKiByZXR1cm4gYW4gYXJyYXkgb2Ygb2JqZWN0cyBvciBhcnJheXMgZGVwZW5kaW5nIHVwb24geW91ciB0YWJsZSdzXG5cdCAqIGNvbmZpZ3VyYXRpb24pLiBUaGUgQVBJIG9iamVjdCBoYXMgYSBudW1iZXIgb2YgYXJyYXkgbGlrZSBtZXRob2RzIChgcHVzaGAsXG5cdCAqIGBwb3BgLCBgcmV2ZXJzZWAgZXRjKSBhcyB3ZWxsIGFzIGFkZGl0aW9uYWwgaGVscGVyIG1ldGhvZHMgKGBlYWNoYCwgYHBsdWNrYCxcblx0ICogYHVuaXF1ZWAgZXRjKSB0byBhc3Npc3QgeW91ciB3b3JraW5nIHdpdGggdGhlIGRhdGEgaGVsZCBpbiBhIHRhYmxlLlxuXHQgKlxuXHQgKiBNb3N0IG1ldGhvZHMgKHRob3NlIHdoaWNoIHJldHVybiBhbiBBcGkgaW5zdGFuY2UpIGFyZSBjaGFpbmFibGUsIHdoaWNoIG1lYW5zXG5cdCAqIHRoZSByZXR1cm4gZnJvbSBhIG1ldGhvZCBjYWxsIGFsc28gaGFzIGFsbCBvZiB0aGUgbWV0aG9kcyBhdmFpbGFibGUgdGhhdCB0aGVcblx0ICogdG9wIGxldmVsIG9iamVjdCBoYWQuIEZvciBleGFtcGxlLCB0aGVzZSB0d28gY2FsbHMgYXJlIGVxdWl2YWxlbnQ6XG5cdCAqXG5cdCAqICAgICAvLyBOb3QgY2hhaW5lZFxuXHQgKiAgICAgYXBpLnJvdy5hZGQoIHsuLi59ICk7XG5cdCAqICAgICBhcGkuZHJhdygpO1xuXHQgKlxuXHQgKiAgICAgLy8gQ2hhaW5lZFxuXHQgKiAgICAgYXBpLnJvdy5hZGQoIHsuLi59ICkuZHJhdygpO1xuXHQgKlxuXHQgKiBAY2xhc3MgRGF0YVRhYmxlLkFwaVxuXHQgKiBAcGFyYW0ge2FycmF5fG9iamVjdHxzdHJpbmd8alF1ZXJ5fSBjb250ZXh0IERhdGFUYWJsZSBpZGVudGlmaWVyLiBUaGlzIGlzXG5cdCAqICAgdXNlZCB0byBkZWZpbmUgd2hpY2ggRGF0YVRhYmxlcyBlbmhhbmNlZCB0YWJsZXMgdGhpcyBBUEkgd2lsbCBvcGVyYXRlIG9uLlxuXHQgKiAgIENhbiBiZSBvbmUgb2Y6XG5cdCAqXG5cdCAqICAgKiBgc3RyaW5nYCAtIGpRdWVyeSBzZWxlY3Rvci4gQW55IERhdGFUYWJsZXMnIG1hdGNoaW5nIHRoZSBnaXZlbiBzZWxlY3RvclxuXHQgKiAgICAgd2l0aCBiZSBmb3VuZCBhbmQgdXNlZC5cblx0ICogICAqIGBub2RlYCAtIGBUQUJMRWAgbm9kZSB3aGljaCBoYXMgYWxyZWFkeSBiZWVuIGZvcm1lZCBpbnRvIGEgRGF0YVRhYmxlLlxuXHQgKiAgICogYGpRdWVyeWAgLSBBIGpRdWVyeSBvYmplY3Qgb2YgYFRBQkxFYCBub2Rlcy5cblx0ICogICAqIGBvYmplY3RgIC0gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogQHBhcmFtIHthcnJheX0gW2RhdGFdIERhdGEgdG8gaW5pdGlhbGlzZSB0aGUgQXBpIGluc3RhbmNlIHdpdGguXG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqICAgLy8gRGlyZWN0IGluaXRpYWxpc2F0aW9uIGR1cmluZyBEYXRhVGFibGVzIGNvbnN0cnVjdGlvblxuXHQgKiAgIHZhciBhcGkgPSAkKCcjZXhhbXBsZScpLkRhdGFUYWJsZSgpO1xuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKiAgIC8vIEluaXRpYWxpc2F0aW9uIHVzaW5nIGEgRGF0YVRhYmxlcyBqUXVlcnkgb2JqZWN0XG5cdCAqICAgdmFyIGFwaSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCkuYXBpKCk7XG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqICAgLy8gSW5pdGlhbGlzYXRpb24gYXMgYSBjb25zdHJ1Y3RvclxuXHQgKiAgIHZhciBhcGkgPSBuZXcgJC5mbi5EYXRhVGFibGUuQXBpKCAndGFibGUuZGF0YVRhYmxlJyApO1xuXHQgKi9cblx0X0FwaSA9IGZ1bmN0aW9uICggY29udGV4dCwgZGF0YSApXG5cdHtcblx0XHRpZiAoICEgKHRoaXMgaW5zdGFuY2VvZiBfQXBpKSApIHtcblx0XHRcdHJldHVybiBuZXcgX0FwaSggY29udGV4dCwgZGF0YSApO1xuXHRcdH1cblx0XG5cdFx0dmFyIHNldHRpbmdzID0gW107XG5cdFx0dmFyIGN0eFNldHRpbmdzID0gZnVuY3Rpb24gKCBvICkge1xuXHRcdFx0dmFyIGEgPSBfdG9TZXR0aW5ncyggbyApO1xuXHRcdFx0aWYgKCBhICkge1xuXHRcdFx0XHRzZXR0aW5ncy5wdXNoLmFwcGx5KCBzZXR0aW5ncywgYSApO1xuXHRcdFx0fVxuXHRcdH07XG5cdFxuXHRcdGlmICggJC5pc0FycmF5KCBjb250ZXh0ICkgKSB7XG5cdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49Y29udGV4dC5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0Y3R4U2V0dGluZ3MoIGNvbnRleHRbaV0gKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRjdHhTZXR0aW5ncyggY29udGV4dCApO1xuXHRcdH1cblx0XG5cdFx0Ly8gUmVtb3ZlIGR1cGxpY2F0ZXNcblx0XHR0aGlzLmNvbnRleHQgPSBfdW5pcXVlKCBzZXR0aW5ncyApO1xuXHRcblx0XHQvLyBJbml0aWFsIGRhdGFcblx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHR0aGlzLnB1c2guYXBwbHkoIHRoaXMsIGRhdGEudG9BcnJheSA/IGRhdGEudG9BcnJheSgpIDogZGF0YSApO1xuXHRcdH1cblx0XG5cdFx0Ly8gc2VsZWN0b3Jcblx0XHR0aGlzLnNlbGVjdG9yID0ge1xuXHRcdFx0cm93czogbnVsbCxcblx0XHRcdGNvbHM6IG51bGwsXG5cdFx0XHRvcHRzOiBudWxsXG5cdFx0fTtcblx0XG5cdFx0X0FwaS5leHRlbmQoIHRoaXMsIHRoaXMsIF9fYXBpU3RydWN0ICk7XG5cdH07XG5cdFxuXHREYXRhVGFibGUuQXBpID0gX0FwaTtcblx0XG5cdF9BcGkucHJvdG90eXBlID0gLyoqIEBsZW5kcyBEYXRhVGFibGVzLkFwaSAqL3tcblx0XHRhbnk6IGZ1bmN0aW9uICgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuZmxhdHRlbigpLmxlbmd0aCAhPT0gMDtcblx0XHR9LFxuXHRcblx0XG5cdFx0Y29uY2F0OiAgX19hcnJheVByb3RvLmNvbmNhdCxcblx0XG5cdFxuXHRcdGNvbnRleHQ6IFtdLCAvLyBhcnJheSBvZiB0YWJsZSBzZXR0aW5ncyBvYmplY3RzXG5cdFxuXHRcblx0XHRlYWNoOiBmdW5jdGlvbiAoIGZuIClcblx0XHR7XG5cdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49dGhpcy5sZW5ndGggOyBpPGllbjsgaSsrICkge1xuXHRcdFx0XHRmbi5jYWxsKCB0aGlzLCB0aGlzW2ldLCBpLCB0aGlzICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblx0XG5cdFxuXHRcdGVxOiBmdW5jdGlvbiAoIGlkeCApXG5cdFx0e1xuXHRcdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblx0XG5cdFx0XHRyZXR1cm4gY3R4Lmxlbmd0aCA+IGlkeCA/XG5cdFx0XHRcdG5ldyBfQXBpKCBjdHhbaWR4XSwgdGhpc1tpZHhdICkgOlxuXHRcdFx0XHRudWxsO1xuXHRcdH0sXG5cdFxuXHRcblx0XHRmaWx0ZXI6IGZ1bmN0aW9uICggZm4gKVxuXHRcdHtcblx0XHRcdHZhciBhID0gW107XG5cdFxuXHRcdFx0aWYgKCBfX2FycmF5UHJvdG8uZmlsdGVyICkge1xuXHRcdFx0XHRhID0gX19hcnJheVByb3RvLmZpbHRlci5jYWxsKCB0aGlzLCBmbiwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdC8vIENvbXBhdGliaWxpdHkgZm9yIGJyb3dzZXJzIHdpdGhvdXQgRU1DQS0yNTItNSAoSlMgMS42KVxuXHRcdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49dGhpcy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGZuLmNhbGwoIHRoaXMsIHRoaXNbaV0sIGksIHRoaXMgKSApIHtcblx0XHRcdFx0XHRcdGEucHVzaCggdGhpc1tpXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdHJldHVybiBuZXcgX0FwaSggdGhpcy5jb250ZXh0LCBhICk7XG5cdFx0fSxcblx0XG5cdFxuXHRcdGZsYXR0ZW46IGZ1bmN0aW9uICgpXG5cdFx0e1xuXHRcdFx0dmFyIGEgPSBbXTtcblx0XHRcdHJldHVybiBuZXcgX0FwaSggdGhpcy5jb250ZXh0LCBhLmNvbmNhdC5hcHBseSggYSwgdGhpcy50b0FycmF5KCkgKSApO1xuXHRcdH0sXG5cdFxuXHRcblx0XHRqb2luOiAgICBfX2FycmF5UHJvdG8uam9pbixcblx0XG5cdFxuXHRcdGluZGV4T2Y6IF9fYXJyYXlQcm90by5pbmRleE9mIHx8IGZ1bmN0aW9uIChvYmosIHN0YXJ0KVxuXHRcdHtcblx0XHRcdGZvciAoIHZhciBpPShzdGFydCB8fCAwKSwgaWVuPXRoaXMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdGlmICggdGhpc1tpXSA9PT0gb2JqICkge1xuXHRcdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gLTE7XG5cdFx0fSxcblx0XG5cdFx0aXRlcmF0b3I6IGZ1bmN0aW9uICggZmxhdHRlbiwgdHlwZSwgZm4sIGFsd2F5c05ldyApIHtcblx0XHRcdHZhclxuXHRcdFx0XHRhID0gW10sIHJldCxcblx0XHRcdFx0aSwgaWVuLCBqLCBqZW4sXG5cdFx0XHRcdGNvbnRleHQgPSB0aGlzLmNvbnRleHQsXG5cdFx0XHRcdHJvd3MsIGl0ZW1zLCBpdGVtLFxuXHRcdFx0XHRzZWxlY3RvciA9IHRoaXMuc2VsZWN0b3I7XG5cdFxuXHRcdFx0Ly8gQXJndW1lbnQgc2hpZnRpbmdcblx0XHRcdGlmICggdHlwZW9mIGZsYXR0ZW4gPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRhbHdheXNOZXcgPSBmbjtcblx0XHRcdFx0Zm4gPSB0eXBlO1xuXHRcdFx0XHR0eXBlID0gZmxhdHRlbjtcblx0XHRcdFx0ZmxhdHRlbiA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcblx0XHRcdGZvciAoIGk9MCwgaWVuPWNvbnRleHQubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdHZhciBhcGlJbnN0ID0gbmV3IF9BcGkoIGNvbnRleHRbaV0gKTtcblx0XG5cdFx0XHRcdGlmICggdHlwZSA9PT0gJ3RhYmxlJyApIHtcblx0XHRcdFx0XHRyZXQgPSBmbi5jYWxsKCBhcGlJbnN0LCBjb250ZXh0W2ldLCBpICk7XG5cdFxuXHRcdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRhLnB1c2goIHJldCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICggdHlwZSA9PT0gJ2NvbHVtbnMnIHx8IHR5cGUgPT09ICdyb3dzJyApIHtcblx0XHRcdFx0XHQvLyB0aGlzIGhhcyBzYW1lIGxlbmd0aCBhcyBjb250ZXh0IC0gb25lIGVudHJ5IGZvciBlYWNoIHRhYmxlXG5cdFx0XHRcdFx0cmV0ID0gZm4uY2FsbCggYXBpSW5zdCwgY29udGV4dFtpXSwgdGhpc1tpXSwgaSApO1xuXHRcblx0XHRcdFx0XHRpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0YS5wdXNoKCByZXQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoIHR5cGUgPT09ICdjb2x1bW4nIHx8IHR5cGUgPT09ICdjb2x1bW4tcm93cycgfHwgdHlwZSA9PT0gJ3JvdycgfHwgdHlwZSA9PT0gJ2NlbGwnICkge1xuXHRcdFx0XHRcdC8vIGNvbHVtbnMgYW5kIHJvd3Mgc2hhcmUgdGhlIHNhbWUgc3RydWN0dXJlLlxuXHRcdFx0XHRcdC8vICd0aGlzJyBpcyBhbiBhcnJheSBvZiBjb2x1bW4gaW5kZXhlcyBmb3IgZWFjaCBjb250ZXh0XG5cdFx0XHRcdFx0aXRlbXMgPSB0aGlzW2ldO1xuXHRcblx0XHRcdFx0XHRpZiAoIHR5cGUgPT09ICdjb2x1bW4tcm93cycgKSB7XG5cdFx0XHRcdFx0XHRyb3dzID0gX3NlbGVjdG9yX3Jvd19pbmRleGVzKCBjb250ZXh0W2ldLCBzZWxlY3Rvci5vcHRzICk7XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRmb3IgKCBqPTAsIGplbj1pdGVtcy5sZW5ndGggOyBqPGplbiA7IGorKyApIHtcblx0XHRcdFx0XHRcdGl0ZW0gPSBpdGVtc1tqXTtcblx0XG5cdFx0XHRcdFx0XHRpZiAoIHR5cGUgPT09ICdjZWxsJyApIHtcblx0XHRcdFx0XHRcdFx0cmV0ID0gZm4uY2FsbCggYXBpSW5zdCwgY29udGV4dFtpXSwgaXRlbS5yb3csIGl0ZW0uY29sdW1uLCBpLCBqICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmV0ID0gZm4uY2FsbCggYXBpSW5zdCwgY29udGV4dFtpXSwgaXRlbSwgaSwgaiwgcm93cyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdGEucHVzaCggcmV0ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0aWYgKCBhLmxlbmd0aCB8fCBhbHdheXNOZXcgKSB7XG5cdFx0XHRcdHZhciBhcGkgPSBuZXcgX0FwaSggY29udGV4dCwgZmxhdHRlbiA/IGEuY29uY2F0LmFwcGx5KCBbXSwgYSApIDogYSApO1xuXHRcdFx0XHR2YXIgYXBpU2VsZWN0b3IgPSBhcGkuc2VsZWN0b3I7XG5cdFx0XHRcdGFwaVNlbGVjdG9yLnJvd3MgPSBzZWxlY3Rvci5yb3dzO1xuXHRcdFx0XHRhcGlTZWxlY3Rvci5jb2xzID0gc2VsZWN0b3IuY29scztcblx0XHRcdFx0YXBpU2VsZWN0b3Iub3B0cyA9IHNlbGVjdG9yLm9wdHM7XG5cdFx0XHRcdHJldHVybiBhcGk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXHRcblx0XG5cdFx0bGFzdEluZGV4T2Y6IF9fYXJyYXlQcm90by5sYXN0SW5kZXhPZiB8fCBmdW5jdGlvbiAob2JqLCBzdGFydClcblx0XHR7XG5cdFx0XHQvLyBCaXQgY2hlZWt5Li4uXG5cdFx0XHRyZXR1cm4gdGhpcy5pbmRleE9mLmFwcGx5KCB0aGlzLnRvQXJyYXkucmV2ZXJzZSgpLCBhcmd1bWVudHMgKTtcblx0XHR9LFxuXHRcblx0XG5cdFx0bGVuZ3RoOiAgMCxcblx0XG5cdFxuXHRcdG1hcDogZnVuY3Rpb24gKCBmbiApXG5cdFx0e1xuXHRcdFx0dmFyIGEgPSBbXTtcblx0XG5cdFx0XHRpZiAoIF9fYXJyYXlQcm90by5tYXAgKSB7XG5cdFx0XHRcdGEgPSBfX2FycmF5UHJvdG8ubWFwLmNhbGwoIHRoaXMsIGZuLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Ly8gQ29tcGF0aWJpbGl0eSBmb3IgYnJvd3NlcnMgd2l0aG91dCBFTUNBLTI1Mi01IChKUyAxLjYpXG5cdFx0XHRcdGZvciAoIHZhciBpPTAsIGllbj10aGlzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRcdGEucHVzaCggZm4uY2FsbCggdGhpcywgdGhpc1tpXSwgaSApICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHRyZXR1cm4gbmV3IF9BcGkoIHRoaXMuY29udGV4dCwgYSApO1xuXHRcdH0sXG5cdFxuXHRcblx0XHRwbHVjazogZnVuY3Rpb24gKCBwcm9wIClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uICggZWwgKSB7XG5cdFx0XHRcdHJldHVybiBlbFsgcHJvcCBdO1xuXHRcdFx0fSApO1xuXHRcdH0sXG5cdFxuXHRcdHBvcDogICAgIF9fYXJyYXlQcm90by5wb3AsXG5cdFxuXHRcblx0XHRwdXNoOiAgICBfX2FycmF5UHJvdG8ucHVzaCxcblx0XG5cdFxuXHRcdC8vIERvZXMgbm90IHJldHVybiBhbiBBUEkgaW5zdGFuY2Vcblx0XHRyZWR1Y2U6IF9fYXJyYXlQcm90by5yZWR1Y2UgfHwgZnVuY3Rpb24gKCBmbiwgaW5pdCApXG5cdFx0e1xuXHRcdFx0cmV0dXJuIF9mblJlZHVjZSggdGhpcywgZm4sIGluaXQsIDAsIHRoaXMubGVuZ3RoLCAxICk7XG5cdFx0fSxcblx0XG5cdFxuXHRcdHJlZHVjZVJpZ2h0OiBfX2FycmF5UHJvdG8ucmVkdWNlUmlnaHQgfHwgZnVuY3Rpb24gKCBmbiwgaW5pdCApXG5cdFx0e1xuXHRcdFx0cmV0dXJuIF9mblJlZHVjZSggdGhpcywgZm4sIGluaXQsIHRoaXMubGVuZ3RoLTEsIC0xLCAtMSApO1xuXHRcdH0sXG5cdFxuXHRcblx0XHRyZXZlcnNlOiBfX2FycmF5UHJvdG8ucmV2ZXJzZSxcblx0XG5cdFxuXHRcdC8vIE9iamVjdCB3aXRoIHJvd3MsIGNvbHVtbnMgYW5kIG9wdHNcblx0XHRzZWxlY3RvcjogbnVsbCxcblx0XG5cdFxuXHRcdHNoaWZ0OiAgIF9fYXJyYXlQcm90by5zaGlmdCxcblx0XG5cdFxuXHRcdHNvcnQ6ICAgIF9fYXJyYXlQcm90by5zb3J0LCAvLyA/IG5hbWUgLSBvcmRlcj9cblx0XG5cdFxuXHRcdHNwbGljZTogIF9fYXJyYXlQcm90by5zcGxpY2UsXG5cdFxuXHRcblx0XHR0b0FycmF5OiBmdW5jdGlvbiAoKVxuXHRcdHtcblx0XHRcdHJldHVybiBfX2FycmF5UHJvdG8uc2xpY2UuY2FsbCggdGhpcyApO1xuXHRcdH0sXG5cdFxuXHRcblx0XHR0byQ6IGZ1bmN0aW9uICgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuICQoIHRoaXMgKTtcblx0XHR9LFxuXHRcblx0XG5cdFx0dG9KUXVlcnk6IGZ1bmN0aW9uICgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuICQoIHRoaXMgKTtcblx0XHR9LFxuXHRcblx0XG5cdFx0dW5pcXVlOiBmdW5jdGlvbiAoKVxuXHRcdHtcblx0XHRcdHJldHVybiBuZXcgX0FwaSggdGhpcy5jb250ZXh0LCBfdW5pcXVlKHRoaXMpICk7XG5cdFx0fSxcblx0XG5cdFxuXHRcdHVuc2hpZnQ6IF9fYXJyYXlQcm90by51bnNoaWZ0XG5cdH07XG5cdFxuXHRcblx0X0FwaS5leHRlbmQgPSBmdW5jdGlvbiAoIHNjb3BlLCBvYmosIGV4dCApXG5cdHtcblx0XHQvLyBPbmx5IGV4dGVuZCBBUEkgaW5zdGFuY2VzIGFuZCBzdGF0aWMgcHJvcGVydGllcyBvZiB0aGUgQVBJXG5cdFx0aWYgKCAhIGV4dC5sZW5ndGggfHwgISBvYmogfHwgKCAhIChvYmogaW5zdGFuY2VvZiBfQXBpKSAmJiAhIG9iai5fX2R0X3dyYXBwZXIgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFxuXHRcdHZhclxuXHRcdFx0aSwgaWVuLFxuXHRcdFx0aiwgamVuLFxuXHRcdFx0c3RydWN0LCBpbm5lcixcblx0XHRcdG1ldGhvZFNjb3BpbmcgPSBmdW5jdGlvbiAoIHNjb3BlLCBmbiwgc3RydWMgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dmFyIHJldCA9IGZuLmFwcGx5KCBzY29wZSwgYXJndW1lbnRzICk7XG5cdFxuXHRcdFx0XHRcdC8vIE1ldGhvZCBleHRlbnNpb25cblx0XHRcdFx0XHRfQXBpLmV4dGVuZCggcmV0LCByZXQsIHN0cnVjLm1ldGhvZEV4dCApO1xuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcblx0XHRmb3IgKCBpPTAsIGllbj1leHQubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRzdHJ1Y3QgPSBleHRbaV07XG5cdFxuXHRcdFx0Ly8gVmFsdWVcblx0XHRcdG9ialsgc3RydWN0Lm5hbWUgXSA9IHR5cGVvZiBzdHJ1Y3QudmFsID09PSAnZnVuY3Rpb24nID9cblx0XHRcdFx0bWV0aG9kU2NvcGluZyggc2NvcGUsIHN0cnVjdC52YWwsIHN0cnVjdCApIDpcblx0XHRcdFx0JC5pc1BsYWluT2JqZWN0KCBzdHJ1Y3QudmFsICkgP1xuXHRcdFx0XHRcdHt9IDpcblx0XHRcdFx0XHRzdHJ1Y3QudmFsO1xuXHRcblx0XHRcdG9ialsgc3RydWN0Lm5hbWUgXS5fX2R0X3dyYXBwZXIgPSB0cnVlO1xuXHRcblx0XHRcdC8vIFByb3BlcnR5IGV4dGVuc2lvblxuXHRcdFx0X0FwaS5leHRlbmQoIHNjb3BlLCBvYmpbIHN0cnVjdC5uYW1lIF0sIHN0cnVjdC5wcm9wRXh0ICk7XG5cdFx0fVxuXHR9O1xuXHRcblx0XG5cdC8vIEB0b2RvIC0gSXMgdGhlcmUgbmVlZCBmb3IgYW4gYXVnbWVudCBmdW5jdGlvbj9cblx0Ly8gX0FwaS5hdWdtZW50ID0gZnVuY3Rpb24gKCBpbnN0LCBuYW1lIClcblx0Ly8ge1xuXHQvLyBcdC8vIEZpbmQgc3JjIG9iamVjdCBpbiB0aGUgc3RydWN0dXJlIGZyb20gdGhlIG5hbWVcblx0Ly8gXHR2YXIgcGFydHMgPSBuYW1lLnNwbGl0KCcuJyk7XG5cdFxuXHQvLyBcdF9BcGkuZXh0ZW5kKCBpbnN0LCBvYmogKTtcblx0Ly8gfTtcblx0XG5cdFxuXHQvLyAgICAgW1xuXHQvLyAgICAgICB7XG5cdC8vICAgICAgICAgbmFtZTogICAgICAnZGF0YScgICAgICAgICAgICAgICAgLS0gc3RyaW5nICAgLSBQcm9wZXJ0eSBuYW1lXG5cdC8vICAgICAgICAgdmFsOiAgICAgICBmdW5jdGlvbiAoKSB7fSwgICAgICAgLS0gZnVuY3Rpb24gLSBBcGkgbWV0aG9kIChvciB1bmRlZmluZWQgaWYganVzdCBhbiBvYmplY3Rcblx0Ly8gICAgICAgICBtZXRob2RFeHQ6IFsgLi4uIF0sICAgICAgICAgICAgICAtLSBhcnJheSAgICAtIEFycmF5IG9mIEFwaSBvYmplY3QgZGVmaW5pdGlvbnMgdG8gZXh0ZW5kIHRoZSBtZXRob2QgcmVzdWx0XG5cdC8vICAgICAgICAgcHJvcEV4dDogICBbIC4uLiBdICAgICAgICAgICAgICAgLS0gYXJyYXkgICAgLSBBcnJheSBvZiBBcGkgb2JqZWN0IGRlZmluaXRpb25zIHRvIGV4dGVuZCB0aGUgcHJvcGVydHlcblx0Ly8gICAgICAgfSxcblx0Ly8gICAgICAge1xuXHQvLyAgICAgICAgIG5hbWU6ICAgICAncm93J1xuXHQvLyAgICAgICAgIHZhbDogICAgICAge30sXG5cdC8vICAgICAgICAgbWV0aG9kRXh0OiBbIC4uLiBdLFxuXHQvLyAgICAgICAgIHByb3BFeHQ6ICAgW1xuXHQvLyAgICAgICAgICAge1xuXHQvLyAgICAgICAgICAgICBuYW1lOiAgICAgICdkYXRhJ1xuXHQvLyAgICAgICAgICAgICB2YWw6ICAgICAgIGZ1bmN0aW9uICgpIHt9LFxuXHQvLyAgICAgICAgICAgICBtZXRob2RFeHQ6IFsgLi4uIF0sXG5cdC8vICAgICAgICAgICAgIHByb3BFeHQ6ICAgWyAuLi4gXVxuXHQvLyAgICAgICAgICAgfSxcblx0Ly8gICAgICAgICAgIC4uLlxuXHQvLyAgICAgICAgIF1cblx0Ly8gICAgICAgfVxuXHQvLyAgICAgXVxuXHRcblx0X0FwaS5yZWdpc3RlciA9IF9hcGlfcmVnaXN0ZXIgPSBmdW5jdGlvbiAoIG5hbWUsIHZhbCApXG5cdHtcblx0XHRpZiAoICQuaXNBcnJheSggbmFtZSApICkge1xuXHRcdFx0Zm9yICggdmFyIGo9MCwgamVuPW5hbWUubGVuZ3RoIDsgajxqZW4gOyBqKysgKSB7XG5cdFx0XHRcdF9BcGkucmVnaXN0ZXIoIG5hbWVbal0sIHZhbCApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XG5cdFx0dmFyXG5cdFx0XHRpLCBpZW4sXG5cdFx0XHRoZWlyID0gbmFtZS5zcGxpdCgnLicpLFxuXHRcdFx0c3RydWN0ID0gX19hcGlTdHJ1Y3QsXG5cdFx0XHRrZXksIG1ldGhvZDtcblx0XG5cdFx0dmFyIGZpbmQgPSBmdW5jdGlvbiAoIHNyYywgbmFtZSApIHtcblx0XHRcdGZvciAoIHZhciBpPTAsIGllbj1zcmMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdGlmICggc3JjW2ldLm5hbWUgPT09IG5hbWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHNyY1tpXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0XG5cdFx0Zm9yICggaT0wLCBpZW49aGVpci5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdG1ldGhvZCA9IGhlaXJbaV0uaW5kZXhPZignKCknKSAhPT0gLTE7XG5cdFx0XHRrZXkgPSBtZXRob2QgP1xuXHRcdFx0XHRoZWlyW2ldLnJlcGxhY2UoJygpJywgJycpIDpcblx0XHRcdFx0aGVpcltpXTtcblx0XG5cdFx0XHR2YXIgc3JjID0gZmluZCggc3RydWN0LCBrZXkgKTtcblx0XHRcdGlmICggISBzcmMgKSB7XG5cdFx0XHRcdHNyYyA9IHtcblx0XHRcdFx0XHRuYW1lOiAgICAgIGtleSxcblx0XHRcdFx0XHR2YWw6ICAgICAgIHt9LFxuXHRcdFx0XHRcdG1ldGhvZEV4dDogW10sXG5cdFx0XHRcdFx0cHJvcEV4dDogICBbXVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRzdHJ1Y3QucHVzaCggc3JjICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0aWYgKCBpID09PSBpZW4tMSApIHtcblx0XHRcdFx0c3JjLnZhbCA9IHZhbDtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRzdHJ1Y3QgPSBtZXRob2QgP1xuXHRcdFx0XHRcdHNyYy5tZXRob2RFeHQgOlxuXHRcdFx0XHRcdHNyYy5wcm9wRXh0O1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0XG5cdFxuXHRfQXBpLnJlZ2lzdGVyUGx1cmFsID0gX2FwaV9yZWdpc3RlclBsdXJhbCA9IGZ1bmN0aW9uICggcGx1cmFsTmFtZSwgc2luZ3VsYXJOYW1lLCB2YWwgKSB7XG5cdFx0X0FwaS5yZWdpc3RlciggcGx1cmFsTmFtZSwgdmFsICk7XG5cdFxuXHRcdF9BcGkucmVnaXN0ZXIoIHNpbmd1bGFyTmFtZSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHJldCA9IHZhbC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFxuXHRcdFx0aWYgKCByZXQgPT09IHRoaXMgKSB7XG5cdFx0XHRcdC8vIFJldHVybmVkIGl0ZW0gaXMgdGhlIEFQSSBpbnN0YW5jZSB0aGF0IHdhcyBwYXNzZWQgaW4sIHJldHVybiBpdFxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCByZXQgaW5zdGFuY2VvZiBfQXBpICkge1xuXHRcdFx0XHQvLyBOZXcgQVBJIGluc3RhbmNlIHJldHVybmVkLCB3YW50IHRoZSB2YWx1ZSBmcm9tIHRoZSBmaXJzdCBpdGVtXG5cdFx0XHRcdC8vIGluIHRoZSByZXR1cm5lZCBhcnJheSBmb3IgdGhlIHNpbmd1bGFyIHJlc3VsdC5cblx0XHRcdFx0cmV0dXJuIHJldC5sZW5ndGggP1xuXHRcdFx0XHRcdCQuaXNBcnJheSggcmV0WzBdICkgP1xuXHRcdFx0XHRcdFx0bmV3IF9BcGkoIHJldC5jb250ZXh0LCByZXRbMF0gKSA6IC8vIEFycmF5IHJlc3VsdHMgYXJlICdlbmhhbmNlZCdcblx0XHRcdFx0XHRcdHJldFswXSA6XG5cdFx0XHRcdFx0dW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIE5vbi1BUEkgcmV0dXJuIC0ganVzdCBmaXJlIGl0IGJhY2tcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSApO1xuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHQgKiBTZWxlY3RvciBmb3IgSFRNTCB0YWJsZXMuIEFwcGx5IHRoZSBnaXZlbiBzZWxlY3RvciB0byB0aGUgZ2l2ZSBhcnJheSBvZlxuXHQgKiBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfGludGVnZXJ9IFtzZWxlY3Rvcl0galF1ZXJ5IHNlbGVjdG9yIHN0cmluZyBvciBpbnRlZ2VyXG5cdCAqIEBwYXJhbSAge2FycmF5fSBBcnJheSBvZiBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdHMgdG8gYmUgZmlsdGVyZWRcblx0ICogQHJldHVybiB7YXJyYXl9XG5cdCAqIEBpZ25vcmVcblx0ICovXG5cdHZhciBfX3RhYmxlX3NlbGVjdG9yID0gZnVuY3Rpb24gKCBzZWxlY3RvciwgYSApXG5cdHtcblx0XHQvLyBJbnRlZ2VyIGlzIHVzZWQgdG8gcGljayBvdXQgYSB0YWJsZSBieSBpbmRleFxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSAnbnVtYmVyJyApIHtcblx0XHRcdHJldHVybiBbIGFbIHNlbGVjdG9yIF0gXTtcblx0XHR9XG5cdFxuXHRcdC8vIFBlcmZvcm0gYSBqUXVlcnkgc2VsZWN0b3Igb24gdGhlIHRhYmxlIG5vZGVzXG5cdFx0dmFyIG5vZGVzID0gJC5tYXAoIGEsIGZ1bmN0aW9uIChlbCwgaSkge1xuXHRcdFx0cmV0dXJuIGVsLm5UYWJsZTtcblx0XHR9ICk7XG5cdFxuXHRcdHJldHVybiAkKG5vZGVzKVxuXHRcdFx0LmZpbHRlciggc2VsZWN0b3IgKVxuXHRcdFx0Lm1hcCggZnVuY3Rpb24gKGkpIHtcblx0XHRcdFx0Ly8gTmVlZCB0byB0cmFuc2xhdGUgYmFjayBmcm9tIHRoZSB0YWJsZSBub2RlIHRvIHRoZSBzZXR0aW5nc1xuXHRcdFx0XHR2YXIgaWR4ID0gJC5pbkFycmF5KCB0aGlzLCBub2RlcyApO1xuXHRcdFx0XHRyZXR1cm4gYVsgaWR4IF07XG5cdFx0XHR9IClcblx0XHRcdC50b0FycmF5KCk7XG5cdH07XG5cdFxuXHRcblx0XG5cdC8qKlxuXHQgKiBDb250ZXh0IHNlbGVjdG9yIGZvciB0aGUgQVBJJ3MgY29udGV4dCAoaS5lLiB0aGUgdGFibGVzIHRoZSBBUEkgaW5zdGFuY2Vcblx0ICogcmVmZXJzIHRvLlxuXHQgKlxuXHQgKiBAbmFtZSAgICBEYXRhVGFibGUuQXBpI3RhYmxlc1xuXHQgKiBAcGFyYW0ge3N0cmluZ3xpbnRlZ2VyfSBbc2VsZWN0b3JdIFNlbGVjdG9yIHRvIHBpY2sgd2hpY2ggdGFibGVzIHRoZSBpdGVyYXRvclxuXHQgKiAgIHNob3VsZCBvcGVyYXRlIG9uLiBJZiBub3QgZ2l2ZW4sIGFsbCB0YWJsZXMgaW4gdGhlIGN1cnJlbnQgY29udGV4dCBhcmVcblx0ICogICB1c2VkLiBUaGlzIGNhbiBiZSBnaXZlbiBhcyBhIGpRdWVyeSBzZWxlY3RvciAoZm9yIGV4YW1wbGUgYCc6Z3QoMCknYCkgdG9cblx0ICogICBzZWxlY3QgbXVsdGlwbGUgdGFibGVzIG9yIGFzIGFuIGludGVnZXIgdG8gc2VsZWN0IGEgc2luZ2xlIHRhYmxlLlxuXHQgKiBAcmV0dXJucyB7RGF0YVRhYmxlLkFwaX0gUmV0dXJucyBhIG5ldyBBUEkgaW5zdGFuY2UgaWYgYSBzZWxlY3RvciBpcyBnaXZlbi5cblx0ICovXG5cdF9hcGlfcmVnaXN0ZXIoICd0YWJsZXMoKScsIGZ1bmN0aW9uICggc2VsZWN0b3IgKSB7XG5cdFx0Ly8gQSBuZXcgaW5zdGFuY2UgaXMgY3JlYXRlZCBpZiB0aGVyZSB3YXMgYSBzZWxlY3RvciBzcGVjaWZpZWRcblx0XHRyZXR1cm4gc2VsZWN0b3IgP1xuXHRcdFx0bmV3IF9BcGkoIF9fdGFibGVfc2VsZWN0b3IoIHNlbGVjdG9yLCB0aGlzLmNvbnRleHQgKSApIDpcblx0XHRcdHRoaXM7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAndGFibGUoKScsIGZ1bmN0aW9uICggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIHRhYmxlcyA9IHRoaXMudGFibGVzKCBzZWxlY3RvciApO1xuXHRcdHZhciBjdHggPSB0YWJsZXMuY29udGV4dDtcblx0XG5cdFx0Ly8gVHJ1bmNhdGUgdG8gdGhlIGZpcnN0IG1hdGNoZWQgdGFibGVcblx0XHRyZXR1cm4gY3R4Lmxlbmd0aCA/XG5cdFx0XHRuZXcgX0FwaSggY3R4WzBdICkgOlxuXHRcdFx0dGFibGVzO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ3RhYmxlcygpLm5vZGVzKCknLCAndGFibGUoKS5ub2RlKCknICwgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIGN0eCApIHtcblx0XHRcdHJldHVybiBjdHgublRhYmxlO1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICd0YWJsZXMoKS5ib2R5KCknLCAndGFibGUoKS5ib2R5KCknICwgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIGN0eCApIHtcblx0XHRcdHJldHVybiBjdHgublRCb2R5O1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICd0YWJsZXMoKS5oZWFkZXIoKScsICd0YWJsZSgpLmhlYWRlcigpJyAsIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHggKSB7XG5cdFx0XHRyZXR1cm4gY3R4Lm5USGVhZDtcblx0XHR9LCAxICk7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyUGx1cmFsKCAndGFibGVzKCkuZm9vdGVyKCknLCAndGFibGUoKS5mb290ZXIoKScgLCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggY3R4ICkge1xuXHRcdFx0cmV0dXJuIGN0eC5uVEZvb3Q7XG5cdFx0fSwgMSApO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ3RhYmxlcygpLmNvbnRhaW5lcnMoKScsICd0YWJsZSgpLmNvbnRhaW5lcigpJyAsIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHggKSB7XG5cdFx0XHRyZXR1cm4gY3R4Lm5UYWJsZVdyYXBwZXI7XG5cdFx0fSwgMSApO1xuXHR9ICk7XG5cdFxuXHRcblx0XG5cdC8qKlxuXHQgKiBSZWRyYXcgdGhlIHRhYmxlcyBpbiB0aGUgY3VycmVudCBjb250ZXh0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXNldD10cnVlXSBSZXNldCAoZGVmYXVsdCkgb3IgaG9sZCB0aGUgY3VycmVudCBwYWdpbmdcblx0ICogICBwb3NpdGlvbi4gQSBmdWxsIHJlLXNvcnQgYW5kIHJlLWZpbHRlciBpcyBwZXJmb3JtZWQgd2hlbiB0aGlzIG1ldGhvZCBpc1xuXHQgKiAgIGNhbGxlZCwgd2hpY2ggaXMgd2h5IHRoZSBwYWdpbmF0aW9uIHJlc2V0IGlzIHRoZSBkZWZhdWx0IGFjdGlvbi5cblx0ICogQHJldHVybnMge0RhdGFUYWJsZXMuQXBpfSB0aGlzXG5cdCAqL1xuXHRfYXBpX3JlZ2lzdGVyKCAnZHJhdygpJywgZnVuY3Rpb24gKCByZXNldFBhZ2luZyApIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdF9mblJlRHJhdyggc2V0dGluZ3MsIHJlc2V0UGFnaW5nPT09ZmFsc2UgKTtcblx0XHR9ICk7XG5cdH0gKTtcblx0XG5cdFxuXHRcblx0LyoqXG5cdCAqIEdldCB0aGUgY3VycmVudCBwYWdlIGluZGV4LlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtpbnRlZ2VyfSBDdXJyZW50IHBhZ2UgaW5kZXggKHplcm8gYmFzZWQpXG5cdCAqLy8qKlxuXHQgKiBTZXQgdGhlIGN1cnJlbnQgcGFnZS5cblx0ICpcblx0ICogTm90ZSB0aGF0IGlmIHlvdSBhdHRlbXB0IHRvIHNob3cgYSBwYWdlIHdoaWNoIGRvZXMgbm90IGV4aXN0LCBEYXRhVGFibGVzIHdpbGxcblx0ICogbm90IHRocm93IGFuIGVycm9yLCBidXQgcmF0aGVyIHJlc2V0IHRoZSBwYWdpbmcuXG5cdCAqXG5cdCAqIEBwYXJhbSB7aW50ZWdlcnxzdHJpbmd9IGFjdGlvbiBUaGUgcGFnaW5nIGFjdGlvbiB0byB0YWtlLiBUaGlzIGNhbiBiZSBvbmUgb2Y6XG5cdCAqICAqIGBpbnRlZ2VyYCAtIFRoZSBwYWdlIGluZGV4IHRvIGp1bXAgdG9cblx0ICogICogYHN0cmluZ2AgLSBBbiBhY3Rpb24gdG8gdGFrZTpcblx0ICogICAgKiBgZmlyc3RgIC0gSnVtcCB0byBmaXJzdCBwYWdlLlxuXHQgKiAgICAqIGBuZXh0YCAtIEp1bXAgdG8gdGhlIG5leHQgcGFnZVxuXHQgKiAgICAqIGBwcmV2aW91c2AgLSBKdW1wIHRvIHByZXZpb3VzIHBhZ2Vcblx0ICogICAgKiBgbGFzdGAgLSBKdW1wIHRvIHRoZSBsYXN0IHBhZ2UuXG5cdCAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xuXHQgKi9cblx0X2FwaV9yZWdpc3RlciggJ3BhZ2UoKScsIGZ1bmN0aW9uICggYWN0aW9uICkge1xuXHRcdGlmICggYWN0aW9uID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wYWdlLmluZm8oKS5wYWdlOyAvLyBub3QgYW4gZXhwZW5zaXZlIGNhbGxcblx0XHR9XG5cdFxuXHRcdC8vIGVsc2UsIGhhdmUgYW4gYWN0aW9uIHRvIHRha2Ugb24gYWxsIHRhYmxlc1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdFx0X2ZuUGFnZUNoYW5nZSggc2V0dGluZ3MsIGFjdGlvbiApO1xuXHRcdH0gKTtcblx0fSApO1xuXHRcblx0XG5cdC8qKlxuXHQgKiBQYWdpbmcgaW5mb3JtYXRpb24gZm9yIHRoZSBmaXJzdCB0YWJsZSBpbiB0aGUgY3VycmVudCBjb250ZXh0LlxuXHQgKlxuXHQgKiBJZiB5b3UgcmVxdWlyZSBwYWdpbmcgaW5mb3JtYXRpb24gZm9yIGFub3RoZXIgdGFibGUsIHVzZSB0aGUgYHRhYmxlKClgIG1ldGhvZFxuXHQgKiB3aXRoIGEgc3VpdGFibGUgc2VsZWN0b3IuXG5cdCAqXG5cdCAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIHNldDpcblx0ICogICogYHBhZ2VgIC0gQ3VycmVudCBwYWdlIGluZGV4ICh6ZXJvIGJhc2VkIC0gaS5lLiB0aGUgZmlyc3QgcGFnZSBpcyBgMGApXG5cdCAqICAqIGBwYWdlc2AgLSBUb3RhbCBudW1iZXIgb2YgcGFnZXNcblx0ICogICogYHN0YXJ0YCAtIERpc3BsYXkgaW5kZXggZm9yIHRoZSBmaXJzdCByZWNvcmQgc2hvd24gb24gdGhlIGN1cnJlbnQgcGFnZVxuXHQgKiAgKiBgZW5kYCAtIERpc3BsYXkgaW5kZXggZm9yIHRoZSBsYXN0IHJlY29yZCBzaG93biBvbiB0aGUgY3VycmVudCBwYWdlXG5cdCAqICAqIGBsZW5ndGhgIC0gRGlzcGxheSBsZW5ndGggKG51bWJlciBvZiByZWNvcmRzKS4gTm90ZSB0aGF0IGdlbmVyYWxseSBgc3RhcnRcblx0ICogICAgKyBsZW5ndGggPSBlbmRgLCBidXQgdGhpcyBpcyBub3QgYWx3YXlzIHRydWUsIGZvciBleGFtcGxlIGlmIHRoZXJlIGFyZVxuXHQgKiAgICBvbmx5IDIgcmVjb3JkcyB0byBzaG93IG9uIHRoZSBmaW5hbCBwYWdlLCB3aXRoIGEgbGVuZ3RoIG9mIDEwLlxuXHQgKiAgKiBgcmVjb3Jkc1RvdGFsYCAtIEZ1bGwgZGF0YSBzZXQgbGVuZ3RoXG5cdCAqICAqIGByZWNvcmRzRGlzcGxheWAgLSBEYXRhIHNldCBsZW5ndGggb25jZSB0aGUgY3VycmVudCBmaWx0ZXJpbmcgY3JpdGVyaW9uXG5cdCAqICAgIGFyZSBhcHBsaWVkLlxuXHQgKi9cblx0X2FwaV9yZWdpc3RlciggJ3BhZ2UuaW5mbygpJywgZnVuY3Rpb24gKCBhY3Rpb24gKSB7XG5cdFx0aWYgKCB0aGlzLmNvbnRleHQubGVuZ3RoID09PSAwICkge1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9XG5cdFxuXHRcdHZhclxuXHRcdFx0c2V0dGluZ3MgICA9IHRoaXMuY29udGV4dFswXSxcblx0XHRcdHN0YXJ0ICAgICAgPSBzZXR0aW5ncy5faURpc3BsYXlTdGFydCxcblx0XHRcdGxlbiAgICAgICAgPSBzZXR0aW5ncy5faURpc3BsYXlMZW5ndGgsXG5cdFx0XHR2aXNSZWNvcmRzID0gc2V0dGluZ3MuZm5SZWNvcmRzRGlzcGxheSgpLFxuXHRcdFx0YWxsICAgICAgICA9IGxlbiA9PT0gLTE7XG5cdFxuXHRcdHJldHVybiB7XG5cdFx0XHRcInBhZ2VcIjogICAgICAgICAgIGFsbCA/IDAgOiBNYXRoLmZsb29yKCBzdGFydCAvIGxlbiApLFxuXHRcdFx0XCJwYWdlc1wiOiAgICAgICAgICBhbGwgPyAxIDogTWF0aC5jZWlsKCB2aXNSZWNvcmRzIC8gbGVuICksXG5cdFx0XHRcInN0YXJ0XCI6ICAgICAgICAgIHN0YXJ0LFxuXHRcdFx0XCJlbmRcIjogICAgICAgICAgICBzZXR0aW5ncy5mbkRpc3BsYXlFbmQoKSxcblx0XHRcdFwibGVuZ3RoXCI6ICAgICAgICAgbGVuLFxuXHRcdFx0XCJyZWNvcmRzVG90YWxcIjogICBzZXR0aW5ncy5mblJlY29yZHNUb3RhbCgpLFxuXHRcdFx0XCJyZWNvcmRzRGlzcGxheVwiOiB2aXNSZWNvcmRzXG5cdFx0fTtcblx0fSApO1xuXHRcblx0XG5cdC8qKlxuXHQgKiBHZXQgdGhlIGN1cnJlbnQgcGFnZSBsZW5ndGguXG5cdCAqXG5cdCAqIEByZXR1cm4ge2ludGVnZXJ9IEN1cnJlbnQgcGFnZSBsZW5ndGguIE5vdGUgYC0xYCBpbmRpY2F0ZXMgdGhhdCBhbGwgcmVjb3Jkc1xuXHQgKiAgIGFyZSB0byBiZSBzaG93bi5cblx0ICovLyoqXG5cdCAqIFNldCB0aGUgY3VycmVudCBwYWdlIGxlbmd0aC5cblx0ICpcblx0ICogQHBhcmFtIHtpbnRlZ2VyfSBQYWdlIGxlbmd0aCB0byBzZXQuIFVzZSBgLTFgIHRvIHNob3cgYWxsIHJlY29yZHMuXG5cdCAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xuXHQgKi9cblx0X2FwaV9yZWdpc3RlciggJ3BhZ2UubGVuKCknLCBmdW5jdGlvbiAoIGxlbiApIHtcblx0XHQvLyBOb3RlIHRoYXQgd2UgY2FuJ3QgY2FsbCB0aGlzIGZ1bmN0aW9uICdsZW5ndGgoKScgYmVjYXVzZSBgbGVuZ3RoYFxuXHRcdC8vIGlzIGEgSmF2YXNjcmlwdCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgd2hpY2ggZGVmaW5lcyBob3cgbWFueSBhcmd1bWVudHNcblx0XHQvLyB0aGUgZnVuY3Rpb24gZXhwZWN0cy5cblx0XHRpZiAoIGxlbiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuY29udGV4dC5sZW5ndGggIT09IDAgP1xuXHRcdFx0XHR0aGlzLmNvbnRleHRbMF0uX2lEaXNwbGF5TGVuZ3RoIDpcblx0XHRcdFx0dW5kZWZpbmVkO1xuXHRcdH1cblx0XG5cdFx0Ly8gZWxzZSwgc2V0IHRoZSBwYWdlIGxlbmd0aFxuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdFx0X2ZuTGVuZ3RoQ2hhbmdlKCBzZXR0aW5ncywgbGVuICk7XG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRcblx0XG5cdHZhciBfX3JlbG9hZCA9IGZ1bmN0aW9uICggc2V0dGluZ3MsIGhvbGRQb3NpdGlvbiwgY2FsbGJhY2sgKSB7XG5cdFx0Ly8gVXNlIHRoZSBkcmF3IGV2ZW50IHRvIHRyaWdnZXIgYSBjYWxsYmFja1xuXHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHR2YXIgYXBpID0gbmV3IF9BcGkoIHNldHRpbmdzICk7XG5cdFxuXHRcdFx0YXBpLm9uZSggJ2RyYXcnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGNhbGxiYWNrKCBhcGkuYWpheC5qc29uKCkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdFxuXHRcdGlmICggX2ZuRGF0YVNvdXJjZSggc2V0dGluZ3MgKSA9PSAnc3NwJyApIHtcblx0XHRcdF9mblJlRHJhdyggc2V0dGluZ3MsIGhvbGRQb3NpdGlvbiApO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIFRyaWdnZXIgeGhyXG5cdFx0XHRfZm5Qcm9jZXNzaW5nRGlzcGxheSggc2V0dGluZ3MsIHRydWUgKTtcblx0XG5cdFx0XHRfZm5CdWlsZEFqYXgoIHNldHRpbmdzLCBbXSwgZnVuY3Rpb24oIGpzb24gKSB7XG5cdFx0XHRcdF9mbkNsZWFyVGFibGUoIHNldHRpbmdzICk7XG5cdFxuXHRcdFx0XHR2YXIgZGF0YSA9IF9mbkFqYXhEYXRhU3JjKCBzZXR0aW5ncywganNvbiApO1xuXHRcdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49ZGF0YS5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0XHRfZm5BZGREYXRhKCBzZXR0aW5ncywgZGF0YVtpXSApO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRfZm5SZURyYXcoIHNldHRpbmdzLCBob2xkUG9zaXRpb24gKTtcblx0XHRcdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIHNldHRpbmdzLCBmYWxzZSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblx0fTtcblx0XG5cdFxuXHQvKipcblx0ICogR2V0IHRoZSBKU09OIHJlc3BvbnNlIGZyb20gdGhlIGxhc3QgQWpheCByZXF1ZXN0IHRoYXQgRGF0YVRhYmxlcyBtYWRlIHRvIHRoZVxuXHQgKiBzZXJ2ZXIuIE5vdGUgdGhhdCB0aGlzIHJldHVybnMgdGhlIEpTT04gZnJvbSB0aGUgZmlyc3QgdGFibGUgaW4gdGhlIGN1cnJlbnRcblx0ICogY29udGV4dC5cblx0ICpcblx0ICogQHJldHVybiB7b2JqZWN0fSBKU09OIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlci5cblx0ICovXG5cdF9hcGlfcmVnaXN0ZXIoICdhamF4Lmpzb24oKScsIGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXHRcblx0XHRpZiAoIGN0eC5sZW5ndGggPiAwICkge1xuXHRcdFx0cmV0dXJuIGN0eFswXS5qc29uO1xuXHRcdH1cblx0XG5cdFx0Ly8gZWxzZSByZXR1cm4gdW5kZWZpbmVkO1xuXHR9ICk7XG5cdFxuXHRcblx0LyoqXG5cdCAqIEdldCB0aGUgZGF0YSBzdWJtaXR0ZWQgaW4gdGhlIGxhc3QgQWpheCByZXF1ZXN0XG5cdCAqL1xuXHRfYXBpX3JlZ2lzdGVyKCAnYWpheC5wYXJhbXMoKScsIGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXHRcblx0XHRpZiAoIGN0eC5sZW5ndGggPiAwICkge1xuXHRcdFx0cmV0dXJuIGN0eFswXS5vQWpheERhdGE7XG5cdFx0fVxuXHRcblx0XHQvLyBlbHNlIHJldHVybiB1bmRlZmluZWQ7XG5cdH0gKTtcblx0XG5cdFxuXHQvKipcblx0ICogUmVsb2FkIHRhYmxlcyBmcm9tIHRoZSBBamF4IGRhdGEgc291cmNlLiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiB3aWxsXG5cdCAqIGF1dG9tYXRpY2FsbHkgcmUtZHJhdyB0aGUgdGFibGUgd2hlbiB0aGUgcmVtb3RlIGRhdGEgaGFzIGJlZW4gbG9hZGVkLlxuXHQgKlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXNldD10cnVlXSBSZXNldCAoZGVmYXVsdCkgb3IgaG9sZCB0aGUgY3VycmVudCBwYWdpbmdcblx0ICogICBwb3NpdGlvbi4gQSBmdWxsIHJlLXNvcnQgYW5kIHJlLWZpbHRlciBpcyBwZXJmb3JtZWQgd2hlbiB0aGlzIG1ldGhvZCBpc1xuXHQgKiAgIGNhbGxlZCwgd2hpY2ggaXMgd2h5IHRoZSBwYWdpbmF0aW9uIHJlc2V0IGlzIHRoZSBkZWZhdWx0IGFjdGlvbi5cblx0ICogQHJldHVybnMge0RhdGFUYWJsZXMuQXBpfSB0aGlzXG5cdCAqL1xuXHRfYXBpX3JlZ2lzdGVyKCAnYWpheC5yZWxvYWQoKScsIGZ1bmN0aW9uICggY2FsbGJhY2ssIHJlc2V0UGFnaW5nICkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcblx0XHRcdF9fcmVsb2FkKCBzZXR0aW5ncywgcmVzZXRQYWdpbmc9PT1mYWxzZSwgY2FsbGJhY2sgKTtcblx0XHR9ICk7XG5cdH0gKTtcblx0XG5cdFxuXHQvKipcblx0ICogR2V0IHRoZSBjdXJyZW50IEFqYXggVVJMLiBOb3RlIHRoYXQgdGhpcyByZXR1cm5zIHRoZSBVUkwgZnJvbSB0aGUgZmlyc3Rcblx0ICogdGFibGUgaW4gdGhlIGN1cnJlbnQgY29udGV4dC5cblx0ICpcblx0ICogQHJldHVybiB7c3RyaW5nfSBDdXJyZW50IEFqYXggc291cmNlIFVSTFxuXHQgKi8vKipcblx0ICogU2V0IHRoZSBBamF4IFVSTC4gTm90ZSB0aGF0IHRoaXMgd2lsbCBzZXQgdGhlIFVSTCBmb3IgYWxsIHRhYmxlcyBpbiB0aGVcblx0ICogY3VycmVudCBjb250ZXh0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFVSTCB0byBzZXQuXG5cdCAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xuXHQgKi9cblx0X2FwaV9yZWdpc3RlciggJ2FqYXgudXJsKCknLCBmdW5jdGlvbiAoIHVybCApIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXHRcblx0XHRpZiAoIHVybCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Ly8gZ2V0XG5cdFx0XHRpZiAoIGN0eC5sZW5ndGggPT09IDAgKSB7XG5cdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0XHRjdHggPSBjdHhbMF07XG5cdFxuXHRcdFx0cmV0dXJuIGN0eC5hamF4ID9cblx0XHRcdFx0JC5pc1BsYWluT2JqZWN0KCBjdHguYWpheCApID9cblx0XHRcdFx0XHRjdHguYWpheC51cmwgOlxuXHRcdFx0XHRcdGN0eC5hamF4IDpcblx0XHRcdFx0Y3R4LnNBamF4U291cmNlO1xuXHRcdH1cblx0XG5cdFx0Ly8gc2V0XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRpZiAoICQuaXNQbGFpbk9iamVjdCggc2V0dGluZ3MuYWpheCApICkge1xuXHRcdFx0XHRzZXR0aW5ncy5hamF4LnVybCA9IHVybDtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRzZXR0aW5ncy5hamF4ID0gdXJsO1xuXHRcdFx0fVxuXHRcdFx0Ly8gTm8gbmVlZCB0byBjb25zaWRlciBzQWpheFNvdXJjZSBoZXJlIHNpbmNlIERhdGFUYWJsZXMgZ2l2ZXMgcHJpb3JpdHlcblx0XHRcdC8vIHRvIGBhamF4YCBvdmVyIGBzQWpheFNvdXJjZWAuIFNvIHNldHRpbmcgYGFqYXhgIGhlcmUsIHJlbmRlcnMgYW55XG5cdFx0XHQvLyB2YWx1ZSBvZiBgc0FqYXhTb3VyY2VgIHJlZHVuZGFudC5cblx0XHR9ICk7XG5cdH0gKTtcblx0XG5cdFxuXHQvKipcblx0ICogTG9hZCBkYXRhIGZyb20gdGhlIG5ld2x5IHNldCBBamF4IFVSTC4gTm90ZSB0aGF0IHRoaXMgbWV0aG9kIGlzIG9ubHlcblx0ICogYXZhaWxhYmxlIHdoZW4gYGFqYXgudXJsKClgIGlzIHVzZWQgdG8gc2V0IGEgVVJMLiBBZGRpdGlvbmFsbHksIHRoaXMgbWV0aG9kXG5cdCAqIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXMgY2FsbGluZyBgYWpheC5yZWxvYWQoKWAgYnV0IGlzIHByb3ZpZGVkIGZvclxuXHQgKiBjb252ZW5pZW5jZSB3aGVuIHNldHRpbmcgYSBuZXcgVVJMLiBMaWtlIGBhamF4LnJlbG9hZCgpYCBpdCB3aWxsXG5cdCAqIGF1dG9tYXRpY2FsbHkgcmVkcmF3IHRoZSB0YWJsZSBvbmNlIHRoZSByZW1vdGUgZGF0YSBoYXMgYmVlbiBsb2FkZWQuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xuXHQgKi9cblx0X2FwaV9yZWdpc3RlciggJ2FqYXgudXJsKCkubG9hZCgpJywgZnVuY3Rpb24gKCBjYWxsYmFjaywgcmVzZXRQYWdpbmcgKSB7XG5cdFx0Ly8gU2FtZSBhcyBhIHJlbG9hZCwgYnV0IG1ha2VzIHNlbnNlIHRvIHByZXNlbnQgaXQgZm9yIGVhc3kgYWNjZXNzIGFmdGVyIGFcblx0XHQvLyB1cmwgY2hhbmdlXG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggY3R4ICkge1xuXHRcdFx0X19yZWxvYWQoIGN0eCwgcmVzZXRQYWdpbmc9PT1mYWxzZSwgY2FsbGJhY2sgKTtcblx0XHR9ICk7XG5cdH0gKTtcblx0XG5cdFxuXHRcblx0XG5cdHZhciBfc2VsZWN0b3JfcnVuID0gZnVuY3Rpb24gKCB0eXBlLCBzZWxlY3Rvciwgc2VsZWN0Rm4sIHNldHRpbmdzLCBvcHRzIClcblx0e1xuXHRcdHZhclxuXHRcdFx0b3V0ID0gW10sIHJlcyxcblx0XHRcdGEsIGksIGllbiwgaiwgamVuLFxuXHRcdFx0c2VsZWN0b3JUeXBlID0gdHlwZW9mIHNlbGVjdG9yO1xuXHRcblx0XHQvLyBDYW4ndCBqdXN0IGNoZWNrIGZvciBpc0FycmF5IGhlcmUsIGFzIGFuIEFQSSBvciBqUXVlcnkgaW5zdGFuY2UgbWlnaHQgYmVcblx0XHQvLyBnaXZlbiB3aXRoIHRoZWlyIGFycmF5IGxpa2UgbG9va1xuXHRcdGlmICggISBzZWxlY3RvciB8fCBzZWxlY3RvclR5cGUgPT09ICdzdHJpbmcnIHx8IHNlbGVjdG9yVHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCBzZWxlY3Rvci5sZW5ndGggPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHNlbGVjdG9yID0gWyBzZWxlY3RvciBdO1xuXHRcdH1cblx0XG5cdFx0Zm9yICggaT0wLCBpZW49c2VsZWN0b3IubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRhID0gc2VsZWN0b3JbaV0gJiYgc2VsZWN0b3JbaV0uc3BsaXQgP1xuXHRcdFx0XHRzZWxlY3RvcltpXS5zcGxpdCgnLCcpIDpcblx0XHRcdFx0WyBzZWxlY3RvcltpXSBdO1xuXHRcblx0XHRcdGZvciAoIGo9MCwgamVuPWEubGVuZ3RoIDsgajxqZW4gOyBqKysgKSB7XG5cdFx0XHRcdHJlcyA9IHNlbGVjdEZuKCB0eXBlb2YgYVtqXSA9PT0gJ3N0cmluZycgPyAkLnRyaW0oYVtqXSkgOiBhW2pdICk7XG5cdFxuXHRcdFx0XHRpZiAoIHJlcyAmJiByZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdG91dC5wdXNoLmFwcGx5KCBvdXQsIHJlcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHQvLyBzZWxlY3RvciBleHRlbnNpb25zXG5cdFx0dmFyIGV4dCA9IF9leHQuc2VsZWN0b3JbIHR5cGUgXTtcblx0XHRpZiAoIGV4dC5sZW5ndGggKSB7XG5cdFx0XHRmb3IgKCBpPTAsIGllbj1leHQubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdG91dCA9IGV4dFtpXSggc2V0dGluZ3MsIG9wdHMsIG91dCApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0cmV0dXJuIG91dDtcblx0fTtcblx0XG5cdFxuXHR2YXIgX3NlbGVjdG9yX29wdHMgPSBmdW5jdGlvbiAoIG9wdHMgKVxuXHR7XG5cdFx0aWYgKCAhIG9wdHMgKSB7XG5cdFx0XHRvcHRzID0ge307XG5cdFx0fVxuXHRcblx0XHQvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmb3IgMS45LSB3aGljaCB1c2VkIHRoZSB0ZXJtaW5vbG9neSBmaWx0ZXIgcmF0aGVyXG5cdFx0Ly8gdGhhbiBzZWFyY2hcblx0XHRpZiAoIG9wdHMuZmlsdGVyICYmIG9wdHMuc2VhcmNoID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRvcHRzLnNlYXJjaCA9IG9wdHMuZmlsdGVyO1xuXHRcdH1cblx0XG5cdFx0cmV0dXJuICQuZXh0ZW5kKCB7XG5cdFx0XHRzZWFyY2g6ICdub25lJyxcblx0XHRcdG9yZGVyOiAnY3VycmVudCcsXG5cdFx0XHRwYWdlOiAnYWxsJ1xuXHRcdH0sIG9wdHMgKTtcblx0fTtcblx0XG5cdFxuXHR2YXIgX3NlbGVjdG9yX2ZpcnN0ID0gZnVuY3Rpb24gKCBpbnN0IClcblx0e1xuXHRcdC8vIFJlZHVjZSB0aGUgQVBJIGluc3RhbmNlIHRvIHRoZSBmaXJzdCBpdGVtIGZvdW5kXG5cdFx0Zm9yICggdmFyIGk9MCwgaWVuPWluc3QubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRpZiAoIGluc3RbaV0ubGVuZ3RoID4gMCApIHtcblx0XHRcdFx0Ly8gQXNzaWduIHRoZSBmaXJzdCBlbGVtZW50IHRvIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBpbnN0YW5jZVxuXHRcdFx0XHQvLyBhbmQgdHJ1bmNhdGUgdGhlIGluc3RhbmNlIGFuZCBjb250ZXh0XG5cdFx0XHRcdGluc3RbMF0gPSBpbnN0W2ldO1xuXHRcdFx0XHRpbnN0WzBdLmxlbmd0aCA9IDE7XG5cdFx0XHRcdGluc3QubGVuZ3RoID0gMTtcblx0XHRcdFx0aW5zdC5jb250ZXh0ID0gWyBpbnN0LmNvbnRleHRbaV0gXTtcblx0XG5cdFx0XHRcdHJldHVybiBpbnN0O1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0Ly8gTm90IGZvdW5kIC0gcmV0dXJuIGFuIGVtcHR5IGluc3RhbmNlXG5cdFx0aW5zdC5sZW5ndGggPSAwO1xuXHRcdHJldHVybiBpbnN0O1xuXHR9O1xuXHRcblx0XG5cdHZhciBfc2VsZWN0b3Jfcm93X2luZGV4ZXMgPSBmdW5jdGlvbiAoIHNldHRpbmdzLCBvcHRzIClcblx0e1xuXHRcdHZhclxuXHRcdFx0aSwgaWVuLCB0bXAsIGE9W10sXG5cdFx0XHRkaXNwbGF5RmlsdGVyZWQgPSBzZXR0aW5ncy5haURpc3BsYXksXG5cdFx0XHRkaXNwbGF5TWFzdGVyID0gc2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyO1xuXHRcblx0XHR2YXJcblx0XHRcdHNlYXJjaCA9IG9wdHMuc2VhcmNoLCAgLy8gbm9uZSwgYXBwbGllZCwgcmVtb3ZlZFxuXHRcdFx0b3JkZXIgID0gb3B0cy5vcmRlciwgICAvLyBhcHBsaWVkLCBjdXJyZW50LCBpbmRleCAob3JpZ2luYWwgLSBjb21wYXRpYmlsaXR5IHdpdGggMS45KVxuXHRcdFx0cGFnZSAgID0gb3B0cy5wYWdlOyAgICAvLyBhbGwsIGN1cnJlbnRcblx0XG5cdFx0aWYgKCBfZm5EYXRhU291cmNlKCBzZXR0aW5ncyApID09ICdzc3AnICkge1xuXHRcdFx0Ly8gSW4gc2VydmVyLXNpZGUgcHJvY2Vzc2luZyBtb2RlLCBtb3N0IG9wdGlvbnMgYXJlIGlycmVsZXZhbnQgc2luY2Vcblx0XHRcdC8vIHJvd3Mgbm90IHNob3duIGRvbid0IGV4aXN0IGFuZCB0aGUgaW5kZXggb3JkZXIgaXMgdGhlIGFwcGxpZWQgb3JkZXJcblx0XHRcdC8vIFJlbW92ZWQgaXMgYSBzcGVjaWFsIGNhc2UgLSBmb3IgY29uc2lzdGVuY3kganVzdCByZXR1cm4gYW4gZW1wdHlcblx0XHRcdC8vIGFycmF5XG5cdFx0XHRyZXR1cm4gc2VhcmNoID09PSAncmVtb3ZlZCcgP1xuXHRcdFx0XHRbXSA6XG5cdFx0XHRcdF9yYW5nZSggMCwgZGlzcGxheU1hc3Rlci5sZW5ndGggKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHBhZ2UgPT0gJ2N1cnJlbnQnICkge1xuXHRcdFx0Ly8gQ3VycmVudCBwYWdlIGltcGxpZXMgdGhhdCBvcmRlcj1jdXJyZW50IGFuZCBmaXRsZXI9YXBwbGllZCwgc2luY2UgaXQgaXNcblx0XHRcdC8vIGZhaXJseSBzZW5zZWxlc3Mgb3RoZXJ3aXNlLCByZWdhcmRsZXNzIG9mIHdoYXQgb3JkZXIgYW5kIHNlYXJjaCBhY3R1YWxseVxuXHRcdFx0Ly8gYXJlXG5cdFx0XHRmb3IgKCBpPXNldHRpbmdzLl9pRGlzcGxheVN0YXJ0LCBpZW49c2V0dGluZ3MuZm5EaXNwbGF5RW5kKCkgOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0YS5wdXNoKCBkaXNwbGF5RmlsdGVyZWRbaV0gKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZiAoIG9yZGVyID09ICdjdXJyZW50JyB8fCBvcmRlciA9PSAnYXBwbGllZCcgKSB7XG5cdFx0XHRhID0gc2VhcmNoID09ICdub25lJyA/XG5cdFx0XHRcdGRpc3BsYXlNYXN0ZXIuc2xpY2UoKSA6ICAgICAgICAgICAgICAgICAgICAgIC8vIG5vIHNlYXJjaFxuXHRcdFx0XHRzZWFyY2ggPT0gJ2FwcGxpZWQnID9cblx0XHRcdFx0XHRkaXNwbGF5RmlsdGVyZWQuc2xpY2UoKSA6ICAgICAgICAgICAgICAgIC8vIGFwcGxpZWQgc2VhcmNoXG5cdFx0XHRcdFx0JC5tYXAoIGRpc3BsYXlNYXN0ZXIsIGZ1bmN0aW9uIChlbCwgaSkgeyAvLyByZW1vdmVkIHNlYXJjaFxuXHRcdFx0XHRcdFx0cmV0dXJuICQuaW5BcnJheSggZWwsIGRpc3BsYXlGaWx0ZXJlZCApID09PSAtMSA/IGVsIDogbnVsbDtcblx0XHRcdFx0XHR9ICk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBvcmRlciA9PSAnaW5kZXgnIHx8IG9yZGVyID09ICdvcmlnaW5hbCcgKSB7XG5cdFx0XHRmb3IgKCBpPTAsIGllbj1zZXR0aW5ncy5hb0RhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdGlmICggc2VhcmNoID09ICdub25lJyApIHtcblx0XHRcdFx0XHRhLnB1c2goIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHsgLy8gYXBwbGllZCB8IHJlbW92ZWRcblx0XHRcdFx0XHR0bXAgPSAkLmluQXJyYXkoIGksIGRpc3BsYXlGaWx0ZXJlZCApO1xuXHRcblx0XHRcdFx0XHRpZiAoKHRtcCA9PT0gLTEgJiYgc2VhcmNoID09ICdyZW1vdmVkJykgfHxcblx0XHRcdFx0XHRcdCh0bXAgPj0gMCAgICYmIHNlYXJjaCA9PSAnYXBwbGllZCcpIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRhLnB1c2goIGkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdHJldHVybiBhO1xuXHR9O1xuXHRcblx0XG5cdC8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuXHQgKiBSb3dzXG5cdCAqXG5cdCAqIHt9ICAgICAgICAgIC0gbm8gc2VsZWN0b3IgLSB1c2UgYWxsIGF2YWlsYWJsZSByb3dzXG5cdCAqIHtpbnRlZ2VyfSAgIC0gcm93IGFvRGF0YSBpbmRleFxuXHQgKiB7bm9kZX0gICAgICAtIFRSIG5vZGVcblx0ICoge3N0cmluZ30gICAgLSBqUXVlcnkgc2VsZWN0b3IgdG8gYXBwbHkgdG8gdGhlIFRSIGVsZW1lbnRzXG5cdCAqIHthcnJheX0gICAgIC0galF1ZXJ5IGFycmF5IG9mIG5vZGVzLCBvciBzaW1wbHkgYW4gYXJyYXkgb2YgVFIgbm9kZXNcblx0ICpcblx0ICovXG5cdFxuXHRcblx0dmFyIF9fcm93X3NlbGVjdG9yID0gZnVuY3Rpb24gKCBzZXR0aW5ncywgc2VsZWN0b3IsIG9wdHMgKVxuXHR7XG5cdFx0dmFyIHJ1biA9IGZ1bmN0aW9uICggc2VsICkge1xuXHRcdFx0dmFyIHNlbEludCA9IF9pbnRWYWwoIHNlbCApO1xuXHRcdFx0dmFyIGksIGllbjtcblx0XG5cdFx0XHQvLyBTaG9ydCBjdXQgLSBzZWxlY3RvciBpcyBhIG51bWJlciBhbmQgbm8gb3B0aW9ucyBwcm92aWRlZCAoZGVmYXVsdCBpc1xuXHRcdFx0Ly8gYWxsIHJlY29yZHMsIHNvIG5vIG5lZWQgdG8gY2hlY2sgaWYgdGhlIGluZGV4IGlzIGluIHRoZXJlLCBzaW5jZSBpdFxuXHRcdFx0Ly8gbXVzdCBiZSAtIGRldiBlcnJvciBpZiB0aGUgaW5kZXggZG9lc24ndCBleGlzdCkuXG5cdFx0XHRpZiAoIHNlbEludCAhPT0gbnVsbCAmJiAhIG9wdHMgKSB7XG5cdFx0XHRcdHJldHVybiBbIHNlbEludCBdO1xuXHRcdFx0fVxuXHRcblx0XHRcdHZhciByb3dzID0gX3NlbGVjdG9yX3Jvd19pbmRleGVzKCBzZXR0aW5ncywgb3B0cyApO1xuXHRcblx0XHRcdGlmICggc2VsSW50ICE9PSBudWxsICYmICQuaW5BcnJheSggc2VsSW50LCByb3dzICkgIT09IC0xICkge1xuXHRcdFx0XHQvLyBTZWxlY3RvciAtIGludGVnZXJcblx0XHRcdFx0cmV0dXJuIFsgc2VsSW50IF07XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggISBzZWwgKSB7XG5cdFx0XHRcdC8vIFNlbGVjdG9yIC0gbm9uZVxuXHRcdFx0XHRyZXR1cm4gcm93cztcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBTZWxlY3RvciAtIGZ1bmN0aW9uXG5cdFx0XHRpZiAoIHR5cGVvZiBzZWwgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdHJldHVybiAkLm1hcCggcm93cywgZnVuY3Rpb24gKGlkeCkge1xuXHRcdFx0XHRcdHZhciByb3cgPSBzZXR0aW5ncy5hb0RhdGFbIGlkeCBdO1xuXHRcdFx0XHRcdHJldHVybiBzZWwoIGlkeCwgcm93Ll9hRGF0YSwgcm93Lm5UciApID8gaWR4IDogbnVsbDtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIEdldCBub2RlcyBpbiB0aGUgb3JkZXIgZnJvbSB0aGUgYHJvd3NgIGFycmF5IHdpdGggbnVsbCB2YWx1ZXMgcmVtb3ZlZFxuXHRcdFx0dmFyIG5vZGVzID0gX3JlbW92ZUVtcHR5KFxuXHRcdFx0XHRfcGx1Y2tfb3JkZXIoIHNldHRpbmdzLmFvRGF0YSwgcm93cywgJ25UcicgKVxuXHRcdFx0KTtcblx0XG5cdFx0XHQvLyBTZWxlY3RvciAtIG5vZGVcblx0XHRcdGlmICggc2VsLm5vZGVOYW1lICkge1xuXHRcdFx0XHRpZiAoICQuaW5BcnJheSggc2VsLCBub2RlcyApICE9PSAtMSApIHtcblx0XHRcdFx0XHRyZXR1cm4gWyBzZWwuX0RUX1Jvd0luZGV4IF07IC8vIHNlbCBpcyBhIFRSIG5vZGUgdGhhdCBpcyBpbiB0aGUgdGFibGVcblx0XHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBEYXRhVGFibGVzIGFkZHMgYSBwcm9wIGZvciBmYXN0IGxvb2t1cFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gU2VsZWN0b3IgLSBqUXVlcnkgc2VsZWN0b3Igc3RyaW5nLCBhcnJheSBvZiBub2RlcyBvciBqUXVlcnkgb2JqZWN0L1xuXHRcdFx0Ly8gQXMgalF1ZXJ5J3MgLmZpbHRlcigpIGFsbG93cyBqUXVlcnkgb2JqZWN0cyB0byBiZSBwYXNzZWQgaW4gZmlsdGVyLFxuXHRcdFx0Ly8gaXQgYWxzbyBhbGxvd3MgYXJyYXlzLCBzbyB0aGlzIHdpbGwgY29wZSB3aXRoIGFsbCB0aHJlZSBvcHRpb25zXG5cdFx0XHRyZXR1cm4gJChub2Rlcylcblx0XHRcdFx0LmZpbHRlciggc2VsIClcblx0XHRcdFx0Lm1hcCggZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLl9EVF9Sb3dJbmRleDtcblx0XHRcdFx0fSApXG5cdFx0XHRcdC50b0FycmF5KCk7XG5cdFx0fTtcblx0XG5cdFx0cmV0dXJuIF9zZWxlY3Rvcl9ydW4oICdyb3cnLCBzZWxlY3RvciwgcnVuLCBzZXR0aW5ncywgb3B0cyApO1xuXHR9O1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdyb3dzKCknLCBmdW5jdGlvbiAoIHNlbGVjdG9yLCBvcHRzICkge1xuXHRcdC8vIGFyZ3VtZW50IHNoaWZ0aW5nXG5cdFx0aWYgKCBzZWxlY3RvciA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0c2VsZWN0b3IgPSAnJztcblx0XHR9XG5cdFx0ZWxzZSBpZiAoICQuaXNQbGFpbk9iamVjdCggc2VsZWN0b3IgKSApIHtcblx0XHRcdG9wdHMgPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gJyc7XG5cdFx0fVxuXHRcblx0XHRvcHRzID0gX3NlbGVjdG9yX29wdHMoIG9wdHMgKTtcblx0XG5cdFx0dmFyIGluc3QgPSB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdFx0cmV0dXJuIF9fcm93X3NlbGVjdG9yKCBzZXR0aW5ncywgc2VsZWN0b3IsIG9wdHMgKTtcblx0XHR9LCAxICk7XG5cdFxuXHRcdC8vIFdhbnQgYXJndW1lbnQgc2hpZnRpbmcgaGVyZSBhbmQgaW4gX19yb3dfc2VsZWN0b3I/XG5cdFx0aW5zdC5zZWxlY3Rvci5yb3dzID0gc2VsZWN0b3I7XG5cdFx0aW5zdC5zZWxlY3Rvci5vcHRzID0gb3B0cztcblx0XG5cdFx0cmV0dXJuIGluc3Q7XG5cdH0gKTtcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdyb3dzKCkubm9kZXMoKScsIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3JvdycsIGZ1bmN0aW9uICggc2V0dGluZ3MsIHJvdyApIHtcblx0XHRcdHJldHVybiBzZXR0aW5ncy5hb0RhdGFbIHJvdyBdLm5UciB8fCB1bmRlZmluZWQ7XG5cdFx0fSwgMSApO1xuXHR9ICk7XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAncm93cygpLmRhdGEoKScsIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggdHJ1ZSwgJ3Jvd3MnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCByb3dzICkge1xuXHRcdFx0cmV0dXJuIF9wbHVja19vcmRlciggc2V0dGluZ3MuYW9EYXRhLCByb3dzLCAnX2FEYXRhJyApO1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ3Jvd3MoKS5jYWNoZSgpJywgJ3JvdygpLmNhY2hlKCknLCBmdW5jdGlvbiAoIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdyb3cnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCByb3cgKSB7XG5cdFx0XHR2YXIgciA9IHNldHRpbmdzLmFvRGF0YVsgcm93IF07XG5cdFx0XHRyZXR1cm4gdHlwZSA9PT0gJ3NlYXJjaCcgPyByLl9hRmlsdGVyRGF0YSA6IHIuX2FTb3J0RGF0YTtcblx0XHR9LCAxICk7XG5cdH0gKTtcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICdyb3dzKCkuaW52YWxpZGF0ZSgpJywgJ3JvdygpLmludmFsaWRhdGUoKScsIGZ1bmN0aW9uICggc3JjICkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAncm93JywgZnVuY3Rpb24gKCBzZXR0aW5ncywgcm93ICkge1xuXHRcdFx0X2ZuSW52YWxpZGF0ZSggc2V0dGluZ3MsIHJvdywgc3JjICk7XG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRfYXBpX3JlZ2lzdGVyUGx1cmFsKCAncm93cygpLmluZGV4ZXMoKScsICdyb3coKS5pbmRleCgpJywgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAncm93JywgZnVuY3Rpb24gKCBzZXR0aW5ncywgcm93ICkge1xuXHRcdFx0cmV0dXJuIHJvdztcblx0XHR9LCAxICk7XG5cdH0gKTtcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICdyb3dzKCkucmVtb3ZlKCknLCAncm93KCkucmVtb3ZlKCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3JvdycsIGZ1bmN0aW9uICggc2V0dGluZ3MsIHJvdywgdGhhdElkeCApIHtcblx0XHRcdHZhciBkYXRhID0gc2V0dGluZ3MuYW9EYXRhO1xuXHRcblx0XHRcdGRhdGEuc3BsaWNlKCByb3csIDEgKTtcblx0XG5cdFx0XHQvLyBVcGRhdGUgdGhlIF9EVF9Sb3dJbmRleCBwYXJhbWV0ZXIgb24gYWxsIHJvd3MgaW4gdGhlIHRhYmxlXG5cdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49ZGF0YS5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBkYXRhW2ldLm5UciAhPT0gbnVsbCApIHtcblx0XHRcdFx0XHRkYXRhW2ldLm5Uci5fRFRfUm93SW5kZXggPSBpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gUmVtb3ZlIHRoZSB0YXJnZXQgcm93IGZyb20gdGhlIHNlYXJjaCBhcnJheVxuXHRcdFx0dmFyIGRpc3BsYXlJbmRleCA9ICQuaW5BcnJheSggcm93LCBzZXR0aW5ncy5haURpc3BsYXkgKTtcblx0XG5cdFx0XHQvLyBEZWxldGUgZnJvbSB0aGUgZGlzcGxheSBhcnJheXNcblx0XHRcdF9mbkRlbGV0ZUluZGV4KCBzZXR0aW5ncy5haURpc3BsYXlNYXN0ZXIsIHJvdyApO1xuXHRcdFx0X2ZuRGVsZXRlSW5kZXgoIHNldHRpbmdzLmFpRGlzcGxheSwgcm93ICk7XG5cdFx0XHRfZm5EZWxldGVJbmRleCggdGhhdFsgdGhhdElkeCBdLCByb3csIGZhbHNlICk7IC8vIG1haW50YWluIGxvY2FsIGluZGV4ZXNcblx0XG5cdFx0XHQvLyBDaGVjayBmb3IgYW4gJ292ZXJmbG93JyB0aGV5IGNhc2UgZm9yIGRpc3BsYXlpbmcgdGhlIHRhYmxlXG5cdFx0XHRfZm5MZW5ndGhPdmVyZmxvdyggc2V0dGluZ3MgKTtcblx0XHR9ICk7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAncm93cy5hZGQoKScsIGZ1bmN0aW9uICggcm93cyApIHtcblx0XHR2YXIgbmV3Um93cyA9IHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRcdHZhciByb3csIGksIGllbjtcblx0XHRcdFx0dmFyIG91dCA9IFtdO1xuXHRcblx0XHRcdFx0Zm9yICggaT0wLCBpZW49cm93cy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0XHRyb3cgPSByb3dzW2ldO1xuXHRcblx0XHRcdFx0XHRpZiAoIHJvdy5ub2RlTmFtZSAmJiByb3cubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ1RSJyApIHtcblx0XHRcdFx0XHRcdG91dC5wdXNoKCBfZm5BZGRUciggc2V0dGluZ3MsIHJvdyApWzBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0b3V0LnB1c2goIF9mbkFkZERhdGEoIHNldHRpbmdzLCByb3cgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0cmV0dXJuIG91dDtcblx0XHRcdH0sIDEgKTtcblx0XG5cdFx0Ly8gUmV0dXJuIGFuIEFwaS5yb3dzKCkgZXh0ZW5kZWQgaW5zdGFuY2UsIHNvIHJvd3MoKS5ub2RlcygpIGV0YyBjYW4gYmUgdXNlZFxuXHRcdHZhciBtb2RSb3dzID0gdGhpcy5yb3dzKCAtMSApO1xuXHRcdG1vZFJvd3MucG9wKCk7XG5cdFx0bW9kUm93cy5wdXNoLmFwcGx5KCBtb2RSb3dzLCBuZXdSb3dzLnRvQXJyYXkoKSApO1xuXHRcblx0XHRyZXR1cm4gbW9kUm93cztcblx0fSApO1xuXHRcblx0XG5cdFxuXHRcblx0XG5cdC8qKlxuXHQgKlxuXHQgKi9cblx0X2FwaV9yZWdpc3RlciggJ3JvdygpJywgZnVuY3Rpb24gKCBzZWxlY3Rvciwgb3B0cyApIHtcblx0XHRyZXR1cm4gX3NlbGVjdG9yX2ZpcnN0KCB0aGlzLnJvd3MoIHNlbGVjdG9yLCBvcHRzICkgKTtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdyb3coKS5kYXRhKCknLCBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblx0XG5cdFx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQvLyBHZXRcblx0XHRcdHJldHVybiBjdHgubGVuZ3RoICYmIHRoaXMubGVuZ3RoID9cblx0XHRcdFx0Y3R4WzBdLmFvRGF0YVsgdGhpc1swXSBdLl9hRGF0YSA6XG5cdFx0XHRcdHVuZGVmaW5lZDtcblx0XHR9XG5cdFxuXHRcdC8vIFNldFxuXHRcdGN0eFswXS5hb0RhdGFbIHRoaXNbMF0gXS5fYURhdGEgPSBkYXRhO1xuXHRcblx0XHQvLyBBdXRvbWF0aWNhbGx5IGludmFsaWRhdGVcblx0XHRfZm5JbnZhbGlkYXRlKCBjdHhbMF0sIHRoaXNbMF0sICdkYXRhJyApO1xuXHRcblx0XHRyZXR1cm4gdGhpcztcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdyb3coKS5ub2RlKCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblx0XG5cdFx0cmV0dXJuIGN0eC5sZW5ndGggJiYgdGhpcy5sZW5ndGggP1xuXHRcdFx0Y3R4WzBdLmFvRGF0YVsgdGhpc1swXSBdLm5UciB8fCBudWxsIDpcblx0XHRcdG51bGw7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAncm93LmFkZCgpJywgZnVuY3Rpb24gKCByb3cgKSB7XG5cdFx0Ly8gQWxsb3cgYSBqUXVlcnkgb2JqZWN0IHRvIGJlIHBhc3NlZCBpbiAtIG9ubHkgYSBzaW5nbGUgcm93IGlzIGFkZGVkIGZyb21cblx0XHQvLyBpdCB0aG91Z2ggLSB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0XG5cdFx0aWYgKCByb3cgaW5zdGFuY2VvZiAkICYmIHJvdy5sZW5ndGggKSB7XG5cdFx0XHRyb3cgPSByb3dbMF07XG5cdFx0fVxuXHRcblx0XHR2YXIgcm93cyA9IHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRpZiAoIHJvdy5ub2RlTmFtZSAmJiByb3cubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ1RSJyApIHtcblx0XHRcdFx0cmV0dXJuIF9mbkFkZFRyKCBzZXR0aW5ncywgcm93IClbMF07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gX2ZuQWRkRGF0YSggc2V0dGluZ3MsIHJvdyApO1xuXHRcdH0gKTtcblx0XG5cdFx0Ly8gUmV0dXJuIGFuIEFwaS5yb3dzKCkgZXh0ZW5kZWQgaW5zdGFuY2UsIHdpdGggdGhlIG5ld2x5IGFkZGVkIHJvdyBzZWxlY3RlZFxuXHRcdHJldHVybiB0aGlzLnJvdyggcm93c1swXSApO1xuXHR9ICk7XG5cdFxuXHRcblx0XG5cdHZhciBfX2RldGFpbHNfYWRkID0gZnVuY3Rpb24gKCBjdHgsIHJvdywgZGF0YSwga2xhc3MgKVxuXHR7XG5cdFx0Ly8gQ29udmVydCB0byBhcnJheSBvZiBUUiBlbGVtZW50c1xuXHRcdHZhciByb3dzID0gW107XG5cdFx0dmFyIGFkZFJvdyA9IGZ1bmN0aW9uICggciwgayApIHtcblx0XHRcdC8vIFJlY3Vyc2lvbiB0byBhbGxvdyBmb3IgYXJyYXlzIG9mIGpRdWVyeSBvYmplY3RzXG5cdFx0XHRpZiAoICQuaXNBcnJheSggciApIHx8IHIgaW5zdGFuY2VvZiAkICkge1xuXHRcdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49ci5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0XHRhZGRSb3coIHJbaV0sIGsgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gSWYgd2UgZ2V0IGEgVFIgZWxlbWVudCwgdGhlbiBqdXN0IGFkZCBpdCBkaXJlY3RseSAtIHVwIHRvIHRoZSBkZXZcblx0XHRcdC8vIHRvIGFkZCB0aGUgY29ycmVjdCBudW1iZXIgb2YgY29sdW1ucyBldGNcblx0XHRcdGlmICggci5ub2RlTmFtZSAmJiByLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd0cicgKSB7XG5cdFx0XHRcdHJvd3MucHVzaCggciApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdC8vIE90aGVyd2lzZSBjcmVhdGUgYSByb3cgd2l0aCBhIHdyYXBwZXJcblx0XHRcdFx0dmFyIGNyZWF0ZWQgPSAkKCc8dHI+PHRkLz48L3RyPicpLmFkZENsYXNzKCBrICk7XG5cdFx0XHRcdCQoJ3RkJywgY3JlYXRlZClcblx0XHRcdFx0XHQuYWRkQ2xhc3MoIGsgKVxuXHRcdFx0XHRcdC5odG1sKCByIClcblx0XHRcdFx0XHRbMF0uY29sU3BhbiA9IF9mblZpc2JsZUNvbHVtbnMoIGN0eCApO1xuXHRcblx0XHRcdFx0cm93cy5wdXNoKCBjcmVhdGVkWzBdICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XG5cdFx0YWRkUm93KCBkYXRhLCBrbGFzcyApO1xuXHRcblx0XHRpZiAoIHJvdy5fZGV0YWlscyApIHtcblx0XHRcdHJvdy5fZGV0YWlscy5yZW1vdmUoKTtcblx0XHR9XG5cdFxuXHRcdHJvdy5fZGV0YWlscyA9ICQocm93cyk7XG5cdFxuXHRcdC8vIElmIHRoZSBjaGlsZHJlbiB3ZXJlIGFscmVhZHkgc2hvd24sIHRoYXQgc3RhdGUgc2hvdWxkIGJlIHJldGFpbmVkXG5cdFx0aWYgKCByb3cuX2RldGFpbHNTaG93ICkge1xuXHRcdFx0cm93Ll9kZXRhaWxzLmluc2VydEFmdGVyKCByb3cublRyICk7XG5cdFx0fVxuXHR9O1xuXHRcblx0XG5cdHZhciBfX2RldGFpbHNfcmVtb3ZlID0gZnVuY3Rpb24gKCBhcGksIGlkeCApXG5cdHtcblx0XHR2YXIgY3R4ID0gYXBpLmNvbnRleHQ7XG5cdFxuXHRcdGlmICggY3R4Lmxlbmd0aCApIHtcblx0XHRcdHZhciByb3cgPSBjdHhbMF0uYW9EYXRhWyBpZHggIT09IHVuZGVmaW5lZCA/IGlkeCA6IGFwaVswXSBdO1xuXHRcblx0XHRcdGlmICggcm93Ll9kZXRhaWxzICkge1xuXHRcdFx0XHRyb3cuX2RldGFpbHMucmVtb3ZlKCk7XG5cdFxuXHRcdFx0XHRyb3cuX2RldGFpbHNTaG93ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRyb3cuX2RldGFpbHMgPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRcblx0XG5cdHZhciBfX2RldGFpbHNfZGlzcGxheSA9IGZ1bmN0aW9uICggYXBpLCBzaG93ICkge1xuXHRcdHZhciBjdHggPSBhcGkuY29udGV4dDtcblx0XG5cdFx0aWYgKCBjdHgubGVuZ3RoICYmIGFwaS5sZW5ndGggKSB7XG5cdFx0XHR2YXIgcm93ID0gY3R4WzBdLmFvRGF0YVsgYXBpWzBdIF07XG5cdFxuXHRcdFx0aWYgKCByb3cuX2RldGFpbHMgKSB7XG5cdFx0XHRcdHJvdy5fZGV0YWlsc1Nob3cgPSBzaG93O1xuXHRcblx0XHRcdFx0aWYgKCBzaG93ICkge1xuXHRcdFx0XHRcdHJvdy5fZGV0YWlscy5pbnNlcnRBZnRlciggcm93Lm5UciApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHJvdy5fZGV0YWlscy5kZXRhY2goKTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0X19kZXRhaWxzX2V2ZW50cyggY3R4WzBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRcblx0XG5cdHZhciBfX2RldGFpbHNfZXZlbnRzID0gZnVuY3Rpb24gKCBzZXR0aW5ncyApXG5cdHtcblx0XHR2YXIgYXBpID0gbmV3IF9BcGkoIHNldHRpbmdzICk7XG5cdFx0dmFyIG5hbWVzcGFjZSA9ICcuZHQuRFRfZGV0YWlscyc7XG5cdFx0dmFyIGRyYXdFdmVudCA9ICdkcmF3JytuYW1lc3BhY2U7XG5cdFx0dmFyIGNvbHZpc0V2ZW50ID0gJ2NvbHVtbi12aXNpYmlsaXR5JytuYW1lc3BhY2U7XG5cdFx0dmFyIGRlc3Ryb3lFdmVudCA9ICdkZXN0cm95JytuYW1lc3BhY2U7XG5cdFx0dmFyIGRhdGEgPSBzZXR0aW5ncy5hb0RhdGE7XG5cdFxuXHRcdGFwaS5vZmYoIGRyYXdFdmVudCArJyAnKyBjb2x2aXNFdmVudCArJyAnKyBkZXN0cm95RXZlbnQgKTtcblx0XG5cdFx0aWYgKCBfcGx1Y2soIGRhdGEsICdfZGV0YWlscycgKS5sZW5ndGggPiAwICkge1xuXHRcdFx0Ly8gT24gZWFjaCBkcmF3LCBpbnNlcnQgdGhlIHJlcXVpcmVkIGVsZW1lbnRzIGludG8gdGhlIGRvY3VtZW50XG5cdFx0XHRhcGkub24oIGRyYXdFdmVudCwgZnVuY3Rpb24gKCBlLCBjdHggKSB7XG5cdFx0XHRcdGlmICggc2V0dGluZ3MgIT09IGN0eCApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdGFwaS5yb3dzKCB7cGFnZTonY3VycmVudCd9ICkuZXEoMCkuZWFjaCggZnVuY3Rpb24gKGlkeCkge1xuXHRcdFx0XHRcdC8vIEludGVybmFsIGRhdGEgZ3JhYlxuXHRcdFx0XHRcdHZhciByb3cgPSBkYXRhWyBpZHggXTtcblx0XG5cdFx0XHRcdFx0aWYgKCByb3cuX2RldGFpbHNTaG93ICkge1xuXHRcdFx0XHRcdFx0cm93Ll9kZXRhaWxzLmluc2VydEFmdGVyKCByb3cublRyICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9ICk7XG5cdFxuXHRcdFx0Ly8gQ29sdW1uIHZpc2liaWxpdHkgY2hhbmdlIC0gdXBkYXRlIHRoZSBjb2xzcGFuXG5cdFx0XHRhcGkub24oIGNvbHZpc0V2ZW50LCBmdW5jdGlvbiAoIGUsIGN0eCwgaWR4LCB2aXMgKSB7XG5cdFx0XHRcdGlmICggc2V0dGluZ3MgIT09IGN0eCApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdC8vIFVwZGF0ZSB0aGUgY29sc3BhbiBmb3IgdGhlIGRldGFpbHMgcm93cyAobm90ZSwgb25seSBpZiBpdCBhbHJlYWR5IGhhc1xuXHRcdFx0XHQvLyBhIGNvbHNwYW4pXG5cdFx0XHRcdHZhciByb3csIHZpc2libGUgPSBfZm5WaXNibGVDb2x1bW5zKCBjdHggKTtcblx0XG5cdFx0XHRcdGZvciAoIHZhciBpPTAsIGllbj1kYXRhLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRcdHJvdyA9IGRhdGFbaV07XG5cdFxuXHRcdFx0XHRcdGlmICggcm93Ll9kZXRhaWxzICkge1xuXHRcdFx0XHRcdFx0cm93Ll9kZXRhaWxzLmNoaWxkcmVuKCd0ZFtjb2xzcGFuXScpLmF0dHIoJ2NvbHNwYW4nLCB2aXNpYmxlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFxuXHRcdFx0Ly8gVGFibGUgZGVzdHJveWVkIC0gbnVrZSBhbnkgY2hpbGQgcm93c1xuXHRcdFx0YXBpLm9uKCBkZXN0cm95RXZlbnQsIGZ1bmN0aW9uICggZSwgY3R4ICkge1xuXHRcdFx0XHRpZiAoIHNldHRpbmdzICE9PSBjdHggKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49ZGF0YS5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGFbaV0uX2RldGFpbHMgKSB7XG5cdFx0XHRcdFx0XHRfX2RldGFpbHNfcmVtb3ZlKCBhcGksIGkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cdH07XG5cdFxuXHQvLyBTdHJpbmdzIGZvciB0aGUgbWV0aG9kIG5hbWVzIHRvIGhlbHAgbWluaWZpY2F0aW9uXG5cdHZhciBfZW1wID0gJyc7XG5cdHZhciBfY2hpbGRfb2JqID0gX2VtcCsncm93KCkuY2hpbGQnO1xuXHR2YXIgX2NoaWxkX210aCA9IF9jaGlsZF9vYmorJygpJztcblx0XG5cdC8vIGRhdGEgY2FuIGJlOlxuXHQvLyAgdHJcblx0Ly8gIHN0cmluZ1xuXHQvLyAgalF1ZXJ5IG9yIGFycmF5IG9mIGFueSBvZiB0aGUgYWJvdmVcblx0X2FwaV9yZWdpc3RlciggX2NoaWxkX210aCwgZnVuY3Rpb24gKCBkYXRhLCBrbGFzcyApIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXHRcblx0XHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdC8vIGdldFxuXHRcdFx0cmV0dXJuIGN0eC5sZW5ndGggJiYgdGhpcy5sZW5ndGggP1xuXHRcdFx0XHRjdHhbMF0uYW9EYXRhWyB0aGlzWzBdIF0uX2RldGFpbHMgOlxuXHRcdFx0XHR1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBkYXRhID09PSB0cnVlICkge1xuXHRcdFx0Ly8gc2hvd1xuXHRcdFx0dGhpcy5jaGlsZC5zaG93KCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBkYXRhID09PSBmYWxzZSApIHtcblx0XHRcdC8vIHJlbW92ZVxuXHRcdFx0X19kZXRhaWxzX3JlbW92ZSggdGhpcyApO1xuXHRcdH1cblx0XHRlbHNlIGlmICggY3R4Lmxlbmd0aCAmJiB0aGlzLmxlbmd0aCApIHtcblx0XHRcdC8vIHNldFxuXHRcdFx0X19kZXRhaWxzX2FkZCggY3R4WzBdLCBjdHhbMF0uYW9EYXRhWyB0aGlzWzBdIF0sIGRhdGEsIGtsYXNzICk7XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gdGhpcztcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoIFtcblx0XHRfY2hpbGRfb2JqKycuc2hvdygpJyxcblx0XHRfY2hpbGRfbXRoKycuc2hvdygpJyAvLyBvbmx5IHdoZW4gYGNoaWxkKClgIHdhcyBjYWxsZWQgd2l0aCBwYXJhbWV0ZXJzICh3aXRob3V0XG5cdF0sIGZ1bmN0aW9uICggc2hvdyApIHsgICAvLyBpdCByZXR1cm5zIGFuIG9iamVjdCBhbmQgdGhpcyBtZXRob2QgaXMgbm90IGV4ZWN1dGVkKVxuXHRcdF9fZGV0YWlsc19kaXNwbGF5KCB0aGlzLCB0cnVlICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCBbXG5cdFx0X2NoaWxkX29iaisnLmhpZGUoKScsXG5cdFx0X2NoaWxkX210aCsnLmhpZGUoKScgLy8gb25seSB3aGVuIGBjaGlsZCgpYCB3YXMgY2FsbGVkIHdpdGggcGFyYW1ldGVycyAod2l0aG91dFxuXHRdLCBmdW5jdGlvbiAoKSB7ICAgICAgICAgLy8gaXQgcmV0dXJucyBhbiBvYmplY3QgYW5kIHRoaXMgbWV0aG9kIGlzIG5vdCBleGVjdXRlZClcblx0XHRfX2RldGFpbHNfZGlzcGxheSggdGhpcywgZmFsc2UgKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoIFtcblx0XHRfY2hpbGRfb2JqKycucmVtb3ZlKCknLFxuXHRcdF9jaGlsZF9tdGgrJy5yZW1vdmUoKScgLy8gb25seSB3aGVuIGBjaGlsZCgpYCB3YXMgY2FsbGVkIHdpdGggcGFyYW1ldGVycyAod2l0aG91dFxuXHRdLCBmdW5jdGlvbiAoKSB7ICAgICAgICAgICAvLyBpdCByZXR1cm5zIGFuIG9iamVjdCBhbmQgdGhpcyBtZXRob2QgaXMgbm90IGV4ZWN1dGVkKVxuXHRcdF9fZGV0YWlsc19yZW1vdmUoIHRoaXMgKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoIF9jaGlsZF9vYmorJy5pc1Nob3duKCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblx0XG5cdFx0aWYgKCBjdHgubGVuZ3RoICYmIHRoaXMubGVuZ3RoICkge1xuXHRcdFx0Ly8gX2RldGFpbHNTaG93biBhcyBmYWxzZSBvciB1bmRlZmluZWQgd2lsbCBmYWxsIHRocm91Z2ggdG8gcmV0dXJuIGZhbHNlXG5cdFx0XHRyZXR1cm4gY3R4WzBdLmFvRGF0YVsgdGhpc1swXSBdLl9kZXRhaWxzU2hvdyB8fCBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9ICk7XG5cdFxuXHRcblx0XG5cdC8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuXHQgKiBDb2x1bW5zXG5cdCAqXG5cdCAqIHtpbnRlZ2VyfSAgICAgICAgICAgLSBjb2x1bW4gaW5kZXggKD49MCBjb3VudCBmcm9tIGxlZnQsIDwwIGNvdW50IGZyb20gcmlnaHQpXG5cdCAqIFwie2ludGVnZXJ9OnZpc0lkeFwiICAtIHZpc2libGUgY29sdW1uIGluZGV4IChpLmUuIHRyYW5zbGF0ZSB0byBjb2x1bW4gaW5kZXgpICAoPj0wIGNvdW50IGZyb20gbGVmdCwgPDAgY291bnQgZnJvbSByaWdodClcblx0ICogXCJ7aW50ZWdlcn06dmlzaWJsZVwiIC0gYWxpYXMgZm9yIHtpbnRlZ2VyfTp2aXNJZHggICg+PTAgY291bnQgZnJvbSBsZWZ0LCA8MCBjb3VudCBmcm9tIHJpZ2h0KVxuXHQgKiBcIntzdHJpbmd9Om5hbWVcIiAgICAgLSBjb2x1bW4gbmFtZVxuXHQgKiBcIntzdHJpbmd9XCIgICAgICAgICAgLSBqUXVlcnkgc2VsZWN0b3Igb24gY29sdW1uIGhlYWRlciBub2Rlc1xuXHQgKlxuXHQgKi9cblx0XG5cdC8vIGNhbiBiZSBhbiBhcnJheSBvZiB0aGVzZSBpdGVtcywgY29tbWEgc2VwYXJhdGVkIGxpc3QsIG9yIGFuIGFycmF5IG9mIGNvbW1hXG5cdC8vIHNlcGFyYXRlZCBsaXN0c1xuXHRcblx0dmFyIF9fcmVfY29sdW1uX3NlbGVjdG9yID0gL14oLispOihuYW1lfHZpc0lkeHx2aXNpYmxlKSQvO1xuXHRcblx0XG5cdC8vIHIxIGFuZCByMiBhcmUgcmVkdW5kYW50IC0gYnV0IGl0IG1lYW5zIHRoYXQgdGhlIHBhcmFtZXRlcnMgbWF0Y2ggZm9yIHRoZVxuXHQvLyBpdGVyYXRvciBjYWxsYmFjayBpbiBjb2x1bW5zKCkuZGF0YSgpXG5cdHZhciBfX2NvbHVtbkRhdGEgPSBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4sIHIxLCByMiwgcm93cyApIHtcblx0XHR2YXIgYSA9IFtdO1xuXHRcdGZvciAoIHZhciByb3c9MCwgaWVuPXJvd3MubGVuZ3RoIDsgcm93PGllbiA7IHJvdysrICkge1xuXHRcdFx0YS5wdXNoKCBfZm5HZXRDZWxsRGF0YSggc2V0dGluZ3MsIHJvd3Nbcm93XSwgY29sdW1uICkgKTtcblx0XHR9XG5cdFx0cmV0dXJuIGE7XG5cdH07XG5cdFxuXHRcblx0dmFyIF9fY29sdW1uX3NlbGVjdG9yID0gZnVuY3Rpb24gKCBzZXR0aW5ncywgc2VsZWN0b3IsIG9wdHMgKVxuXHR7XG5cdFx0dmFyXG5cdFx0XHRjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zLFxuXHRcdFx0bmFtZXMgPSBfcGx1Y2soIGNvbHVtbnMsICdzTmFtZScgKSxcblx0XHRcdG5vZGVzID0gX3BsdWNrKCBjb2x1bW5zLCAnblRoJyApO1xuXHRcblx0XHR2YXIgcnVuID0gZnVuY3Rpb24gKCBzICkge1xuXHRcdFx0dmFyIHNlbEludCA9IF9pbnRWYWwoIHMgKTtcblx0XG5cdFx0XHQvLyBTZWxlY3RvciAtIGFsbFxuXHRcdFx0aWYgKCBzID09PSAnJyApIHtcblx0XHRcdFx0cmV0dXJuIF9yYW5nZSggY29sdW1ucy5sZW5ndGggKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gU2VsZWN0b3IgLSBpbmRleFxuXHRcdFx0aWYgKCBzZWxJbnQgIT09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiBbIHNlbEludCA+PSAwID9cblx0XHRcdFx0XHRzZWxJbnQgOiAvLyBDb3VudCBmcm9tIGxlZnRcblx0XHRcdFx0XHRjb2x1bW5zLmxlbmd0aCArIHNlbEludCAvLyBDb3VudCBmcm9tIHJpZ2h0ICgrIGJlY2F1c2UgaXRzIGEgbmVnYXRpdmUgdmFsdWUpXG5cdFx0XHRcdF07XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIFNlbGVjdG9yID0gZnVuY3Rpb25cblx0XHRcdGlmICggdHlwZW9mIHMgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdHZhciByb3dzID0gX3NlbGVjdG9yX3Jvd19pbmRleGVzKCBzZXR0aW5ncywgb3B0cyApO1xuXHRcblx0XHRcdFx0cmV0dXJuICQubWFwKCBjb2x1bW5zLCBmdW5jdGlvbiAoY29sLCBpZHgpIHtcblx0XHRcdFx0XHRyZXR1cm4gcyhcblx0XHRcdFx0XHRcdFx0aWR4LFxuXHRcdFx0XHRcdFx0XHRfX2NvbHVtbkRhdGEoIHNldHRpbmdzLCBpZHgsIDAsIDAsIHJvd3MgKSxcblx0XHRcdFx0XHRcdFx0bm9kZXNbIGlkeCBdXG5cdFx0XHRcdFx0XHQpID8gaWR4IDogbnVsbDtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIGpRdWVyeSBvciBzdHJpbmcgc2VsZWN0b3Jcblx0XHRcdHZhciBtYXRjaCA9IHR5cGVvZiBzID09PSAnc3RyaW5nJyA/XG5cdFx0XHRcdHMubWF0Y2goIF9fcmVfY29sdW1uX3NlbGVjdG9yICkgOlxuXHRcdFx0XHQnJztcblx0XG5cdFx0XHRpZiAoIG1hdGNoICkge1xuXHRcdFx0XHRzd2l0Y2goIG1hdGNoWzJdICkge1xuXHRcdFx0XHRcdGNhc2UgJ3Zpc0lkeCc6XG5cdFx0XHRcdFx0Y2FzZSAndmlzaWJsZSc6XG5cdFx0XHRcdFx0XHR2YXIgaWR4ID0gcGFyc2VJbnQoIG1hdGNoWzFdLCAxMCApO1xuXHRcdFx0XHRcdFx0Ly8gVmlzaWJsZSBpbmRleCBnaXZlbiwgY29udmVydCB0byBjb2x1bW4gaW5kZXhcblx0XHRcdFx0XHRcdGlmICggaWR4IDwgMCApIHtcblx0XHRcdFx0XHRcdFx0Ly8gQ291bnRpbmcgZnJvbSB0aGUgcmlnaHRcblx0XHRcdFx0XHRcdFx0dmFyIHZpc0NvbHVtbnMgPSAkLm1hcCggY29sdW1ucywgZnVuY3Rpb24gKGNvbCxpKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGNvbC5iVmlzaWJsZSA/IGkgOiBudWxsO1xuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBbIHZpc0NvbHVtbnNbIHZpc0NvbHVtbnMubGVuZ3RoICsgaWR4IF0gXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIENvdW50aW5nIGZyb20gdGhlIGxlZnRcblx0XHRcdFx0XHRcdHJldHVybiBbIF9mblZpc2libGVUb0NvbHVtbkluZGV4KCBzZXR0aW5ncywgaWR4ICkgXTtcblx0XG5cdFx0XHRcdFx0Y2FzZSAnbmFtZSc6XG5cdFx0XHRcdFx0XHQvLyBtYXRjaCBieSBuYW1lLiBgbmFtZXNgIGlzIGNvbHVtbiBpbmRleCBjb21wbGV0ZSBhbmQgaW4gb3JkZXJcblx0XHRcdFx0XHRcdHJldHVybiAkLm1hcCggbmFtZXMsIGZ1bmN0aW9uIChuYW1lLCBpKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBuYW1lID09PSBtYXRjaFsxXSA/IGkgOiBudWxsO1xuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Ly8galF1ZXJ5IHNlbGVjdG9yIG9uIHRoZSBUSCBlbGVtZW50cyBmb3IgdGhlIGNvbHVtbnNcblx0XHRcdFx0cmV0dXJuICQoIG5vZGVzIClcblx0XHRcdFx0XHQuZmlsdGVyKCBzIClcblx0XHRcdFx0XHQubWFwKCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gJC5pbkFycmF5KCB0aGlzLCBub2RlcyApOyAvLyBgbm9kZXNgIGlzIGNvbHVtbiBpbmRleCBjb21wbGV0ZSBhbmQgaW4gb3JkZXJcblx0XHRcdFx0XHR9IClcblx0XHRcdFx0XHQudG9BcnJheSgpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFxuXHRcdHJldHVybiBfc2VsZWN0b3JfcnVuKCAnY29sdW1uJywgc2VsZWN0b3IsIHJ1biwgc2V0dGluZ3MsIG9wdHMgKTtcblx0fTtcblx0XG5cdFxuXHR2YXIgX19zZXRDb2x1bW5WaXMgPSBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4sIHZpcywgcmVjYWxjICkge1xuXHRcdHZhclxuXHRcdFx0Y29scyA9IHNldHRpbmdzLmFvQ29sdW1ucyxcblx0XHRcdGNvbCAgPSBjb2xzWyBjb2x1bW4gXSxcblx0XHRcdGRhdGEgPSBzZXR0aW5ncy5hb0RhdGEsXG5cdFx0XHRyb3csIGNlbGxzLCBpLCBpZW4sIHRyO1xuXHRcblx0XHQvLyBHZXRcblx0XHRpZiAoIHZpcyA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuIGNvbC5iVmlzaWJsZTtcblx0XHR9XG5cdFxuXHRcdC8vIFNldFxuXHRcdC8vIE5vIGNoYW5nZVxuXHRcdGlmICggY29sLmJWaXNpYmxlID09PSB2aXMgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcblx0XHRpZiAoIHZpcyApIHtcblx0XHRcdC8vIEluc2VydCBjb2x1bW5cblx0XHRcdC8vIE5lZWQgdG8gZGVjaWRlIGlmIHdlIHNob3VsZCB1c2UgYXBwZW5kQ2hpbGQgb3IgaW5zZXJ0QmVmb3JlXG5cdFx0XHR2YXIgaW5zZXJ0QmVmb3JlID0gJC5pbkFycmF5KCB0cnVlLCBfcGx1Y2soY29scywgJ2JWaXNpYmxlJyksIGNvbHVtbisxICk7XG5cdFxuXHRcdFx0Zm9yICggaT0wLCBpZW49ZGF0YS5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0dHIgPSBkYXRhW2ldLm5Ucjtcblx0XHRcdFx0Y2VsbHMgPSBkYXRhW2ldLmFuQ2VsbHM7XG5cdFxuXHRcdFx0XHRpZiAoIHRyICkge1xuXHRcdFx0XHRcdC8vIGluc2VydEJlZm9yZSBjYW4gYWN0IGxpa2UgYXBwZW5kQ2hpbGQgaWYgMm5kIGFyZyBpcyBudWxsXG5cdFx0XHRcdFx0dHIuaW5zZXJ0QmVmb3JlKCBjZWxsc1sgY29sdW1uIF0sIGNlbGxzWyBpbnNlcnRCZWZvcmUgXSB8fCBudWxsICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBSZW1vdmUgY29sdW1uXG5cdFx0XHQkKCBfcGx1Y2soIHNldHRpbmdzLmFvRGF0YSwgJ2FuQ2VsbHMnLCBjb2x1bW4gKSApLmRldGFjaCgpO1xuXHRcdH1cblx0XG5cdFx0Ly8gQ29tbW9uIGFjdGlvbnNcblx0XHRjb2wuYlZpc2libGUgPSB2aXM7XG5cdFx0X2ZuRHJhd0hlYWQoIHNldHRpbmdzLCBzZXR0aW5ncy5hb0hlYWRlciApO1xuXHRcdF9mbkRyYXdIZWFkKCBzZXR0aW5ncywgc2V0dGluZ3MuYW9Gb290ZXIgKTtcblx0XG5cdFx0aWYgKCByZWNhbGMgPT09IHVuZGVmaW5lZCB8fCByZWNhbGMgKSB7XG5cdFx0XHQvLyBBdXRvbWF0aWNhbGx5IGFkanVzdCBjb2x1bW4gc2l6aW5nXG5cdFx0XHRfZm5BZGp1c3RDb2x1bW5TaXppbmcoIHNldHRpbmdzICk7XG5cdFxuXHRcdFx0Ly8gUmVhbGlnbiBjb2x1bW5zIGZvciBzY3JvbGxpbmdcblx0XHRcdGlmICggc2V0dGluZ3Mub1Njcm9sbC5zWCB8fCBzZXR0aW5ncy5vU2Nyb2xsLnNZICkge1xuXHRcdFx0XHRfZm5TY3JvbGxEcmF3KCBzZXR0aW5ncyApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0X2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgbnVsbCwgJ2NvbHVtbi12aXNpYmlsaXR5JywgW3NldHRpbmdzLCBjb2x1bW4sIHZpc10gKTtcblx0XG5cdFx0X2ZuU2F2ZVN0YXRlKCBzZXR0aW5ncyApO1xuXHR9O1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdjb2x1bW5zKCknLCBmdW5jdGlvbiAoIHNlbGVjdG9yLCBvcHRzICkge1xuXHRcdC8vIGFyZ3VtZW50IHNoaWZ0aW5nXG5cdFx0aWYgKCBzZWxlY3RvciA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0c2VsZWN0b3IgPSAnJztcblx0XHR9XG5cdFx0ZWxzZSBpZiAoICQuaXNQbGFpbk9iamVjdCggc2VsZWN0b3IgKSApIHtcblx0XHRcdG9wdHMgPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gJyc7XG5cdFx0fVxuXHRcblx0XHRvcHRzID0gX3NlbGVjdG9yX29wdHMoIG9wdHMgKTtcblx0XG5cdFx0dmFyIGluc3QgPSB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdFx0cmV0dXJuIF9fY29sdW1uX3NlbGVjdG9yKCBzZXR0aW5ncywgc2VsZWN0b3IsIG9wdHMgKTtcblx0XHR9LCAxICk7XG5cdFxuXHRcdC8vIFdhbnQgYXJndW1lbnQgc2hpZnRpbmcgaGVyZSBhbmQgaW4gX3Jvd19zZWxlY3Rvcj9cblx0XHRpbnN0LnNlbGVjdG9yLmNvbHMgPSBzZWxlY3Rvcjtcblx0XHRpbnN0LnNlbGVjdG9yLm9wdHMgPSBvcHRzO1xuXHRcblx0XHRyZXR1cm4gaW5zdDtcblx0fSApO1xuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ2NvbHVtbnMoKS5oZWFkZXIoKScsICdjb2x1bW4oKS5oZWFkZXIoKScsIGZ1bmN0aW9uICggc2VsZWN0b3IsIG9wdHMgKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjb2x1bW4nLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4gKSB7XG5cdFx0XHRyZXR1cm4gc2V0dGluZ3MuYW9Db2x1bW5zW2NvbHVtbl0ublRoO1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ2NvbHVtbnMoKS5mb290ZXIoKScsICdjb2x1bW4oKS5mb290ZXIoKScsIGZ1bmN0aW9uICggc2VsZWN0b3IsIG9wdHMgKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjb2x1bW4nLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4gKSB7XG5cdFx0XHRyZXR1cm4gc2V0dGluZ3MuYW9Db2x1bW5zW2NvbHVtbl0ublRmO1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ2NvbHVtbnMoKS5kYXRhKCknLCAnY29sdW1uKCkuZGF0YSgpJywgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY29sdW1uLXJvd3MnLCBfX2NvbHVtbkRhdGEsIDEgKTtcblx0fSApO1xuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ2NvbHVtbnMoKS5kYXRhU3JjKCknLCAnY29sdW1uKCkuZGF0YVNyYygpJywgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY29sdW1uJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgY29sdW1uICkge1xuXHRcdFx0cmV0dXJuIHNldHRpbmdzLmFvQ29sdW1uc1tjb2x1bW5dLm1EYXRhO1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ2NvbHVtbnMoKS5jYWNoZSgpJywgJ2NvbHVtbigpLmNhY2hlKCknLCBmdW5jdGlvbiAoIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjb2x1bW4tcm93cycsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGNvbHVtbiwgaSwgaiwgcm93cyApIHtcblx0XHRcdHJldHVybiBfcGx1Y2tfb3JkZXIoIHNldHRpbmdzLmFvRGF0YSwgcm93cyxcblx0XHRcdFx0dHlwZSA9PT0gJ3NlYXJjaCcgPyAnX2FGaWx0ZXJEYXRhJyA6ICdfYVNvcnREYXRhJywgY29sdW1uXG5cdFx0XHQpO1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ2NvbHVtbnMoKS5ub2RlcygpJywgJ2NvbHVtbigpLm5vZGVzKCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjb2x1bW4tcm93cycsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGNvbHVtbiwgaSwgaiwgcm93cyApIHtcblx0XHRcdHJldHVybiBfcGx1Y2tfb3JkZXIoIHNldHRpbmdzLmFvRGF0YSwgcm93cywgJ2FuQ2VsbHMnLCBjb2x1bW4gKSA7XG5cdFx0fSwgMSApO1xuXHR9ICk7XG5cdFxuXHRfYXBpX3JlZ2lzdGVyUGx1cmFsKCAnY29sdW1ucygpLnZpc2libGUoKScsICdjb2x1bW4oKS52aXNpYmxlKCknLCBmdW5jdGlvbiAoIHZpcywgY2FsYyApIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NvbHVtbicsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGNvbHVtbiApIHtcblx0XHRcdGlmICggdmlzID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiBzZXR0aW5ncy5hb0NvbHVtbnNbIGNvbHVtbiBdLmJWaXNpYmxlO1xuXHRcdFx0fSAvLyBlbHNlXG5cdFx0XHRfX3NldENvbHVtblZpcyggc2V0dGluZ3MsIGNvbHVtbiwgdmlzLCBjYWxjICk7XG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRfYXBpX3JlZ2lzdGVyUGx1cmFsKCAnY29sdW1ucygpLmluZGV4ZXMoKScsICdjb2x1bW4oKS5pbmRleCgpJywgZnVuY3Rpb24gKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY29sdW1uJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgY29sdW1uICkge1xuXHRcdFx0cmV0dXJuIHR5cGUgPT09ICd2aXNpYmxlJyA/XG5cdFx0XHRcdF9mbkNvbHVtbkluZGV4VG9WaXNpYmxlKCBzZXR0aW5ncywgY29sdW1uICkgOlxuXHRcdFx0XHRjb2x1bW47XG5cdFx0fSwgMSApO1xuXHR9ICk7XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAnY29sdW1ucy5hZGp1c3QoKScsIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdF9mbkFkanVzdENvbHVtblNpemluZyggc2V0dGluZ3MgKTtcblx0XHR9LCAxICk7XG5cdH0gKTtcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdjb2x1bW4uaW5kZXgoKScsIGZ1bmN0aW9uICggdHlwZSwgaWR4ICkge1xuXHRcdGlmICggdGhpcy5jb250ZXh0Lmxlbmd0aCAhPT0gMCApIHtcblx0XHRcdHZhciBjdHggPSB0aGlzLmNvbnRleHRbMF07XG5cdFxuXHRcdFx0aWYgKCB0eXBlID09PSAnZnJvbVZpc2libGUnIHx8IHR5cGUgPT09ICd0b0RhdGEnICkge1xuXHRcdFx0XHRyZXR1cm4gX2ZuVmlzaWJsZVRvQ29sdW1uSW5kZXgoIGN0eCwgaWR4ICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggdHlwZSA9PT0gJ2Zyb21EYXRhJyB8fCB0eXBlID09PSAndG9WaXNpYmxlJyApIHtcblx0XHRcdFx0cmV0dXJuIF9mbkNvbHVtbkluZGV4VG9WaXNpYmxlKCBjdHgsIGlkeCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSApO1xuXHRcblx0X2FwaV9yZWdpc3RlciggJ2NvbHVtbigpJywgZnVuY3Rpb24gKCBzZWxlY3Rvciwgb3B0cyApIHtcblx0XHRyZXR1cm4gX3NlbGVjdG9yX2ZpcnN0KCB0aGlzLmNvbHVtbnMoIHNlbGVjdG9yLCBvcHRzICkgKTtcblx0fSApO1xuXHRcblx0XG5cdFxuXHRcblx0dmFyIF9fY2VsbF9zZWxlY3RvciA9IGZ1bmN0aW9uICggc2V0dGluZ3MsIHNlbGVjdG9yLCBvcHRzIClcblx0e1xuXHRcdHZhciBkYXRhID0gc2V0dGluZ3MuYW9EYXRhO1xuXHRcdHZhciByb3dzID0gX3NlbGVjdG9yX3Jvd19pbmRleGVzKCBzZXR0aW5ncywgb3B0cyApO1xuXHRcdHZhciBjZWxscyA9IF9yZW1vdmVFbXB0eSggX3BsdWNrX29yZGVyKCBkYXRhLCByb3dzLCAnYW5DZWxscycgKSApO1xuXHRcdHZhciBhbGxDZWxscyA9ICQoIFtdLmNvbmNhdC5hcHBseShbXSwgY2VsbHMpICk7XG5cdFx0dmFyIHJvdztcblx0XHR2YXIgY29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucy5sZW5ndGg7XG5cdFx0dmFyIGEsIGksIGllbiwgaiwgbywgaG9zdDtcblx0XG5cdFx0dmFyIHJ1biA9IGZ1bmN0aW9uICggcyApIHtcblx0XHRcdHZhciBmblNlbGVjdG9yID0gdHlwZW9mIHMgPT09ICdmdW5jdGlvbic7XG5cdFxuXHRcdFx0aWYgKCBzID09PSBudWxsIHx8IHMgPT09IHVuZGVmaW5lZCB8fCBmblNlbGVjdG9yICkge1xuXHRcdFx0XHQvLyBBbGwgY2VsbHMgYW5kIGZ1bmN0aW9uIHNlbGVjdG9yc1xuXHRcdFx0XHRhID0gW107XG5cdFxuXHRcdFx0XHRmb3IgKCBpPTAsIGllbj1yb3dzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRcdHJvdyA9IHJvd3NbaV07XG5cdFxuXHRcdFx0XHRcdGZvciAoIGo9MCA7IGo8Y29sdW1ucyA7IGorKyApIHtcblx0XHRcdFx0XHRcdG8gPSB7XG5cdFx0XHRcdFx0XHRcdHJvdzogcm93LFxuXHRcdFx0XHRcdFx0XHRjb2x1bW46IGpcblx0XHRcdFx0XHRcdH07XG5cdFxuXHRcdFx0XHRcdFx0aWYgKCBmblNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0XHQvLyBTZWxlY3RvciAtIGZ1bmN0aW9uXG5cdFx0XHRcdFx0XHRcdGhvc3QgPSBzZXR0aW5ncy5hb0RhdGFbIHJvdyBdO1xuXHRcblx0XHRcdFx0XHRcdFx0aWYgKCBzKCBvLCBfZm5HZXRDZWxsRGF0YShzZXR0aW5ncywgcm93LCBqKSwgaG9zdC5hbkNlbGxzID8gaG9zdC5hbkNlbGxzW2pdIDogbnVsbCApICkge1xuXHRcdFx0XHRcdFx0XHRcdGEucHVzaCggbyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gU2VsZWN0b3IgLSBhbGxcblx0XHRcdFx0XHRcdFx0YS5wdXNoKCBvICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRyZXR1cm4gYTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gU2VsZWN0b3IgLSBpbmRleFxuXHRcdFx0aWYgKCAkLmlzUGxhaW5PYmplY3QoIHMgKSApIHtcblx0XHRcdFx0cmV0dXJuIFtzXTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBTZWxlY3RvciAtIGpRdWVyeSBmaWx0ZXJlZCBjZWxsc1xuXHRcdFx0cmV0dXJuIGFsbENlbGxzXG5cdFx0XHRcdC5maWx0ZXIoIHMgKVxuXHRcdFx0XHQubWFwKCBmdW5jdGlvbiAoaSwgZWwpIHtcblx0XHRcdFx0XHRyb3cgPSBlbC5wYXJlbnROb2RlLl9EVF9Sb3dJbmRleDtcblx0XG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdHJvdzogcm93LFxuXHRcdFx0XHRcdFx0Y29sdW1uOiAkLmluQXJyYXkoIGVsLCBkYXRhWyByb3cgXS5hbkNlbGxzIClcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9IClcblx0XHRcdFx0LnRvQXJyYXkoKTtcblx0XHR9O1xuXHRcblx0XHRyZXR1cm4gX3NlbGVjdG9yX3J1biggJ2NlbGwnLCBzZWxlY3RvciwgcnVuLCBzZXR0aW5ncywgb3B0cyApO1xuXHR9O1xuXHRcblx0XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggJ2NlbGxzKCknLCBmdW5jdGlvbiAoIHJvd1NlbGVjdG9yLCBjb2x1bW5TZWxlY3Rvciwgb3B0cyApIHtcblx0XHQvLyBBcmd1bWVudCBzaGlmdGluZ1xuXHRcdGlmICggJC5pc1BsYWluT2JqZWN0KCByb3dTZWxlY3RvciApICkge1xuXHRcdFx0Ly8gSW5kZXhlc1xuXHRcdFx0aWYgKCByb3dTZWxlY3Rvci5yb3cgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0Ly8gU2VsZWN0b3Igb3B0aW9ucyBpbiBmaXJzdCBwYXJhbWV0ZXJcblx0XHRcdFx0b3B0cyA9IHJvd1NlbGVjdG9yO1xuXHRcdFx0XHRyb3dTZWxlY3RvciA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Ly8gQ2VsbCBpbmRleCBvYmplY3RzIGluIGZpcnN0IHBhcmFtZXRlclxuXHRcdFx0XHRvcHRzID0gY29sdW1uU2VsZWN0b3I7XG5cdFx0XHRcdGNvbHVtblNlbGVjdG9yID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCAkLmlzUGxhaW5PYmplY3QoIGNvbHVtblNlbGVjdG9yICkgKSB7XG5cdFx0XHRvcHRzID0gY29sdW1uU2VsZWN0b3I7XG5cdFx0XHRjb2x1bW5TZWxlY3RvciA9IG51bGw7XG5cdFx0fVxuXHRcblx0XHQvLyBDZWxsIHNlbGVjdG9yXG5cdFx0aWYgKCBjb2x1bW5TZWxlY3RvciA9PT0gbnVsbCB8fCBjb2x1bW5TZWxlY3RvciA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRcdHJldHVybiBfX2NlbGxfc2VsZWN0b3IoIHNldHRpbmdzLCByb3dTZWxlY3RvciwgX3NlbGVjdG9yX29wdHMoIG9wdHMgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblx0XG5cdFx0Ly8gUm93ICsgY29sdW1uIHNlbGVjdG9yXG5cdFx0dmFyIGNvbHVtbnMgPSB0aGlzLmNvbHVtbnMoIGNvbHVtblNlbGVjdG9yLCBvcHRzICk7XG5cdFx0dmFyIHJvd3MgPSB0aGlzLnJvd3MoIHJvd1NlbGVjdG9yLCBvcHRzICk7XG5cdFx0dmFyIGEsIGksIGllbiwgaiwgamVuO1xuXHRcblx0XHR2YXIgY2VsbHMgPSB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBpZHggKSB7XG5cdFx0XHRhID0gW107XG5cdFxuXHRcdFx0Zm9yICggaT0wLCBpZW49cm93c1tpZHhdLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRmb3IgKCBqPTAsIGplbj1jb2x1bW5zW2lkeF0ubGVuZ3RoIDsgajxqZW4gOyBqKysgKSB7XG5cdFx0XHRcdFx0YS5wdXNoKCB7XG5cdFx0XHRcdFx0XHRyb3c6ICAgIHJvd3NbaWR4XVtpXSxcblx0XHRcdFx0XHRcdGNvbHVtbjogY29sdW1uc1tpZHhdW2pdXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0cmV0dXJuIGE7XG5cdFx0fSwgMSApO1xuXHRcblx0XHQkLmV4dGVuZCggY2VsbHMuc2VsZWN0b3IsIHtcblx0XHRcdGNvbHM6IGNvbHVtblNlbGVjdG9yLFxuXHRcdFx0cm93czogcm93U2VsZWN0b3IsXG5cdFx0XHRvcHRzOiBvcHRzXG5cdFx0fSApO1xuXHRcblx0XHRyZXR1cm4gY2VsbHM7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyUGx1cmFsKCAnY2VsbHMoKS5ub2RlcygpJywgJ2NlbGwoKS5ub2RlKCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjZWxsJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgcm93LCBjb2x1bW4gKSB7XG5cdFx0XHR2YXIgY2VsbHMgPSBzZXR0aW5ncy5hb0RhdGFbIHJvdyBdLmFuQ2VsbHM7XG5cdFx0XHRyZXR1cm4gY2VsbHMgP1xuXHRcdFx0XHRjZWxsc1sgY29sdW1uIF0gOlxuXHRcdFx0XHR1bmRlZmluZWQ7XG5cdFx0fSwgMSApO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggJ2NlbGxzKCkuZGF0YSgpJywgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY2VsbCcsIGZ1bmN0aW9uICggc2V0dGluZ3MsIHJvdywgY29sdW1uICkge1xuXHRcdFx0cmV0dXJuIF9mbkdldENlbGxEYXRhKCBzZXR0aW5ncywgcm93LCBjb2x1bW4gKTtcblx0XHR9LCAxICk7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyUGx1cmFsKCAnY2VsbHMoKS5jYWNoZSgpJywgJ2NlbGwoKS5jYWNoZSgpJywgZnVuY3Rpb24gKCB0eXBlICkge1xuXHRcdHR5cGUgPSB0eXBlID09PSAnc2VhcmNoJyA/ICdfYUZpbHRlckRhdGEnIDogJ19hU29ydERhdGEnO1xuXHRcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NlbGwnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCByb3csIGNvbHVtbiApIHtcblx0XHRcdHJldHVybiBzZXR0aW5ncy5hb0RhdGFbIHJvdyBdWyB0eXBlIF1bIGNvbHVtbiBdO1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjZWxscygpLnJlbmRlcigpJywgJ2NlbGwoKS5yZW5kZXIoKScsIGZ1bmN0aW9uICggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NlbGwnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCByb3csIGNvbHVtbiApIHtcblx0XHRcdHJldHVybiBfZm5HZXRDZWxsRGF0YSggc2V0dGluZ3MsIHJvdywgY29sdW1uLCB0eXBlICk7XG5cdFx0fSwgMSApO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ2NlbGxzKCkuaW5kZXhlcygpJywgJ2NlbGwoKS5pbmRleCgpJywgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY2VsbCcsIGZ1bmN0aW9uICggc2V0dGluZ3MsIHJvdywgY29sdW1uICkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0cm93OiByb3csXG5cdFx0XHRcdGNvbHVtbjogY29sdW1uLFxuXHRcdFx0XHRjb2x1bW5WaXNpYmxlOiBfZm5Db2x1bW5JbmRleFRvVmlzaWJsZSggc2V0dGluZ3MsIGNvbHVtbiApXG5cdFx0XHR9O1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjZWxscygpLmludmFsaWRhdGUoKScsICdjZWxsKCkuaW52YWxpZGF0ZSgpJywgZnVuY3Rpb24gKCBzcmMgKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjZWxsJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgcm93LCBjb2x1bW4gKSB7XG5cdFx0XHRfZm5JbnZhbGlkYXRlKCBzZXR0aW5ncywgcm93LCBzcmMsIGNvbHVtbiApO1xuXHRcdH0gKTtcblx0fSApO1xuXHRcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAnY2VsbCgpJywgZnVuY3Rpb24gKCByb3dTZWxlY3RvciwgY29sdW1uU2VsZWN0b3IsIG9wdHMgKSB7XG5cdFx0cmV0dXJuIF9zZWxlY3Rvcl9maXJzdCggdGhpcy5jZWxscyggcm93U2VsZWN0b3IsIGNvbHVtblNlbGVjdG9yLCBvcHRzICkgKTtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdjZWxsKCkuZGF0YSgpJywgZnVuY3Rpb24gKCBkYXRhICkge1xuXHRcdHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cdFx0dmFyIGNlbGwgPSB0aGlzWzBdO1xuXHRcblx0XHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdC8vIEdldFxuXHRcdFx0cmV0dXJuIGN0eC5sZW5ndGggJiYgY2VsbC5sZW5ndGggP1xuXHRcdFx0XHRfZm5HZXRDZWxsRGF0YSggY3R4WzBdLCBjZWxsWzBdLnJvdywgY2VsbFswXS5jb2x1bW4gKSA6XG5cdFx0XHRcdHVuZGVmaW5lZDtcblx0XHR9XG5cdFxuXHRcdC8vIFNldFxuXHRcdF9mblNldENlbGxEYXRhKCBjdHhbMF0sIGNlbGxbMF0ucm93LCBjZWxsWzBdLmNvbHVtbiwgZGF0YSApO1xuXHRcdF9mbkludmFsaWRhdGUoIGN0eFswXSwgY2VsbFswXS5yb3csICdkYXRhJywgY2VsbFswXS5jb2x1bW4gKTtcblx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0gKTtcblx0XG5cdFxuXHRcblx0LyoqXG5cdCAqIEdldCBjdXJyZW50IG9yZGVyaW5nIChzb3J0aW5nKSB0aGF0IGhhcyBiZWVuIGFwcGxpZWQgdG8gdGhlIHRhYmxlLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7YXJyYXl9IDJEIGFycmF5IGNvbnRhaW5pbmcgdGhlIHNvcnRpbmcgaW5mb3JtYXRpb24gZm9yIHRoZSBmaXJzdFxuXHQgKiAgIHRhYmxlIGluIHRoZSBjdXJyZW50IGNvbnRleHQuIEVhY2ggZWxlbWVudCBpbiB0aGUgcGFyZW50IGFycmF5IHJlcHJlc2VudHNcblx0ICogICBhIGNvbHVtbiBiZWluZyBzb3J0ZWQgdXBvbiAoaS5lLiBtdWx0aS1zb3J0aW5nIHdpdGggdHdvIGNvbHVtbnMgd291bGQgaGF2ZVxuXHQgKiAgIDIgaW5uZXIgYXJyYXlzKS4gVGhlIGlubmVyIGFycmF5cyBtYXkgaGF2ZSAyIG9yIDMgZWxlbWVudHMuIFRoZSBmaXJzdCBpc1xuXHQgKiAgIHRoZSBjb2x1bW4gaW5kZXggdGhhdCB0aGUgc29ydGluZyBjb25kaXRpb24gYXBwbGllcyB0bywgdGhlIHNlY29uZCBpcyB0aGVcblx0ICogICBkaXJlY3Rpb24gb2YgdGhlIHNvcnQgKGBkZXNjYCBvciBgYXNjYCkgYW5kLCBvcHRpb25hbGx5LCB0aGUgdGhpcmQgaXMgdGhlXG5cdCAqICAgaW5kZXggb2YgdGhlIHNvcnRpbmcgb3JkZXIgZnJvbSB0aGUgYGNvbHVtbi5zb3J0aW5nYCBpbml0aWFsaXNhdGlvbiBhcnJheS5cblx0ICovLyoqXG5cdCAqIFNldCB0aGUgb3JkZXJpbmcgZm9yIHRoZSB0YWJsZS5cblx0ICpcblx0ICogQHBhcmFtIHtpbnRlZ2VyfSBvcmRlciBDb2x1bW4gaW5kZXggdG8gc29ydCB1cG9uLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZGlyZWN0aW9uIERpcmVjdGlvbiBvZiB0aGUgc29ydCB0byBiZSBhcHBsaWVkIChgYXNjYCBvciBgZGVzY2ApXG5cdCAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xuXHQgKi8vKipcblx0ICogU2V0IHRoZSBvcmRlcmluZyBmb3IgdGhlIHRhYmxlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge2FycmF5fSBvcmRlciAxRCBhcnJheSBvZiBzb3J0aW5nIGluZm9ybWF0aW9uIHRvIGJlIGFwcGxpZWQuXG5cdCAqIEBwYXJhbSB7YXJyYXl9IFsuLi5dIE9wdGlvbmFsIGFkZGl0aW9uYWwgc29ydGluZyBjb25kaXRpb25zXG5cdCAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xuXHQgKi8vKipcblx0ICogU2V0IHRoZSBvcmRlcmluZyBmb3IgdGhlIHRhYmxlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge2FycmF5fSBvcmRlciAyRCBhcnJheSBvZiBzb3J0aW5nIGluZm9ybWF0aW9uIHRvIGJlIGFwcGxpZWQuXG5cdCAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xuXHQgKi9cblx0X2FwaV9yZWdpc3RlciggJ29yZGVyKCknLCBmdW5jdGlvbiAoIG9yZGVyLCBkaXIgKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblx0XG5cdFx0aWYgKCBvcmRlciA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Ly8gZ2V0XG5cdFx0XHRyZXR1cm4gY3R4Lmxlbmd0aCAhPT0gMCA/XG5cdFx0XHRcdGN0eFswXS5hYVNvcnRpbmcgOlxuXHRcdFx0XHR1bmRlZmluZWQ7XG5cdFx0fVxuXHRcblx0XHQvLyBzZXRcblx0XHRpZiAoIHR5cGVvZiBvcmRlciA9PT0gJ251bWJlcicgKSB7XG5cdFx0XHQvLyBTaW1wbGUgY29sdW1uIC8gZGlyZWN0aW9uIHBhc3NlZCBpblxuXHRcdFx0b3JkZXIgPSBbIFsgb3JkZXIsIGRpciBdIF07XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCAhICQuaXNBcnJheSggb3JkZXJbMF0gKSApIHtcblx0XHRcdC8vIEFyZ3VtZW50cyBwYXNzZWQgaW4gKGxpc3Qgb2YgMUQgYXJyYXlzKVxuXHRcdFx0b3JkZXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XG5cdFx0fVxuXHRcdC8vIG90aGVyd2lzZSBhIDJEIGFycmF5IHdhcyBwYXNzZWQgaW5cblx0XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRzZXR0aW5ncy5hYVNvcnRpbmcgPSBvcmRlci5zbGljZSgpO1xuXHRcdH0gKTtcblx0fSApO1xuXHRcblx0XG5cdC8qKlxuXHQgKiBBdHRhY2ggYSBzb3J0IGxpc3RlbmVyIHRvIGFuIGVsZW1lbnQgZm9yIGEgZ2l2ZW4gY29sdW1uXG5cdCAqXG5cdCAqIEBwYXJhbSB7bm9kZXxqUXVlcnl8c3RyaW5nfSBub2RlIElkZW50aWZpZXIgZm9yIHRoZSBlbGVtZW50KHMpIHRvIGF0dGFjaCB0aGVcblx0ICogICBsaXN0ZW5lciB0by4gVGhpcyBjYW4gdGFrZSB0aGUgZm9ybSBvZiBhIHNpbmdsZSBET00gbm9kZSwgYSBqUXVlcnlcblx0ICogICBjb2xsZWN0aW9uIG9mIG5vZGVzIG9yIGEgalF1ZXJ5IHNlbGVjdG9yIHdoaWNoIHdpbGwgaWRlbnRpZnkgdGhlIG5vZGUocykuXG5cdCAqIEBwYXJhbSB7aW50ZWdlcn0gY29sdW1uIHRoZSBjb2x1bW4gdGhhdCBhIGNsaWNrIG9uIHRoaXMgbm9kZSB3aWxsIHNvcnQgb25cblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIHNvcnQgaXMgcnVuXG5cdCAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xuXHQgKi9cblx0X2FwaV9yZWdpc3RlciggJ29yZGVyLmxpc3RlbmVyKCknLCBmdW5jdGlvbiAoIG5vZGUsIGNvbHVtbiwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRfZm5Tb3J0QXR0YWNoTGlzdGVuZXIoIHNldHRpbmdzLCBub2RlLCBjb2x1bW4sIGNhbGxiYWNrICk7XG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRcblx0Ly8gT3JkZXIgYnkgdGhlIHNlbGVjdGVkIGNvbHVtbihzKVxuXHRfYXBpX3JlZ2lzdGVyKCBbXG5cdFx0J2NvbHVtbnMoKS5vcmRlcigpJyxcblx0XHQnY29sdW1uKCkub3JkZXIoKSdcblx0XSwgZnVuY3Rpb24gKCBkaXIgKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgaSApIHtcblx0XHRcdHZhciBzb3J0ID0gW107XG5cdFxuXHRcdFx0JC5lYWNoKCB0aGF0W2ldLCBmdW5jdGlvbiAoaiwgY29sKSB7XG5cdFx0XHRcdHNvcnQucHVzaCggWyBjb2wsIGRpciBdICk7XG5cdFx0XHR9ICk7XG5cdFxuXHRcdFx0c2V0dGluZ3MuYWFTb3J0aW5nID0gc29ydDtcblx0XHR9ICk7XG5cdH0gKTtcblx0XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggJ3NlYXJjaCgpJywgZnVuY3Rpb24gKCBpbnB1dCwgcmVnZXgsIHNtYXJ0LCBjYXNlSW5zZW4gKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblx0XG5cdFx0aWYgKCBpbnB1dCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Ly8gZ2V0XG5cdFx0XHRyZXR1cm4gY3R4Lmxlbmd0aCAhPT0gMCA/XG5cdFx0XHRcdGN0eFswXS5vUHJldmlvdXNTZWFyY2guc1NlYXJjaCA6XG5cdFx0XHRcdHVuZGVmaW5lZDtcblx0XHR9XG5cdFxuXHRcdC8vIHNldFxuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdFx0aWYgKCAhIHNldHRpbmdzLm9GZWF0dXJlcy5iRmlsdGVyICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFxuXHRcdFx0X2ZuRmlsdGVyQ29tcGxldGUoIHNldHRpbmdzLCAkLmV4dGVuZCgge30sIHNldHRpbmdzLm9QcmV2aW91c1NlYXJjaCwge1xuXHRcdFx0XHRcInNTZWFyY2hcIjogaW5wdXQrXCJcIixcblx0XHRcdFx0XCJiUmVnZXhcIjogIHJlZ2V4ID09PSBudWxsID8gZmFsc2UgOiByZWdleCxcblx0XHRcdFx0XCJiU21hcnRcIjogIHNtYXJ0ID09PSBudWxsID8gdHJ1ZSAgOiBzbWFydCxcblx0XHRcdFx0XCJiQ2FzZUluc2Vuc2l0aXZlXCI6IGNhc2VJbnNlbiA9PT0gbnVsbCA/IHRydWUgOiBjYXNlSW5zZW5cblx0XHRcdH0gKSwgMSApO1xuXHRcdH0gKTtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoXG5cdFx0J2NvbHVtbnMoKS5zZWFyY2goKScsXG5cdFx0J2NvbHVtbigpLnNlYXJjaCgpJyxcblx0XHRmdW5jdGlvbiAoIGlucHV0LCByZWdleCwgc21hcnQsIGNhc2VJbnNlbiApIHtcblx0XHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY29sdW1uJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgY29sdW1uICkge1xuXHRcdFx0XHR2YXIgcHJlU2VhcmNoID0gc2V0dGluZ3MuYW9QcmVTZWFyY2hDb2xzO1xuXHRcblx0XHRcdFx0aWYgKCBpbnB1dCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdC8vIGdldFxuXHRcdFx0XHRcdHJldHVybiBwcmVTZWFyY2hbIGNvbHVtbiBdLnNTZWFyY2g7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdC8vIHNldFxuXHRcdFx0XHRpZiAoICEgc2V0dGluZ3Mub0ZlYXR1cmVzLmJGaWx0ZXIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHQkLmV4dGVuZCggcHJlU2VhcmNoWyBjb2x1bW4gXSwge1xuXHRcdFx0XHRcdFwic1NlYXJjaFwiOiBpbnB1dCtcIlwiLFxuXHRcdFx0XHRcdFwiYlJlZ2V4XCI6ICByZWdleCA9PT0gbnVsbCA/IGZhbHNlIDogcmVnZXgsXG5cdFx0XHRcdFx0XCJiU21hcnRcIjogIHNtYXJ0ID09PSBudWxsID8gdHJ1ZSAgOiBzbWFydCxcblx0XHRcdFx0XHRcImJDYXNlSW5zZW5zaXRpdmVcIjogY2FzZUluc2VuID09PSBudWxsID8gdHJ1ZSA6IGNhc2VJbnNlblxuXHRcdFx0XHR9ICk7XG5cdFxuXHRcdFx0XHRfZm5GaWx0ZXJDb21wbGV0ZSggc2V0dGluZ3MsIHNldHRpbmdzLm9QcmV2aW91c1NlYXJjaCwgMSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblx0KTtcblx0XG5cdC8qXG5cdCAqIFN0YXRlIEFQSSBtZXRob2RzXG5cdCAqL1xuXHRcblx0X2FwaV9yZWdpc3RlciggJ3N0YXRlKCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29udGV4dC5sZW5ndGggP1xuXHRcdFx0dGhpcy5jb250ZXh0WzBdLm9TYXZlZFN0YXRlIDpcblx0XHRcdG51bGw7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAnc3RhdGUuY2xlYXIoKScsIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdC8vIFNhdmUgYW4gZW1wdHkgb2JqZWN0XG5cdFx0XHRzZXR0aW5ncy5mblN0YXRlU2F2ZUNhbGxiYWNrLmNhbGwoIHNldHRpbmdzLm9JbnN0YW5jZSwgc2V0dGluZ3MsIHt9ICk7XG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggJ3N0YXRlLmxvYWRlZCgpJywgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLmNvbnRleHQubGVuZ3RoID9cblx0XHRcdHRoaXMuY29udGV4dFswXS5vTG9hZGVkU3RhdGUgOlxuXHRcdFx0bnVsbDtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdzdGF0ZS5zYXZlKCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRfZm5TYXZlU3RhdGUoIHNldHRpbmdzICk7XG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRcblx0XG5cdC8qKlxuXHQgKiBQcm92aWRlIGEgY29tbW9uIG1ldGhvZCBmb3IgcGx1Zy1pbnMgdG8gY2hlY2sgdGhlIHZlcnNpb24gb2YgRGF0YVRhYmxlcyBiZWluZ1xuXHQgKiB1c2VkLCBpbiBvcmRlciB0byBlbnN1cmUgY29tcGF0aWJpbGl0eS5cblx0ICpcblx0ICogIEBwYXJhbSB7c3RyaW5nfSB2ZXJzaW9uIFZlcnNpb24gc3RyaW5nIHRvIGNoZWNrIGZvciwgaW4gdGhlIGZvcm1hdCBcIlguWS5aXCIuXG5cdCAqICAgIE5vdGUgdGhhdCB0aGUgZm9ybWF0cyBcIlhcIiBhbmQgXCJYLllcIiBhcmUgYWxzbyBhY2NlcHRhYmxlLlxuXHQgKiAgQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhpcyB2ZXJzaW9uIG9mIERhdGFUYWJsZXMgaXMgZ3JlYXRlciBvciBlcXVhbCB0b1xuXHQgKiAgICB0aGUgcmVxdWlyZWQgdmVyc2lvbiwgb3IgZmFsc2UgaWYgdGhpcyB2ZXJzaW9uIG9mIERhdGFUYWxlcyBpcyBub3Rcblx0ICogICAgc3VpdGFibGVcblx0ICogIEBzdGF0aWNcblx0ICogIEBkdG9wdCBBUEktU3RhdGljXG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICBhbGVydCggJC5mbi5kYXRhVGFibGUudmVyc2lvbkNoZWNrKCAnMS45LjAnICkgKTtcblx0ICovXG5cdERhdGFUYWJsZS52ZXJzaW9uQ2hlY2sgPSBEYXRhVGFibGUuZm5WZXJzaW9uQ2hlY2sgPSBmdW5jdGlvbiggdmVyc2lvbiApXG5cdHtcblx0XHR2YXIgYVRoaXMgPSBEYXRhVGFibGUudmVyc2lvbi5zcGxpdCgnLicpO1xuXHRcdHZhciBhVGhhdCA9IHZlcnNpb24uc3BsaXQoJy4nKTtcblx0XHR2YXIgaVRoaXMsIGlUaGF0O1xuXHRcblx0XHRmb3IgKCB2YXIgaT0wLCBpTGVuPWFUaGF0Lmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApIHtcblx0XHRcdGlUaGlzID0gcGFyc2VJbnQoIGFUaGlzW2ldLCAxMCApIHx8IDA7XG5cdFx0XHRpVGhhdCA9IHBhcnNlSW50KCBhVGhhdFtpXSwgMTAgKSB8fCAwO1xuXHRcblx0XHRcdC8vIFBhcnRzIGFyZSB0aGUgc2FtZSwga2VlcCBjb21wYXJpbmdcblx0XHRcdGlmIChpVGhpcyA9PT0gaVRoYXQpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gUGFydHMgYXJlIGRpZmZlcmVudCwgcmV0dXJuIGltbWVkaWF0ZWx5XG5cdFx0XHRyZXR1cm4gaVRoaXMgPiBpVGhhdDtcblx0XHR9XG5cdFxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHQgKiBDaGVjayBpZiBhIGA8dGFibGU+YCBub2RlIGlzIGEgRGF0YVRhYmxlIHRhYmxlIGFscmVhZHkgb3Igbm90LlxuXHQgKlxuXHQgKiAgQHBhcmFtIHtub2RlfGpxdWVyeXxzdHJpbmd9IHRhYmxlIFRhYmxlIG5vZGUsIGpRdWVyeSBvYmplY3Qgb3IgalF1ZXJ5XG5cdCAqICAgICAgc2VsZWN0b3IgZm9yIHRoZSB0YWJsZSB0byB0ZXN0LiBOb3RlIHRoYXQgaWYgbW9yZSB0aGFuIG1vcmUgdGhhbiBvbmVcblx0ICogICAgICB0YWJsZSBpcyBwYXNzZWQgb24sIG9ubHkgdGhlIGZpcnN0IHdpbGwgYmUgY2hlY2tlZFxuXHQgKiAgQHJldHVybnMge2Jvb2xlYW59IHRydWUgdGhlIHRhYmxlIGdpdmVuIGlzIGEgRGF0YVRhYmxlLCBvciBmYWxzZSBvdGhlcndpc2Vcblx0ICogIEBzdGF0aWNcblx0ICogIEBkdG9wdCBBUEktU3RhdGljXG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICBpZiAoICEgJC5mbi5EYXRhVGFibGUuaXNEYXRhVGFibGUoICcjZXhhbXBsZScgKSApIHtcblx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHQgKiAgICB9XG5cdCAqL1xuXHREYXRhVGFibGUuaXNEYXRhVGFibGUgPSBEYXRhVGFibGUuZm5Jc0RhdGFUYWJsZSA9IGZ1bmN0aW9uICggdGFibGUgKVxuXHR7XG5cdFx0dmFyIHQgPSAkKHRhYmxlKS5nZXQoMCk7XG5cdFx0dmFyIGlzID0gZmFsc2U7XG5cdFxuXHRcdCQuZWFjaCggRGF0YVRhYmxlLnNldHRpbmdzLCBmdW5jdGlvbiAoaSwgbykge1xuXHRcdFx0dmFyIGhlYWQgPSBvLm5TY3JvbGxIZWFkID8gJCgndGFibGUnLCBvLm5TY3JvbGxIZWFkKVswXSA6IG51bGw7XG5cdFx0XHR2YXIgZm9vdCA9IG8ublNjcm9sbEZvb3QgPyAkKCd0YWJsZScsIG8ublNjcm9sbEZvb3QpWzBdIDogbnVsbDtcblx0XG5cdFx0XHRpZiAoIG8ublRhYmxlID09PSB0IHx8IGhlYWQgPT09IHQgfHwgZm9vdCA9PT0gdCApIHtcblx0XHRcdFx0aXMgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XG5cdFx0cmV0dXJuIGlzO1xuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHQgKiBHZXQgYWxsIERhdGFUYWJsZSB0YWJsZXMgdGhhdCBoYXZlIGJlZW4gaW5pdGlhbGlzZWQgLSBvcHRpb25hbGx5IHlvdSBjYW5cblx0ICogc2VsZWN0IHRvIGdldCBvbmx5IGN1cnJlbnRseSB2aXNpYmxlIHRhYmxlcy5cblx0ICpcblx0ICogIEBwYXJhbSB7Ym9vbGVhbn0gW3Zpc2libGU9ZmFsc2VdIEZsYWcgdG8gaW5kaWNhdGUgaWYgeW91IHdhbnQgYWxsIChkZWZhdWx0KVxuXHQgKiAgICBvciB2aXNpYmxlIHRhYmxlcyBvbmx5LlxuXHQgKiAgQHJldHVybnMge2FycmF5fSBBcnJheSBvZiBgdGFibGVgIG5vZGVzIChub3QgRGF0YVRhYmxlIGluc3RhbmNlcykgd2hpY2ggYXJlXG5cdCAqICAgIERhdGFUYWJsZXNcblx0ICogIEBzdGF0aWNcblx0ICogIEBkdG9wdCBBUEktU3RhdGljXG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAkLmVhY2goICQuZm4uZGF0YVRhYmxlLnRhYmxlcyh0cnVlKSwgZnVuY3Rpb24gKCkge1xuXHQgKiAgICAgICQodGFibGUpLkRhdGFUYWJsZSgpLmNvbHVtbnMuYWRqdXN0KCk7XG5cdCAqICAgIH0gKTtcblx0ICovXG5cdERhdGFUYWJsZS50YWJsZXMgPSBEYXRhVGFibGUuZm5UYWJsZXMgPSBmdW5jdGlvbiAoIHZpc2libGUgKVxuXHR7XG5cdFx0cmV0dXJuICQubWFwKCBEYXRhVGFibGUuc2V0dGluZ3MsIGZ1bmN0aW9uIChvKSB7XG5cdFx0XHRpZiAoICF2aXNpYmxlIHx8ICh2aXNpYmxlICYmICQoby5uVGFibGUpLmlzKCc6dmlzaWJsZScpKSApIHtcblx0XHRcdFx0cmV0dXJuIG8ublRhYmxlO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fTtcblx0XG5cdFxuXHQvKipcblx0ICogRGF0YVRhYmxlcyB1dGlsaXR5IG1ldGhvZHNcblx0ICogXG5cdCAqIFRoaXMgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBtZXRob2RzIHRoYXQgRGF0YVRhYmxlcyB1c2VzIGludGVybmFsbHkgdG9cblx0ICogY3JlYXRlIGEgRGF0YVRhYmxlLCBidXQgd2hpY2ggYXJlIG5vdCBleGNsdXNpdmVseSB1c2VkIG9ubHkgZm9yIERhdGFUYWJsZXMuXG5cdCAqIFRoZXNlIG1ldGhvZHMgY2FuIGJlIHVzZWQgYnkgZXh0ZW5zaW9uIGF1dGhvcnMgdG8gc2F2ZSB0aGUgZHVwbGljYXRpb24gb2Zcblx0ICogY29kZS5cblx0ICpcblx0ICogIEBuYW1lc3BhY2Vcblx0ICovXG5cdERhdGFUYWJsZS51dGlsID0ge1xuXHRcdC8qKlxuXHRcdCAqIFRocm90dGxlIHRoZSBjYWxscyB0byBhIGZ1bmN0aW9uLiBBcmd1bWVudHMgYW5kIGNvbnRleHQgYXJlIG1haW50YWluZWRcblx0XHQgKiBmb3IgdGhlIHRocm90dGxlZCBmdW5jdGlvbi5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuXHRcdCAqIEBwYXJhbSB7aW50ZWdlcn0gZnJlcSBDYWxsIGZyZXF1ZW5jeSBpbiBtU1xuXHRcdCAqIEByZXR1cm4ge2Z1bmN0aW9ufSBXcmFwcGVkIGZ1bmN0aW9uXG5cdFx0ICovXG5cdFx0dGhyb3R0bGU6IF9mblRocm90dGxlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRXNjYXBlIGEgc3RyaW5nIHN1Y2ggdGhhdCBpdCBjYW4gYmUgdXNlZCBpbiBhIHJlZ3VsYXIgZXhwcmVzc2lvblxuXHRcdCAqXG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nfSBzVmFsIHN0cmluZyB0byBlc2NhcGVcblx0XHQgKiAgQHJldHVybnMge3N0cmluZ30gZXNjYXBlZCBzdHJpbmdcblx0XHQgKi9cblx0XHRlc2NhcGVSZWdleDogX2ZuRXNjYXBlUmVnZXhcblx0fTtcblx0XG5cdFxuXHQvKipcblx0ICogQ29udmVydCBmcm9tIGNhbWVsIGNhc2UgcGFyYW1ldGVycyB0byBIdW5nYXJpYW4gbm90YXRpb24uIFRoaXMgaXMgbWFkZSBwdWJsaWNcblx0ICogZm9yIHRoZSBleHRlbnNpb25zIHRvIHByb3ZpZGUgdGhlIHNhbWUgYWJpbGl0eSBhcyBEYXRhVGFibGVzIGNvcmUgdG8gYWNjZXB0XG5cdCAqIGVpdGhlciB0aGUgMS45IHN0eWxlIEh1bmdhcmlhbiBub3RhdGlvbiwgb3IgdGhlIDEuMTArIHN0eWxlIGNhbWVsQ2FzZVxuXHQgKiBwYXJhbWV0ZXJzLlxuXHQgKlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNyYyBUaGUgbW9kZWwgb2JqZWN0IHdoaWNoIGhvbGRzIGFsbCBwYXJhbWV0ZXJzIHRoYXQgY2FuIGJlXG5cdCAqICAgIG1hcHBlZC5cblx0ICogIEBwYXJhbSB7b2JqZWN0fSB1c2VyIFRoZSBvYmplY3QgdG8gY29udmVydCBmcm9tIGNhbWVsIGNhc2UgdG8gSHVuZ2FyaWFuLlxuXHQgKiAgQHBhcmFtIHtib29sZWFufSBmb3JjZSBXaGVuIHNldCB0byBgdHJ1ZWAsIHByb3BlcnRpZXMgd2hpY2ggYWxyZWFkeSBoYXZlIGFcblx0ICogICAgSHVuZ2FyaWFuIHZhbHVlIGluIHRoZSBgdXNlcmAgb2JqZWN0IHdpbGwgYmUgb3ZlcndyaXR0ZW4uIE90aGVyd2lzZSB0aGV5XG5cdCAqICAgIHdvbid0IGJlLlxuXHQgKi9cblx0RGF0YVRhYmxlLmNhbWVsVG9IdW5nYXJpYW4gPSBfZm5DYW1lbFRvSHVuZ2FyaWFuO1xuXHRcblx0XG5cdFxuXHQvKipcblx0ICpcblx0ICovXG5cdF9hcGlfcmVnaXN0ZXIoICckKCknLCBmdW5jdGlvbiAoIHNlbGVjdG9yLCBvcHRzICkge1xuXHRcdHZhclxuXHRcdFx0cm93cyAgID0gdGhpcy5yb3dzKCBvcHRzICkubm9kZXMoKSwgLy8gR2V0IGFsbCByb3dzXG5cdFx0XHRqcVJvd3MgPSAkKHJvd3MpO1xuXHRcblx0XHRyZXR1cm4gJCggW10uY29uY2F0KFxuXHRcdFx0anFSb3dzLmZpbHRlciggc2VsZWN0b3IgKS50b0FycmF5KCksXG5cdFx0XHRqcVJvd3MuZmluZCggc2VsZWN0b3IgKS50b0FycmF5KClcblx0XHQpICk7XG5cdH0gKTtcblx0XG5cdFxuXHQvLyBqUXVlcnkgZnVuY3Rpb25zIHRvIG9wZXJhdGUgb24gdGhlIHRhYmxlc1xuXHQkLmVhY2goIFsgJ29uJywgJ29uZScsICdvZmYnIF0sIGZ1bmN0aW9uIChpLCBrZXkpIHtcblx0XHRfYXBpX3JlZ2lzdGVyKCBrZXkrJygpJywgZnVuY3Rpb24gKCAvKiBldmVudCwgaGFuZGxlciAqLyApIHtcblx0XHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0XG5cdFx0XHQvLyBBZGQgdGhlIGBkdGAgbmFtZXNwYWNlIGF1dG9tYXRpY2FsbHkgaWYgaXQgaXNuJ3QgYWxyZWFkeSBwcmVzZW50XG5cdFx0XHRpZiAoICEgYXJnc1swXS5tYXRjaCgvXFwuZHRcXGIvKSApIHtcblx0XHRcdFx0YXJnc1swXSArPSAnLmR0Jztcblx0XHRcdH1cblx0XG5cdFx0XHR2YXIgaW5zdCA9ICQoIHRoaXMudGFibGVzKCkubm9kZXMoKSApO1xuXHRcdFx0aW5zdFtrZXldLmFwcGx5KCBpbnN0LCBhcmdzICk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9ICk7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAnY2xlYXIoKScsIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdF9mbkNsZWFyVGFibGUoIHNldHRpbmdzICk7XG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggJ3NldHRpbmdzKCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIG5ldyBfQXBpKCB0aGlzLmNvbnRleHQsIHRoaXMuY29udGV4dCApO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggJ2luaXQoKScsIGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXHRcdHJldHVybiBjdHgubGVuZ3RoID8gY3R4WzBdLm9Jbml0IDogbnVsbDtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdkYXRhKCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRyZXR1cm4gX3BsdWNrKCBzZXR0aW5ncy5hb0RhdGEsICdfYURhdGEnICk7XG5cdFx0fSApLmZsYXR0ZW4oKTtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdkZXN0cm95KCknLCBmdW5jdGlvbiAoIHJlbW92ZSApIHtcblx0XHRyZW1vdmUgPSByZW1vdmUgfHwgZmFsc2U7XG5cdFxuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdFx0dmFyIG9yaWcgICAgICA9IHNldHRpbmdzLm5UYWJsZVdyYXBwZXIucGFyZW50Tm9kZTtcblx0XHRcdHZhciBjbGFzc2VzICAgPSBzZXR0aW5ncy5vQ2xhc3Nlcztcblx0XHRcdHZhciB0YWJsZSAgICAgPSBzZXR0aW5ncy5uVGFibGU7XG5cdFx0XHR2YXIgdGJvZHkgICAgID0gc2V0dGluZ3MublRCb2R5O1xuXHRcdFx0dmFyIHRoZWFkICAgICA9IHNldHRpbmdzLm5USGVhZDtcblx0XHRcdHZhciB0Zm9vdCAgICAgPSBzZXR0aW5ncy5uVEZvb3Q7XG5cdFx0XHR2YXIganFUYWJsZSAgID0gJCh0YWJsZSk7XG5cdFx0XHR2YXIganFUYm9keSAgID0gJCh0Ym9keSk7XG5cdFx0XHR2YXIganFXcmFwcGVyID0gJChzZXR0aW5ncy5uVGFibGVXcmFwcGVyKTtcblx0XHRcdHZhciByb3dzICAgICAgPSAkLm1hcCggc2V0dGluZ3MuYW9EYXRhLCBmdW5jdGlvbiAocikgeyByZXR1cm4gci5uVHI7IH0gKTtcblx0XHRcdHZhciBpLCBpZW47XG5cdFxuXHRcdFx0Ly8gRmxhZyB0byBub3RlIHRoYXQgdGhlIHRhYmxlIGlzIGN1cnJlbnRseSBiZWluZyBkZXN0cm95ZWQgLSBubyBhY3Rpb25cblx0XHRcdC8vIHNob3VsZCBiZSB0YWtlblxuXHRcdFx0c2V0dGluZ3MuYkRlc3Ryb3lpbmcgPSB0cnVlO1xuXHRcblx0XHRcdC8vIEZpcmUgb2ZmIHRoZSBkZXN0cm95IGNhbGxiYWNrcyBmb3IgcGx1Zy1pbnMgZXRjXG5cdFx0XHRfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCBcImFvRGVzdHJveUNhbGxiYWNrXCIsIFwiZGVzdHJveVwiLCBbc2V0dGluZ3NdICk7XG5cdFxuXHRcdFx0Ly8gSWYgbm90IGJlaW5nIHJlbW92ZWQgZnJvbSB0aGUgZG9jdW1lbnQsIG1ha2UgYWxsIGNvbHVtbnMgdmlzaWJsZVxuXHRcdFx0aWYgKCAhIHJlbW92ZSApIHtcblx0XHRcdFx0bmV3IF9BcGkoIHNldHRpbmdzICkuY29sdW1ucygpLnZpc2libGUoIHRydWUgKTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBCbGl0eiBhbGwgYERUYCBuYW1lc3BhY2VkIGV2ZW50cyAodGhlc2UgYXJlIGludGVybmFsIGV2ZW50cywgdGhlXG5cdFx0XHQvLyBsb3dlcmNhc2UsIGBkdGAgZXZlbnRzIGFyZSB1c2VyIHN1YnNjcmliZWQgYW5kIHRoZXkgYXJlIHJlc3BvbnNpYmxlXG5cdFx0XHQvLyBmb3IgcmVtb3ZpbmcgdGhlbVxuXHRcdFx0anFXcmFwcGVyLnVuYmluZCgnLkRUJykuZmluZCgnOm5vdCh0Ym9keSAqKScpLnVuYmluZCgnLkRUJyk7XG5cdFx0XHQkKHdpbmRvdykudW5iaW5kKCcuRFQtJytzZXR0aW5ncy5zSW5zdGFuY2UpO1xuXHRcblx0XHRcdC8vIFdoZW4gc2Nyb2xsaW5nIHdlIGhhZCB0byBicmVhayB0aGUgdGFibGUgdXAgLSByZXN0b3JlIGl0XG5cdFx0XHRpZiAoIHRhYmxlICE9IHRoZWFkLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGpxVGFibGUuY2hpbGRyZW4oJ3RoZWFkJykuZGV0YWNoKCk7XG5cdFx0XHRcdGpxVGFibGUuYXBwZW5kKCB0aGVhZCApO1xuXHRcdFx0fVxuXHRcblx0XHRcdGlmICggdGZvb3QgJiYgdGFibGUgIT0gdGZvb3QucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0anFUYWJsZS5jaGlsZHJlbigndGZvb3QnKS5kZXRhY2goKTtcblx0XHRcdFx0anFUYWJsZS5hcHBlbmQoIHRmb290ICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gUmVtb3ZlIHRoZSBEYXRhVGFibGVzIGdlbmVyYXRlZCBub2RlcywgZXZlbnRzIGFuZCBjbGFzc2VzXG5cdFx0XHRqcVRhYmxlLmRldGFjaCgpO1xuXHRcdFx0anFXcmFwcGVyLmRldGFjaCgpO1xuXHRcblx0XHRcdHNldHRpbmdzLmFhU29ydGluZyA9IFtdO1xuXHRcdFx0c2V0dGluZ3MuYWFTb3J0aW5nRml4ZWQgPSBbXTtcblx0XHRcdF9mblNvcnRpbmdDbGFzc2VzKCBzZXR0aW5ncyApO1xuXHRcblx0XHRcdCQoIHJvd3MgKS5yZW1vdmVDbGFzcyggc2V0dGluZ3MuYXNTdHJpcGVDbGFzc2VzLmpvaW4oJyAnKSApO1xuXHRcblx0XHRcdCQoJ3RoLCB0ZCcsIHRoZWFkKS5yZW1vdmVDbGFzcyggY2xhc3Nlcy5zU29ydGFibGUrJyAnK1xuXHRcdFx0XHRjbGFzc2VzLnNTb3J0YWJsZUFzYysnICcrY2xhc3Nlcy5zU29ydGFibGVEZXNjKycgJytjbGFzc2VzLnNTb3J0YWJsZU5vbmVcblx0XHRcdCk7XG5cdFxuXHRcdFx0aWYgKCBzZXR0aW5ncy5iSlVJICkge1xuXHRcdFx0XHQkKCd0aCBzcGFuLicrY2xhc3Nlcy5zU29ydEljb24rICcsIHRkIHNwYW4uJytjbGFzc2VzLnNTb3J0SWNvbiwgdGhlYWQpLmRldGFjaCgpO1xuXHRcdFx0XHQkKCd0aCwgdGQnLCB0aGVhZCkuZWFjaCggZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHZhciB3cmFwcGVyID0gJCgnZGl2LicrY2xhc3Nlcy5zU29ydEpVSVdyYXBwZXIsIHRoaXMpO1xuXHRcdFx0XHRcdCQodGhpcykuYXBwZW5kKCB3cmFwcGVyLmNvbnRlbnRzKCkgKTtcblx0XHRcdFx0XHR3cmFwcGVyLmRldGFjaCgpO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0aWYgKCAhIHJlbW92ZSAmJiBvcmlnICkge1xuXHRcdFx0XHQvLyBpbnNlcnRCZWZvcmUgYWN0cyBsaWtlIGFwcGVuZENoaWxkIGlmICFhcmdbMV1cblx0XHRcdFx0b3JpZy5pbnNlcnRCZWZvcmUoIHRhYmxlLCBzZXR0aW5ncy5uVGFibGVSZWluc2VydEJlZm9yZSApO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIEFkZCB0aGUgVFIgZWxlbWVudHMgYmFjayBpbnRvIHRoZSB0YWJsZSBpbiB0aGVpciBvcmlnaW5hbCBvcmRlclxuXHRcdFx0anFUYm9keS5jaGlsZHJlbigpLmRldGFjaCgpO1xuXHRcdFx0anFUYm9keS5hcHBlbmQoIHJvd3MgKTtcblx0XG5cdFx0XHQvLyBSZXN0b3JlIHRoZSB3aWR0aCBvZiB0aGUgb3JpZ2luYWwgdGFibGUgLSB3YXMgcmVhZCBmcm9tIHRoZSBzdHlsZSBwcm9wZXJ0eSxcblx0XHRcdC8vIHNvIHdlIGNhbiByZXN0b3JlIGRpcmVjdGx5IHRvIHRoYXRcblx0XHRcdGpxVGFibGVcblx0XHRcdFx0LmNzcyggJ3dpZHRoJywgc2V0dGluZ3Muc0Rlc3Ryb3lXaWR0aCApXG5cdFx0XHRcdC5yZW1vdmVDbGFzcyggY2xhc3Nlcy5zVGFibGUgKTtcblx0XG5cdFx0XHQvLyBJZiB0aGUgd2VyZSBvcmlnaW5hbGx5IHN0cmlwZSBjbGFzc2VzIC0gdGhlbiB3ZSBhZGQgdGhlbSBiYWNrIGhlcmUuXG5cdFx0XHQvLyBOb3RlIHRoaXMgaXMgbm90IGZvb2wgcHJvb2YgKGZvciBleGFtcGxlIGlmIG5vdCBhbGwgcm93cyBoYWQgc3RyaXBlXG5cdFx0XHQvLyBjbGFzc2VzIC0gYnV0IGl0J3MgYSBnb29kIGVmZm9ydCB3aXRob3V0IGdldHRpbmcgY2FycmllZCBhd2F5XG5cdFx0XHRpZW4gPSBzZXR0aW5ncy5hc0Rlc3Ryb3lTdHJpcGVzLmxlbmd0aDtcblx0XG5cdFx0XHRpZiAoIGllbiApIHtcblx0XHRcdFx0anFUYm9keS5jaGlsZHJlbigpLmVhY2goIGZ1bmN0aW9uIChpKSB7XG5cdFx0XHRcdFx0JCh0aGlzKS5hZGRDbGFzcyggc2V0dGluZ3MuYXNEZXN0cm95U3RyaXBlc1tpICUgaWVuXSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0LyogUmVtb3ZlIHRoZSBzZXR0aW5ncyBvYmplY3QgZnJvbSB0aGUgc2V0dGluZ3MgYXJyYXkgKi9cblx0XHRcdHZhciBpZHggPSAkLmluQXJyYXkoIHNldHRpbmdzLCBEYXRhVGFibGUuc2V0dGluZ3MgKTtcblx0XHRcdGlmICggaWR4ICE9PSAtMSApIHtcblx0XHRcdFx0RGF0YVRhYmxlLnNldHRpbmdzLnNwbGljZSggaWR4LCAxICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRcblx0Ly8gQWRkIHRoZSBgZXZlcnkoKWAgbWV0aG9kIGZvciByb3dzLCBjb2x1bW5zIGFuZCBjZWxscyBpbiBhIGNvbXBhY3QgZm9ybVxuXHQkLmVhY2goIFsgJ2NvbHVtbicsICdyb3cnLCAnY2VsbCcgXSwgZnVuY3Rpb24gKCBpLCB0eXBlICkge1xuXHRcdF9hcGlfcmVnaXN0ZXIoIHR5cGUrJ3MoKS5ldmVyeSgpJywgZnVuY3Rpb24gKCBmbiApIHtcblx0XHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCB0eXBlLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBpZHgsIGlkeDIgKSB7XG5cdFx0XHRcdC8vIGlkeDIgaXMgdW5kZWZpbmVkIGZvciByb3dzIGFuZCBjb2x1bW5zLlxuXHRcdFx0XHRmbi5jYWxsKCBuZXcgX0FwaSggc2V0dGluZ3MgKVsgdHlwZSBdKCBpZHgsIGlkeDIgKSApO1xuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fSApO1xuXHRcblx0XG5cdC8vIGkxOG4gbWV0aG9kIGZvciBleHRlbnNpb25zIHRvIGJlIGFibGUgdG8gdXNlIHRoZSBsYW5ndWFnZSBvYmplY3QgZnJvbSB0aGVcblx0Ly8gRGF0YVRhYmxlXG5cdF9hcGlfcmVnaXN0ZXIoICdpMThuKCknLCBmdW5jdGlvbiAoIHRva2VuLCBkZWYsIHBsdXJhbCApIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0WzBdO1xuXHRcdHZhciByZXNvbHZlZCA9IF9mbkdldE9iamVjdERhdGFGbiggdG9rZW4gKSggY3R4Lm9MYW5ndWFnZSApO1xuXHRcblx0XHRpZiAoIHJlc29sdmVkID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXNvbHZlZCA9IGRlZjtcblx0XHR9XG5cdFxuXHRcdGlmICggcGx1cmFsICE9PSB1bmRlZmluZWQgJiYgJC5pc1BsYWluT2JqZWN0KCByZXNvbHZlZCApICkge1xuXHRcdFx0cmVzb2x2ZWQgPSByZXNvbHZlZFsgcGx1cmFsIF0gIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHJlc29sdmVkWyBwbHVyYWwgXSA6XG5cdFx0XHRcdHJlc29sdmVkLl87XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gcmVzb2x2ZWQucmVwbGFjZSggJyVkJywgcGx1cmFsICk7IC8vIG5iOiBwbHVyYWwgbWlnaHQgYmUgdW5kZWZpbmVkLFxuXHR9ICk7XG5cblx0LyoqXG5cdCAqIFZlcnNpb24gc3RyaW5nIGZvciBwbHVnLWlucyB0byBjaGVjayBjb21wYXRpYmlsaXR5LiBBbGxvd2VkIGZvcm1hdCBpc1xuXHQgKiBgYS5iLmMtZGAgd2hlcmU6IGE6aW50LCBiOmludCwgYzppbnQsIGQ6c3RyaW5nKGRldnxiZXRhfGFscGhhKS4gYGRgIGlzIHVzZWRcblx0ICogb25seSBmb3Igbm9uLXJlbGVhc2UgYnVpbGRzLiBTZWUgaHR0cDovL3NlbXZlci5vcmcvIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiAgQG1lbWJlclxuXHQgKiAgQHR5cGUgc3RyaW5nXG5cdCAqICBAZGVmYXVsdCBWZXJzaW9uIG51bWJlclxuXHQgKi9cblx0RGF0YVRhYmxlLnZlcnNpb24gPSBcIjEuMTAuN1wiO1xuXG5cdC8qKlxuXHQgKiBQcml2YXRlIGRhdGEgc3RvcmUsIGNvbnRhaW5pbmcgYWxsIG9mIHRoZSBzZXR0aW5ncyBvYmplY3RzIHRoYXQgYXJlXG5cdCAqIGNyZWF0ZWQgZm9yIHRoZSB0YWJsZXMgb24gYSBnaXZlbiBwYWdlLlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgdGhlIGBEYXRhVGFibGUuc2V0dGluZ3NgIG9iamVjdCBpcyBhbGlhc2VkIHRvXG5cdCAqIGBqUXVlcnkuZm4uZGF0YVRhYmxlRXh0YCB0aHJvdWdoIHdoaWNoIGl0IG1heSBiZSBhY2Nlc3NlZCBhbmRcblx0ICogbWFuaXB1bGF0ZWQsIG9yIGBqUXVlcnkuZm4uZGF0YVRhYmxlLnNldHRpbmdzYC5cblx0ICogIEBtZW1iZXJcblx0ICogIEB0eXBlIGFycmF5XG5cdCAqICBAZGVmYXVsdCBbXVxuXHQgKiAgQHByaXZhdGVcblx0ICovXG5cdERhdGFUYWJsZS5zZXR0aW5ncyA9IFtdO1xuXG5cdC8qKlxuXHQgKiBPYmplY3QgbW9kZWxzIGNvbnRhaW5lciwgZm9yIHRoZSB2YXJpb3VzIG1vZGVscyB0aGF0IERhdGFUYWJsZXMgaGFzXG5cdCAqIGF2YWlsYWJsZSB0byBpdC4gVGhlc2UgbW9kZWxzIGRlZmluZSB0aGUgb2JqZWN0cyB0aGF0IGFyZSB1c2VkIHRvIGhvbGRcblx0ICogdGhlIGFjdGl2ZSBzdGF0ZSBhbmQgY29uZmlndXJhdGlvbiBvZiB0aGUgdGFibGUuXG5cdCAqICBAbmFtZXNwYWNlXG5cdCAqL1xuXHREYXRhVGFibGUubW9kZWxzID0ge307XG5cdFxuXHRcblx0XG5cdC8qKlxuXHQgKiBUZW1wbGF0ZSBvYmplY3QgZm9yIHRoZSB3YXkgaW4gd2hpY2ggRGF0YVRhYmxlcyBob2xkcyBpbmZvcm1hdGlvbiBhYm91dFxuXHQgKiBzZWFyY2ggaW5mb3JtYXRpb24gZm9yIHRoZSBnbG9iYWwgZmlsdGVyIGFuZCBpbmRpdmlkdWFsIGNvbHVtbiBmaWx0ZXJzLlxuXHQgKiAgQG5hbWVzcGFjZVxuXHQgKi9cblx0RGF0YVRhYmxlLm1vZGVscy5vU2VhcmNoID0ge1xuXHRcdC8qKlxuXHRcdCAqIEZsYWcgdG8gaW5kaWNhdGUgaWYgdGhlIGZpbHRlcmluZyBzaG91bGQgYmUgY2FzZSBpbnNlbnNpdGl2ZSBvciBub3Rcblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0XCJiQ2FzZUluc2Vuc2l0aXZlXCI6IHRydWUsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEFwcGxpZWQgc2VhcmNoIHRlcm1cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IDxpPkVtcHR5IHN0cmluZzwvaT5cblx0XHQgKi9cblx0XHRcInNTZWFyY2hcIjogXCJcIixcblx0XG5cdFx0LyoqXG5cdFx0ICogRmxhZyB0byBpbmRpY2F0ZSBpZiB0aGUgc2VhcmNoIHRlcm0gc2hvdWxkIGJlIGludGVycHJldGVkIGFzIGFcblx0XHQgKiByZWd1bGFyIGV4cHJlc3Npb24gKHRydWUpIG9yIG5vdCAoZmFsc2UpIGFuZCB0aGVyZWZvcmUgYW5kIHNwZWNpYWxcblx0XHQgKiByZWdleCBjaGFyYWN0ZXJzIGVzY2FwZWQuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHRcImJSZWdleFwiOiBmYWxzZSxcblx0XG5cdFx0LyoqXG5cdFx0ICogRmxhZyB0byBpbmRpY2F0ZSBpZiBEYXRhVGFibGVzIGlzIHRvIHVzZSBpdHMgc21hcnQgZmlsdGVyaW5nIG9yIG5vdC5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0XCJiU21hcnRcIjogdHJ1ZVxuXHR9O1xuXHRcblx0XG5cdFxuXHRcblx0LyoqXG5cdCAqIFRlbXBsYXRlIG9iamVjdCBmb3IgdGhlIHdheSBpbiB3aGljaCBEYXRhVGFibGVzIGhvbGRzIGluZm9ybWF0aW9uIGFib3V0XG5cdCAqIGVhY2ggaW5kaXZpZHVhbCByb3cuIFRoaXMgaXMgdGhlIG9iamVjdCBmb3JtYXQgdXNlZCBmb3IgdGhlIHNldHRpbmdzXG5cdCAqIGFvRGF0YSBhcnJheS5cblx0ICogIEBuYW1lc3BhY2Vcblx0ICovXG5cdERhdGFUYWJsZS5tb2RlbHMub1JvdyA9IHtcblx0XHQvKipcblx0XHQgKiBUUiBlbGVtZW50IGZvciB0aGUgcm93XG5cdFx0ICogIEB0eXBlIG5vZGVcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwiblRyXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEFycmF5IG9mIFREIGVsZW1lbnRzIGZvciBlYWNoIHJvdy4gVGhpcyBpcyBudWxsIHVudGlsIHRoZSByb3cgaGFzIGJlZW5cblx0XHQgKiBjcmVhdGVkLlxuXHRcdCAqICBAdHlwZSBhcnJheSBub2Rlc1xuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYW5DZWxsc1wiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBEYXRhIG9iamVjdCBmcm9tIHRoZSBvcmlnaW5hbCBkYXRhIHNvdXJjZSBmb3IgdGhlIHJvdy4gVGhpcyBpcyBlaXRoZXJcblx0XHQgKiBhbiBhcnJheSBpZiB1c2luZyB0aGUgdHJhZGl0aW9uYWwgZm9ybSBvZiBEYXRhVGFibGVzLCBvciBhbiBvYmplY3QgaWZcblx0XHQgKiB1c2luZyBtRGF0YSBvcHRpb25zLiBUaGUgZXhhY3QgdHlwZSB3aWxsIGRlcGVuZCBvbiB0aGUgcGFzc2VkIGluXG5cdFx0ICogZGF0YSBmcm9tIHRoZSBkYXRhIHNvdXJjZSwgb3Igd2lsbCBiZSBhbiBhcnJheSBpZiB1c2luZyBET00gYSBkYXRhXG5cdFx0ICogc291cmNlLlxuXHRcdCAqICBAdHlwZSBhcnJheXxvYmplY3Rcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcIl9hRGF0YVwiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogU29ydGluZyBkYXRhIGNhY2hlIC0gdGhpcyBhcnJheSBpcyBvc3RlbnNpYmx5IHRoZSBzYW1lIGxlbmd0aCBhcyB0aGVcblx0XHQgKiBudW1iZXIgb2YgY29sdW1ucyAoYWx0aG91Z2ggZWFjaCBpbmRleCBpcyBnZW5lcmF0ZWQgb25seSBhcyBpdCBpc1xuXHRcdCAqIG5lZWRlZCksIGFuZCBob2xkcyB0aGUgZGF0YSB0aGF0IGlzIHVzZWQgZm9yIHNvcnRpbmcgZWFjaCBjb2x1bW4gaW4gdGhlXG5cdFx0ICogcm93LiBXZSBkbyB0aGlzIGNhY2hlIGdlbmVyYXRpb24gYXQgdGhlIHN0YXJ0IG9mIHRoZSBzb3J0IGluIG9yZGVyIHRoYXRcblx0XHQgKiB0aGUgZm9ybWF0dGluZyBvZiB0aGUgc29ydCBkYXRhIG5lZWQgYmUgZG9uZSBvbmx5IG9uY2UgZm9yIGVhY2ggY2VsbFxuXHRcdCAqIHBlciBzb3J0LiBUaGlzIGFycmF5IHNob3VsZCBub3QgYmUgcmVhZCBmcm9tIG9yIHdyaXR0ZW4gdG8gYnkgYW55dGhpbmdcblx0XHQgKiBvdGhlciB0aGFuIHRoZSBtYXN0ZXIgc29ydGluZyBtZXRob2RzLlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0XCJfYVNvcnREYXRhXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFBlciBjZWxsIGZpbHRlcmluZyBkYXRhIGNhY2hlLiBBcyBwZXIgdGhlIHNvcnQgZGF0YSBjYWNoZSwgdXNlZCB0b1xuXHRcdCAqIGluY3JlYXNlIHRoZSBwZXJmb3JtYW5jZSBvZiB0aGUgZmlsdGVyaW5nIGluIERhdGFUYWJsZXNcblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdFwiX2FGaWx0ZXJEYXRhXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEZpbHRlcmluZyBkYXRhIGNhY2hlLiBUaGlzIGlzIHRoZSBzYW1lIGFzIHRoZSBjZWxsIGZpbHRlcmluZyBjYWNoZSwgYnV0XG5cdFx0ICogaW4gdGhpcyBjYXNlIGEgc3RyaW5nIHJhdGhlciB0aGFuIGFuIGFycmF5LiBUaGlzIGlzIGVhc2lseSBjb21wdXRlZCB3aXRoXG5cdFx0ICogYSBqb2luIG9uIGBfYUZpbHRlckRhdGFgLCBidXQgaXMgcHJvdmlkZWQgYXMgYSBjYWNoZSBzbyB0aGUgam9pbiBpc24ndFxuXHRcdCAqIG5lZWRlZCBvbiBldmVyeSBzZWFyY2ggKG1lbW9yeSB0cmFkZWQgZm9yIHBlcmZvcm1hbmNlKVxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0XCJfc0ZpbHRlclJvd1wiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBDYWNoZSBvZiB0aGUgY2xhc3MgbmFtZSB0aGF0IERhdGFUYWJsZXMgaGFzIGFwcGxpZWQgdG8gdGhlIHJvdywgc28gd2Vcblx0XHQgKiBjYW4gcXVpY2tseSBsb29rIGF0IHRoaXMgdmFyaWFibGUgcmF0aGVyIHRoYW4gbmVlZGluZyB0byBkbyBhIERPTSBjaGVja1xuXHRcdCAqIG9uIGNsYXNzTmFtZSBmb3IgdGhlIG5UciBwcm9wZXJ0eS5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IDxpPkVtcHR5IHN0cmluZzwvaT5cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0XHRcIl9zUm93U3RyaXBlXCI6IFwiXCIsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIERlbm90ZSBpZiB0aGUgb3JpZ2luYWwgZGF0YSBzb3VyY2Ugd2FzIGZyb20gdGhlIERPTSwgb3IgdGhlIGRhdGEgc291cmNlXG5cdFx0ICogb2JqZWN0LiBUaGlzIGlzIHVzZWQgZm9yIGludmFsaWRhdGluZyBkYXRhLCBzbyBEYXRhVGFibGVzIGNhblxuXHRcdCAqIGF1dG9tYXRpY2FsbHkgcmVhZCBkYXRhIGZyb20gdGhlIG9yaWdpbmFsIHNvdXJjZSwgdW5sZXNzIHVuaW5zdHJ1Y3RlZFxuXHRcdCAqIG90aGVyd2lzZS5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0XHRcInNyY1wiOiBudWxsXG5cdH07XG5cdFxuXHRcblx0LyoqXG5cdCAqIFRlbXBsYXRlIG9iamVjdCBmb3IgdGhlIGNvbHVtbiBpbmZvcm1hdGlvbiBvYmplY3QgaW4gRGF0YVRhYmxlcy4gVGhpcyBvYmplY3Rcblx0ICogaXMgaGVsZCBpbiB0aGUgc2V0dGluZ3MgYW9Db2x1bW5zIGFycmF5IGFuZCBjb250YWlucyBhbGwgdGhlIGluZm9ybWF0aW9uIHRoYXRcblx0ICogRGF0YVRhYmxlcyBuZWVkcyBhYm91dCBlYWNoIGluZGl2aWR1YWwgY29sdW1uLlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgdGhpcyBvYmplY3QgaXMgcmVsYXRlZCB0byB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbn1cblx0ICogYnV0IHRoaXMgb25lIGlzIHRoZSBpbnRlcm5hbCBkYXRhIHN0b3JlIGZvciBEYXRhVGFibGVzJ3MgY2FjaGUgb2YgY29sdW1ucy5cblx0ICogSXQgc2hvdWxkIE5PVCBiZSBtYW5pcHVsYXRlZCBvdXRzaWRlIG9mIERhdGFUYWJsZXMuIEFueSBjb25maWd1cmF0aW9uIHNob3VsZFxuXHQgKiBiZSBkb25lIHRocm91Z2ggdGhlIGluaXRpYWxpc2F0aW9uIG9wdGlvbnMuXG5cdCAqICBAbmFtZXNwYWNlXG5cdCAqL1xuXHREYXRhVGFibGUubW9kZWxzLm9Db2x1bW4gPSB7XG5cdFx0LyoqXG5cdFx0ICogQ29sdW1uIGluZGV4LiBUaGlzIGNvdWxkIGJlIHdvcmtlZCBvdXQgb24tdGhlLWZseSB3aXRoICQuaW5BcnJheSwgYnV0IGl0XG5cdFx0ICogaXMgZmFzdGVyIHRvIGp1c3QgaG9sZCBpdCBhcyBhIHZhcmlhYmxlXG5cdFx0ICogIEB0eXBlIGludGVnZXJcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwiaWR4XCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEEgbGlzdCBvZiB0aGUgY29sdW1ucyB0aGF0IHNvcnRpbmcgc2hvdWxkIG9jY3VyIG9uIHdoZW4gdGhpcyBjb2x1bW5cblx0XHQgKiBpcyBzb3J0ZWQuIFRoYXQgdGhpcyBwcm9wZXJ0eSBpcyBhbiBhcnJheSBhbGxvd3MgbXVsdGktY29sdW1uIHNvcnRpbmdcblx0XHQgKiB0byBiZSBkZWZpbmVkIGZvciBhIGNvbHVtbiAoZm9yIGV4YW1wbGUgZmlyc3QgbmFtZSAvIGxhc3QgbmFtZSBjb2x1bW5zXG5cdFx0ICogd291bGQgYmVuZWZpdCBmcm9tIHRoaXMpLiBUaGUgdmFsdWVzIGFyZSBpbnRlZ2VycyBwb2ludGluZyB0byB0aGVcblx0XHQgKiBjb2x1bW5zIHRvIGJlIHNvcnRlZCBvbiAodHlwaWNhbGx5IGl0IHdpbGwgYmUgYSBzaW5nbGUgaW50ZWdlciBwb2ludGluZ1xuXHRcdCAqIGF0IGl0c2VsZiwgYnV0IHRoYXQgZG9lc24ndCBuZWVkIHRvIGJlIHRoZSBjYXNlKS5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKi9cblx0XHRcImFEYXRhU29ydFwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBEZWZpbmUgdGhlIHNvcnRpbmcgZGlyZWN0aW9ucyB0aGF0IGFyZSBhcHBsaWVkIHRvIHRoZSBjb2x1bW4sIGluIHNlcXVlbmNlXG5cdFx0ICogYXMgdGhlIGNvbHVtbiBpcyByZXBlYXRlZGx5IHNvcnRlZCB1cG9uIC0gaS5lLiB0aGUgZmlyc3QgdmFsdWUgaXMgdXNlZFxuXHRcdCAqIGFzIHRoZSBzb3J0aW5nIGRpcmVjdGlvbiB3aGVuIHRoZSBjb2x1bW4gaWYgZmlyc3Qgc29ydGVkIChjbGlja2VkIG9uKS5cblx0XHQgKiBTb3J0IGl0IGFnYWluIChjbGljayBhZ2FpbikgYW5kIGl0IHdpbGwgbW92ZSBvbiB0byB0aGUgbmV4dCBpbmRleC5cblx0XHQgKiBSZXBlYXQgdW50aWwgbG9vcC5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKi9cblx0XHRcImFzU29ydGluZ1wiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBGbGFnIHRvIGluZGljYXRlIGlmIHRoZSBjb2x1bW4gaXMgc2VhcmNoYWJsZSwgYW5kIHRodXMgc2hvdWxkIGJlIGluY2x1ZGVkXG5cdFx0ICogaW4gdGhlIGZpbHRlcmluZyBvciBub3QuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKi9cblx0XHRcImJTZWFyY2hhYmxlXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEZsYWcgdG8gaW5kaWNhdGUgaWYgdGhlIGNvbHVtbiBpcyBzb3J0YWJsZSBvciBub3QuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKi9cblx0XHRcImJTb3J0YWJsZVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBGbGFnIHRvIGluZGljYXRlIGlmIHRoZSBjb2x1bW4gaXMgY3VycmVudGx5IHZpc2libGUgaW4gdGhlIHRhYmxlIG9yIG5vdFxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICovXG5cdFx0XCJiVmlzaWJsZVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBTdG9yZSBmb3IgbWFudWFsIHR5cGUgYXNzaWdubWVudCB1c2luZyB0aGUgYGNvbHVtbi50eXBlYCBvcHRpb24uIFRoaXNcblx0XHQgKiBpcyBoZWxkIGluIHN0b3JlIHNvIHdlIGNhbiBtYW5pcHVsYXRlIHRoZSBjb2x1bW4ncyBgc1R5cGVgIHByb3BlcnR5LlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdFwiX3NNYW51YWxUeXBlXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEZsYWcgdG8gaW5kaWNhdGUgaWYgSFRNTDUgZGF0YSBhdHRyaWJ1dGVzIHNob3VsZCBiZSB1c2VkIGFzIHRoZSBkYXRhXG5cdFx0ICogc291cmNlIGZvciBmaWx0ZXJpbmcgb3Igc29ydGluZy4gVHJ1ZSBpcyBlaXRoZXIgYXJlLlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0XCJfYkF0dHJTcmNcIjogZmFsc2UsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIERldmVsb3BlciBkZWZpbmFibGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbmV2ZXIgYSBjZWxsIGlzIGNyZWF0ZWQgKEFqYXggc291cmNlLFxuXHRcdCAqIGV0Yykgb3IgcHJvY2Vzc2VkIGZvciBpbnB1dCAoRE9NIHNvdXJjZSkuIFRoaXMgY2FuIGJlIHVzZWQgYXMgYSBjb21wbGltZW50IHRvIG1SZW5kZXJcblx0XHQgKiBhbGxvd2luZyB5b3UgdG8gbW9kaWZ5IHRoZSBET00gZWxlbWVudCAoYWRkIGJhY2tncm91bmQgY29sb3VyIGZvciBleGFtcGxlKSB3aGVuIHRoZVxuXHRcdCAqIGVsZW1lbnQgaXMgYXZhaWxhYmxlLlxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAcGFyYW0ge2VsZW1lbnR9IG5UZCBUaGUgVEQgbm9kZSB0aGF0IGhhcyBiZWVuIGNyZWF0ZWRcblx0XHQgKiAgQHBhcmFtIHsqfSBzRGF0YSBUaGUgRGF0YSBmb3IgdGhlIGNlbGxcblx0XHQgKiAgQHBhcmFtIHthcnJheXxvYmplY3R9IG9EYXRhIFRoZSBkYXRhIGZvciB0aGUgd2hvbGUgcm93XG5cdFx0ICogIEBwYXJhbSB7aW50fSBpUm93IFRoZSByb3cgaW5kZXggZm9yIHRoZSBhb0RhdGEgZGF0YSBzdG9yZVxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJmbkNyZWF0ZWRDZWxsXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEZ1bmN0aW9uIHRvIGdldCBkYXRhIGZyb20gYSBjZWxsIGluIGEgY29sdW1uLiBZb3Ugc2hvdWxkIDxiPm5ldmVyPC9iPlxuXHRcdCAqIGFjY2VzcyBkYXRhIGRpcmVjdGx5IHRocm91Z2ggX2FEYXRhIGludGVybmFsbHkgaW4gRGF0YVRhYmxlcyAtIGFsd2F5cyB1c2Vcblx0XHQgKiB0aGUgbWV0aG9kIGF0dGFjaGVkIHRvIHRoaXMgcHJvcGVydHkuIEl0IGFsbG93cyBtRGF0YSB0byBmdW5jdGlvbiBhc1xuXHRcdCAqIHJlcXVpcmVkLiBUaGlzIGZ1bmN0aW9uIGlzIGF1dG9tYXRpY2FsbHkgYXNzaWduZWQgYnkgdGhlIGNvbHVtblxuXHRcdCAqIGluaXRpYWxpc2F0aW9uIG1ldGhvZFxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAcGFyYW0ge2FycmF5fG9iamVjdH0gb0RhdGEgVGhlIGRhdGEgYXJyYXkvb2JqZWN0IGZvciB0aGUgYXJyYXlcblx0XHQgKiAgICAoaS5lLiBhb0RhdGFbXS5fYURhdGEpXG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nfSBzU3BlY2lmaWMgVGhlIHNwZWNpZmljIGRhdGEgdHlwZSB5b3Ugd2FudCB0byBnZXQgLVxuXHRcdCAqICAgICdkaXNwbGF5JywgJ3R5cGUnICdmaWx0ZXInICdzb3J0J1xuXHRcdCAqICBAcmV0dXJucyB7Kn0gVGhlIGRhdGEgZm9yIHRoZSBjZWxsIGZyb20gdGhlIGdpdmVuIHJvdydzIGRhdGFcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwiZm5HZXREYXRhXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEZ1bmN0aW9uIHRvIHNldCBkYXRhIGZvciBhIGNlbGwgaW4gdGhlIGNvbHVtbi4gWW91IHNob3VsZCA8Yj5uZXZlcjwvYj5cblx0XHQgKiBzZXQgdGhlIGRhdGEgZGlyZWN0bHkgdG8gX2FEYXRhIGludGVybmFsbHkgaW4gRGF0YVRhYmxlcyAtIGFsd2F5cyB1c2Vcblx0XHQgKiB0aGlzIG1ldGhvZC4gSXQgYWxsb3dzIG1EYXRhIHRvIGZ1bmN0aW9uIGFzIHJlcXVpcmVkLiBUaGlzIGZ1bmN0aW9uXG5cdFx0ICogaXMgYXV0b21hdGljYWxseSBhc3NpZ25lZCBieSB0aGUgY29sdW1uIGluaXRpYWxpc2F0aW9uIG1ldGhvZFxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAcGFyYW0ge2FycmF5fG9iamVjdH0gb0RhdGEgVGhlIGRhdGEgYXJyYXkvb2JqZWN0IGZvciB0aGUgYXJyYXlcblx0XHQgKiAgICAoaS5lLiBhb0RhdGFbXS5fYURhdGEpXG5cdFx0ICogIEBwYXJhbSB7Kn0gc1ZhbHVlIFZhbHVlIHRvIHNldFxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJmblNldERhdGFcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogUHJvcGVydHkgdG8gcmVhZCB0aGUgdmFsdWUgZm9yIHRoZSBjZWxscyBpbiB0aGUgY29sdW1uIGZyb20gdGhlIGRhdGFcblx0XHQgKiBzb3VyY2UgYXJyYXkgLyBvYmplY3QuIElmIG51bGwsIHRoZW4gdGhlIGRlZmF1bHQgY29udGVudCBpcyB1c2VkLCBpZiBhXG5cdFx0ICogZnVuY3Rpb24gaXMgZ2l2ZW4gdGhlbiB0aGUgcmV0dXJuIGZyb20gdGhlIGZ1bmN0aW9uIGlzIHVzZWQuXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9ufGludHxzdHJpbmd8bnVsbFxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJtRGF0YVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBQYXJ0bmVyIHByb3BlcnR5IHRvIG1EYXRhIHdoaWNoIGlzIHVzZWQgKG9ubHkgd2hlbiBkZWZpbmVkKSB0byBnZXRcblx0XHQgKiB0aGUgZGF0YSAtIGkuZS4gaXQgaXMgYmFzaWNhbGx5IHRoZSBzYW1lIGFzIG1EYXRhLCBidXQgd2l0aG91dCB0aGVcblx0XHQgKiAnc2V0JyBvcHRpb24sIGFuZCBhbHNvIHRoZSBkYXRhIGZlZCB0byBpdCBpcyB0aGUgcmVzdWx0IGZyb20gbURhdGEuXG5cdFx0ICogVGhpcyBpcyB0aGUgcmVuZGVyaW5nIG1ldGhvZCB0byBtYXRjaCB0aGUgZGF0YSBtZXRob2Qgb2YgbURhdGEuXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9ufGludHxzdHJpbmd8bnVsbFxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJtUmVuZGVyXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFVuaXF1ZSBoZWFkZXIgVEgvVEQgZWxlbWVudCBmb3IgdGhpcyBjb2x1bW4gLSB0aGlzIGlzIHdoYXQgdGhlIHNvcnRpbmdcblx0XHQgKiBsaXN0ZW5lciBpcyBhdHRhY2hlZCB0byAoaWYgc29ydGluZyBpcyBlbmFibGVkLilcblx0XHQgKiAgQHR5cGUgbm9kZVxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJuVGhcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogVW5pcXVlIGZvb3RlciBUSC9URCBlbGVtZW50IGZvciB0aGlzIGNvbHVtbiAoaWYgdGhlcmUgaXMgb25lKS4gTm90IHVzZWRcblx0XHQgKiBpbiBEYXRhVGFibGVzIGFzIHN1Y2gsIGJ1dCBjYW4gYmUgdXNlZCBmb3IgcGx1Zy1pbnMgdG8gcmVmZXJlbmNlIHRoZVxuXHRcdCAqIGZvb3RlciBmb3IgZWFjaCBjb2x1bW4uXG5cdFx0ICogIEB0eXBlIG5vZGVcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwiblRmXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjbGFzcyB0byBhcHBseSB0byBhbGwgVEQgZWxlbWVudHMgaW4gdGhlIHRhYmxlJ3MgVEJPRFkgZm9yIHRoZSBjb2x1bW5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcInNDbGFzc1wiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBXaGVuIERhdGFUYWJsZXMgY2FsY3VsYXRlcyB0aGUgY29sdW1uIHdpZHRocyB0byBhc3NpZ24gdG8gZWFjaCBjb2x1bW4sXG5cdFx0ICogaXQgZmluZHMgdGhlIGxvbmdlc3Qgc3RyaW5nIGluIGVhY2ggY29sdW1uIGFuZCB0aGVuIGNvbnN0cnVjdHMgYVxuXHRcdCAqIHRlbXBvcmFyeSB0YWJsZSBhbmQgcmVhZHMgdGhlIHdpZHRocyBmcm9tIHRoYXQuIFRoZSBwcm9ibGVtIHdpdGggdGhpc1xuXHRcdCAqIGlzIHRoYXQgXCJtbW1cIiBpcyBtdWNoIHdpZGVyIHRoZW4gXCJpaWlpXCIsIGJ1dCB0aGUgbGF0dGVyIGlzIGEgbG9uZ2VyXG5cdFx0ICogc3RyaW5nIC0gdGh1cyB0aGUgY2FsY3VsYXRpb24gY2FuIGdvIHdyb25nIChkb2luZyBpdCBwcm9wZXJseSBhbmQgcHV0dGluZ1xuXHRcdCAqIGl0IGludG8gYW4gRE9NIG9iamVjdCBhbmQgbWVhc3VyaW5nIHRoYXQgaXMgaG9ycmlibHkoISkgc2xvdykuIFRodXMgYXNcblx0XHQgKiBhIFwid29yayBhcm91bmRcIiB3ZSBwcm92aWRlIHRoaXMgb3B0aW9uLiBJdCB3aWxsIGFwcGVuZCBpdHMgdmFsdWUgdG8gdGhlXG5cdFx0ICogdGV4dCB0aGF0IGlzIGZvdW5kIHRvIGJlIHRoZSBsb25nZXN0IHN0cmluZyBmb3IgdGhlIGNvbHVtbiAtIGkuZS4gcGFkZGluZy5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICovXG5cdFx0XCJzQ29udGVudFBhZGRpbmdcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogQWxsb3dzIGEgZGVmYXVsdCB2YWx1ZSB0byBiZSBnaXZlbiBmb3IgYSBjb2x1bW4ncyBkYXRhLCBhbmQgd2lsbCBiZSB1c2VkXG5cdFx0ICogd2hlbmV2ZXIgYSBudWxsIGRhdGEgc291cmNlIGlzIGVuY291bnRlcmVkICh0aGlzIGNhbiBiZSBiZWNhdXNlIG1EYXRhXG5cdFx0ICogaXMgc2V0IHRvIG51bGwsIG9yIGJlY2F1c2UgdGhlIGRhdGEgc291cmNlIGl0c2VsZiBpcyBudWxsKS5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcInNEZWZhdWx0Q29udGVudFwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBOYW1lIGZvciB0aGUgY29sdW1uLCBhbGxvd2luZyByZWZlcmVuY2UgdG8gdGhlIGNvbHVtbiBieSBuYW1lIGFzIHdlbGwgYXNcblx0XHQgKiBieSBpbmRleCAobmVlZHMgYSBsb29rdXAgdG8gd29yayBieSBuYW1lKS5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICovXG5cdFx0XCJzTmFtZVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBDdXN0b20gc29ydGluZyBkYXRhIHR5cGUgLSBkZWZpbmVzIHdoaWNoIG9mIHRoZSBhdmFpbGFibGUgcGx1Zy1pbnMgaW5cblx0XHQgKiBhZm5Tb3J0RGF0YSB0aGUgY3VzdG9tIHNvcnRpbmcgd2lsbCB1c2UgLSBpZiBhbnkgaXMgZGVmaW5lZC5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IHN0ZFxuXHRcdCAqL1xuXHRcdFwic1NvcnREYXRhVHlwZVwiOiAnc3RkJyxcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2xhc3MgdG8gYmUgYXBwbGllZCB0byB0aGUgaGVhZGVyIGVsZW1lbnQgd2hlbiBzb3J0aW5nIG9uIHRoaXMgY29sdW1uXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJzU29ydGluZ0NsYXNzXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIENsYXNzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGhlYWRlciBlbGVtZW50IHdoZW4gc29ydGluZyBvbiB0aGlzIGNvbHVtbiAtXG5cdFx0ICogd2hlbiBqUXVlcnkgVUkgdGhlbWluZyBpcyB1c2VkLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwic1NvcnRpbmdDbGFzc0pVSVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBUaXRsZSBvZiB0aGUgY29sdW1uIC0gd2hhdCBpcyBzZWVuIGluIHRoZSBUSCBlbGVtZW50IChuVGgpLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKi9cblx0XHRcInNUaXRsZVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBDb2x1bW4gc29ydGluZyBhbmQgZmlsdGVyaW5nIHR5cGVcblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcInNUeXBlXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFdpZHRoIG9mIHRoZSBjb2x1bW5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcInNXaWR0aFwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBXaWR0aCBvZiB0aGUgY29sdW1uIHdoZW4gaXQgd2FzIGZpcnN0IFwiZW5jb3VudGVyZWRcIlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwic1dpZHRoT3JpZ1wiOiBudWxsXG5cdH07XG5cdFxuXHRcblx0Lypcblx0ICogRGV2ZWxvcGVyIG5vdGU6IFRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBvYmplY3QgYmVsb3cgYXJlIGdpdmVuIGluIEh1bmdhcmlhblxuXHQgKiBub3RhdGlvbiwgdGhhdCB3YXMgdXNlZCBhcyB0aGUgaW50ZXJmYWNlIGZvciBEYXRhVGFibGVzIHByaW9yIHRvIHYxLjEwLCBob3dldmVyXG5cdCAqIGZyb20gdjEuMTAgb253YXJkcyB0aGUgcHJpbWFyeSBpbnRlcmZhY2UgaXMgY2FtZWwgY2FzZS4gSW4gb3JkZXIgdG8gYXZvaWRcblx0ICogYnJlYWtpbmcgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgdXR0ZXJseSB3aXRoIHRoaXMgY2hhbmdlLCB0aGUgSHVuZ2FyaWFuXG5cdCAqIHZlcnNpb24gaXMgc3RpbGwsIGludGVybmFsbHkgdGhlIHByaW1hcnkgaW50ZXJmYWNlLCBidXQgaXMgaXMgbm90IGRvY3VtZW50ZWRcblx0ICogLSBoZW5jZSB0aGUgQG5hbWUgdGFncyBpbiBlYWNoIGRvYyBjb21tZW50LiBUaGlzIGFsbG93cyBhIEphdmFzY3JpcHQgZnVuY3Rpb25cblx0ICogdG8gY3JlYXRlIGEgbWFwIGZyb20gSHVuZ2FyaWFuIG5vdGF0aW9uIHRvIGNhbWVsIGNhc2UgKGdvaW5nIHRoZSBvdGhlciBkaXJlY3Rpb25cblx0ICogd291bGQgcmVxdWlyZSBlYWNoIHByb3BlcnR5IHRvIGJlIGxpc3RlZCwgd2hpY2ggd291bGQgYXQgYXJvdW5kIDNLIHRvIHRoZSBzaXplXG5cdCAqIG9mIERhdGFUYWJsZXMsIHdoaWxlIHRoaXMgbWV0aG9kIGlzIGFib3V0IGEgMC41SyBoaXQuXG5cdCAqXG5cdCAqIFVsdGltYXRlbHkgdGhpcyBkb2VzIHBhdmUgdGhlIHdheSBmb3IgSHVuZ2FyaWFuIG5vdGF0aW9uIHRvIGJlIGRyb3BwZWRcblx0ICogY29tcGxldGVseSwgYnV0IHRoYXQgaXMgYSBtYXNzaXZlIGFtb3VudCBvZiB3b3JrIGFuZCB3aWxsIGJyZWFrIGN1cnJlbnRcblx0ICogaW5zdGFsbHMgKHRoZXJlZm9yZSBpcyBvbi1ob2xkIHVudGlsIHYyKS5cblx0ICovXG5cdFxuXHQvKipcblx0ICogSW5pdGlhbGlzYXRpb24gb3B0aW9ucyB0aGF0IGNhbiBiZSBnaXZlbiB0byBEYXRhVGFibGVzIGF0IGluaXRpYWxpc2F0aW9uXG5cdCAqIHRpbWUuXG5cdCAqICBAbmFtZXNwYWNlXG5cdCAqL1xuXHREYXRhVGFibGUuZGVmYXVsdHMgPSB7XG5cdFx0LyoqXG5cdFx0ICogQW4gYXJyYXkgb2YgZGF0YSB0byB1c2UgZm9yIHRoZSB0YWJsZSwgcGFzc2VkIGluIGF0IGluaXRpYWxpc2F0aW9uIHdoaWNoXG5cdFx0ICogd2lsbCBiZSB1c2VkIGluIHByZWZlcmVuY2UgdG8gYW55IGRhdGEgd2hpY2ggaXMgYWxyZWFkeSBpbiB0aGUgRE9NLiBUaGlzIGlzXG5cdFx0ICogcGFydGljdWxhcmx5IHVzZWZ1bCBmb3IgY29uc3RydWN0aW5nIHRhYmxlcyBwdXJlbHkgaW4gSmF2YXNjcmlwdCwgZm9yXG5cdFx0ICogZXhhbXBsZSB3aXRoIGEgY3VzdG9tIEFqYXggY2FsbC5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25cblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmRhdGFcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGEgMkQgYXJyYXkgZGF0YSBzb3VyY2Vcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJkYXRhXCI6IFtcblx0XHQgKiAgICAgICAgICBbJ1RyaWRlbnQnLCAnSW50ZXJuZXQgRXhwbG9yZXIgNC4wJywgJ1dpbiA5NSsnLCA0LCAnWCddLFxuXHRcdCAqICAgICAgICAgIFsnVHJpZGVudCcsICdJbnRlcm5ldCBFeHBsb3JlciA1LjAnLCAnV2luIDk1KycsIDUsICdDJ10sXG5cdFx0ICogICAgICAgIF0sXG5cdFx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdFx0ICogICAgICAgICAgeyBcInRpdGxlXCI6IFwiRW5naW5lXCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJCcm93c2VyXCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJQbGF0Zm9ybVwiIH0sXG5cdFx0ICogICAgICAgICAgeyBcInRpdGxlXCI6IFwiVmVyc2lvblwiIH0sXG5cdFx0ICogICAgICAgICAgeyBcInRpdGxlXCI6IFwiR3JhZGVcIiB9XG5cdFx0ICogICAgICAgIF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBhbiBhcnJheSBvZiBvYmplY3RzIGFzIGEgZGF0YSBzb3VyY2UgKGBkYXRhYClcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJkYXRhXCI6IFtcblx0XHQgKiAgICAgICAgICB7XG5cdFx0ICogICAgICAgICAgICBcImVuZ2luZVwiOiAgIFwiVHJpZGVudFwiLFxuXHRcdCAqICAgICAgICAgICAgXCJicm93c2VyXCI6ICBcIkludGVybmV0IEV4cGxvcmVyIDQuMFwiLFxuXHRcdCAqICAgICAgICAgICAgXCJwbGF0Zm9ybVwiOiBcIldpbiA5NStcIixcblx0XHQgKiAgICAgICAgICAgIFwidmVyc2lvblwiOiAgNCxcblx0XHQgKiAgICAgICAgICAgIFwiZ3JhZGVcIjogICAgXCJYXCJcblx0XHQgKiAgICAgICAgICB9LFxuXHRcdCAqICAgICAgICAgIHtcblx0XHQgKiAgICAgICAgICAgIFwiZW5naW5lXCI6ICAgXCJUcmlkZW50XCIsXG5cdFx0ICogICAgICAgICAgICBcImJyb3dzZXJcIjogIFwiSW50ZXJuZXQgRXhwbG9yZXIgNS4wXCIsXG5cdFx0ICogICAgICAgICAgICBcInBsYXRmb3JtXCI6IFwiV2luIDk1K1wiLFxuXHRcdCAqICAgICAgICAgICAgXCJ2ZXJzaW9uXCI6ICA1LFxuXHRcdCAqICAgICAgICAgICAgXCJncmFkZVwiOiAgICBcIkNcIlxuXHRcdCAqICAgICAgICAgIH1cblx0XHQgKiAgICAgICAgXSxcblx0XHQgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJFbmdpbmVcIiwgICBcImRhdGFcIjogXCJlbmdpbmVcIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIkJyb3dzZXJcIiwgIFwiZGF0YVwiOiBcImJyb3dzZXJcIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIlBsYXRmb3JtXCIsIFwiZGF0YVwiOiBcInBsYXRmb3JtXCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJWZXJzaW9uXCIsICBcImRhdGFcIjogXCJ2ZXJzaW9uXCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJHcmFkZVwiLCAgICBcImRhdGFcIjogXCJncmFkZVwiIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImFhRGF0YVwiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogSWYgb3JkZXJpbmcgaXMgZW5hYmxlZCwgdGhlbiBEYXRhVGFibGVzIHdpbGwgcGVyZm9ybSBhIGZpcnN0IHBhc3Mgc29ydCBvblxuXHRcdCAqIGluaXRpYWxpc2F0aW9uLiBZb3UgY2FuIGRlZmluZSB3aGljaCBjb2x1bW4ocykgdGhlIHNvcnQgaXMgcGVyZm9ybWVkXG5cdFx0ICogdXBvbiwgYW5kIHRoZSBzb3J0aW5nIGRpcmVjdGlvbiwgd2l0aCB0aGlzIHZhcmlhYmxlLiBUaGUgYHNvcnRpbmdgIGFycmF5XG5cdFx0ICogc2hvdWxkIGNvbnRhaW4gYW4gYXJyYXkgZm9yIGVhY2ggY29sdW1uIHRvIGJlIHNvcnRlZCBpbml0aWFsbHkgY29udGFpbmluZ1xuXHRcdCAqIHRoZSBjb2x1bW4ncyBpbmRleCBhbmQgYSBkaXJlY3Rpb24gc3RyaW5nICgnYXNjJyBvciAnZGVzYycpLlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbWzAsJ2FzYyddXVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25cblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLm9yZGVyXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBTb3J0IGJ5IDNyZCBjb2x1bW4gZmlyc3QsIGFuZCB0aGVuIDR0aCBjb2x1bW5cblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcIm9yZGVyXCI6IFtbMiwnYXNjJ10sIFszLCdkZXNjJ11dXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogICAgLy8gTm8gaW5pdGlhbCBzb3J0aW5nXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJvcmRlclwiOiBbXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImFhU29ydGluZ1wiOiBbWzAsJ2FzYyddXSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgcGFyYW1ldGVyIGlzIGJhc2ljYWxseSBpZGVudGljYWwgdG8gdGhlIGBzb3J0aW5nYCBwYXJhbWV0ZXIsIGJ1dFxuXHRcdCAqIGNhbm5vdCBiZSBvdmVycmlkZGVuIGJ5IHVzZXIgaW50ZXJhY3Rpb24gd2l0aCB0aGUgdGFibGUuIFdoYXQgdGhpcyBtZWFuc1xuXHRcdCAqIGlzIHRoYXQgeW91IGNvdWxkIGhhdmUgYSBjb2x1bW4gKHZpc2libGUgb3IgaGlkZGVuKSB3aGljaCB0aGUgc29ydGluZ1xuXHRcdCAqIHdpbGwgYWx3YXlzIGJlIGZvcmNlZCBvbiBmaXJzdCAtIGFueSBzb3J0aW5nIGFmdGVyIHRoYXQgKGZyb20gdGhlIHVzZXIpXG5cdFx0ICogd2lsbCB0aGVuIGJlIHBlcmZvcm1lZCBhcyByZXF1aXJlZC4gVGhpcyBjYW4gYmUgdXNlZnVsIGZvciBncm91cGluZyByb3dzXG5cdFx0ICogdG9nZXRoZXIuXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5vcmRlckZpeGVkXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcIm9yZGVyRml4ZWRcIjogW1swLCdhc2MnXV1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9IClcblx0XHQgKi9cblx0XHRcImFhU29ydGluZ0ZpeGVkXCI6IFtdLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRGF0YVRhYmxlcyBjYW4gYmUgaW5zdHJ1Y3RlZCB0byBsb2FkIGRhdGEgdG8gZGlzcGxheSBpbiB0aGUgdGFibGUgZnJvbSBhXG5cdFx0ICogQWpheCBzb3VyY2UuIFRoaXMgb3B0aW9uIGRlZmluZXMgaG93IHRoYXQgQWpheCBjYWxsIGlzIG1hZGUgYW5kIHdoZXJlIHRvLlxuXHRcdCAqXG5cdFx0ICogVGhlIGBhamF4YCBwcm9wZXJ0eSBoYXMgdGhyZWUgZGlmZmVyZW50IG1vZGVzIG9mIG9wZXJhdGlvbiwgZGVwZW5kaW5nIG9uXG5cdFx0ICogaG93IGl0IGlzIGRlZmluZWQuIFRoZXNlIGFyZTpcblx0XHQgKlxuXHRcdCAqICogYHN0cmluZ2AgLSBTZXQgdGhlIFVSTCBmcm9tIHdoZXJlIHRoZSBkYXRhIHNob3VsZCBiZSBsb2FkZWQgZnJvbS5cblx0XHQgKiAqIGBvYmplY3RgIC0gRGVmaW5lIHByb3BlcnRpZXMgZm9yIGBqUXVlcnkuYWpheGAuXG5cdFx0ICogKiBgZnVuY3Rpb25gIC0gQ3VzdG9tIGRhdGEgZ2V0IGZ1bmN0aW9uXG5cdFx0ICpcblx0XHQgKiBgc3RyaW5nYFxuXHRcdCAqIC0tLS0tLS0tXG5cdFx0ICpcblx0XHQgKiBBcyBhIHN0cmluZywgdGhlIGBhamF4YCBwcm9wZXJ0eSBzaW1wbHkgZGVmaW5lcyB0aGUgVVJMIGZyb20gd2hpY2hcblx0XHQgKiBEYXRhVGFibGVzIHdpbGwgbG9hZCBkYXRhLlxuXHRcdCAqXG5cdFx0ICogYG9iamVjdGBcblx0XHQgKiAtLS0tLS0tLVxuXHRcdCAqXG5cdFx0ICogQXMgYW4gb2JqZWN0LCB0aGUgcGFyYW1ldGVycyBpbiB0aGUgb2JqZWN0IGFyZSBwYXNzZWQgdG9cblx0XHQgKiBbalF1ZXJ5LmFqYXhdKGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS9qUXVlcnkuYWpheC8pIGFsbG93aW5nIGZpbmUgY29udHJvbFxuXHRcdCAqIG9mIHRoZSBBamF4IHJlcXVlc3QuIERhdGFUYWJsZXMgaGFzIGEgbnVtYmVyIG9mIGRlZmF1bHQgcGFyYW1ldGVycyB3aGljaFxuXHRcdCAqIHlvdSBjYW4gb3ZlcnJpZGUgdXNpbmcgdGhpcyBvcHRpb24uIFBsZWFzZSByZWZlciB0byB0aGUgalF1ZXJ5XG5cdFx0ICogZG9jdW1lbnRhdGlvbiBmb3IgYSBmdWxsIGRlc2NyaXB0aW9uIG9mIHRoZSBvcHRpb25zIGF2YWlsYWJsZSwgYWx0aG91Z2hcblx0XHQgKiB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnMgcHJvdmlkZSBhZGRpdGlvbmFsIG9wdGlvbnMgaW4gRGF0YVRhYmxlcyBvclxuXHRcdCAqIHJlcXVpcmUgc3BlY2lhbCBjb25zaWRlcmF0aW9uOlxuXHRcdCAqXG5cdFx0ICogKiBgZGF0YWAgLSBBcyB3aXRoIGpRdWVyeSwgYGRhdGFgIGNhbiBiZSBwcm92aWRlZCBhcyBhbiBvYmplY3QsIGJ1dCBpdFxuXHRcdCAqICAgY2FuIGFsc28gYmUgdXNlZCBhcyBhIGZ1bmN0aW9uIHRvIG1hbmlwdWxhdGUgdGhlIGRhdGEgRGF0YVRhYmxlcyBzZW5kc1xuXHRcdCAqICAgdG8gdGhlIHNlcnZlci4gVGhlIGZ1bmN0aW9uIHRha2VzIGEgc2luZ2xlIHBhcmFtZXRlciwgYW4gb2JqZWN0IG9mXG5cdFx0ICogICBwYXJhbWV0ZXJzIHdpdGggdGhlIHZhbHVlcyB0aGF0IERhdGFUYWJsZXMgaGFzIHJlYWRpZWQgZm9yIHNlbmRpbmcuIEFuXG5cdFx0ICogICBvYmplY3QgbWF5IGJlIHJldHVybmVkIHdoaWNoIHdpbGwgYmUgbWVyZ2VkIGludG8gdGhlIERhdGFUYWJsZXNcblx0XHQgKiAgIGRlZmF1bHRzLCBvciB5b3UgY2FuIGFkZCB0aGUgaXRlbXMgdG8gdGhlIG9iamVjdCB0aGF0IHdhcyBwYXNzZWQgaW4gYW5kXG5cdFx0ICogICBub3QgcmV0dXJuIGFueXRoaW5nIGZyb20gdGhlIGZ1bmN0aW9uLiBUaGlzIHN1cGVyc2VkZXMgYGZuU2VydmVyUGFyYW1zYFxuXHRcdCAqICAgZnJvbSBEYXRhVGFibGVzIDEuOS0uXG5cdFx0ICpcblx0XHQgKiAqIGBkYXRhU3JjYCAtIEJ5IGRlZmF1bHQgRGF0YVRhYmxlcyB3aWxsIGxvb2sgZm9yIHRoZSBwcm9wZXJ0eSBgZGF0YWAgKG9yXG5cdFx0ICogICBgYWFEYXRhYCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIERhdGFUYWJsZXMgMS45LSkgd2hlbiBvYnRhaW5pbmcgZGF0YVxuXHRcdCAqICAgZnJvbSBhbiBBamF4IHNvdXJjZSBvciBmb3Igc2VydmVyLXNpZGUgcHJvY2Vzc2luZyAtIHRoaXMgcGFyYW1ldGVyXG5cdFx0ICogICBhbGxvd3MgdGhhdCBwcm9wZXJ0eSB0byBiZSBjaGFuZ2VkLiBZb3UgY2FuIHVzZSBKYXZhc2NyaXB0IGRvdHRlZFxuXHRcdCAqICAgb2JqZWN0IG5vdGF0aW9uIHRvIGdldCBhIGRhdGEgc291cmNlIGZvciBtdWx0aXBsZSBsZXZlbHMgb2YgbmVzdGluZywgb3Jcblx0XHQgKiAgIGl0IG15IGJlIHVzZWQgYXMgYSBmdW5jdGlvbi4gQXMgYSBmdW5jdGlvbiBpdCB0YWtlcyBhIHNpbmdsZSBwYXJhbWV0ZXIsXG5cdFx0ICogICB0aGUgSlNPTiByZXR1cm5lZCBmcm9tIHRoZSBzZXJ2ZXIsIHdoaWNoIGNhbiBiZSBtYW5pcHVsYXRlZCBhc1xuXHRcdCAqICAgcmVxdWlyZWQsIHdpdGggdGhlIHJldHVybmVkIHZhbHVlIGJlaW5nIHRoYXQgdXNlZCBieSBEYXRhVGFibGVzIGFzIHRoZVxuXHRcdCAqICAgZGF0YSBzb3VyY2UgZm9yIHRoZSB0YWJsZS4gVGhpcyBzdXBlcnNlZGVzIGBzQWpheERhdGFQcm9wYCBmcm9tXG5cdFx0ICogICBEYXRhVGFibGVzIDEuOS0uXG5cdFx0ICpcblx0XHQgKiAqIGBzdWNjZXNzYCAtIFNob3VsZCBub3QgYmUgb3ZlcnJpZGRlbiBpdCBpcyB1c2VkIGludGVybmFsbHkgaW5cblx0XHQgKiAgIERhdGFUYWJsZXMuIFRvIG1hbmlwdWxhdGUgLyB0cmFuc2Zvcm0gdGhlIGRhdGEgcmV0dXJuZWQgYnkgdGhlIHNlcnZlclxuXHRcdCAqICAgdXNlIGBhamF4LmRhdGFTcmNgLCBvciB1c2UgYGFqYXhgIGFzIGEgZnVuY3Rpb24gKHNlZSBiZWxvdykuXG5cdFx0ICpcblx0XHQgKiBgZnVuY3Rpb25gXG5cdFx0ICogLS0tLS0tLS0tLVxuXHRcdCAqXG5cdFx0ICogQXMgYSBmdW5jdGlvbiwgbWFraW5nIHRoZSBBamF4IGNhbGwgaXMgbGVmdCB1cCB0byB5b3Vyc2VsZiBhbGxvd2luZ1xuXHRcdCAqIGNvbXBsZXRlIGNvbnRyb2wgb2YgdGhlIEFqYXggcmVxdWVzdC4gSW5kZWVkLCBpZiBkZXNpcmVkLCBhIG1ldGhvZCBvdGhlclxuXHRcdCAqIHRoYW4gQWpheCBjb3VsZCBiZSB1c2VkIHRvIG9idGFpbiB0aGUgcmVxdWlyZWQgZGF0YSwgc3VjaCBhcyBXZWIgc3RvcmFnZVxuXHRcdCAqIG9yIGFuIEFJUiBkYXRhYmFzZS5cblx0XHQgKlxuXHRcdCAqIFRoZSBmdW5jdGlvbiBpcyBnaXZlbiBmb3VyIHBhcmFtZXRlcnMgYW5kIG5vIHJldHVybiBpcyByZXF1aXJlZC4gVGhlXG5cdFx0ICogcGFyYW1ldGVycyBhcmU6XG5cdFx0ICpcblx0XHQgKiAxLiBfb2JqZWN0XyAtIERhdGEgdG8gc2VuZCB0byB0aGUgc2VydmVyXG5cdFx0ICogMi4gX2Z1bmN0aW9uXyAtIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgbXVzdCBiZSBleGVjdXRlZCB3aGVuIHRoZSByZXF1aXJlZFxuXHRcdCAqICAgIGRhdGEgaGFzIGJlZW4gb2J0YWluZWQuIFRoYXQgZGF0YSBzaG91bGQgYmUgcGFzc2VkIGludG8gdGhlIGNhbGxiYWNrXG5cdFx0ICogICAgYXMgdGhlIG9ubHkgcGFyYW1ldGVyXG5cdFx0ICogMy4gX29iamVjdF8gLSBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdCBmb3IgdGhlIHRhYmxlXG5cdFx0ICpcblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBzdXBlcnNlZGVzIGBmblNlcnZlckRhdGFgIGZyb20gRGF0YVRhYmxlcyAxLjktLlxuXHRcdCAqXG5cdFx0ICogIEB0eXBlIHN0cmluZ3xvYmplY3R8ZnVuY3Rpb25cblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25cblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmFqYXhcblx0XHQgKiAgQHNpbmNlIDEuMTAuMFxuXHRcdCAqXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAgIC8vIEdldCBKU09OIGRhdGEgZnJvbSBhIGZpbGUgdmlhIEFqYXguXG5cdFx0ICogICAvLyBOb3RlIERhdGFUYWJsZXMgZXhwZWN0cyBkYXRhIGluIHRoZSBmb3JtIGB7IGRhdGE6IFsgLi4uZGF0YS4uLiBdIH1gIGJ5IGRlZmF1bHQpLlxuXHRcdCAqICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgXCJhamF4XCI6IFwiZGF0YS5qc29uXCJcblx0XHQgKiAgIH0gKTtcblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogICAvLyBHZXQgSlNPTiBkYXRhIGZyb20gYSBmaWxlIHZpYSBBamF4LCB1c2luZyBgZGF0YVNyY2AgdG8gY2hhbmdlXG5cdFx0ICogICAvLyBgZGF0YWAgdG8gYHRhYmxlRGF0YWAgKGkuZS4gYHsgdGFibGVEYXRhOiBbIC4uLmRhdGEuLi4gXSB9YClcblx0XHQgKiAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgIFwiYWpheFwiOiB7XG5cdFx0ICogICAgICAgXCJ1cmxcIjogXCJkYXRhLmpzb25cIixcblx0XHQgKiAgICAgICBcImRhdGFTcmNcIjogXCJ0YWJsZURhdGFcIlxuXHRcdCAqICAgICB9XG5cdFx0ICogICB9ICk7XG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqICAgLy8gR2V0IEpTT04gZGF0YSBmcm9tIGEgZmlsZSB2aWEgQWpheCwgdXNpbmcgYGRhdGFTcmNgIHRvIHJlYWQgZGF0YVxuXHRcdCAqICAgLy8gZnJvbSBhIHBsYWluIGFycmF5IHJhdGhlciB0aGFuIGFuIGFycmF5IGluIGFuIG9iamVjdFxuXHRcdCAqICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgXCJhamF4XCI6IHtcblx0XHQgKiAgICAgICBcInVybFwiOiBcImRhdGEuanNvblwiLFxuXHRcdCAqICAgICAgIFwiZGF0YVNyY1wiOiBcIlwiXG5cdFx0ICogICAgIH1cblx0XHQgKiAgIH0gKTtcblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogICAvLyBNYW5pcHVsYXRlIHRoZSBkYXRhIHJldHVybmVkIGZyb20gdGhlIHNlcnZlciAtIGFkZCBhIGxpbmsgdG8gZGF0YVxuXHRcdCAqICAgLy8gKG5vdGUgdGhpcyBjYW4sIHNob3VsZCwgYmUgZG9uZSB1c2luZyBgcmVuZGVyYCBmb3IgdGhlIGNvbHVtbiAtIHRoaXNcblx0XHQgKiAgIC8vIGlzIGp1c3QgYSBzaW1wbGUgZXhhbXBsZSBvZiBob3cgdGhlIGRhdGEgY2FuIGJlIG1hbmlwdWxhdGVkKS5cblx0XHQgKiAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgIFwiYWpheFwiOiB7XG5cdFx0ICogICAgICAgXCJ1cmxcIjogXCJkYXRhLmpzb25cIixcblx0XHQgKiAgICAgICBcImRhdGFTcmNcIjogZnVuY3Rpb24gKCBqc29uICkge1xuXHRcdCAqICAgICAgICAgZm9yICggdmFyIGk9MCwgaWVuPWpzb24ubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0ICogICAgICAgICAgIGpzb25baV1bMF0gPSAnPGEgaHJlZj1cIi9tZXNzYWdlLycranNvbltpXVswXSsnPlZpZXcgbWVzc2FnZTwvYT4nO1xuXHRcdCAqICAgICAgICAgfVxuXHRcdCAqICAgICAgICAgcmV0dXJuIGpzb247XG5cdFx0ICogICAgICAgfVxuXHRcdCAqICAgICB9XG5cdFx0ICogICB9ICk7XG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqICAgLy8gQWRkIGRhdGEgdG8gdGhlIHJlcXVlc3Rcblx0XHQgKiAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgIFwiYWpheFwiOiB7XG5cdFx0ICogICAgICAgXCJ1cmxcIjogXCJkYXRhLmpzb25cIixcblx0XHQgKiAgICAgICBcImRhdGFcIjogZnVuY3Rpb24gKCBkICkge1xuXHRcdCAqICAgICAgICAgcmV0dXJuIHtcblx0XHQgKiAgICAgICAgICAgXCJleHRyYV9zZWFyY2hcIjogJCgnI2V4dHJhJykudmFsKClcblx0XHQgKiAgICAgICAgIH07XG5cdFx0ICogICAgICAgfVxuXHRcdCAqICAgICB9XG5cdFx0ICogICB9ICk7XG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqICAgLy8gU2VuZCByZXF1ZXN0IGFzIFBPU1Rcblx0XHQgKiAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgIFwiYWpheFwiOiB7XG5cdFx0ICogICAgICAgXCJ1cmxcIjogXCJkYXRhLmpzb25cIixcblx0XHQgKiAgICAgICBcInR5cGVcIjogXCJQT1NUXCJcblx0XHQgKiAgICAgfVxuXHRcdCAqICAgfSApO1xuXHRcdCAqXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAgIC8vIEdldCB0aGUgZGF0YSBmcm9tIGxvY2FsU3RvcmFnZSAoY291bGQgaW50ZXJmYWNlIHdpdGggYSBmb3JtIGZvclxuXHRcdCAqICAgLy8gYWRkaW5nLCBlZGl0aW5nIGFuZCByZW1vdmluZyByb3dzKS5cblx0XHQgKiAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgIFwiYWpheFwiOiBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2ssIHNldHRpbmdzKSB7XG5cdFx0ICogICAgICAgY2FsbGJhY2soXG5cdFx0ICogICAgICAgICBKU09OLnBhcnNlKCBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnZGF0YVRhYmxlc0RhdGEnKSApXG5cdFx0ICogICAgICAgKTtcblx0XHQgKiAgICAgfVxuXHRcdCAqICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYWpheFwiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhpcyBwYXJhbWV0ZXIgYWxsb3dzIHlvdSB0byByZWFkaWx5IHNwZWNpZnkgdGhlIGVudHJpZXMgaW4gdGhlIGxlbmd0aCBkcm9wXG5cdFx0ICogZG93biBtZW51IHRoYXQgRGF0YVRhYmxlcyBzaG93cyB3aGVuIHBhZ2luYXRpb24gaXMgZW5hYmxlZC4gSXQgY2FuIGJlXG5cdFx0ICogZWl0aGVyIGEgMUQgYXJyYXkgb2Ygb3B0aW9ucyB3aGljaCB3aWxsIGJlIHVzZWQgZm9yIGJvdGggdGhlIGRpc3BsYXllZFxuXHRcdCAqIG9wdGlvbiBhbmQgdGhlIHZhbHVlLCBvciBhIDJEIGFycmF5IHdoaWNoIHdpbGwgdXNlIHRoZSBhcnJheSBpbiB0aGUgZmlyc3Rcblx0XHQgKiBwb3NpdGlvbiBhcyB0aGUgdmFsdWUsIGFuZCB0aGUgYXJyYXkgaW4gdGhlIHNlY29uZCBwb3NpdGlvbiBhcyB0aGVcblx0XHQgKiBkaXNwbGF5ZWQgb3B0aW9ucyAodXNlZnVsIGZvciBsYW5ndWFnZSBzdHJpbmdzIHN1Y2ggYXMgJ0FsbCcpLlxuXHRcdCAqXG5cdFx0ICogTm90ZSB0aGF0IHRoZSBgcGFnZUxlbmd0aGAgcHJvcGVydHkgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHNldCB0byB0aGVcblx0XHQgKiBmaXJzdCB2YWx1ZSBnaXZlbiBpbiB0aGlzIGFycmF5LCB1bmxlc3MgYHBhZ2VMZW5ndGhgIGlzIGFsc28gcHJvdmlkZWQuXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFsgMTAsIDI1LCA1MCwgMTAwIF1cblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sZW5ndGhNZW51XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImxlbmd0aE1lbnVcIjogW1sxMCwgMjUsIDUwLCAtMV0sIFsxMCwgMjUsIDUwLCBcIkFsbFwiXV1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJhTGVuZ3RoTWVudVwiOiBbIDEwLCAyNSwgNTAsIDEwMCBdLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGBjb2x1bW5zYCBvcHRpb24gaW4gdGhlIGluaXRpYWxpc2F0aW9uIHBhcmFtZXRlciBhbGxvd3MgeW91IHRvIGRlZmluZVxuXHRcdCAqIGRldGFpbHMgYWJvdXQgdGhlIHdheSBpbmRpdmlkdWFsIGNvbHVtbnMgYmVoYXZlLiBGb3IgYSBmdWxsIGxpc3Qgb2Zcblx0XHQgKiBjb2x1bW4gb3B0aW9ucyB0aGF0IGNhbiBiZSBzZXQsIHBsZWFzZSBzZWVcblx0XHQgKiB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbn0uIE5vdGUgdGhhdCBpZiB5b3UgdXNlIGBjb2x1bW5zYCB0b1xuXHRcdCAqIGRlZmluZSB5b3VyIGNvbHVtbnMsIHlvdSBtdXN0IGhhdmUgYW4gZW50cnkgaW4gdGhlIGFycmF5IGZvciBldmVyeSBzaW5nbGVcblx0XHQgKiBjb2x1bW4gdGhhdCB5b3UgaGF2ZSBpbiB5b3VyIHRhYmxlICh0aGVzZSBjYW4gYmUgbnVsbCBpZiB5b3UgZG9uJ3Qgd2hpY2hcblx0XHQgKiB0byBzcGVjaWZ5IGFueSBvcHRpb25zKS5cblx0XHQgKiAgQG1lbWJlclxuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW5cblx0XHQgKi9cblx0XHRcImFvQ29sdW1uc1wiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBWZXJ5IHNpbWlsYXIgdG8gYGNvbHVtbnNgLCBgY29sdW1uRGVmc2AgYWxsb3dzIHlvdSB0byB0YXJnZXQgYSBzcGVjaWZpY1xuXHRcdCAqIGNvbHVtbiwgbXVsdGlwbGUgY29sdW1ucywgb3IgYWxsIGNvbHVtbnMsIHVzaW5nIHRoZSBgdGFyZ2V0c2AgcHJvcGVydHkgb2Zcblx0XHQgKiBlYWNoIG9iamVjdCBpbiB0aGUgYXJyYXkuIFRoaXMgYWxsb3dzIGdyZWF0IGZsZXhpYmlsaXR5IHdoZW4gY3JlYXRpbmdcblx0XHQgKiB0YWJsZXMsIGFzIHRoZSBgY29sdW1uRGVmc2AgYXJyYXlzIGNhbiBiZSBvZiBhbnkgbGVuZ3RoLCB0YXJnZXRpbmcgdGhlXG5cdFx0ICogY29sdW1ucyB5b3Ugc3BlY2lmaWNhbGx5IHdhbnQuIGBjb2x1bW5EZWZzYCBtYXkgdXNlIGFueSBvZiB0aGUgY29sdW1uXG5cdFx0ICogb3B0aW9ucyBhdmFpbGFibGU6IHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1ufSwgYnV0IGl0IF9tdXN0X1xuXHRcdCAqIGhhdmUgYHRhcmdldHNgIGRlZmluZWQgaW4gZWFjaCBvYmplY3QgaW4gdGhlIGFycmF5LiBWYWx1ZXMgaW4gdGhlIGB0YXJnZXRzYFxuXHRcdCAqIGFycmF5IG1heSBiZTpcblx0XHQgKiAgIDx1bD5cblx0XHQgKiAgICAgPGxpPmEgc3RyaW5nIC0gY2xhc3MgbmFtZSB3aWxsIGJlIG1hdGNoZWQgb24gdGhlIFRIIGZvciB0aGUgY29sdW1uPC9saT5cblx0XHQgKiAgICAgPGxpPjAgb3IgYSBwb3NpdGl2ZSBpbnRlZ2VyIC0gY29sdW1uIGluZGV4IGNvdW50aW5nIGZyb20gdGhlIGxlZnQ8L2xpPlxuXHRcdCAqICAgICA8bGk+YSBuZWdhdGl2ZSBpbnRlZ2VyIC0gY29sdW1uIGluZGV4IGNvdW50aW5nIGZyb20gdGhlIHJpZ2h0PC9saT5cblx0XHQgKiAgICAgPGxpPnRoZSBzdHJpbmcgXCJfYWxsXCIgLSBhbGwgY29sdW1ucyAoaS5lLiBhc3NpZ24gYSBkZWZhdWx0KTwvbGk+XG5cdFx0ICogICA8L3VsPlxuXHRcdCAqICBAbWVtYmVyXG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbkRlZnNcblx0XHQgKi9cblx0XHRcImFvQ29sdW1uRGVmc1wiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogQmFzaWNhbGx5IHRoZSBzYW1lIGFzIGBzZWFyY2hgLCB0aGlzIHBhcmFtZXRlciBkZWZpbmVzIHRoZSBpbmRpdmlkdWFsIGNvbHVtblxuXHRcdCAqIGZpbHRlcmluZyBzdGF0ZSBhdCBpbml0aWFsaXNhdGlvbiB0aW1lLiBUaGUgYXJyYXkgbXVzdCBiZSBvZiB0aGUgc2FtZSBzaXplXG5cdFx0ICogYXMgdGhlIG51bWJlciBvZiBjb2x1bW5zLCBhbmQgZWFjaCBlbGVtZW50IGJlIGFuIG9iamVjdCB3aXRoIHRoZSBwYXJhbWV0ZXJzXG5cdFx0ICogYHNlYXJjaGAgYW5kIGBlc2NhcGVSZWdleGAgKHRoZSBsYXR0ZXIgaXMgb3B0aW9uYWwpLiAnbnVsbCcgaXMgYWxzb1xuXHRcdCAqIGFjY2VwdGVkIGFuZCB0aGUgZGVmYXVsdCB3aWxsIGJlIHVzZWQuXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvblxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2VhcmNoQ29sc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzZWFyY2hDb2xzXCI6IFtcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIHsgXCJzZWFyY2hcIjogXCJNeSBmaWx0ZXJcIiB9LFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgeyBcInNlYXJjaFwiOiBcIl5bMC05XVwiLCBcImVzY2FwZVJlZ2V4XCI6IGZhbHNlIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKVxuXHRcdCAqL1xuXHRcdFwiYW9TZWFyY2hDb2xzXCI6IFtdLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogQW4gYXJyYXkgb2YgQ1NTIGNsYXNzZXMgdGhhdCBzaG91bGQgYmUgYXBwbGllZCB0byBkaXNwbGF5ZWQgcm93cy4gVGhpc1xuXHRcdCAqIGFycmF5IG1heSBiZSBvZiBhbnkgbGVuZ3RoLCBhbmQgRGF0YVRhYmxlcyB3aWxsIGFwcGx5IGVhY2ggY2xhc3Ncblx0XHQgKiBzZXF1ZW50aWFsbHksIGxvb3Bpbmcgd2hlbiByZXF1aXJlZC5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgbnVsbCA8aT5XaWxsIHRha2UgdGhlIHZhbHVlcyBkZXRlcm1pbmVkIGJ5IHRoZSBgb0NsYXNzZXMuc3RyaXBlKmBcblx0XHQgKiAgICBvcHRpb25zPC9pPlxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25cblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnN0cmlwZUNsYXNzZXNcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwic3RyaXBlQ2xhc3Nlc1wiOiBbICdzdHJpcDEnLCAnc3RyaXAyJywgJ3N0cmlwMycgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKVxuXHRcdCAqL1xuXHRcdFwiYXNTdHJpcGVDbGFzc2VzXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBFbmFibGUgb3IgZGlzYWJsZSBhdXRvbWF0aWMgY29sdW1uIHdpZHRoIGNhbGN1bGF0aW9uLiBUaGlzIGNhbiBiZSBkaXNhYmxlZFxuXHRcdCAqIGFzIGFuIG9wdGltaXNhdGlvbiAoaXQgdGFrZXMgc29tZSB0aW1lIHRvIGNhbGN1bGF0ZSB0aGUgd2lkdGhzKSBpZiB0aGVcblx0XHQgKiB0YWJsZXMgd2lkdGhzIGFyZSBwYXNzZWQgaW4gdXNpbmcgYGNvbHVtbnNgLlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IHRydWVcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgRmVhdHVyZXNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmF1dG9XaWR0aFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uICgpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiYXV0b1dpZHRoXCI6IGZhbHNlXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYkF1dG9XaWR0aFwiOiB0cnVlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRGVmZXJyZWQgcmVuZGVyaW5nIGNhbiBwcm92aWRlIERhdGFUYWJsZXMgd2l0aCBhIGh1Z2Ugc3BlZWQgYm9vc3Qgd2hlbiB5b3Vcblx0XHQgKiBhcmUgdXNpbmcgYW4gQWpheCBvciBKUyBkYXRhIHNvdXJjZSBmb3IgdGhlIHRhYmxlLiBUaGlzIG9wdGlvbiwgd2hlbiBzZXQgdG9cblx0XHQgKiB0cnVlLCB3aWxsIGNhdXNlIERhdGFUYWJsZXMgdG8gZGVmZXIgdGhlIGNyZWF0aW9uIG9mIHRoZSB0YWJsZSBlbGVtZW50cyBmb3Jcblx0XHQgKiBlYWNoIHJvdyB1bnRpbCB0aGV5IGFyZSBuZWVkZWQgZm9yIGEgZHJhdyAtIHNhdmluZyBhIHNpZ25pZmljYW50IGFtb3VudCBvZlxuXHRcdCAqIHRpbWUuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgRmVhdHVyZXNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmRlZmVyUmVuZGVyXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImFqYXhcIjogXCJzb3VyY2VzL2FycmF5cy50eHRcIixcblx0XHQgKiAgICAgICAgXCJkZWZlclJlbmRlclwiOiB0cnVlXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYkRlZmVyUmVuZGVyXCI6IGZhbHNlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogUmVwbGFjZSBhIERhdGFUYWJsZSB3aGljaCBtYXRjaGVzIHRoZSBnaXZlbiBzZWxlY3RvciBhbmQgcmVwbGFjZSBpdCB3aXRoXG5cdFx0ICogb25lIHdoaWNoIGhhcyB0aGUgcHJvcGVydGllcyBvZiB0aGUgbmV3IGluaXRpYWxpc2F0aW9uIG9iamVjdCBwYXNzZWQuIElmIG5vXG5cdFx0ICogdGFibGUgbWF0Y2hlcyB0aGUgc2VsZWN0b3IsIHRoZW4gdGhlIG5ldyBEYXRhVGFibGUgd2lsbCBiZSBjb25zdHJ1Y3RlZCBhc1xuXHRcdCAqIHBlciBub3JtYWwuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuZGVzdHJveVxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzcm9sbFlcIjogXCIyMDBweFwiLFxuXHRcdCAqICAgICAgICBcInBhZ2luYXRlXCI6IGZhbHNlXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgICAgIC8vIFNvbWUgdGltZSBsYXRlci4uLi5cblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiZmlsdGVyXCI6IGZhbHNlLFxuXHRcdCAqICAgICAgICBcImRlc3Ryb3lcIjogdHJ1ZVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImJEZXN0cm95XCI6IGZhbHNlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRW5hYmxlIG9yIGRpc2FibGUgZmlsdGVyaW5nIG9mIGRhdGEuIEZpbHRlcmluZyBpbiBEYXRhVGFibGVzIGlzIFwic21hcnRcIiBpblxuXHRcdCAqIHRoYXQgaXQgYWxsb3dzIHRoZSBlbmQgdXNlciB0byBpbnB1dCBtdWx0aXBsZSB3b3JkcyAoc3BhY2Ugc2VwYXJhdGVkKSBhbmRcblx0XHQgKiB3aWxsIG1hdGNoIGEgcm93IGNvbnRhaW5pbmcgdGhvc2Ugd29yZHMsIGV2ZW4gaWYgbm90IGluIHRoZSBvcmRlciB0aGF0IHdhc1xuXHRcdCAqIHNwZWNpZmllZCAodGhpcyBhbGxvdyBtYXRjaGluZyBhY3Jvc3MgbXVsdGlwbGUgY29sdW1ucykuIE5vdGUgdGhhdCBpZiB5b3Vcblx0XHQgKiB3aXNoIHRvIHVzZSBmaWx0ZXJpbmcgaW4gRGF0YVRhYmxlcyB0aGlzIG11c3QgcmVtYWluICd0cnVlJyAtIHRvIHJlbW92ZSB0aGVcblx0XHQgKiBkZWZhdWx0IGZpbHRlcmluZyBpbnB1dCBib3ggYW5kIHJldGFpbiBmaWx0ZXJpbmcgYWJpbGl0aWVzLCBwbGVhc2UgdXNlXG5cdFx0ICoge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0cy5kb219LlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IHRydWVcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgRmVhdHVyZXNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNlYXJjaGluZ1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uICgpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwic2VhcmNoaW5nXCI6IGZhbHNlXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYkZpbHRlclwiOiB0cnVlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRW5hYmxlIG9yIGRpc2FibGUgdGhlIHRhYmxlIGluZm9ybWF0aW9uIGRpc3BsYXkuIFRoaXMgc2hvd3MgaW5mb3JtYXRpb25cblx0XHQgKiBhYm91dCB0aGUgZGF0YSB0aGF0IGlzIGN1cnJlbnRseSB2aXNpYmxlIG9uIHRoZSBwYWdlLCBpbmNsdWRpbmcgaW5mb3JtYXRpb25cblx0XHQgKiBhYm91dCBmaWx0ZXJlZCBkYXRhIGlmIHRoYXQgYWN0aW9uIGlzIGJlaW5nIHBlcmZvcm1lZC5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCB0cnVlXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IEZlYXR1cmVzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5pbmZvXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJpbmZvXCI6IGZhbHNlXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYkluZm9cIjogdHJ1ZSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEVuYWJsZSBqUXVlcnkgVUkgVGhlbWVSb2xsZXIgc3VwcG9ydCAocmVxdWlyZWQgYXMgVGhlbWVSb2xsZXIgcmVxdWlyZXMgc29tZVxuXHRcdCAqIHNsaWdodGx5IGRpZmZlcmVudCBhbmQgYWRkaXRpb25hbCBtYXJrLXVwIGZyb20gd2hhdCBEYXRhVGFibGVzIGhhc1xuXHRcdCAqIHRyYWRpdGlvbmFsbHkgdXNlZCkuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgRmVhdHVyZXNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmpRdWVyeVVJXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImpRdWVyeVVJXCI6IHRydWVcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJiSlF1ZXJ5VUlcIjogZmFsc2UsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBBbGxvd3MgdGhlIGVuZCB1c2VyIHRvIHNlbGVjdCB0aGUgc2l6ZSBvZiBhIGZvcm1hdHRlZCBwYWdlIGZyb20gYSBzZWxlY3Rcblx0XHQgKiBtZW51IChzaXplcyBhcmUgMTAsIDI1LCA1MCBhbmQgMTAwKS4gUmVxdWlyZXMgcGFnaW5hdGlvbiAoYHBhZ2luYXRlYCkuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBGZWF0dXJlc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGVuZ3RoQ2hhbmdlXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJsZW5ndGhDaGFuZ2VcIjogZmFsc2Vcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJiTGVuZ3RoQ2hhbmdlXCI6IHRydWUsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBFbmFibGUgb3IgZGlzYWJsZSBwYWdpbmF0aW9uLlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IHRydWVcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgRmVhdHVyZXNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnBhZ2luZ1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uICgpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwicGFnaW5nXCI6IGZhbHNlXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYlBhZ2luYXRlXCI6IHRydWUsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBFbmFibGUgb3IgZGlzYWJsZSB0aGUgZGlzcGxheSBvZiBhICdwcm9jZXNzaW5nJyBpbmRpY2F0b3Igd2hlbiB0aGUgdGFibGUgaXNcblx0XHQgKiBiZWluZyBwcm9jZXNzZWQgKGUuZy4gYSBzb3J0KS4gVGhpcyBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciB0YWJsZXMgd2l0aFxuXHRcdCAqIGxhcmdlIGFtb3VudHMgb2YgZGF0YSB3aGVyZSBpdCBjYW4gdGFrZSBhIG5vdGljZWFibGUgYW1vdW50IG9mIHRpbWUgdG8gc29ydFxuXHRcdCAqIHRoZSBlbnRyaWVzLlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IEZlYXR1cmVzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5wcm9jZXNzaW5nXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJwcm9jZXNzaW5nXCI6IHRydWVcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJiUHJvY2Vzc2luZ1wiOiBmYWxzZSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFJldHJpZXZlIHRoZSBEYXRhVGFibGVzIG9iamVjdCBmb3IgdGhlIGdpdmVuIHNlbGVjdG9yLiBOb3RlIHRoYXQgaWYgdGhlXG5cdFx0ICogdGFibGUgaGFzIGFscmVhZHkgYmVlbiBpbml0aWFsaXNlZCwgdGhpcyBwYXJhbWV0ZXIgd2lsbCBjYXVzZSBEYXRhVGFibGVzXG5cdFx0ICogdG8gc2ltcGx5IHJldHVybiB0aGUgb2JqZWN0IHRoYXQgaGFzIGFscmVhZHkgYmVlbiBzZXQgdXAgLSBpdCB3aWxsIG5vdCB0YWtlXG5cdFx0ICogYWNjb3VudCBvZiBhbnkgY2hhbmdlcyB5b3UgbWlnaHQgaGF2ZSBtYWRlIHRvIHRoZSBpbml0aWFsaXNhdGlvbiBvYmplY3Rcblx0XHQgKiBwYXNzZWQgdG8gRGF0YVRhYmxlcyAoc2V0dGluZyB0aGlzIHBhcmFtZXRlciB0byB0cnVlIGlzIGFuIGFja25vd2xlZGdlbWVudFxuXHRcdCAqIHRoYXQgeW91IHVuZGVyc3RhbmQgdGhpcykuIGBkZXN0cm95YCBjYW4gYmUgdXNlZCB0byByZWluaXRpYWxpc2UgYSB0YWJsZSBpZlxuXHRcdCAqIHlvdSBuZWVkLlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnJldHJpZXZlXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICBpbml0VGFibGUoKTtcblx0XHQgKiAgICAgIHRhYmxlQWN0aW9ucygpO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICAgIGZ1bmN0aW9uIGluaXRUYWJsZSAoKVxuXHRcdCAqICAgIHtcblx0XHQgKiAgICAgIHJldHVybiAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInNjcm9sbFlcIjogXCIyMDBweFwiLFxuXHRcdCAqICAgICAgICBcInBhZ2luYXRlXCI6IGZhbHNlLFxuXHRcdCAqICAgICAgICBcInJldHJpZXZlXCI6IHRydWVcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9XG5cdFx0ICpcblx0XHQgKiAgICBmdW5jdGlvbiB0YWJsZUFjdGlvbnMgKClcblx0XHQgKiAgICB7XG5cdFx0ICogICAgICB2YXIgdGFibGUgPSBpbml0VGFibGUoKTtcblx0XHQgKiAgICAgIC8vIHBlcmZvcm0gQVBJIG9wZXJhdGlvbnMgd2l0aCBvVGFibGVcblx0XHQgKiAgICB9XG5cdFx0ICovXG5cdFx0XCJiUmV0cmlldmVcIjogZmFsc2UsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBXaGVuIHZlcnRpY2FsICh5KSBzY3JvbGxpbmcgaXMgZW5hYmxlZCwgRGF0YVRhYmxlcyB3aWxsIGZvcmNlIHRoZSBoZWlnaHQgb2Zcblx0XHQgKiB0aGUgdGFibGUncyB2aWV3cG9ydCB0byB0aGUgZ2l2ZW4gaGVpZ2h0IGF0IGFsbCB0aW1lcyAodXNlZnVsIGZvciBsYXlvdXQpLlxuXHRcdCAqIEhvd2V2ZXIsIHRoaXMgY2FuIGxvb2sgb2RkIHdoZW4gZmlsdGVyaW5nIGRhdGEgZG93biB0byBhIHNtYWxsIGRhdGEgc2V0LFxuXHRcdCAqIGFuZCB0aGUgZm9vdGVyIGlzIGxlZnQgXCJmbG9hdGluZ1wiIGZ1cnRoZXIgZG93bi4gVGhpcyBwYXJhbWV0ZXIgKHdoZW5cblx0XHQgKiBlbmFibGVkKSB3aWxsIGNhdXNlIERhdGFUYWJsZXMgdG8gY29sbGFwc2UgdGhlIHRhYmxlJ3Mgdmlld3BvcnQgZG93biB3aGVuXG5cdFx0ICogdGhlIHJlc3VsdCBzZXQgd2lsbCBmaXQgd2l0aGluIHRoZSBnaXZlbiBZIGhlaWdodC5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25zXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zY3JvbGxDb2xsYXBzZVxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzY3JvbGxZXCI6IFwiMjAwXCIsXG5cdFx0ICogICAgICAgIFwic2Nyb2xsQ29sbGFwc2VcIjogdHJ1ZVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImJTY3JvbGxDb2xsYXBzZVwiOiBmYWxzZSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIENvbmZpZ3VyZSBEYXRhVGFibGVzIHRvIHVzZSBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nLiBOb3RlIHRoYXQgdGhlXG5cdFx0ICogYGFqYXhgIHBhcmFtZXRlciBtdXN0IGFsc28gYmUgZ2l2ZW4gaW4gb3JkZXIgdG8gZ2l2ZSBEYXRhVGFibGVzIGFcblx0XHQgKiBzb3VyY2UgdG8gb2J0YWluIHRoZSByZXF1aXJlZCBkYXRhIGZvciBlYWNoIGRyYXcuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgRmVhdHVyZXNcblx0XHQgKiAgQGR0b3B0IFNlcnZlci1zaWRlXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zZXJ2ZXJTaWRlXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzZXJ2ZXJTaWRlXCI6IHRydWUsXG5cdFx0ICogICAgICAgIFwiYWpheFwiOiBcInhoci5waHBcIlxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImJTZXJ2ZXJTaWRlXCI6IGZhbHNlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRW5hYmxlIG9yIGRpc2FibGUgc29ydGluZyBvZiBjb2x1bW5zLiBTb3J0aW5nIG9mIGluZGl2aWR1YWwgY29sdW1ucyBjYW4gYmVcblx0XHQgKiBkaXNhYmxlZCBieSB0aGUgYHNvcnRhYmxlYCBvcHRpb24gZm9yIGVhY2ggY29sdW1uLlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IHRydWVcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgRmVhdHVyZXNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLm9yZGVyaW5nXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJvcmRlcmluZ1wiOiBmYWxzZVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImJTb3J0XCI6IHRydWUsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBFbmFibGUgb3IgZGlzcGxheSBEYXRhVGFibGVzJyBhYmlsaXR5IHRvIHNvcnQgbXVsdGlwbGUgY29sdW1ucyBhdCB0aGVcblx0XHQgKiBzYW1lIHRpbWUgKGFjdGl2YXRlZCBieSBzaGlmdC1jbGljayBieSB0aGUgdXNlcikuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25zXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5vcmRlck11bHRpXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBEaXNhYmxlIG11bHRpcGxlIGNvbHVtbiBzb3J0aW5nIGFiaWxpdHlcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJvcmRlck11bHRpXCI6IGZhbHNlXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYlNvcnRNdWx0aVwiOiB0cnVlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogQWxsb3dzIGNvbnRyb2wgb3ZlciB3aGV0aGVyIERhdGFUYWJsZXMgc2hvdWxkIHVzZSB0aGUgdG9wICh0cnVlKSB1bmlxdWVcblx0XHQgKiBjZWxsIHRoYXQgaXMgZm91bmQgZm9yIGEgc2luZ2xlIGNvbHVtbiwgb3IgdGhlIGJvdHRvbSAoZmFsc2UgLSBkZWZhdWx0KS5cblx0XHQgKiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHVzaW5nIGNvbXBsZXggaGVhZGVycy5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25zXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5vcmRlckNlbGxzVG9wXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcIm9yZGVyQ2VsbHNUb3BcIjogdHJ1ZVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImJTb3J0Q2VsbHNUb3BcIjogZmFsc2UsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBFbmFibGUgb3IgZGlzYWJsZSB0aGUgYWRkaXRpb24gb2YgdGhlIGNsYXNzZXMgYHNvcnRpbmdcXF8xYCwgYHNvcnRpbmdcXF8yYCBhbmRcblx0XHQgKiBgc29ydGluZ1xcXzNgIHRvIHRoZSBjb2x1bW5zIHdoaWNoIGFyZSBjdXJyZW50bHkgYmVpbmcgc29ydGVkIG9uLiBUaGlzIGlzXG5cdFx0ICogcHJlc2VudGVkIGFzIGEgZmVhdHVyZSBzd2l0Y2ggYXMgaXQgY2FuIGluY3JlYXNlIHByb2Nlc3NpbmcgdGltZSAod2hpbGVcblx0XHQgKiBjbGFzc2VzIGFyZSByZW1vdmVkIGFuZCBhZGRlZCkgc28gZm9yIGxhcmdlIGRhdGEgc2V0cyB5b3UgbWlnaHQgd2FudCB0b1xuXHRcdCAqIHR1cm4gdGhpcyBvZmYuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBGZWF0dXJlc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMub3JkZXJDbGFzc2VzXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJvcmRlckNsYXNzZXNcIjogZmFsc2Vcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJiU29ydENsYXNzZXNcIjogdHJ1ZSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEVuYWJsZSBvciBkaXNhYmxlIHN0YXRlIHNhdmluZy4gV2hlbiBlbmFibGVkIEhUTUw1IGBsb2NhbFN0b3JhZ2VgIHdpbGwgYmVcblx0XHQgKiB1c2VkIHRvIHNhdmUgdGFibGUgZGlzcGxheSBpbmZvcm1hdGlvbiBzdWNoIGFzIHBhZ2luYXRpb24gaW5mb3JtYXRpb24sXG5cdFx0ICogZGlzcGxheSBsZW5ndGgsIGZpbHRlcmluZyBhbmQgc29ydGluZy4gQXMgc3VjaCB3aGVuIHRoZSBlbmQgdXNlciByZWxvYWRzXG5cdFx0ICogdGhlIHBhZ2UgdGhlIGRpc3BsYXkgZGlzcGxheSB3aWxsIG1hdGNoIHdoYXQgdGh5IGhhZCBwcmV2aW91c2x5IHNldCB1cC5cblx0XHQgKlxuXHRcdCAqIER1ZSB0byB0aGUgdXNlIG9mIGBsb2NhbFN0b3JhZ2VgIHRoZSBkZWZhdWx0IHN0YXRlIHNhdmluZyBpcyBub3Qgc3VwcG9ydGVkXG5cdFx0ICogaW4gSUU2IG9yIDcuIElmIHN0YXRlIHNhdmluZyBpcyByZXF1aXJlZCBpbiB0aG9zZSBicm93c2VycywgdXNlXG5cdFx0ICogYHN0YXRlU2F2ZUNhbGxiYWNrYCB0byBwcm92aWRlIGEgc3RvcmFnZSBzb2x1dGlvbiBzdWNoIGFzIGNvb2tpZXMuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgRmVhdHVyZXNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnN0YXRlU2F2ZVxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uICgpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwic3RhdGVTYXZlXCI6IHRydWVcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJiU3RhdGVTYXZlXCI6IGZhbHNlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiBhIFRSIGVsZW1lbnQgaXMgY3JlYXRlZCAoYW5kIGFsbCBURCBjaGlsZFxuXHRcdCAqIGVsZW1lbnRzIGhhdmUgYmVlbiBpbnNlcnRlZCksIG9yIHJlZ2lzdGVyZWQgaWYgdXNpbmcgYSBET00gc291cmNlLCBhbGxvd2luZ1xuXHRcdCAqIG1hbmlwdWxhdGlvbiBvZiB0aGUgVFIgZWxlbWVudCAoYWRkaW5nIGNsYXNzZXMgZXRjKS5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQHBhcmFtIHtub2RlfSByb3cgXCJUUlwiIGVsZW1lbnQgZm9yIHRoZSBjdXJyZW50IHJvd1xuXHRcdCAqICBAcGFyYW0ge2FycmF5fSBkYXRhIFJhdyBkYXRhIGFycmF5IGZvciB0aGlzIHJvd1xuXHRcdCAqICBAcGFyYW0ge2ludH0gZGF0YUluZGV4IFRoZSBpbmRleCBvZiB0aGlzIHJvdyBpbiB0aGUgaW50ZXJuYWwgYW9EYXRhIGFycmF5XG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IENhbGxiYWNrc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY3JlYXRlZFJvd1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjcmVhdGVkUm93XCI6IGZ1bmN0aW9uKCByb3csIGRhdGEsIGRhdGFJbmRleCApIHtcblx0XHQgKiAgICAgICAgICAvLyBCb2xkIHRoZSBncmFkZSBmb3IgYWxsICdBJyBncmFkZSBicm93c2Vyc1xuXHRcdCAqICAgICAgICAgIGlmICggZGF0YVs0XSA9PSBcIkFcIiApXG5cdFx0ICogICAgICAgICAge1xuXHRcdCAqICAgICAgICAgICAgJCgndGQ6ZXEoNCknLCByb3cpLmh0bWwoICc8Yj5BPC9iPicgKTtcblx0XHQgKiAgICAgICAgICB9XG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJmbkNyZWF0ZWRSb3dcIjogbnVsbCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGV2ZXJ5ICdkcmF3JyBldmVudCwgYW5kIGFsbG93cyB5b3UgdG9cblx0XHQgKiBkeW5hbWljYWxseSBtb2RpZnkgYW55IGFzcGVjdCB5b3Ugd2FudCBhYm91dCB0aGUgY3JlYXRlZCBET00uXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBDYWxsYmFja3Ncblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmRyYXdDYWxsYmFja1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJkcmF3Q2FsbGJhY2tcIjogZnVuY3Rpb24oIHNldHRpbmdzICkge1xuXHRcdCAqICAgICAgICAgIGFsZXJ0KCAnRGF0YVRhYmxlcyBoYXMgcmVkcmF3biB0aGUgdGFibGUnICk7XG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJmbkRyYXdDYWxsYmFja1wiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogSWRlbnRpY2FsIHRvIGZuSGVhZGVyQ2FsbGJhY2soKSBidXQgZm9yIHRoZSB0YWJsZSBmb290ZXIgdGhpcyBmdW5jdGlvblxuXHRcdCAqIGFsbG93cyB5b3UgdG8gbW9kaWZ5IHRoZSB0YWJsZSBmb290ZXIgb24gZXZlcnkgJ2RyYXcnIGV2ZW50LlxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAcGFyYW0ge25vZGV9IGZvb3QgXCJUUlwiIGVsZW1lbnQgZm9yIHRoZSBmb290ZXJcblx0XHQgKiAgQHBhcmFtIHthcnJheX0gZGF0YSBGdWxsIHRhYmxlIGRhdGEgKGFzIGRlcml2ZWQgZnJvbSB0aGUgb3JpZ2luYWwgSFRNTClcblx0XHQgKiAgQHBhcmFtIHtpbnR9IHN0YXJ0IEluZGV4IGZvciB0aGUgY3VycmVudCBkaXNwbGF5IHN0YXJ0aW5nIHBvaW50IGluIHRoZVxuXHRcdCAqICAgIGRpc3BsYXkgYXJyYXlcblx0XHQgKiAgQHBhcmFtIHtpbnR9IGVuZCBJbmRleCBmb3IgdGhlIGN1cnJlbnQgZGlzcGxheSBlbmRpbmcgcG9pbnQgaW4gdGhlXG5cdFx0ICogICAgZGlzcGxheSBhcnJheVxuXHRcdCAqICBAcGFyYW0ge2FycmF5IGludH0gZGlzcGxheSBJbmRleCBhcnJheSB0byB0cmFuc2xhdGUgdGhlIHZpc3VhbCBwb3NpdGlvblxuXHRcdCAqICAgIHRvIHRoZSBmdWxsIGRhdGEgYXJyYXlcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgQ2FsbGJhY2tzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5mb290ZXJDYWxsYmFja1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJmb290ZXJDYWxsYmFja1wiOiBmdW5jdGlvbiggdGZvb3QsIGRhdGEsIHN0YXJ0LCBlbmQsIGRpc3BsYXkgKSB7XG5cdFx0ICogICAgICAgICAgdGZvb3QuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3RoJylbMF0uaW5uZXJIVE1MID0gXCJTdGFydGluZyBpbmRleCBpcyBcIitzdGFydDtcblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKVxuXHRcdCAqL1xuXHRcdFwiZm5Gb290ZXJDYWxsYmFja1wiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogV2hlbiByZW5kZXJpbmcgbGFyZ2UgbnVtYmVycyBpbiB0aGUgaW5mb3JtYXRpb24gZWxlbWVudCBmb3IgdGhlIHRhYmxlXG5cdFx0ICogKGkuZS4gXCJTaG93aW5nIDEgdG8gMTAgb2YgNTcgZW50cmllc1wiKSBEYXRhVGFibGVzIHdpbGwgcmVuZGVyIGxhcmdlIG51bWJlcnNcblx0XHQgKiB0byBoYXZlIGEgY29tbWEgc2VwYXJhdG9yIGZvciB0aGUgJ3Rob3VzYW5kcycgdW5pdHMgKGUuZy4gMSBtaWxsaW9uIGlzXG5cdFx0ICogcmVuZGVyZWQgYXMgXCIxLDAwMCwwMDBcIikgdG8gaGVscCByZWFkYWJpbGl0eSBmb3IgdGhlIGVuZCB1c2VyLiBUaGlzXG5cdFx0ICogZnVuY3Rpb24gd2lsbCBvdmVycmlkZSB0aGUgZGVmYXVsdCBtZXRob2QgRGF0YVRhYmxlcyB1c2VzLlxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAbWVtYmVyXG5cdFx0ICogIEBwYXJhbSB7aW50fSB0b0Zvcm1hdCBudW1iZXIgdG8gYmUgZm9ybWF0dGVkXG5cdFx0ICogIEByZXR1cm5zIHtzdHJpbmd9IGZvcm1hdHRlZCBzdHJpbmcgZm9yIERhdGFUYWJsZXMgdG8gc2hvdyB0aGUgbnVtYmVyXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IENhbGxiYWNrc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuZm9ybWF0TnVtYmVyXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBGb3JtYXQgYSBudW1iZXIgdXNpbmcgYSBzaW5nbGUgcXVvdGUgZm9yIHRoZSBzZXBhcmF0b3IgKG5vdGUgdGhhdFxuXHRcdCAqICAgIC8vIHRoaXMgY2FuIGFsc28gYmUgZG9uZSB3aXRoIHRoZSBsYW5ndWFnZS50aG91c2FuZHMgb3B0aW9uKVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiZm9ybWF0TnVtYmVyXCI6IGZ1bmN0aW9uICggdG9Gb3JtYXQgKSB7XG5cdFx0ICogICAgICAgICAgcmV0dXJuIHRvRm9ybWF0LnRvU3RyaW5nKCkucmVwbGFjZShcblx0XHQgKiAgICAgICAgICAgIC9cXEIoPz0oXFxkezN9KSsoPyFcXGQpKS9nLCBcIidcIlxuXHRcdCAqICAgICAgICAgICk7XG5cdFx0ICogICAgICAgIH07XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiZm5Gb3JtYXROdW1iZXJcIjogZnVuY3Rpb24gKCB0b0Zvcm1hdCApIHtcblx0XHRcdHJldHVybiB0b0Zvcm1hdC50b1N0cmluZygpLnJlcGxhY2UoXG5cdFx0XHRcdC9cXEIoPz0oXFxkezN9KSsoPyFcXGQpKS9nLFxuXHRcdFx0XHR0aGlzLm9MYW5ndWFnZS5zVGhvdXNhbmRzXG5cdFx0XHQpO1xuXHRcdH0sXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBldmVyeSAnZHJhdycgZXZlbnQsIGFuZCBhbGxvd3MgeW91IHRvXG5cdFx0ICogZHluYW1pY2FsbHkgbW9kaWZ5IHRoZSBoZWFkZXIgcm93LiBUaGlzIGNhbiBiZSB1c2VkIHRvIGNhbGN1bGF0ZSBhbmRcblx0XHQgKiBkaXNwbGF5IHVzZWZ1bCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdGFibGUuXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICogIEBwYXJhbSB7bm9kZX0gaGVhZCBcIlRSXCIgZWxlbWVudCBmb3IgdGhlIGhlYWRlclxuXHRcdCAqICBAcGFyYW0ge2FycmF5fSBkYXRhIEZ1bGwgdGFibGUgZGF0YSAoYXMgZGVyaXZlZCBmcm9tIHRoZSBvcmlnaW5hbCBIVE1MKVxuXHRcdCAqICBAcGFyYW0ge2ludH0gc3RhcnQgSW5kZXggZm9yIHRoZSBjdXJyZW50IGRpc3BsYXkgc3RhcnRpbmcgcG9pbnQgaW4gdGhlXG5cdFx0ICogICAgZGlzcGxheSBhcnJheVxuXHRcdCAqICBAcGFyYW0ge2ludH0gZW5kIEluZGV4IGZvciB0aGUgY3VycmVudCBkaXNwbGF5IGVuZGluZyBwb2ludCBpbiB0aGVcblx0XHQgKiAgICBkaXNwbGF5IGFycmF5XG5cdFx0ICogIEBwYXJhbSB7YXJyYXkgaW50fSBkaXNwbGF5IEluZGV4IGFycmF5IHRvIHRyYW5zbGF0ZSB0aGUgdmlzdWFsIHBvc2l0aW9uXG5cdFx0ICogICAgdG8gdGhlIGZ1bGwgZGF0YSBhcnJheVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBDYWxsYmFja3Ncblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmhlYWRlckNhbGxiYWNrXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImZoZWFkZXJDYWxsYmFja1wiOiBmdW5jdGlvbiggaGVhZCwgZGF0YSwgc3RhcnQsIGVuZCwgZGlzcGxheSApIHtcblx0XHQgKiAgICAgICAgICBoZWFkLmdldEVsZW1lbnRzQnlUYWdOYW1lKCd0aCcpWzBdLmlubmVySFRNTCA9IFwiRGlzcGxheWluZyBcIisoZW5kLXN0YXJ0KStcIiByZWNvcmRzXCI7XG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9IClcblx0XHQgKi9cblx0XHRcImZuSGVhZGVyQ2FsbGJhY2tcIjogbnVsbCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBpbmZvcm1hdGlvbiBlbGVtZW50IGNhbiBiZSB1c2VkIHRvIGNvbnZleSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY3VycmVudFxuXHRcdCAqIHN0YXRlIG9mIHRoZSB0YWJsZS4gQWx0aG91Z2ggdGhlIGludGVybmF0aW9uYWxpc2F0aW9uIG9wdGlvbnMgcHJlc2VudGVkIGJ5XG5cdFx0ICogRGF0YVRhYmxlcyBhcmUgcXVpdGUgY2FwYWJsZSBvZiBkZWFsaW5nIHdpdGggbW9zdCBjdXN0b21pc2F0aW9ucywgdGhlcmUgbWF5XG5cdFx0ICogYmUgdGltZXMgd2hlcmUgeW91IHdpc2ggdG8gY3VzdG9taXNlIHRoZSBzdHJpbmcgZnVydGhlci4gVGhpcyBjYWxsYmFja1xuXHRcdCAqIGFsbG93cyB5b3UgdG8gZG8gZXhhY3RseSB0aGF0LlxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0ICogIEBwYXJhbSB7aW50fSBzdGFydCBTdGFydGluZyBwb3NpdGlvbiBpbiBkYXRhIGZvciB0aGUgZHJhd1xuXHRcdCAqICBAcGFyYW0ge2ludH0gZW5kIEVuZCBwb3NpdGlvbiBpbiBkYXRhIGZvciB0aGUgZHJhd1xuXHRcdCAqICBAcGFyYW0ge2ludH0gbWF4IFRvdGFsIG51bWJlciBvZiByb3dzIGluIHRoZSB0YWJsZSAocmVnYXJkbGVzcyBvZlxuXHRcdCAqICAgIGZpbHRlcmluZylcblx0XHQgKiAgQHBhcmFtIHtpbnR9IHRvdGFsIFRvdGFsIG51bWJlciBvZiByb3dzIGluIHRoZSBkYXRhIHNldCwgYWZ0ZXIgZmlsdGVyaW5nXG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nfSBwcmUgVGhlIHN0cmluZyB0aGF0IERhdGFUYWJsZXMgaGFzIGZvcm1hdHRlZCB1c2luZyBpdCdzXG5cdFx0ICogICAgb3duIHJ1bGVzXG5cdFx0ICogIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBzdHJpbmcgdG8gYmUgZGlzcGxheWVkIGluIHRoZSBpbmZvcm1hdGlvbiBlbGVtZW50LlxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBDYWxsYmFja3Ncblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmluZm9DYWxsYmFja1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgIFwiaW5mb0NhbGxiYWNrXCI6IGZ1bmN0aW9uKCBzZXR0aW5ncywgc3RhcnQsIGVuZCwgbWF4LCB0b3RhbCwgcHJlICkge1xuXHRcdCAqICAgICAgICByZXR1cm4gc3RhcnQgK1wiIHRvIFwiKyBlbmQ7XG5cdFx0ICogICAgICB9XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiZm5JbmZvQ2FsbGJhY2tcIjogbnVsbCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIENhbGxlZCB3aGVuIHRoZSB0YWJsZSBoYXMgYmVlbiBpbml0aWFsaXNlZC4gTm9ybWFsbHkgRGF0YVRhYmxlcyB3aWxsXG5cdFx0ICogaW5pdGlhbGlzZSBzZXF1ZW50aWFsbHkgYW5kIHRoZXJlIHdpbGwgYmUgbm8gbmVlZCBmb3IgdGhpcyBmdW5jdGlvbixcblx0XHQgKiBob3dldmVyLCB0aGlzIGRvZXMgbm90IGhvbGQgdHJ1ZSB3aGVuIHVzaW5nIGV4dGVybmFsIGxhbmd1YWdlIGluZm9ybWF0aW9uXG5cdFx0ICogc2luY2UgdGhhdCBpcyBvYnRhaW5lZCB1c2luZyBhbiBhc3luYyBYSFIgY2FsbC5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0ICogIEBwYXJhbSB7b2JqZWN0fSBqc29uIFRoZSBKU09OIG9iamVjdCByZXF1ZXN0IGZyb20gdGhlIHNlcnZlciAtIG9ubHlcblx0XHQgKiAgICBwcmVzZW50IGlmIGNsaWVudC1zaWRlIEFqYXggc291cmNlZCBkYXRhIGlzIHVzZWRcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgQ2FsbGJhY2tzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5pbml0Q29tcGxldGVcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiaW5pdENvbXBsZXRlXCI6IGZ1bmN0aW9uKHNldHRpbmdzLCBqc29uKSB7XG5cdFx0ICogICAgICAgICAgYWxlcnQoICdEYXRhVGFibGVzIGhhcyBmaW5pc2hlZCBpdHMgaW5pdGlhbGlzYXRpb24uJyApO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApXG5cdFx0ICovXG5cdFx0XCJmbkluaXRDb21wbGV0ZVwiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2FsbGVkIGF0IHRoZSB2ZXJ5IHN0YXJ0IG9mIGVhY2ggdGFibGUgZHJhdyBhbmQgY2FuIGJlIHVzZWQgdG8gY2FuY2VsIHRoZVxuXHRcdCAqIGRyYXcgYnkgcmV0dXJuaW5nIGZhbHNlLCBhbnkgb3RoZXIgcmV0dXJuIChpbmNsdWRpbmcgdW5kZWZpbmVkKSByZXN1bHRzIGluXG5cdFx0ICogdGhlIGZ1bGwgZHJhdyBvY2N1cnJpbmcpLlxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0XHQgKiAgQHJldHVybnMge2Jvb2xlYW59IEZhbHNlIHdpbGwgY2FuY2VsIHRoZSBkcmF3LCBhbnl0aGluZyBlbHNlIChpbmNsdWRpbmcgbm9cblx0XHQgKiAgICByZXR1cm4pIHdpbGwgYWxsb3cgaXQgdG8gY29tcGxldGUuXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IENhbGxiYWNrc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMucHJlRHJhd0NhbGxiYWNrXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInByZURyYXdDYWxsYmFja1wiOiBmdW5jdGlvbiggc2V0dGluZ3MgKSB7XG5cdFx0ICogICAgICAgICAgaWYgKCAkKCcjdGVzdCcpLnZhbCgpID09IDEgKSB7XG5cdFx0ICogICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICogICAgICAgICAgfVxuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiZm5QcmVEcmF3Q2FsbGJhY2tcIjogbnVsbCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byAncG9zdCBwcm9jZXNzJyBlYWNoIHJvdyBhZnRlciBpdCBoYXZlIGJlZW5cblx0XHQgKiBnZW5lcmF0ZWQgZm9yIGVhY2ggdGFibGUgZHJhdywgYnV0IGJlZm9yZSBpdCBpcyByZW5kZXJlZCBvbiBzY3JlZW4uIFRoaXNcblx0XHQgKiBmdW5jdGlvbiBtaWdodCBiZSB1c2VkIGZvciBzZXR0aW5nIHRoZSByb3cgY2xhc3MgbmFtZSBldGMuXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICogIEBwYXJhbSB7bm9kZX0gcm93IFwiVFJcIiBlbGVtZW50IGZvciB0aGUgY3VycmVudCByb3dcblx0XHQgKiAgQHBhcmFtIHthcnJheX0gZGF0YSBSYXcgZGF0YSBhcnJheSBmb3IgdGhpcyByb3dcblx0XHQgKiAgQHBhcmFtIHtpbnR9IGRpc3BsYXlJbmRleCBUaGUgZGlzcGxheSBpbmRleCBmb3IgdGhlIGN1cnJlbnQgdGFibGUgZHJhd1xuXHRcdCAqICBAcGFyYW0ge2ludH0gZGlzcGxheUluZGV4RnVsbCBUaGUgaW5kZXggb2YgdGhlIGRhdGEgaW4gdGhlIGZ1bGwgbGlzdCBvZlxuXHRcdCAqICAgIHJvd3MgKGFmdGVyIGZpbHRlcmluZylcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgQ2FsbGJhY2tzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5yb3dDYWxsYmFja1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJyb3dDYWxsYmFja1wiOiBmdW5jdGlvbiggcm93LCBkYXRhLCBkaXNwbGF5SW5kZXgsIGRpc3BsYXlJbmRleEZ1bGwgKSB7XG5cdFx0ICogICAgICAgICAgLy8gQm9sZCB0aGUgZ3JhZGUgZm9yIGFsbCAnQScgZ3JhZGUgYnJvd3NlcnNcblx0XHQgKiAgICAgICAgICBpZiAoIGRhdGFbNF0gPT0gXCJBXCIgKSB7XG5cdFx0ICogICAgICAgICAgICAkKCd0ZDplcSg0KScsIHJvdykuaHRtbCggJzxiPkE8L2I+JyApO1xuXHRcdCAqICAgICAgICAgIH1cblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImZuUm93Q2FsbGJhY2tcIjogbnVsbCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIF9fRGVwcmVjYXRlZF9fIFRoZSBmdW5jdGlvbmFsaXR5IHByb3ZpZGVkIGJ5IHRoaXMgcGFyYW1ldGVyIGhhcyBub3cgYmVlblxuXHRcdCAqIHN1cGVyc2VkZWQgYnkgdGhhdCBwcm92aWRlZCB0aHJvdWdoIGBhamF4YCwgd2hpY2ggc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cblx0XHQgKlxuXHRcdCAqIFRoaXMgcGFyYW1ldGVyIGFsbG93cyB5b3UgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgZnVuY3Rpb24gd2hpY2ggb2J0YWluc1xuXHRcdCAqIHRoZSBkYXRhIGZyb20gdGhlIHNlcnZlciBzbyBzb21ldGhpbmcgbW9yZSBzdWl0YWJsZSBmb3IgeW91ciBhcHBsaWNhdGlvbi5cblx0XHQgKiBGb3IgZXhhbXBsZSB5b3UgY291bGQgdXNlIFBPU1QgZGF0YSwgb3IgcHVsbCBpbmZvcm1hdGlvbiBmcm9tIGEgR2VhcnMgb3Jcblx0XHQgKiBBSVIgZGF0YWJhc2UuXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICogIEBtZW1iZXJcblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBIVFRQIHNvdXJjZSB0byBvYnRhaW4gdGhlIGRhdGEgZnJvbSAoYGFqYXhgKVxuXHRcdCAqICBAcGFyYW0ge2FycmF5fSBkYXRhIEEga2V5L3ZhbHVlIHBhaXIgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGRhdGEgdG8gc2VuZFxuXHRcdCAqICAgIHRvIHRoZSBzZXJ2ZXJcblx0XHQgKiAgQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIGNvbXBsZXRpb24gb2YgdGhlIGRhdGEgZ2V0XG5cdFx0ICogICAgcHJvY2VzcyB0aGF0IHdpbGwgZHJhdyB0aGUgZGF0YSBvbiB0aGUgcGFnZS5cblx0XHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IENhbGxiYWNrc1xuXHRcdCAqICBAZHRvcHQgU2VydmVyLXNpZGVcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNlcnZlckRhdGFcblx0XHQgKlxuXHRcdCAqICBAZGVwcmVjYXRlZCAxLjEwLiBQbGVhc2UgdXNlIGBhamF4YCBmb3IgdGhpcyBmdW5jdGlvbmFsaXR5IG5vdy5cblx0XHQgKi9cblx0XHRcImZuU2VydmVyRGF0YVwiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogX19EZXByZWNhdGVkX18gVGhlIGZ1bmN0aW9uYWxpdHkgcHJvdmlkZWQgYnkgdGhpcyBwYXJhbWV0ZXIgaGFzIG5vdyBiZWVuXG5cdFx0ICogc3VwZXJzZWRlZCBieSB0aGF0IHByb3ZpZGVkIHRocm91Z2ggYGFqYXhgLCB3aGljaCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuXHRcdCAqXG5cdFx0ICogIEl0IGlzIG9mdGVuIHVzZWZ1bCB0byBzZW5kIGV4dHJhIGRhdGEgdG8gdGhlIHNlcnZlciB3aGVuIG1ha2luZyBhbiBBamF4XG5cdFx0ICogcmVxdWVzdCAtIGZvciBleGFtcGxlIGN1c3RvbSBmaWx0ZXJpbmcgaW5mb3JtYXRpb24sIGFuZCB0aGlzIGNhbGxiYWNrXG5cdFx0ICogZnVuY3Rpb24gbWFrZXMgaXQgdHJpdmlhbCB0byBzZW5kIGV4dHJhIGluZm9ybWF0aW9uIHRvIHRoZSBzZXJ2ZXIuIFRoZVxuXHRcdCAqIHBhc3NlZCBpbiBwYXJhbWV0ZXIgaXMgdGhlIGRhdGEgc2V0IHRoYXQgaGFzIGJlZW4gY29uc3RydWN0ZWQgYnlcblx0XHQgKiBEYXRhVGFibGVzLCBhbmQgeW91IGNhbiBhZGQgdG8gdGhpcyBvciBtb2RpZnkgaXQgYXMgeW91IHJlcXVpcmUuXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICogIEBwYXJhbSB7YXJyYXl9IGRhdGEgRGF0YSBhcnJheSAoYXJyYXkgb2Ygb2JqZWN0cyB3aGljaCBhcmUgbmFtZS92YWx1ZVxuXHRcdCAqICAgIHBhaXJzKSB0aGF0IGhhcyBiZWVuIGNvbnN0cnVjdGVkIGJ5IERhdGFUYWJsZXMgYW5kIHdpbGwgYmUgc2VudCB0byB0aGVcblx0XHQgKiAgICBzZXJ2ZXIuIEluIHRoZSBjYXNlIG9mIEFqYXggc291cmNlZCBkYXRhIHdpdGggc2VydmVyLXNpZGUgcHJvY2Vzc2luZ1xuXHRcdCAqICAgIHRoaXMgd2lsbCBiZSBhbiBlbXB0eSBhcnJheSwgZm9yIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcgdGhlcmUgd2lsbCBiZSBhXG5cdFx0ICogICAgc2lnbmlmaWNhbnQgbnVtYmVyIG9mIHBhcmFtZXRlcnMhXG5cdFx0ICogIEByZXR1cm5zIHt1bmRlZmluZWR9IEVuc3VyZSB0aGF0IHlvdSBtb2RpZnkgdGhlIGRhdGEgYXJyYXkgcGFzc2VkIGluLFxuXHRcdCAqICAgIGFzIHRoaXMgaXMgcGFzc2VkIGJ5IHJlZmVyZW5jZS5cblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgQ2FsbGJhY2tzXG5cdFx0ICogIEBkdG9wdCBTZXJ2ZXItc2lkZVxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2VydmVyUGFyYW1zXG5cdFx0ICpcblx0XHQgKiAgQGRlcHJlY2F0ZWQgMS4xMC4gUGxlYXNlIHVzZSBgYWpheGAgZm9yIHRoaXMgZnVuY3Rpb25hbGl0eSBub3cuXG5cdFx0ICovXG5cdFx0XCJmblNlcnZlclBhcmFtc1wiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogTG9hZCB0aGUgdGFibGUgc3RhdGUuIFdpdGggdGhpcyBmdW5jdGlvbiB5b3UgY2FuIGRlZmluZSBmcm9tIHdoZXJlLCBhbmQgaG93LCB0aGVcblx0XHQgKiBzdGF0ZSBvZiBhIHRhYmxlIGlzIGxvYWRlZC4gQnkgZGVmYXVsdCBEYXRhVGFibGVzIHdpbGwgbG9hZCBmcm9tIGBsb2NhbFN0b3JhZ2VgXG5cdFx0ICogYnV0IHlvdSBtaWdodCB3aXNoIHRvIHVzZSBhIHNlcnZlci1zaWRlIGRhdGFiYXNlIG9yIGNvb2tpZXMuXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICogIEBtZW1iZXJcblx0XHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0ICogIEByZXR1cm4ge29iamVjdH0gVGhlIERhdGFUYWJsZXMgc3RhdGUgb2JqZWN0IHRvIGJlIGxvYWRlZFxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBDYWxsYmFja3Ncblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnN0YXRlTG9hZENhbGxiYWNrXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInN0YXRlU2F2ZVwiOiB0cnVlLFxuXHRcdCAqICAgICAgICBcInN0YXRlTG9hZENhbGxiYWNrXCI6IGZ1bmN0aW9uIChzZXR0aW5ncykge1xuXHRcdCAqICAgICAgICAgIHZhciBvO1xuXHRcdCAqXG5cdFx0ICogICAgICAgICAgLy8gU2VuZCBhbiBBamF4IHJlcXVlc3QgdG8gdGhlIHNlcnZlciB0byBnZXQgdGhlIGRhdGEuIE5vdGUgdGhhdFxuXHRcdCAqICAgICAgICAgIC8vIHRoaXMgaXMgYSBzeW5jaHJvbm91cyByZXF1ZXN0LlxuXHRcdCAqICAgICAgICAgICQuYWpheCgge1xuXHRcdCAqICAgICAgICAgICAgXCJ1cmxcIjogXCIvc3RhdGVfbG9hZFwiLFxuXHRcdCAqICAgICAgICAgICAgXCJhc3luY1wiOiBmYWxzZSxcblx0XHQgKiAgICAgICAgICAgIFwiZGF0YVR5cGVcIjogXCJqc29uXCIsXG5cdFx0ICogICAgICAgICAgICBcInN1Y2Nlc3NcIjogZnVuY3Rpb24gKGpzb24pIHtcblx0XHQgKiAgICAgICAgICAgICAgbyA9IGpzb247XG5cdFx0ICogICAgICAgICAgICB9XG5cdFx0ICogICAgICAgICAgfSApO1xuXHRcdCAqXG5cdFx0ICogICAgICAgICAgcmV0dXJuIG87XG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJmblN0YXRlTG9hZENhbGxiYWNrXCI6IGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyZXR1cm4gSlNPTi5wYXJzZShcblx0XHRcdFx0XHQoc2V0dGluZ3MuaVN0YXRlRHVyYXRpb24gPT09IC0xID8gc2Vzc2lvblN0b3JhZ2UgOiBsb2NhbFN0b3JhZ2UpLmdldEl0ZW0oXG5cdFx0XHRcdFx0XHQnRGF0YVRhYmxlc18nK3NldHRpbmdzLnNJbnN0YW5jZSsnXycrbG9jYXRpb24ucGF0aG5hbWVcblx0XHRcdFx0XHQpXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGNhdGNoIChlKSB7fVxuXHRcdH0sXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBDYWxsYmFjayB3aGljaCBhbGxvd3MgbW9kaWZpY2F0aW9uIG9mIHRoZSBzYXZlZCBzdGF0ZSBwcmlvciB0byBsb2FkaW5nIHRoYXQgc3RhdGUuXG5cdFx0ICogVGhpcyBjYWxsYmFjayBpcyBjYWxsZWQgd2hlbiB0aGUgdGFibGUgaXMgbG9hZGluZyBzdGF0ZSBmcm9tIHRoZSBzdG9yZWQgZGF0YSwgYnV0XG5cdFx0ICogcHJpb3IgdG8gdGhlIHNldHRpbmdzIG9iamVjdCBiZWluZyBtb2RpZmllZCBieSB0aGUgc2F2ZWQgc3RhdGUuIE5vdGUgdGhhdCBmb3Jcblx0XHQgKiBwbHVnLWluIGF1dGhvcnMsIHlvdSBzaG91bGQgdXNlIHRoZSBgc3RhdGVMb2FkUGFyYW1zYCBldmVudCB0byBsb2FkIHBhcmFtZXRlcnMgZm9yXG5cdFx0ICogYSBwbHVnLWluLlxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0XHQgKiAgQHBhcmFtIHtvYmplY3R9IGRhdGEgVGhlIHN0YXRlIG9iamVjdCB0aGF0IGlzIHRvIGJlIGxvYWRlZFxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBDYWxsYmFja3Ncblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnN0YXRlTG9hZFBhcmFtc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gUmVtb3ZlIGEgc2F2ZWQgZmlsdGVyLCBzbyBmaWx0ZXJpbmcgaXMgbmV2ZXIgbG9hZGVkXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzdGF0ZVNhdmVcIjogdHJ1ZSxcblx0XHQgKiAgICAgICAgXCJzdGF0ZUxvYWRQYXJhbXNcIjogZnVuY3Rpb24gKHNldHRpbmdzLCBkYXRhKSB7XG5cdFx0ICogICAgICAgICAgZGF0YS5vU2VhcmNoLnNTZWFyY2ggPSBcIlwiO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gRGlzYWxsb3cgc3RhdGUgbG9hZGluZyBieSByZXR1cm5pbmcgZmFsc2Vcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInN0YXRlU2F2ZVwiOiB0cnVlLFxuXHRcdCAqICAgICAgICBcInN0YXRlTG9hZFBhcmFtc1wiOiBmdW5jdGlvbiAoc2V0dGluZ3MsIGRhdGEpIHtcblx0XHQgKiAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJmblN0YXRlTG9hZFBhcmFtc1wiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgc3RhdGUgaGFzIGJlZW4gbG9hZGVkIGZyb20gdGhlIHN0YXRlIHNhdmluZyBtZXRob2Rcblx0XHQgKiBhbmQgdGhlIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IGhhcyBiZWVuIG1vZGlmaWVkIGFzIGEgcmVzdWx0IG9mIHRoZSBsb2FkZWQgc3RhdGUuXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHRcdCAqICBAcGFyYW0ge29iamVjdH0gZGF0YSBUaGUgc3RhdGUgb2JqZWN0IHRoYXQgd2FzIGxvYWRlZFxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBDYWxsYmFja3Ncblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnN0YXRlTG9hZGVkXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBTaG93IGFuIGFsZXJ0IHdpdGggdGhlIGZpbHRlcmluZyB2YWx1ZSB0aGF0IHdhcyBzYXZlZFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwic3RhdGVTYXZlXCI6IHRydWUsXG5cdFx0ICogICAgICAgIFwic3RhdGVMb2FkZWRcIjogZnVuY3Rpb24gKHNldHRpbmdzLCBkYXRhKSB7XG5cdFx0ICogICAgICAgICAgYWxlcnQoICdTYXZlZCBmaWx0ZXIgd2FzOiAnK2RhdGEub1NlYXJjaC5zU2VhcmNoICk7XG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJmblN0YXRlTG9hZGVkXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBTYXZlIHRoZSB0YWJsZSBzdGF0ZS4gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIGRlZmluZSB3aGVyZSBhbmQgaG93IHRoZSBzdGF0ZVxuXHRcdCAqIGluZm9ybWF0aW9uIGZvciB0aGUgdGFibGUgaXMgc3RvcmVkIEJ5IGRlZmF1bHQgRGF0YVRhYmxlcyB3aWxsIHVzZSBgbG9jYWxTdG9yYWdlYFxuXHRcdCAqIGJ1dCB5b3UgbWlnaHQgd2lzaCB0byB1c2UgYSBzZXJ2ZXItc2lkZSBkYXRhYmFzZSBvciBjb29raWVzLlxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAbWVtYmVyXG5cdFx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHRcdCAqICBAcGFyYW0ge29iamVjdH0gZGF0YSBUaGUgc3RhdGUgb2JqZWN0IHRvIGJlIHNhdmVkXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IENhbGxiYWNrc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc3RhdGVTYXZlQ2FsbGJhY2tcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwic3RhdGVTYXZlXCI6IHRydWUsXG5cdFx0ICogICAgICAgIFwic3RhdGVTYXZlQ2FsbGJhY2tcIjogZnVuY3Rpb24gKHNldHRpbmdzLCBkYXRhKSB7XG5cdFx0ICogICAgICAgICAgLy8gU2VuZCBhbiBBamF4IHJlcXVlc3QgdG8gdGhlIHNlcnZlciB3aXRoIHRoZSBzdGF0ZSBvYmplY3Rcblx0XHQgKiAgICAgICAgICAkLmFqYXgoIHtcblx0XHQgKiAgICAgICAgICAgIFwidXJsXCI6IFwiL3N0YXRlX3NhdmVcIixcblx0XHQgKiAgICAgICAgICAgIFwiZGF0YVwiOiBkYXRhLFxuXHRcdCAqICAgICAgICAgICAgXCJkYXRhVHlwZVwiOiBcImpzb25cIixcblx0XHQgKiAgICAgICAgICAgIFwibWV0aG9kXCI6IFwiUE9TVFwiXG5cdFx0ICogICAgICAgICAgICBcInN1Y2Nlc3NcIjogZnVuY3Rpb24gKCkge31cblx0XHQgKiAgICAgICAgICB9ICk7XG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJmblN0YXRlU2F2ZUNhbGxiYWNrXCI6IGZ1bmN0aW9uICggc2V0dGluZ3MsIGRhdGEgKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHQoc2V0dGluZ3MuaVN0YXRlRHVyYXRpb24gPT09IC0xID8gc2Vzc2lvblN0b3JhZ2UgOiBsb2NhbFN0b3JhZ2UpLnNldEl0ZW0oXG5cdFx0XHRcdFx0J0RhdGFUYWJsZXNfJytzZXR0aW5ncy5zSW5zdGFuY2UrJ18nK2xvY2F0aW9uLnBhdGhuYW1lLFxuXHRcdFx0XHRcdEpTT04uc3RyaW5naWZ5KCBkYXRhIClcblx0XHRcdFx0KTtcblx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cdFx0fSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIENhbGxiYWNrIHdoaWNoIGFsbG93cyBtb2RpZmljYXRpb24gb2YgdGhlIHN0YXRlIHRvIGJlIHNhdmVkLiBDYWxsZWQgd2hlbiB0aGUgdGFibGVcblx0XHQgKiBoYXMgY2hhbmdlZCBzdGF0ZSBhIG5ldyBzdGF0ZSBzYXZlIGlzIHJlcXVpcmVkLiBUaGlzIG1ldGhvZCBhbGxvd3MgbW9kaWZpY2F0aW9uIG9mXG5cdFx0ICogdGhlIHN0YXRlIHNhdmluZyBvYmplY3QgcHJpb3IgdG8gYWN0dWFsbHkgZG9pbmcgdGhlIHNhdmUsIGluY2x1ZGluZyBhZGRpdGlvbiBvclxuXHRcdCAqIG90aGVyIHN0YXRlIHByb3BlcnRpZXMgb3IgbW9kaWZpY2F0aW9uLiBOb3RlIHRoYXQgZm9yIHBsdWctaW4gYXV0aG9ycywgeW91IHNob3VsZFxuXHRcdCAqIHVzZSB0aGUgYHN0YXRlU2F2ZVBhcmFtc2AgZXZlbnQgdG8gc2F2ZSBwYXJhbWV0ZXJzIGZvciBhIHBsdWctaW4uXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHRcdCAqICBAcGFyYW0ge29iamVjdH0gZGF0YSBUaGUgc3RhdGUgb2JqZWN0IHRvIGJlIHNhdmVkXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IENhbGxiYWNrc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc3RhdGVTYXZlUGFyYW1zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBSZW1vdmUgYSBzYXZlZCBmaWx0ZXIsIHNvIGZpbHRlcmluZyBpcyBuZXZlciBzYXZlZFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwic3RhdGVTYXZlXCI6IHRydWUsXG5cdFx0ICogICAgICAgIFwic3RhdGVTYXZlUGFyYW1zXCI6IGZ1bmN0aW9uIChzZXR0aW5ncywgZGF0YSkge1xuXHRcdCAqICAgICAgICAgIGRhdGEub1NlYXJjaC5zU2VhcmNoID0gXCJcIjtcblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImZuU3RhdGVTYXZlUGFyYW1zXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBEdXJhdGlvbiBmb3Igd2hpY2ggdGhlIHNhdmVkIHN0YXRlIGluZm9ybWF0aW9uIGlzIGNvbnNpZGVyZWQgdmFsaWQuIEFmdGVyIHRoaXMgcGVyaW9kXG5cdFx0ICogaGFzIGVsYXBzZWQgdGhlIHN0YXRlIHdpbGwgYmUgcmV0dXJuZWQgdG8gdGhlIGRlZmF1bHQuXG5cdFx0ICogVmFsdWUgaXMgZ2l2ZW4gaW4gc2Vjb25kcy5cblx0XHQgKiAgQHR5cGUgaW50XG5cdFx0ICogIEBkZWZhdWx0IDcyMDAgPGk+KDIgaG91cnMpPC9pPlxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25zXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zdGF0ZUR1cmF0aW9uXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInN0YXRlRHVyYXRpb25cIjogNjAqNjAqMjQ7IC8vIDEgZGF5XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApXG5cdFx0ICovXG5cdFx0XCJpU3RhdGVEdXJhdGlvblwiOiA3MjAwLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogV2hlbiBlbmFibGVkIERhdGFUYWJsZXMgd2lsbCBub3QgbWFrZSBhIHJlcXVlc3QgdG8gdGhlIHNlcnZlciBmb3IgdGhlIGZpcnN0XG5cdFx0ICogcGFnZSBkcmF3IC0gcmF0aGVyIGl0IHdpbGwgdXNlIHRoZSBkYXRhIGFscmVhZHkgb24gdGhlIHBhZ2UgKG5vIHNvcnRpbmcgZXRjXG5cdFx0ICogd2lsbCBiZSBhcHBsaWVkIHRvIGl0KSwgdGh1cyBzYXZpbmcgb24gYW4gWEhSIGF0IGxvYWQgdGltZS4gYGRlZmVyTG9hZGluZ2Bcblx0XHQgKiBpcyB1c2VkIHRvIGluZGljYXRlIHRoYXQgZGVmZXJyZWQgbG9hZGluZyBpcyByZXF1aXJlZCwgYnV0IGl0IGlzIGFsc28gdXNlZFxuXHRcdCAqIHRvIHRlbGwgRGF0YVRhYmxlcyBob3cgbWFueSByZWNvcmRzIHRoZXJlIGFyZSBpbiB0aGUgZnVsbCB0YWJsZSAoYWxsb3dpbmdcblx0XHQgKiB0aGUgaW5mb3JtYXRpb24gZWxlbWVudCBhbmQgcGFnaW5hdGlvbiB0byBiZSBkaXNwbGF5ZWQgY29ycmVjdGx5KS4gSW4gdGhlIGNhc2Vcblx0XHQgKiB3aGVyZSBhIGZpbHRlcmluZyBpcyBhcHBsaWVkIHRvIHRoZSB0YWJsZSBvbiBpbml0aWFsIGxvYWQsIHRoaXMgY2FuIGJlXG5cdFx0ICogaW5kaWNhdGVkIGJ5IGdpdmluZyB0aGUgcGFyYW1ldGVyIGFzIGFuIGFycmF5LCB3aGVyZSB0aGUgZmlyc3QgZWxlbWVudCBpc1xuXHRcdCAqIHRoZSBudW1iZXIgb2YgcmVjb3JkcyBhdmFpbGFibGUgYWZ0ZXIgZmlsdGVyaW5nIGFuZCB0aGUgc2Vjb25kIGVsZW1lbnQgaXMgdGhlXG5cdFx0ICogbnVtYmVyIG9mIHJlY29yZHMgd2l0aG91dCBmaWx0ZXJpbmcgKGFsbG93aW5nIHRoZSB0YWJsZSBpbmZvcm1hdGlvbiBlbGVtZW50XG5cdFx0ICogdG8gYmUgc2hvd24gY29ycmVjdGx5KS5cblx0XHQgKiAgQHR5cGUgaW50IHwgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25zXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5kZWZlckxvYWRpbmdcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIDU3IHJlY29yZHMgYXZhaWxhYmxlIGluIHRoZSB0YWJsZSwgbm8gZmlsdGVyaW5nIGFwcGxpZWRcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInNlcnZlclNpZGVcIjogdHJ1ZSxcblx0XHQgKiAgICAgICAgXCJhamF4XCI6IFwic2NyaXB0cy9zZXJ2ZXJfcHJvY2Vzc2luZy5waHBcIixcblx0XHQgKiAgICAgICAgXCJkZWZlckxvYWRpbmdcIjogNTdcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyA1NyByZWNvcmRzIGFmdGVyIGZpbHRlcmluZywgMTAwIHdpdGhvdXQgZmlsdGVyaW5nIChhbiBpbml0aWFsIGZpbHRlciBhcHBsaWVkKVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwic2VydmVyU2lkZVwiOiB0cnVlLFxuXHRcdCAqICAgICAgICBcImFqYXhcIjogXCJzY3JpcHRzL3NlcnZlcl9wcm9jZXNzaW5nLnBocFwiLFxuXHRcdCAqICAgICAgICBcImRlZmVyTG9hZGluZ1wiOiBbIDU3LCAxMDAgXSxcblx0XHQgKiAgICAgICAgXCJzZWFyY2hcIjoge1xuXHRcdCAqICAgICAgICAgIFwic2VhcmNoXCI6IFwibXlfZmlsdGVyXCJcblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImlEZWZlckxvYWRpbmdcIjogbnVsbCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIE51bWJlciBvZiByb3dzIHRvIGRpc3BsYXkgb24gYSBzaW5nbGUgcGFnZSB3aGVuIHVzaW5nIHBhZ2luYXRpb24uIElmXG5cdFx0ICogZmVhdHVyZSBlbmFibGVkIChgbGVuZ3RoQ2hhbmdlYCkgdGhlbiB0aGUgZW5kIHVzZXIgd2lsbCBiZSBhYmxlIHRvIG92ZXJyaWRlXG5cdFx0ICogdGhpcyB0byBhIGN1c3RvbSBzZXR0aW5nIHVzaW5nIGEgcG9wLXVwIG1lbnUuXG5cdFx0ICogIEB0eXBlIGludFxuXHRcdCAqICBAZGVmYXVsdCAxMFxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25zXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5wYWdlTGVuZ3RoXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInBhZ2VMZW5ndGhcIjogNTBcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9IClcblx0XHQgKi9cblx0XHRcImlEaXNwbGF5TGVuZ3RoXCI6IDEwLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRGVmaW5lIHRoZSBzdGFydGluZyBwb2ludCBmb3IgZGF0YSBkaXNwbGF5IHdoZW4gdXNpbmcgRGF0YVRhYmxlcyB3aXRoXG5cdFx0ICogcGFnaW5hdGlvbi4gTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIGlzIHRoZSBudW1iZXIgb2YgcmVjb3JkcywgcmF0aGVyIHRoYW5cblx0XHQgKiB0aGUgcGFnZSBudW1iZXIsIHNvIGlmIHlvdSBoYXZlIDEwIHJlY29yZHMgcGVyIHBhZ2UgYW5kIHdhbnQgdG8gc3RhcnQgb25cblx0XHQgKiB0aGUgdGhpcmQgcGFnZSwgaXQgc2hvdWxkIGJlIFwiMjBcIi5cblx0XHQgKiAgQHR5cGUgaW50XG5cdFx0ICogIEBkZWZhdWx0IDBcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuZGlzcGxheVN0YXJ0XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImRpc3BsYXlTdGFydFwiOiAyMFxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKVxuXHRcdCAqL1xuXHRcdFwiaURpc3BsYXlTdGFydFwiOiAwLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogQnkgZGVmYXVsdCBEYXRhVGFibGVzIGFsbG93cyBrZXlib2FyZCBuYXZpZ2F0aW9uIG9mIHRoZSB0YWJsZSAoc29ydGluZywgcGFnaW5nLFxuXHRcdCAqIGFuZCBmaWx0ZXJpbmcpIGJ5IGFkZGluZyBhIGB0YWJpbmRleGAgYXR0cmlidXRlIHRvIHRoZSByZXF1aXJlZCBlbGVtZW50cy4gVGhpc1xuXHRcdCAqIGFsbG93cyB5b3UgdG8gdGFiIHRocm91Z2ggdGhlIGNvbnRyb2xzIGFuZCBwcmVzcyB0aGUgZW50ZXIga2V5IHRvIGFjdGl2YXRlIHRoZW0uXG5cdFx0ICogVGhlIHRhYmluZGV4IGlzIGRlZmF1bHQgMCwgbWVhbmluZyB0aGF0IHRoZSB0YWIgZm9sbG93cyB0aGUgZmxvdyBvZiB0aGUgZG9jdW1lbnQuXG5cdFx0ICogWW91IGNhbiBvdmVycnVsZSB0aGlzIHVzaW5nIHRoaXMgcGFyYW1ldGVyIGlmIHlvdSB3aXNoLiBVc2UgYSB2YWx1ZSBvZiAtMSB0b1xuXHRcdCAqIGRpc2FibGUgYnVpbHQtaW4ga2V5Ym9hcmQgbmF2aWdhdGlvbi5cblx0XHQgKiAgQHR5cGUgaW50XG5cdFx0ICogIEBkZWZhdWx0IDBcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMudGFiSW5kZXhcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwidGFiSW5kZXhcIjogMVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImlUYWJJbmRleFwiOiAwLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2xhc3NlcyB0aGF0IERhdGFUYWJsZXMgYXNzaWducyB0byB0aGUgdmFyaW91cyBjb21wb25lbnRzIGFuZCBmZWF0dXJlc1xuXHRcdCAqIHRoYXQgaXQgYWRkcyB0byB0aGUgSFRNTCB0YWJsZS4gVGhpcyBhbGxvd3MgY2xhc3NlcyB0byBiZSBjb25maWd1cmVkXG5cdFx0ICogZHVyaW5nIGluaXRpYWxpc2F0aW9uIGluIGFkZGl0aW9uIHRvIHRocm91Z2ggdGhlIHN0YXRpY1xuXHRcdCAqIHtAbGluayBEYXRhVGFibGUuZXh0Lm9TdGRDbGFzc2VzfSBvYmplY3QpLlxuXHRcdCAqICBAbmFtZXNwYWNlXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jbGFzc2VzXG5cdFx0ICovXG5cdFx0XCJvQ2xhc3Nlc1wiOiB7fSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEFsbCBzdHJpbmdzIHRoYXQgRGF0YVRhYmxlcyB1c2VzIGluIHRoZSB1c2VyIGludGVyZmFjZSB0aGF0IGl0IGNyZWF0ZXNcblx0XHQgKiBhcmUgZGVmaW5lZCBpbiB0aGlzIG9iamVjdCwgYWxsb3dpbmcgeW91IHRvIG1vZGlmaWVkIHRoZW0gaW5kaXZpZHVhbGx5IG9yXG5cdFx0ICogY29tcGxldGVseSByZXBsYWNlIHRoZW0gYWxsIGFzIHJlcXVpcmVkLlxuXHRcdCAqICBAbmFtZXNwYWNlXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZVxuXHRcdCAqL1xuXHRcdFwib0xhbmd1YWdlXCI6IHtcblx0XHRcdC8qKlxuXHRcdFx0ICogU3RyaW5ncyB0aGF0IGFyZSB1c2VkIGZvciBXQUktQVJJQSBsYWJlbHMgYW5kIGNvbnRyb2xzIG9ubHkgKHRoZXNlIGFyZSBub3Rcblx0XHRcdCAqIGFjdHVhbGx5IHZpc2libGUgb24gdGhlIHBhZ2UsIGJ1dCB3aWxsIGJlIHJlYWQgYnkgc2NyZWVucmVhZGVycywgYW5kIHRodXNcblx0XHRcdCAqIG11c3QgYmUgaW50ZXJuYXRpb25hbGlzZWQgYXMgd2VsbCkuXG5cdFx0XHQgKiAgQG5hbWVzcGFjZVxuXHRcdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5hcmlhXG5cdFx0XHQgKi9cblx0XHRcdFwib0FyaWFcIjoge1xuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogQVJJQSBsYWJlbCB0aGF0IGlzIGFkZGVkIHRvIHRoZSB0YWJsZSBoZWFkZXJzIHdoZW4gdGhlIGNvbHVtbiBtYXkgYmVcblx0XHRcdFx0ICogc29ydGVkIGFzY2VuZGluZyBieSBhY3RpdmluZyB0aGUgY29sdW1uIChjbGljayBvciByZXR1cm4gd2hlbiBmb2N1c2VkKS5cblx0XHRcdFx0ICogTm90ZSB0aGF0IHRoZSBjb2x1bW4gaGVhZGVyIGlzIHByZWZpeGVkIHRvIHRoaXMgc3RyaW5nLlxuXHRcdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHRcdCAqICBAZGVmYXVsdCA6IGFjdGl2YXRlIHRvIHNvcnQgY29sdW1uIGFzY2VuZGluZ1xuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UuYXJpYS5zb3J0QXNjZW5kaW5nXG5cdFx0XHRcdCAqXG5cdFx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHRcdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdFx0XHQgKiAgICAgICAgICBcImFyaWFcIjoge1xuXHRcdFx0XHQgKiAgICAgICAgICAgIFwic29ydEFzY2VuZGluZ1wiOiBcIiAtIGNsaWNrL3JldHVybiB0byBzb3J0IGFzY2VuZGluZ1wiXG5cdFx0XHRcdCAqICAgICAgICAgIH1cblx0XHRcdFx0ICogICAgICAgIH1cblx0XHRcdFx0ICogICAgICB9ICk7XG5cdFx0XHRcdCAqICAgIH0gKTtcblx0XHRcdFx0ICovXG5cdFx0XHRcdFwic1NvcnRBc2NlbmRpbmdcIjogXCI6IGFjdGl2YXRlIHRvIHNvcnQgY29sdW1uIGFzY2VuZGluZ1wiLFxuXHRcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIEFSSUEgbGFiZWwgdGhhdCBpcyBhZGRlZCB0byB0aGUgdGFibGUgaGVhZGVycyB3aGVuIHRoZSBjb2x1bW4gbWF5IGJlXG5cdFx0XHRcdCAqIHNvcnRlZCBkZXNjZW5kaW5nIGJ5IGFjdGl2aW5nIHRoZSBjb2x1bW4gKGNsaWNrIG9yIHJldHVybiB3aGVuIGZvY3VzZWQpLlxuXHRcdFx0XHQgKiBOb3RlIHRoYXQgdGhlIGNvbHVtbiBoZWFkZXIgaXMgcHJlZml4ZWQgdG8gdGhpcyBzdHJpbmcuXG5cdFx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdFx0ICogIEBkZWZhdWx0IDogYWN0aXZhdGUgdG8gc29ydCBjb2x1bW4gYXNjZW5kaW5nXG5cdFx0XHRcdCAqXG5cdFx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5hcmlhLnNvcnREZXNjZW5kaW5nXG5cdFx0XHRcdCAqXG5cdFx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHRcdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdFx0XHQgKiAgICAgICAgICBcImFyaWFcIjoge1xuXHRcdFx0XHQgKiAgICAgICAgICAgIFwic29ydERlc2NlbmRpbmdcIjogXCIgLSBjbGljay9yZXR1cm4gdG8gc29ydCBkZXNjZW5kaW5nXCJcblx0XHRcdFx0ICogICAgICAgICAgfVxuXHRcdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0XHQgKiAgICAgIH0gKTtcblx0XHRcdFx0ICogICAgfSApO1xuXHRcdFx0XHQgKi9cblx0XHRcdFx0XCJzU29ydERlc2NlbmRpbmdcIjogXCI6IGFjdGl2YXRlIHRvIHNvcnQgY29sdW1uIGRlc2NlbmRpbmdcIlxuXHRcdFx0fSxcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFBhZ2luYXRpb24gc3RyaW5nIHVzZWQgYnkgRGF0YVRhYmxlcyBmb3IgdGhlIGJ1aWx0LWluIHBhZ2luYXRpb25cblx0XHRcdCAqIGNvbnRyb2wgdHlwZXMuXG5cdFx0XHQgKiAgQG5hbWVzcGFjZVxuXHRcdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5wYWdpbmF0ZVxuXHRcdFx0ICovXG5cdFx0XHRcIm9QYWdpbmF0ZVwiOiB7XG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBUZXh0IHRvIHVzZSB3aGVuIHVzaW5nIHRoZSAnZnVsbF9udW1iZXJzJyB0eXBlIG9mIHBhZ2luYXRpb24gZm9yIHRoZVxuXHRcdFx0XHQgKiBidXR0b24gdG8gdGFrZSB0aGUgdXNlciB0byB0aGUgZmlyc3QgcGFnZS5cblx0XHRcdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdFx0XHQgKiAgQGRlZmF1bHQgRmlyc3Rcblx0XHRcdFx0ICpcblx0XHRcdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLnBhZ2luYXRlLmZpcnN0XG5cdFx0XHRcdCAqXG5cdFx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHRcdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdFx0XHQgKiAgICAgICAgICBcInBhZ2luYXRlXCI6IHtcblx0XHRcdFx0ICogICAgICAgICAgICBcImZpcnN0XCI6IFwiRmlyc3QgcGFnZVwiXG5cdFx0XHRcdCAqICAgICAgICAgIH1cblx0XHRcdFx0ICogICAgICAgIH1cblx0XHRcdFx0ICogICAgICB9ICk7XG5cdFx0XHRcdCAqICAgIH0gKTtcblx0XHRcdFx0ICovXG5cdFx0XHRcdFwic0ZpcnN0XCI6IFwiRmlyc3RcIixcblx0XG5cdFxuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogVGV4dCB0byB1c2Ugd2hlbiB1c2luZyB0aGUgJ2Z1bGxfbnVtYmVycycgdHlwZSBvZiBwYWdpbmF0aW9uIGZvciB0aGVcblx0XHRcdFx0ICogYnV0dG9uIHRvIHRha2UgdGhlIHVzZXIgdG8gdGhlIGxhc3QgcGFnZS5cblx0XHRcdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdFx0XHQgKiAgQGRlZmF1bHQgTGFzdFxuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UucGFnaW5hdGUubGFzdFxuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHRcdFx0ICogICAgICAgICAgXCJwYWdpbmF0ZVwiOiB7XG5cdFx0XHRcdCAqICAgICAgICAgICAgXCJsYXN0XCI6IFwiTGFzdCBwYWdlXCJcblx0XHRcdFx0ICogICAgICAgICAgfVxuXHRcdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0XHQgKiAgICAgIH0gKTtcblx0XHRcdFx0ICogICAgfSApO1xuXHRcdFx0XHQgKi9cblx0XHRcdFx0XCJzTGFzdFwiOiBcIkxhc3RcIixcblx0XG5cdFxuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogVGV4dCB0byB1c2UgZm9yIHRoZSAnbmV4dCcgcGFnaW5hdGlvbiBidXR0b24gKHRvIHRha2UgdGhlIHVzZXIgdG8gdGhlXG5cdFx0XHRcdCAqIG5leHQgcGFnZSkuXG5cdFx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdFx0ICogIEBkZWZhdWx0IE5leHRcblx0XHRcdFx0ICpcblx0XHRcdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLnBhZ2luYXRlLm5leHRcblx0XHRcdFx0ICpcblx0XHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHRcdCAqICAgICAgICAgIFwicGFnaW5hdGVcIjoge1xuXHRcdFx0XHQgKiAgICAgICAgICAgIFwibmV4dFwiOiBcIk5leHQgcGFnZVwiXG5cdFx0XHRcdCAqICAgICAgICAgIH1cblx0XHRcdFx0ICogICAgICAgIH1cblx0XHRcdFx0ICogICAgICB9ICk7XG5cdFx0XHRcdCAqICAgIH0gKTtcblx0XHRcdFx0ICovXG5cdFx0XHRcdFwic05leHRcIjogXCJOZXh0XCIsXG5cdFxuXHRcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIFRleHQgdG8gdXNlIGZvciB0aGUgJ3ByZXZpb3VzJyBwYWdpbmF0aW9uIGJ1dHRvbiAodG8gdGFrZSB0aGUgdXNlciB0b1xuXHRcdFx0XHQgKiB0aGUgcHJldmlvdXMgcGFnZSkuXG5cdFx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdFx0ICogIEBkZWZhdWx0IFByZXZpb3VzXG5cdFx0XHRcdCAqXG5cdFx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5wYWdpbmF0ZS5wcmV2aW91c1xuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHRcdFx0ICogICAgICAgICAgXCJwYWdpbmF0ZVwiOiB7XG5cdFx0XHRcdCAqICAgICAgICAgICAgXCJwcmV2aW91c1wiOiBcIlByZXZpb3VzIHBhZ2VcIlxuXHRcdFx0XHQgKiAgICAgICAgICB9XG5cdFx0XHRcdCAqICAgICAgICB9XG5cdFx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0XHQgKiAgICB9ICk7XG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRcInNQcmV2aW91c1wiOiBcIlByZXZpb3VzXCJcblx0XHRcdH0sXG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUaGlzIHN0cmluZyBpcyBzaG93biBpbiBwcmVmZXJlbmNlIHRvIGB6ZXJvUmVjb3Jkc2Agd2hlbiB0aGUgdGFibGUgaXNcblx0XHRcdCAqIGVtcHR5IG9mIGRhdGEgKHJlZ2FyZGxlc3Mgb2YgZmlsdGVyaW5nKS4gTm90ZSB0aGF0IHRoaXMgaXMgYW4gb3B0aW9uYWxcblx0XHRcdCAqIHBhcmFtZXRlciAtIGlmIGl0IGlzIG5vdCBnaXZlbiwgdGhlIHZhbHVlIG9mIGB6ZXJvUmVjb3Jkc2Agd2lsbCBiZSB1c2VkXG5cdFx0XHQgKiBpbnN0ZWFkIChlaXRoZXIgdGhlIGRlZmF1bHQgb3IgZ2l2ZW4gdmFsdWUpLlxuXHRcdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdFx0ICogIEBkZWZhdWx0IE5vIGRhdGEgYXZhaWxhYmxlIGluIHRhYmxlXG5cdFx0XHQgKlxuXHRcdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5lbXB0eVRhYmxlXG5cdFx0XHQgKlxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHQgKiAgICAgICAgICBcImVtcHR5VGFibGVcIjogXCJObyBkYXRhIGF2YWlsYWJsZSBpbiB0YWJsZVwiXG5cdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0ICogICAgICB9ICk7XG5cdFx0XHQgKiAgICB9ICk7XG5cdFx0XHQgKi9cblx0XHRcdFwic0VtcHR5VGFibGVcIjogXCJObyBkYXRhIGF2YWlsYWJsZSBpbiB0YWJsZVwiLFxuXHRcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFRoaXMgc3RyaW5nIGdpdmVzIGluZm9ybWF0aW9uIHRvIHRoZSBlbmQgdXNlciBhYm91dCB0aGUgaW5mb3JtYXRpb25cblx0XHRcdCAqIHRoYXQgaXMgY3VycmVudCBvbiBkaXNwbGF5IG9uIHRoZSBwYWdlLiBUaGUgZm9sbG93aW5nIHRva2VucyBjYW4gYmVcblx0XHRcdCAqIHVzZWQgaW4gdGhlIHN0cmluZyBhbmQgd2lsbCBiZSBkeW5hbWljYWxseSByZXBsYWNlZCBhcyB0aGUgdGFibGVcblx0XHRcdCAqIGRpc3BsYXkgdXBkYXRlcy4gVGhpcyB0b2tlbnMgY2FuIGJlIHBsYWNlZCBhbnl3aGVyZSBpbiB0aGUgc3RyaW5nLCBvclxuXHRcdFx0ICogcmVtb3ZlZCBhcyBuZWVkZWQgYnkgdGhlIGxhbmd1YWdlIHJlcXVpcmVzOlxuXHRcdFx0ICpcblx0XHRcdCAqICogYFxcX1NUQVJUXFxfYCAtIERpc3BsYXkgaW5kZXggb2YgdGhlIGZpcnN0IHJlY29yZCBvbiB0aGUgY3VycmVudCBwYWdlXG5cdFx0XHQgKiAqIGBcXF9FTkRcXF9gIC0gRGlzcGxheSBpbmRleCBvZiB0aGUgbGFzdCByZWNvcmQgb24gdGhlIGN1cnJlbnQgcGFnZVxuXHRcdFx0ICogKiBgXFxfVE9UQUxcXF9gIC0gTnVtYmVyIG9mIHJlY29yZHMgaW4gdGhlIHRhYmxlIGFmdGVyIGZpbHRlcmluZ1xuXHRcdFx0ICogKiBgXFxfTUFYXFxfYCAtIE51bWJlciBvZiByZWNvcmRzIGluIHRoZSB0YWJsZSB3aXRob3V0IGZpbHRlcmluZ1xuXHRcdFx0ICogKiBgXFxfUEFHRVxcX2AgLSBDdXJyZW50IHBhZ2UgbnVtYmVyXG5cdFx0XHQgKiAqIGBcXF9QQUdFU1xcX2AgLSBUb3RhbCBudW1iZXIgb2YgcGFnZXMgb2YgZGF0YSBpbiB0aGUgdGFibGVcblx0XHRcdCAqXG5cdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHQgKiAgQGRlZmF1bHQgU2hvd2luZyBfU1RBUlRfIHRvIF9FTkRfIG9mIF9UT1RBTF8gZW50cmllc1xuXHRcdFx0ICpcblx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UuaW5mb1xuXHRcdFx0ICpcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdFx0ICogICAgICAgICAgXCJpbmZvXCI6IFwiU2hvd2luZyBwYWdlIF9QQUdFXyBvZiBfUEFHRVNfXCJcblx0XHRcdCAqICAgICAgICB9XG5cdFx0XHQgKiAgICAgIH0gKTtcblx0XHRcdCAqICAgIH0gKTtcblx0XHRcdCAqL1xuXHRcdFx0XCJzSW5mb1wiOiBcIlNob3dpbmcgX1NUQVJUXyB0byBfRU5EXyBvZiBfVE9UQUxfIGVudHJpZXNcIixcblx0XG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBEaXNwbGF5IGluZm9ybWF0aW9uIHN0cmluZyBmb3Igd2hlbiB0aGUgdGFibGUgaXMgZW1wdHkuIFR5cGljYWxseSB0aGVcblx0XHRcdCAqIGZvcm1hdCBvZiB0aGlzIHN0cmluZyBzaG91bGQgbWF0Y2ggYGluZm9gLlxuXHRcdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdFx0ICogIEBkZWZhdWx0IFNob3dpbmcgMCB0byAwIG9mIDAgZW50cmllc1xuXHRcdFx0ICpcblx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UuaW5mb0VtcHR5XG5cdFx0XHQgKlxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHQgKiAgICAgICAgICBcImluZm9FbXB0eVwiOiBcIk5vIGVudHJpZXMgdG8gc2hvd1wiXG5cdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0ICogICAgICB9ICk7XG5cdFx0XHQgKiAgICB9ICk7XG5cdFx0XHQgKi9cblx0XHRcdFwic0luZm9FbXB0eVwiOiBcIlNob3dpbmcgMCB0byAwIG9mIDAgZW50cmllc1wiLFxuXHRcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFdoZW4gYSB1c2VyIGZpbHRlcnMgdGhlIGluZm9ybWF0aW9uIGluIGEgdGFibGUsIHRoaXMgc3RyaW5nIGlzIGFwcGVuZGVkXG5cdFx0XHQgKiB0byB0aGUgaW5mb3JtYXRpb24gKGBpbmZvYCkgdG8gZ2l2ZSBhbiBpZGVhIG9mIGhvdyBzdHJvbmcgdGhlIGZpbHRlcmluZ1xuXHRcdFx0ICogaXMuIFRoZSB2YXJpYWJsZSBfTUFYXyBpcyBkeW5hbWljYWxseSB1cGRhdGVkLlxuXHRcdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdFx0ICogIEBkZWZhdWx0IChmaWx0ZXJlZCBmcm9tIF9NQVhfIHRvdGFsIGVudHJpZXMpXG5cdFx0XHQgKlxuXHRcdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5pbmZvRmlsdGVyZWRcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHRcdCAqICAgICAgICAgIFwiaW5mb0ZpbHRlcmVkXCI6IFwiIC0gZmlsdGVyaW5nIGZyb20gX01BWF8gcmVjb3Jkc1wiXG5cdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0ICogICAgICB9ICk7XG5cdFx0XHQgKiAgICB9ICk7XG5cdFx0XHQgKi9cblx0XHRcdFwic0luZm9GaWx0ZXJlZFwiOiBcIihmaWx0ZXJlZCBmcm9tIF9NQVhfIHRvdGFsIGVudHJpZXMpXCIsXG5cdFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogSWYgY2FuIGJlIHVzZWZ1bCB0byBhcHBlbmQgZXh0cmEgaW5mb3JtYXRpb24gdG8gdGhlIGluZm8gc3RyaW5nIGF0IHRpbWVzLFxuXHRcdFx0ICogYW5kIHRoaXMgdmFyaWFibGUgZG9lcyBleGFjdGx5IHRoYXQuIFRoaXMgaW5mb3JtYXRpb24gd2lsbCBiZSBhcHBlbmRlZCB0b1xuXHRcdFx0ICogdGhlIGBpbmZvYCAoYGluZm9FbXB0eWAgYW5kIGBpbmZvRmlsdGVyZWRgIGluIHdoYXRldmVyIGNvbWJpbmF0aW9uIHRoZXkgYXJlXG5cdFx0XHQgKiBiZWluZyB1c2VkKSBhdCBhbGwgdGltZXMuXG5cdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHQgKiAgQGRlZmF1bHQgPGk+RW1wdHkgc3RyaW5nPC9pPlxuXHRcdFx0ICpcblx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UuaW5mb1Bvc3RGaXhcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHRcdCAqICAgICAgICAgIFwiaW5mb1Bvc3RGaXhcIjogXCJBbGwgcmVjb3JkcyBzaG93biBhcmUgZGVyaXZlZCBmcm9tIHJlYWwgaW5mb3JtYXRpb24uXCJcblx0XHRcdCAqICAgICAgICB9XG5cdFx0XHQgKiAgICAgIH0gKTtcblx0XHRcdCAqICAgIH0gKTtcblx0XHRcdCAqL1xuXHRcdFx0XCJzSW5mb1Bvc3RGaXhcIjogXCJcIixcblx0XG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUaGlzIGRlY2ltYWwgcGxhY2Ugb3BlcmF0b3IgaXMgYSBsaXR0bGUgZGlmZmVyZW50IGZyb20gdGhlIG90aGVyXG5cdFx0XHQgKiBsYW5ndWFnZSBvcHRpb25zIHNpbmNlIERhdGFUYWJsZXMgZG9lc24ndCBvdXRwdXQgZmxvYXRpbmcgcG9pbnRcblx0XHRcdCAqIG51bWJlcnMsIHNvIGl0IHdvbid0IGV2ZXIgdXNlIHRoaXMgZm9yIGRpc3BsYXkgb2YgYSBudW1iZXIuIFJhdGhlcixcblx0XHRcdCAqIHdoYXQgdGhpcyBwYXJhbWV0ZXIgZG9lcyBpcyBtb2RpZnkgdGhlIHNvcnQgbWV0aG9kcyBvZiB0aGUgdGFibGUgc29cblx0XHRcdCAqIHRoYXQgbnVtYmVycyB3aGljaCBhcmUgaW4gYSBmb3JtYXQgd2hpY2ggaGFzIGEgY2hhcmFjdGVyIG90aGVyIHRoYW5cblx0XHRcdCAqIGEgcGVyaW9kIChgLmApIGFzIGEgZGVjaW1hbCBwbGFjZSB3aWxsIGJlIHNvcnRlZCBudW1lcmljYWxseS5cblx0XHRcdCAqXG5cdFx0XHQgKiBOb3RlIHRoYXQgbnVtYmVycyB3aXRoIGRpZmZlcmVudCBkZWNpbWFsIHBsYWNlcyBjYW5ub3QgYmUgc2hvd24gaW5cblx0XHRcdCAqIHRoZSBzYW1lIHRhYmxlIGFuZCBzdGlsbCBiZSBzb3J0YWJsZSwgdGhlIHRhYmxlIG11c3QgYmUgY29uc2lzdGVudC5cblx0XHRcdCAqIEhvd2V2ZXIsIG11bHRpcGxlIGRpZmZlcmVudCB0YWJsZXMgb24gdGhlIHBhZ2UgY2FuIHVzZSBkaWZmZXJlbnRcblx0XHRcdCAqIGRlY2ltYWwgcGxhY2UgY2hhcmFjdGVycy5cblx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdCAqICBAZGVmYXVsdCBcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmRlY2ltYWxcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHRcdCAqICAgICAgICAgIFwiZGVjaW1hbFwiOiBcIixcIlxuXHRcdFx0ICogICAgICAgICAgXCJ0aG91c2FuZHNcIjogXCIuXCJcblx0XHRcdCAqICAgICAgICB9XG5cdFx0XHQgKiAgICAgIH0gKTtcblx0XHRcdCAqICAgIH0gKTtcblx0XHRcdCAqL1xuXHRcdFx0XCJzRGVjaW1hbFwiOiBcIlwiLFxuXHRcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIERhdGFUYWJsZXMgaGFzIGEgYnVpbGQgaW4gbnVtYmVyIGZvcm1hdHRlciAoYGZvcm1hdE51bWJlcmApIHdoaWNoIGlzXG5cdFx0XHQgKiB1c2VkIHRvIGZvcm1hdCBsYXJnZSBudW1iZXJzIHRoYXQgYXJlIHVzZWQgaW4gdGhlIHRhYmxlIGluZm9ybWF0aW9uLlxuXHRcdFx0ICogQnkgZGVmYXVsdCBhIGNvbW1hIGlzIHVzZWQsIGJ1dCB0aGlzIGNhbiBiZSB0cml2aWFsbHkgY2hhbmdlZCB0byBhbnlcblx0XHRcdCAqIGNoYXJhY3RlciB5b3Ugd2lzaCB3aXRoIHRoaXMgcGFyYW1ldGVyLlxuXHRcdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdFx0ICogIEBkZWZhdWx0ICxcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLnRob3VzYW5kc1xuXHRcdFx0ICpcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdFx0ICogICAgICAgICAgXCJ0aG91c2FuZHNcIjogXCInXCJcblx0XHRcdCAqICAgICAgICB9XG5cdFx0XHQgKiAgICAgIH0gKTtcblx0XHRcdCAqICAgIH0gKTtcblx0XHRcdCAqL1xuXHRcdFx0XCJzVGhvdXNhbmRzXCI6IFwiLFwiLFxuXHRcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIERldGFpbCB0aGUgYWN0aW9uIHRoYXQgd2lsbCBiZSB0YWtlbiB3aGVuIHRoZSBkcm9wIGRvd24gbWVudSBmb3IgdGhlXG5cdFx0XHQgKiBwYWdpbmF0aW9uIGxlbmd0aCBvcHRpb24gaXMgY2hhbmdlZC4gVGhlICdfTUVOVV8nIHZhcmlhYmxlIGlzIHJlcGxhY2VkXG5cdFx0XHQgKiB3aXRoIGEgZGVmYXVsdCBzZWxlY3QgbGlzdCBvZiAxMCwgMjUsIDUwIGFuZCAxMDAsIGFuZCBjYW4gYmUgcmVwbGFjZWRcblx0XHRcdCAqIHdpdGggYSBjdXN0b20gc2VsZWN0IGJveCBpZiByZXF1aXJlZC5cblx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdCAqICBAZGVmYXVsdCBTaG93IF9NRU5VXyBlbnRyaWVzXG5cdFx0XHQgKlxuXHRcdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5sZW5ndGhNZW51XG5cdFx0XHQgKlxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAgICAvLyBMYW5ndWFnZSBjaGFuZ2Ugb25seVxuXHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdFx0ICogICAgICAgICAgXCJsZW5ndGhNZW51XCI6IFwiRGlzcGxheSBfTUVOVV8gcmVjb3Jkc1wiXG5cdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0ICogICAgICB9ICk7XG5cdFx0XHQgKiAgICB9ICk7XG5cdFx0XHQgKlxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAgICAvLyBMYW5ndWFnZSBhbmQgb3B0aW9ucyBjaGFuZ2Vcblx0XHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHRcdCAqICAgICAgICAgIFwibGVuZ3RoTWVudVwiOiAnRGlzcGxheSA8c2VsZWN0PicrXG5cdFx0XHQgKiAgICAgICAgICAgICc8b3B0aW9uIHZhbHVlPVwiMTBcIj4xMDwvb3B0aW9uPicrXG5cdFx0XHQgKiAgICAgICAgICAgICc8b3B0aW9uIHZhbHVlPVwiMjBcIj4yMDwvb3B0aW9uPicrXG5cdFx0XHQgKiAgICAgICAgICAgICc8b3B0aW9uIHZhbHVlPVwiMzBcIj4zMDwvb3B0aW9uPicrXG5cdFx0XHQgKiAgICAgICAgICAgICc8b3B0aW9uIHZhbHVlPVwiNDBcIj40MDwvb3B0aW9uPicrXG5cdFx0XHQgKiAgICAgICAgICAgICc8b3B0aW9uIHZhbHVlPVwiNTBcIj41MDwvb3B0aW9uPicrXG5cdFx0XHQgKiAgICAgICAgICAgICc8b3B0aW9uIHZhbHVlPVwiLTFcIj5BbGw8L29wdGlvbj4nK1xuXHRcdFx0ICogICAgICAgICAgICAnPC9zZWxlY3Q+IHJlY29yZHMnXG5cdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0ICogICAgICB9ICk7XG5cdFx0XHQgKiAgICB9ICk7XG5cdFx0XHQgKi9cblx0XHRcdFwic0xlbmd0aE1lbnVcIjogXCJTaG93IF9NRU5VXyBlbnRyaWVzXCIsXG5cdFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogV2hlbiB1c2luZyBBamF4IHNvdXJjZWQgZGF0YSBhbmQgZHVyaW5nIHRoZSBmaXJzdCBkcmF3IHdoZW4gRGF0YVRhYmxlcyBpc1xuXHRcdFx0ICogZ2F0aGVyaW5nIHRoZSBkYXRhLCB0aGlzIG1lc3NhZ2UgaXMgc2hvd24gaW4gYW4gZW1wdHkgcm93IGluIHRoZSB0YWJsZSB0b1xuXHRcdFx0ICogaW5kaWNhdGUgdG8gdGhlIGVuZCB1c2VyIHRoZSB0aGUgZGF0YSBpcyBiZWluZyBsb2FkZWQuIE5vdGUgdGhhdCB0aGlzXG5cdFx0XHQgKiBwYXJhbWV0ZXIgaXMgbm90IHVzZWQgd2hlbiBsb2FkaW5nIGRhdGEgYnkgc2VydmVyLXNpZGUgcHJvY2Vzc2luZywganVzdFxuXHRcdFx0ICogQWpheCBzb3VyY2VkIGRhdGEgd2l0aCBjbGllbnQtc2lkZSBwcm9jZXNzaW5nLlxuXHRcdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdFx0ICogIEBkZWZhdWx0IExvYWRpbmcuLi5cblx0XHRcdCAqXG5cdFx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmxvYWRpbmdSZWNvcmRzXG5cdFx0XHQgKlxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHQgKiAgICAgICAgICBcImxvYWRpbmdSZWNvcmRzXCI6IFwiUGxlYXNlIHdhaXQgLSBsb2FkaW5nLi4uXCJcblx0XHRcdCAqICAgICAgICB9XG5cdFx0XHQgKiAgICAgIH0gKTtcblx0XHRcdCAqICAgIH0gKTtcblx0XHRcdCAqL1xuXHRcdFx0XCJzTG9hZGluZ1JlY29yZHNcIjogXCJMb2FkaW5nLi4uXCIsXG5cdFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogVGV4dCB3aGljaCBpcyBkaXNwbGF5ZWQgd2hlbiB0aGUgdGFibGUgaXMgcHJvY2Vzc2luZyBhIHVzZXIgYWN0aW9uXG5cdFx0XHQgKiAodXN1YWxseSBhIHNvcnQgY29tbWFuZCBvciBzaW1pbGFyKS5cblx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdCAqICBAZGVmYXVsdCBQcm9jZXNzaW5nLi4uXG5cdFx0XHQgKlxuXHRcdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5wcm9jZXNzaW5nXG5cdFx0XHQgKlxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHQgKiAgICAgICAgICBcInByb2Nlc3NpbmdcIjogXCJEYXRhVGFibGVzIGlzIGN1cnJlbnRseSBidXN5XCJcblx0XHRcdCAqICAgICAgICB9XG5cdFx0XHQgKiAgICAgIH0gKTtcblx0XHRcdCAqICAgIH0gKTtcblx0XHRcdCAqL1xuXHRcdFx0XCJzUHJvY2Vzc2luZ1wiOiBcIlByb2Nlc3NpbmcuLi5cIixcblx0XG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBEZXRhaWxzIHRoZSBhY3Rpb25zIHRoYXQgd2lsbCBiZSB0YWtlbiB3aGVuIHRoZSB1c2VyIHR5cGVzIGludG8gdGhlXG5cdFx0XHQgKiBmaWx0ZXJpbmcgaW5wdXQgdGV4dCBib3guIFRoZSB2YXJpYWJsZSBcIl9JTlBVVF9cIiwgaWYgdXNlZCBpbiB0aGUgc3RyaW5nLFxuXHRcdFx0ICogaXMgcmVwbGFjZWQgd2l0aCB0aGUgSFRNTCB0ZXh0IGJveCBmb3IgdGhlIGZpbHRlcmluZyBpbnB1dCBhbGxvd2luZ1xuXHRcdFx0ICogY29udHJvbCBvdmVyIHdoZXJlIGl0IGFwcGVhcnMgaW4gdGhlIHN0cmluZy4gSWYgXCJfSU5QVVRfXCIgaXMgbm90IGdpdmVuXG5cdFx0XHQgKiB0aGVuIHRoZSBpbnB1dCBib3ggaXMgYXBwZW5kZWQgdG8gdGhlIHN0cmluZyBhdXRvbWF0aWNhbGx5LlxuXHRcdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdFx0ICogIEBkZWZhdWx0IFNlYXJjaDpcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLnNlYXJjaFxuXHRcdFx0ICpcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogICAgLy8gSW5wdXQgdGV4dCBib3ggd2lsbCBiZSBhcHBlbmRlZCBhdCB0aGUgZW5kIGF1dG9tYXRpY2FsbHlcblx0XHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHRcdCAqICAgICAgICAgIFwic2VhcmNoXCI6IFwiRmlsdGVyIHJlY29yZHM6XCJcblx0XHRcdCAqICAgICAgICB9XG5cdFx0XHQgKiAgICAgIH0gKTtcblx0XHRcdCAqICAgIH0gKTtcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqICAgIC8vIFNwZWNpZnkgd2hlcmUgdGhlIGZpbHRlciBzaG91bGQgYXBwZWFyXG5cdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHQgKiAgICAgICAgICBcInNlYXJjaFwiOiBcIkFwcGx5IGZpbHRlciBfSU5QVVRfIHRvIHRhYmxlXCJcblx0XHRcdCAqICAgICAgICB9XG5cdFx0XHQgKiAgICAgIH0gKTtcblx0XHRcdCAqICAgIH0gKTtcblx0XHRcdCAqL1xuXHRcdFx0XCJzU2VhcmNoXCI6IFwiU2VhcmNoOlwiLFxuXHRcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIEFzc2lnbiBhIGBwbGFjZWhvbGRlcmAgYXR0cmlidXRlIHRvIHRoZSBzZWFyY2ggYGlucHV0YCBlbGVtZW50XG5cdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHQgKiAgQGRlZmF1bHQgXG5cdFx0XHQgKlxuXHRcdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5zZWFyY2hQbGFjZWhvbGRlclxuXHRcdFx0ICovXG5cdFx0XHRcInNTZWFyY2hQbGFjZWhvbGRlclwiOiBcIlwiLFxuXHRcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIEFsbCBvZiB0aGUgbGFuZ3VhZ2UgaW5mb3JtYXRpb24gY2FuIGJlIHN0b3JlZCBpbiBhIGZpbGUgb24gdGhlXG5cdFx0XHQgKiBzZXJ2ZXItc2lkZSwgd2hpY2ggRGF0YVRhYmxlcyB3aWxsIGxvb2sgdXAgaWYgdGhpcyBwYXJhbWV0ZXIgaXMgcGFzc2VkLlxuXHRcdFx0ICogSXQgbXVzdCBzdG9yZSB0aGUgVVJMIG9mIHRoZSBsYW5ndWFnZSBmaWxlLCB3aGljaCBpcyBpbiBhIEpTT04gZm9ybWF0LFxuXHRcdFx0ICogYW5kIHRoZSBvYmplY3QgaGFzIHRoZSBzYW1lIHByb3BlcnRpZXMgYXMgdGhlIG9MYW5ndWFnZSBvYmplY3QgaW4gdGhlXG5cdFx0XHQgKiBpbml0aWFsaXNlciBvYmplY3QgKGkuZS4gdGhlIGFib3ZlIHBhcmFtZXRlcnMpLiBQbGVhc2UgcmVmZXIgdG8gb25lIG9mXG5cdFx0XHQgKiB0aGUgZXhhbXBsZSBsYW5ndWFnZSBmaWxlcyB0byBzZWUgaG93IHRoaXMgd29ya3MgaW4gYWN0aW9uLlxuXHRcdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdFx0ICogIEBkZWZhdWx0IDxpPkVtcHR5IHN0cmluZyAtIGkuZS4gZGlzYWJsZWQ8L2k+XG5cdFx0XHQgKlxuXHRcdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS51cmxcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHRcdCAqICAgICAgICAgIFwidXJsXCI6IFwiaHR0cDovL3d3dy5zcHJ5bWVkaWEuY28udWsvZGF0YVRhYmxlcy9sYW5nLnR4dFwiXG5cdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0ICogICAgICB9ICk7XG5cdFx0XHQgKiAgICB9ICk7XG5cdFx0XHQgKi9cblx0XHRcdFwic1VybFwiOiBcIlwiLFxuXHRcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFRleHQgc2hvd24gaW5zaWRlIHRoZSB0YWJsZSByZWNvcmRzIHdoZW4gdGhlIGlzIG5vIGluZm9ybWF0aW9uIHRvIGJlXG5cdFx0XHQgKiBkaXNwbGF5ZWQgYWZ0ZXIgZmlsdGVyaW5nLiBgZW1wdHlUYWJsZWAgaXMgc2hvd24gd2hlbiB0aGVyZSBpcyBzaW1wbHkgbm9cblx0XHRcdCAqIGluZm9ybWF0aW9uIGluIHRoZSB0YWJsZSBhdCBhbGwgKHJlZ2FyZGxlc3Mgb2YgZmlsdGVyaW5nKS5cblx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdCAqICBAZGVmYXVsdCBObyBtYXRjaGluZyByZWNvcmRzIGZvdW5kXG5cdFx0XHQgKlxuXHRcdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS56ZXJvUmVjb3Jkc1xuXHRcdFx0ICpcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdFx0ICogICAgICAgICAgXCJ6ZXJvUmVjb3Jkc1wiOiBcIk5vIHJlY29yZHMgdG8gZGlzcGxheVwiXG5cdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0ICogICAgICB9ICk7XG5cdFx0XHQgKiAgICB9ICk7XG5cdFx0XHQgKi9cblx0XHRcdFwic1plcm9SZWNvcmRzXCI6IFwiTm8gbWF0Y2hpbmcgcmVjb3JkcyBmb3VuZFwiXG5cdFx0fSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgcGFyYW1ldGVyIGFsbG93cyB5b3UgdG8gaGF2ZSBkZWZpbmUgdGhlIGdsb2JhbCBmaWx0ZXJpbmcgc3RhdGUgYXRcblx0XHQgKiBpbml0aWFsaXNhdGlvbiB0aW1lLiBBcyBhbiBvYmplY3QgdGhlIGBzZWFyY2hgIHBhcmFtZXRlciBtdXN0IGJlXG5cdFx0ICogZGVmaW5lZCwgYnV0IGFsbCBvdGhlciBwYXJhbWV0ZXJzIGFyZSBvcHRpb25hbC4gV2hlbiBgcmVnZXhgIGlzIHRydWUsXG5cdFx0ICogdGhlIHNlYXJjaCBzdHJpbmcgd2lsbCBiZSB0cmVhdGVkIGFzIGEgcmVndWxhciBleHByZXNzaW9uLCB3aGVuIGZhbHNlXG5cdFx0ICogKGRlZmF1bHQpIGl0IHdpbGwgYmUgdHJlYXRlZCBhcyBhIHN0cmFpZ2h0IHN0cmluZy4gV2hlbiBgc21hcnRgXG5cdFx0ICogRGF0YVRhYmxlcyB3aWxsIHVzZSBpdCdzIHNtYXJ0IGZpbHRlcmluZyBtZXRob2RzICh0byB3b3JkIG1hdGNoIGF0XG5cdFx0ICogYW55IHBvaW50IGluIHRoZSBkYXRhKSwgd2hlbiBmYWxzZSB0aGlzIHdpbGwgbm90IGJlIGRvbmUuXG5cdFx0ICogIEBuYW1lc3BhY2Vcblx0XHQgKiAgQGV4dGVuZHMgRGF0YVRhYmxlLm1vZGVscy5vU2VhcmNoXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNlYXJjaFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzZWFyY2hcIjoge1wic2VhcmNoXCI6IFwiSW5pdGlhbCBzZWFyY2hcIn1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9IClcblx0XHQgKi9cblx0XHRcIm9TZWFyY2hcIjogJC5leHRlbmQoIHt9LCBEYXRhVGFibGUubW9kZWxzLm9TZWFyY2ggKSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIF9fRGVwcmVjYXRlZF9fIFRoZSBmdW5jdGlvbmFsaXR5IHByb3ZpZGVkIGJ5IHRoaXMgcGFyYW1ldGVyIGhhcyBub3cgYmVlblxuXHRcdCAqIHN1cGVyc2VkZWQgYnkgdGhhdCBwcm92aWRlZCB0aHJvdWdoIGBhamF4YCwgd2hpY2ggc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cblx0XHQgKlxuXHRcdCAqIEJ5IGRlZmF1bHQgRGF0YVRhYmxlcyB3aWxsIGxvb2sgZm9yIHRoZSBwcm9wZXJ0eSBgZGF0YWAgKG9yIGBhYURhdGFgIGZvclxuXHRcdCAqIGNvbXBhdGliaWxpdHkgd2l0aCBEYXRhVGFibGVzIDEuOS0pIHdoZW4gb2J0YWluaW5nIGRhdGEgZnJvbSBhbiBBamF4XG5cdFx0ICogc291cmNlIG9yIGZvciBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIC0gdGhpcyBwYXJhbWV0ZXIgYWxsb3dzIHRoYXRcblx0XHQgKiBwcm9wZXJ0eSB0byBiZSBjaGFuZ2VkLiBZb3UgY2FuIHVzZSBKYXZhc2NyaXB0IGRvdHRlZCBvYmplY3Qgbm90YXRpb24gdG9cblx0XHQgKiBnZXQgYSBkYXRhIHNvdXJjZSBmb3IgbXVsdGlwbGUgbGV2ZWxzIG9mIG5lc3RpbmcuXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBkYXRhXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0XHQgKiAgQGR0b3B0IFNlcnZlci1zaWRlXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5hamF4RGF0YVByb3Bcblx0XHQgKlxuXHRcdCAqICBAZGVwcmVjYXRlZCAxLjEwLiBQbGVhc2UgdXNlIGBhamF4YCBmb3IgdGhpcyBmdW5jdGlvbmFsaXR5IG5vdy5cblx0XHQgKi9cblx0XHRcInNBamF4RGF0YVByb3BcIjogXCJkYXRhXCIsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBfX0RlcHJlY2F0ZWRfXyBUaGUgZnVuY3Rpb25hbGl0eSBwcm92aWRlZCBieSB0aGlzIHBhcmFtZXRlciBoYXMgbm93IGJlZW5cblx0XHQgKiBzdXBlcnNlZGVkIGJ5IHRoYXQgcHJvdmlkZWQgdGhyb3VnaCBgYWpheGAsIHdoaWNoIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG5cdFx0ICpcblx0XHQgKiBZb3UgY2FuIGluc3RydWN0IERhdGFUYWJsZXMgdG8gbG9hZCBkYXRhIGZyb20gYW4gZXh0ZXJuYWxcblx0XHQgKiBzb3VyY2UgdXNpbmcgdGhpcyBwYXJhbWV0ZXIgKHVzZSBhRGF0YSBpZiB5b3Ugd2FudCB0byBwYXNzIGRhdGEgaW4geW91XG5cdFx0ICogYWxyZWFkeSBoYXZlKS4gU2ltcGx5IHByb3ZpZGUgYSB1cmwgYSBKU09OIG9iamVjdCBjYW4gYmUgb2J0YWluZWQgZnJvbS5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uc1xuXHRcdCAqICBAZHRvcHQgU2VydmVyLXNpZGVcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmFqYXhTb3VyY2Vcblx0XHQgKlxuXHRcdCAqICBAZGVwcmVjYXRlZCAxLjEwLiBQbGVhc2UgdXNlIGBhamF4YCBmb3IgdGhpcyBmdW5jdGlvbmFsaXR5IG5vdy5cblx0XHQgKi9cblx0XHRcInNBamF4U291cmNlXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGlzIGluaXRpYWxpc2F0aW9uIHZhcmlhYmxlIGFsbG93cyB5b3UgdG8gc3BlY2lmeSBleGFjdGx5IHdoZXJlIGluIHRoZVxuXHRcdCAqIERPTSB5b3Ugd2FudCBEYXRhVGFibGVzIHRvIGluamVjdCB0aGUgdmFyaW91cyBjb250cm9scyBpdCBhZGRzIHRvIHRoZSBwYWdlXG5cdFx0ICogKGZvciBleGFtcGxlIHlvdSBtaWdodCB3YW50IHRoZSBwYWdpbmF0aW9uIGNvbnRyb2xzIGF0IHRoZSB0b3Agb2YgdGhlXG5cdFx0ICogdGFibGUpLiBESVYgZWxlbWVudHMgKHdpdGggb3Igd2l0aG91dCBhIGN1c3RvbSBjbGFzcykgY2FuIGFsc28gYmUgYWRkZWQgdG9cblx0XHQgKiBhaWQgc3R5bGluZy4gVGhlIGZvbGxvdyBzeW50YXggaXMgdXNlZDpcblx0XHQgKiAgIDx1bD5cblx0XHQgKiAgICAgPGxpPlRoZSBmb2xsb3dpbmcgb3B0aW9ucyBhcmUgYWxsb3dlZDpcblx0XHQgKiAgICAgICA8dWw+XG5cdFx0ICogICAgICAgICA8bGk+J2wnIC0gTGVuZ3RoIGNoYW5naW5nPC9saT5cblx0XHQgKiAgICAgICAgIDxsaT4nZicgLSBGaWx0ZXJpbmcgaW5wdXQ8L2xpPlxuXHRcdCAqICAgICAgICAgPGxpPid0JyAtIFRoZSB0YWJsZSE8L2xpPlxuXHRcdCAqICAgICAgICAgPGxpPidpJyAtIEluZm9ybWF0aW9uPC9saT5cblx0XHQgKiAgICAgICAgIDxsaT4ncCcgLSBQYWdpbmF0aW9uPC9saT5cblx0XHQgKiAgICAgICAgIDxsaT4ncicgLSBwUm9jZXNzaW5nPC9saT5cblx0XHQgKiAgICAgICA8L3VsPlxuXHRcdCAqICAgICA8L2xpPlxuXHRcdCAqICAgICA8bGk+VGhlIGZvbGxvd2luZyBjb25zdGFudHMgYXJlIGFsbG93ZWQ6XG5cdFx0ICogICAgICAgPHVsPlxuXHRcdCAqICAgICAgICAgPGxpPidIJyAtIGpRdWVyeVVJIHRoZW1lIFwiaGVhZGVyXCIgY2xhc3NlcyAoJ2ZnLXRvb2xiYXIgdWktd2lkZ2V0LWhlYWRlciB1aS1jb3JuZXItdGwgdWktY29ybmVyLXRyIHVpLWhlbHBlci1jbGVhcmZpeCcpPC9saT5cblx0XHQgKiAgICAgICAgIDxsaT4nRicgLSBqUXVlcnlVSSB0aGVtZSBcImZvb3RlclwiIGNsYXNzZXMgKCdmZy10b29sYmFyIHVpLXdpZGdldC1oZWFkZXIgdWktY29ybmVyLWJsIHVpLWNvcm5lci1iciB1aS1oZWxwZXItY2xlYXJmaXgnKTwvbGk+XG5cdFx0ICogICAgICAgPC91bD5cblx0XHQgKiAgICAgPC9saT5cblx0XHQgKiAgICAgPGxpPlRoZSBmb2xsb3dpbmcgc3ludGF4IGlzIGV4cGVjdGVkOlxuXHRcdCAqICAgICAgIDx1bD5cblx0XHQgKiAgICAgICAgIDxsaT4nJmx0OycgYW5kICcmZ3Q7JyAtIGRpdiBlbGVtZW50czwvbGk+XG5cdFx0ICogICAgICAgICA8bGk+JyZsdDtcImNsYXNzXCIgYW5kICcmZ3Q7JyAtIGRpdiB3aXRoIGEgY2xhc3M8L2xpPlxuXHRcdCAqICAgICAgICAgPGxpPicmbHQ7XCIjaWRcIiBhbmQgJyZndDsnIC0gZGl2IHdpdGggYW4gSUQ8L2xpPlxuXHRcdCAqICAgICAgIDwvdWw+XG5cdFx0ICogICAgIDwvbGk+XG5cdFx0ICogICAgIDxsaT5FeGFtcGxlczpcblx0XHQgKiAgICAgICA8dWw+XG5cdFx0ICogICAgICAgICA8bGk+JyZsdDtcIndyYXBwZXJcImZsaXB0Jmd0Oyc8L2xpPlxuXHRcdCAqICAgICAgICAgPGxpPicmbHQ7bGYmbHQ7dCZndDtpcCZndDsnPC9saT5cblx0XHQgKiAgICAgICA8L3VsPlxuXHRcdCAqICAgICA8L2xpPlxuXHRcdCAqICAgPC91bD5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IGxmcnRpcCA8aT4od2hlbiBgalF1ZXJ5VUlgIGlzIGZhbHNlKTwvaT4gPGI+b3I8L2I+XG5cdFx0ICogICAgPFwiSFwibGZyPnQ8XCJGXCJpcD4gPGk+KHdoZW4gYGpRdWVyeVVJYCBpcyB0cnVlKTwvaT5cblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuZG9tXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImRvbVwiOiAnJmx0O1widG9wXCJpJmd0O3J0Jmx0O1wiYm90dG9tXCJmbHAmZ3Q7Jmx0O1wiY2xlYXJcIiZndDsnXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwic0RvbVwiOiBcImxmcnRpcFwiLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogU2VhcmNoIGRlbGF5IG9wdGlvbi4gVGhpcyB3aWxsIHRocm90dGxlIGZ1bGwgdGFibGUgc2VhcmNoZXMgdGhhdCB1c2UgdGhlXG5cdFx0ICogRGF0YVRhYmxlcyBwcm92aWRlZCBzZWFyY2ggaW5wdXQgZWxlbWVudCAoaXQgZG9lcyBub3QgZWZmZWN0IGNhbGxzIHRvXG5cdFx0ICogYGR0LWFwaSBzZWFyY2goKWAsIHByb3ZpZGluZyBhIGRlbGF5IGJlZm9yZSB0aGUgc2VhcmNoIGlzIG1hZGUuXG5cdFx0ICogIEB0eXBlIGludGVnZXJcblx0XHQgKiAgQGRlZmF1bHQgMFxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25zXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zZWFyY2hEZWxheVxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzZWFyY2hEZWxheVwiOiAyMDBcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9IClcblx0XHQgKi9cblx0XHRcInNlYXJjaERlbGF5XCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBEYXRhVGFibGVzIGZlYXR1cmVzIGZvdXIgZGlmZmVyZW50IGJ1aWx0LWluIG9wdGlvbnMgZm9yIHRoZSBidXR0b25zIHRvXG5cdFx0ICogZGlzcGxheSBmb3IgcGFnaW5hdGlvbiBjb250cm9sOlxuXHRcdCAqXG5cdFx0ICogKiBgc2ltcGxlYCAtICdQcmV2aW91cycgYW5kICdOZXh0JyBidXR0b25zIG9ubHlcblx0XHQgKiAqICdzaW1wbGVfbnVtYmVyc2AgLSAnUHJldmlvdXMnIGFuZCAnTmV4dCcgYnV0dG9ucywgcGx1cyBwYWdlIG51bWJlcnNcblx0XHQgKiAqIGBmdWxsYCAtICdGaXJzdCcsICdQcmV2aW91cycsICdOZXh0JyBhbmQgJ0xhc3QnIGJ1dHRvbnNcblx0XHQgKiAqIGBmdWxsX251bWJlcnNgIC0gJ0ZpcnN0JywgJ1ByZXZpb3VzJywgJ05leHQnIGFuZCAnTGFzdCcgYnV0dG9ucywgcGx1c1xuXHRcdCAqICAgcGFnZSBudW1iZXJzXG5cdFx0ICogIFxuXHRcdCAqIEZ1cnRoZXIgbWV0aG9kcyBjYW4gYmUgYWRkZWQgdXNpbmcge0BsaW5rIERhdGFUYWJsZS5leHQub1BhZ2luYXRpb259LlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgc2ltcGxlX251bWJlcnNcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMucGFnaW5nVHlwZVxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJwYWdpbmdUeXBlXCI6IFwiZnVsbF9udW1iZXJzXCJcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9IClcblx0XHQgKi9cblx0XHRcInNQYWdpbmF0aW9uVHlwZVwiOiBcInNpbXBsZV9udW1iZXJzXCIsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBFbmFibGUgaG9yaXpvbnRhbCBzY3JvbGxpbmcuIFdoZW4gYSB0YWJsZSBpcyB0b28gd2lkZSB0byBmaXQgaW50byBhXG5cdFx0ICogY2VydGFpbiBsYXlvdXQsIG9yIHlvdSBoYXZlIGEgbGFyZ2UgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIHRhYmxlLCB5b3Vcblx0XHQgKiBjYW4gZW5hYmxlIHgtc2Nyb2xsaW5nIHRvIHNob3cgdGhlIHRhYmxlIGluIGEgdmlld3BvcnQsIHdoaWNoIGNhbiBiZVxuXHRcdCAqIHNjcm9sbGVkLiBUaGlzIHByb3BlcnR5IGNhbiBiZSBgdHJ1ZWAgd2hpY2ggd2lsbCBhbGxvdyB0aGUgdGFibGUgdG9cblx0XHQgKiBzY3JvbGwgaG9yaXpvbnRhbGx5IHdoZW4gbmVlZGVkLCBvciBhbnkgQ1NTIHVuaXQsIG9yIGEgbnVtYmVyIChpbiB3aGljaFxuXHRcdCAqIGNhc2UgaXQgd2lsbCBiZSB0cmVhdGVkIGFzIGEgcGl4ZWwgbWVhc3VyZW1lbnQpLiBTZXR0aW5nIGFzIHNpbXBseSBgdHJ1ZWBcblx0XHQgKiBpcyByZWNvbW1lbmRlZC5cblx0XHQgKiAgQHR5cGUgYm9vbGVhbnxzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgPGk+Ymxhbmsgc3RyaW5nIC0gaS5lLiBkaXNhYmxlZDwvaT5cblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgRmVhdHVyZXNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNjcm9sbFhcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwic2Nyb2xsWFwiOiB0cnVlLFxuXHRcdCAqICAgICAgICBcInNjcm9sbENvbGxhcHNlXCI6IHRydWVcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJzU2Nyb2xsWFwiOiBcIlwiLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhpcyBwcm9wZXJ0eSBjYW4gYmUgdXNlZCB0byBmb3JjZSBhIERhdGFUYWJsZSB0byB1c2UgbW9yZSB3aWR0aCB0aGFuIGl0XG5cdFx0ICogbWlnaHQgb3RoZXJ3aXNlIGRvIHdoZW4geC1zY3JvbGxpbmcgaXMgZW5hYmxlZC4gRm9yIGV4YW1wbGUgaWYgeW91IGhhdmUgYVxuXHRcdCAqIHRhYmxlIHdoaWNoIHJlcXVpcmVzIHRvIGJlIHdlbGwgc3BhY2VkLCB0aGlzIHBhcmFtZXRlciBpcyB1c2VmdWwgZm9yXG5cdFx0ICogXCJvdmVyLXNpemluZ1wiIHRoZSB0YWJsZSwgYW5kIHRodXMgZm9yY2luZyBzY3JvbGxpbmcuIFRoaXMgcHJvcGVydHkgY2FuIGJ5XG5cdFx0ICogYW55IENTUyB1bml0LCBvciBhIG51bWJlciAoaW4gd2hpY2ggY2FzZSBpdCB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBwaXhlbFxuXHRcdCAqIG1lYXN1cmVtZW50KS5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IDxpPmJsYW5rIHN0cmluZyAtIGkuZS4gZGlzYWJsZWQ8L2k+XG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNjcm9sbFhJbm5lclxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzY3JvbGxYXCI6IFwiMTAwJVwiLFxuXHRcdCAqICAgICAgICBcInNjcm9sbFhJbm5lclwiOiBcIjExMCVcIlxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcInNTY3JvbGxYSW5uZXJcIjogXCJcIixcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEVuYWJsZSB2ZXJ0aWNhbCBzY3JvbGxpbmcuIFZlcnRpY2FsIHNjcm9sbGluZyB3aWxsIGNvbnN0cmFpbiB0aGUgRGF0YVRhYmxlXG5cdFx0ICogdG8gdGhlIGdpdmVuIGhlaWdodCwgYW5kIGVuYWJsZSBzY3JvbGxpbmcgZm9yIGFueSBkYXRhIHdoaWNoIG92ZXJmbG93cyB0aGVcblx0XHQgKiBjdXJyZW50IHZpZXdwb3J0LiBUaGlzIGNhbiBiZSB1c2VkIGFzIGFuIGFsdGVybmF0aXZlIHRvIHBhZ2luZyB0byBkaXNwbGF5XG5cdFx0ICogYSBsb3Qgb2YgZGF0YSBpbiBhIHNtYWxsIGFyZWEgKGFsdGhvdWdoIHBhZ2luZyBhbmQgc2Nyb2xsaW5nIGNhbiBib3RoIGJlXG5cdFx0ICogZW5hYmxlZCBhdCB0aGUgc2FtZSB0aW1lKS4gVGhpcyBwcm9wZXJ0eSBjYW4gYmUgYW55IENTUyB1bml0LCBvciBhIG51bWJlclxuXHRcdCAqIChpbiB3aGljaCBjYXNlIGl0IHdpbGwgYmUgdHJlYXRlZCBhcyBhIHBpeGVsIG1lYXN1cmVtZW50KS5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IDxpPmJsYW5rIHN0cmluZyAtIGkuZS4gZGlzYWJsZWQ8L2k+XG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IEZlYXR1cmVzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zY3JvbGxZXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInNjcm9sbFlcIjogXCIyMDBweFwiLFxuXHRcdCAqICAgICAgICBcInBhZ2luYXRlXCI6IGZhbHNlXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwic1Njcm9sbFlcIjogXCJcIixcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIF9fRGVwcmVjYXRlZF9fIFRoZSBmdW5jdGlvbmFsaXR5IHByb3ZpZGVkIGJ5IHRoaXMgcGFyYW1ldGVyIGhhcyBub3cgYmVlblxuXHRcdCAqIHN1cGVyc2VkZWQgYnkgdGhhdCBwcm92aWRlZCB0aHJvdWdoIGBhamF4YCwgd2hpY2ggc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cblx0XHQgKlxuXHRcdCAqIFNldCB0aGUgSFRUUCBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIG1ha2UgdGhlIEFqYXggY2FsbCBmb3Igc2VydmVyLXNpZGVcblx0XHQgKiBwcm9jZXNzaW5nIG9yIEFqYXggc291cmNlZCBkYXRhLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgR0VUXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0XHQgKiAgQGR0b3B0IFNlcnZlci1zaWRlXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zZXJ2ZXJNZXRob2Rcblx0XHQgKlxuXHRcdCAqICBAZGVwcmVjYXRlZCAxLjEwLiBQbGVhc2UgdXNlIGBhamF4YCBmb3IgdGhpcyBmdW5jdGlvbmFsaXR5IG5vdy5cblx0XHQgKi9cblx0XHRcInNTZXJ2ZXJNZXRob2RcIjogXCJHRVRcIixcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIERhdGFUYWJsZXMgbWFrZXMgdXNlIG9mIHJlbmRlcmVycyB3aGVuIGRpc3BsYXlpbmcgSFRNTCBlbGVtZW50cyBmb3Jcblx0XHQgKiBhIHRhYmxlLiBUaGVzZSByZW5kZXJlcnMgY2FuIGJlIGFkZGVkIG9yIG1vZGlmaWVkIGJ5IHBsdWctaW5zIHRvXG5cdFx0ICogZ2VuZXJhdGUgc3VpdGFibGUgbWFyay11cCBmb3IgYSBzaXRlLiBGb3IgZXhhbXBsZSB0aGUgQm9vdHN0cmFwXG5cdFx0ICogaW50ZWdyYXRpb24gcGx1Zy1pbiBmb3IgRGF0YVRhYmxlcyB1c2VzIGEgcGFnaW5nIGJ1dHRvbiByZW5kZXJlciB0b1xuXHRcdCAqIGRpc3BsYXkgcGFnaW5hdGlvbiBidXR0b25zIGluIHRoZSBtYXJrLXVwIHJlcXVpcmVkIGJ5IEJvb3RzdHJhcC5cblx0XHQgKlxuXHRcdCAqIEZvciBmdXJ0aGVyIGluZm9ybWF0aW9uIGFib3V0IHRoZSByZW5kZXJlcnMgYXZhaWxhYmxlIHNlZVxuXHRcdCAqIERhdGFUYWJsZS5leHQucmVuZGVyZXJcblx0XHQgKiAgQHR5cGUgc3RyaW5nfG9iamVjdFxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnJlbmRlcmVyXG5cdFx0ICpcblx0XHQgKi9cblx0XHRcInJlbmRlcmVyXCI6IG51bGxcblx0fTtcblx0XG5cdF9mbkh1bmdhcmlhbk1hcCggRGF0YVRhYmxlLmRlZmF1bHRzICk7XG5cdFxuXHRcblx0XG5cdC8qXG5cdCAqIERldmVsb3BlciBub3RlIC0gU2VlIG5vdGUgaW4gbW9kZWwuZGVmYXVsdHMuanMgYWJvdXQgdGhlIHVzZSBvZiBIdW5nYXJpYW5cblx0ICogbm90YXRpb24gYW5kIGNhbWVsIGNhc2UuXG5cdCAqL1xuXHRcblx0LyoqXG5cdCAqIENvbHVtbiBvcHRpb25zIHRoYXQgY2FuIGJlIGdpdmVuIHRvIERhdGFUYWJsZXMgYXQgaW5pdGlhbGlzYXRpb24gdGltZS5cblx0ICogIEBuYW1lc3BhY2Vcblx0ICovXG5cdERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4gPSB7XG5cdFx0LyoqXG5cdFx0ICogRGVmaW5lIHdoaWNoIGNvbHVtbihzKSBhbiBvcmRlciB3aWxsIG9jY3VyIG9uIGZvciB0aGlzIGNvbHVtbi4gVGhpc1xuXHRcdCAqIGFsbG93cyBhIGNvbHVtbidzIG9yZGVyaW5nIHRvIHRha2UgbXVsdGlwbGUgY29sdW1ucyBpbnRvIGFjY291bnQgd2hlblxuXHRcdCAqIGRvaW5nIGEgc29ydCBvciB1c2UgdGhlIGRhdGEgZnJvbSBhIGRpZmZlcmVudCBjb2x1bW4uIEZvciBleGFtcGxlIGZpcnN0XG5cdFx0ICogbmFtZSAvIGxhc3QgbmFtZSBjb2x1bW5zIG1ha2Ugc2Vuc2UgdG8gZG8gYSBtdWx0aS1jb2x1bW4gc29ydCBvdmVyIHRoZVxuXHRcdCAqIHR3byBjb2x1bW5zLlxuXHRcdCAqICBAdHlwZSBhcnJheXxpbnRcblx0XHQgKiAgQGRlZmF1bHQgbnVsbCA8aT5UYWtlcyB0aGUgdmFsdWUgb2YgdGhlIGNvbHVtbiBpbmRleCBhdXRvbWF0aWNhbGx5PC9pPlxuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4ub3JkZXJEYXRhXG5cdFx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlckRhdGFcIjogWyAwLCAxIF0sIFwidGFyZ2V0c1wiOiBbIDAgXSB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlckRhdGFcIjogWyAxLCAwIF0sIFwidGFyZ2V0c1wiOiBbIDEgXSB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlckRhdGFcIjogMiwgXCJ0YXJnZXRzXCI6IFsgMiBdIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdFx0ICogICAgICAgICAgeyBcIm9yZGVyRGF0YVwiOiBbIDAsIDEgXSB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlckRhdGFcIjogWyAxLCAwIF0gfSxcblx0XHQgKiAgICAgICAgICB7IFwib3JkZXJEYXRhXCI6IDIgfSxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGxcblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImFEYXRhU29ydFwiOiBudWxsLFxuXHRcdFwiaURhdGFTb3J0XCI6IC0xLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogWW91IGNhbiBjb250cm9sIHRoZSBkZWZhdWx0IG9yZGVyaW5nIGRpcmVjdGlvbiwgYW5kIGV2ZW4gYWx0ZXIgdGhlXG5cdFx0ICogYmVoYXZpb3VyIG9mIHRoZSBzb3J0IGhhbmRsZXIgKGkuZS4gb25seSBhbGxvdyBhc2NlbmRpbmcgb3JkZXJpbmcgZXRjKVxuXHRcdCAqIHVzaW5nIHRoaXMgcGFyYW1ldGVyLlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbICdhc2MnLCAnZGVzYycgXVxuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4ub3JkZXJTZXF1ZW5jZVxuXHRcdCAqICBAZHRvcHQgQ29sdW1uc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwib3JkZXJTZXF1ZW5jZVwiOiBbIFwiYXNjXCIgXSwgXCJ0YXJnZXRzXCI6IFsgMSBdIH0sXG5cdFx0ICogICAgICAgICAgeyBcIm9yZGVyU2VxdWVuY2VcIjogWyBcImRlc2NcIiwgXCJhc2NcIiwgXCJhc2NcIiBdLCBcInRhcmdldHNcIjogWyAyIF0gfSxcblx0XHQgKiAgICAgICAgICB7IFwib3JkZXJTZXF1ZW5jZVwiOiBbIFwiZGVzY1wiIF0sIFwidGFyZ2V0c1wiOiBbIDMgXSB9XG5cdFx0ICogICAgICAgIF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbnNcIjogW1xuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgeyBcIm9yZGVyU2VxdWVuY2VcIjogWyBcImFzY1wiIF0gfSxcblx0XHQgKiAgICAgICAgICB7IFwib3JkZXJTZXF1ZW5jZVwiOiBbIFwiZGVzY1wiLCBcImFzY1wiLCBcImFzY1wiIF0gfSxcblx0XHQgKiAgICAgICAgICB7IFwib3JkZXJTZXF1ZW5jZVwiOiBbIFwiZGVzY1wiIF0gfSxcblx0XHQgKiAgICAgICAgICBudWxsXG5cdFx0ICogICAgICAgIF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJhc1NvcnRpbmdcIjogWyAnYXNjJywgJ2Rlc2MnIF0sXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBFbmFibGUgb3IgZGlzYWJsZSBmaWx0ZXJpbmcgb24gdGhlIGRhdGEgaW4gdGhpcyBjb2x1bW4uXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4uc2VhcmNoYWJsZVxuXHRcdCAqICBAZHRvcHQgQ29sdW1uc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwic2VhcmNoYWJsZVwiOiBmYWxzZSwgXCJ0YXJnZXRzXCI6IFsgMCBdIH1cblx0XHQgKiAgICAgICAgXSB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwic2VhcmNoYWJsZVwiOiBmYWxzZSB9LFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGxcblx0XHQgKiAgICAgICAgXSB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYlNlYXJjaGFibGVcIjogdHJ1ZSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEVuYWJsZSBvciBkaXNhYmxlIG9yZGVyaW5nIG9uIHRoaXMgY29sdW1uLlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IHRydWVcblx0XHQgKlxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLm9yZGVyYWJsZVxuXHRcdCAqICBAZHRvcHQgQ29sdW1uc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwib3JkZXJhYmxlXCI6IGZhbHNlLCBcInRhcmdldHNcIjogWyAwIF0gfVxuXHRcdCAqICAgICAgICBdIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlcmFibGVcIjogZmFsc2UgfSxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsXG5cdFx0ICogICAgICAgIF0gfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImJTb3J0YWJsZVwiOiB0cnVlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRW5hYmxlIG9yIGRpc2FibGUgdGhlIGRpc3BsYXkgb2YgdGhpcyBjb2x1bW4uXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4udmlzaWJsZVxuXHRcdCAqICBAZHRvcHQgQ29sdW1uc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwidmlzaWJsZVwiOiBmYWxzZSwgXCJ0YXJnZXRzXCI6IFsgMCBdIH1cblx0XHQgKiAgICAgICAgXSB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwidmlzaWJsZVwiOiBmYWxzZSB9LFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGxcblx0XHQgKiAgICAgICAgXSB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYlZpc2libGVcIjogdHJ1ZSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIERldmVsb3BlciBkZWZpbmFibGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbmV2ZXIgYSBjZWxsIGlzIGNyZWF0ZWQgKEFqYXggc291cmNlLFxuXHRcdCAqIGV0Yykgb3IgcHJvY2Vzc2VkIGZvciBpbnB1dCAoRE9NIHNvdXJjZSkuIFRoaXMgY2FuIGJlIHVzZWQgYXMgYSBjb21wbGltZW50IHRvIG1SZW5kZXJcblx0XHQgKiBhbGxvd2luZyB5b3UgdG8gbW9kaWZ5IHRoZSBET00gZWxlbWVudCAoYWRkIGJhY2tncm91bmQgY29sb3VyIGZvciBleGFtcGxlKSB3aGVuIHRoZVxuXHRcdCAqIGVsZW1lbnQgaXMgYXZhaWxhYmxlLlxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAcGFyYW0ge2VsZW1lbnR9IHRkIFRoZSBURCBub2RlIHRoYXQgaGFzIGJlZW4gY3JlYXRlZFxuXHRcdCAqICBAcGFyYW0geyp9IGNlbGxEYXRhIFRoZSBEYXRhIGZvciB0aGUgY2VsbFxuXHRcdCAqICBAcGFyYW0ge2FycmF5fG9iamVjdH0gcm93RGF0YSBUaGUgZGF0YSBmb3IgdGhlIHdob2xlIHJvd1xuXHRcdCAqICBAcGFyYW0ge2ludH0gcm93IFRoZSByb3cgaW5kZXggZm9yIHRoZSBhb0RhdGEgZGF0YSBzdG9yZVxuXHRcdCAqICBAcGFyYW0ge2ludH0gY29sIFRoZSBjb2x1bW4gaW5kZXggZm9yIGFvQ29sdW1uc1xuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4uY3JlYXRlZENlbGxcblx0XHQgKiAgQGR0b3B0IENvbHVtbnNcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbIHtcblx0XHQgKiAgICAgICAgICBcInRhcmdldHNcIjogWzNdLFxuXHRcdCAqICAgICAgICAgIFwiY3JlYXRlZENlbGxcIjogZnVuY3Rpb24gKHRkLCBjZWxsRGF0YSwgcm93RGF0YSwgcm93LCBjb2wpIHtcblx0XHQgKiAgICAgICAgICAgIGlmICggY2VsbERhdGEgPT0gXCIxLjdcIiApIHtcblx0XHQgKiAgICAgICAgICAgICAgJCh0ZCkuY3NzKCdjb2xvcicsICdibHVlJylcblx0XHQgKiAgICAgICAgICAgIH1cblx0XHQgKiAgICAgICAgICB9XG5cdFx0ICogICAgICAgIH0gXVxuXHRcdCAqICAgICAgfSk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiZm5DcmVhdGVkQ2VsbFwiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhpcyBwYXJhbWV0ZXIgaGFzIGJlZW4gcmVwbGFjZWQgYnkgYGRhdGFgIGluIERhdGFUYWJsZXMgdG8gZW5zdXJlIG5hbWluZ1xuXHRcdCAqIGNvbnNpc3RlbmN5LiBgZGF0YVByb3BgIGNhbiBzdGlsbCBiZSB1c2VkLCBhcyB0aGVyZSBpcyBiYWNrd2FyZHNcblx0XHQgKiBjb21wYXRpYmlsaXR5IGluIERhdGFUYWJsZXMgZm9yIHRoaXMgb3B0aW9uLCBidXQgaXQgaXMgc3Ryb25nbHlcblx0XHQgKiByZWNvbW1lbmRlZCB0aGF0IHlvdSB1c2UgYGRhdGFgIGluIHByZWZlcmVuY2UgdG8gYGRhdGFQcm9wYC5cblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5kYXRhUHJvcFxuXHRcdCAqL1xuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhpcyBwcm9wZXJ0eSBjYW4gYmUgdXNlZCB0byByZWFkIGRhdGEgZnJvbSBhbnkgZGF0YSBzb3VyY2UgcHJvcGVydHksXG5cdFx0ICogaW5jbHVkaW5nIGRlZXBseSBuZXN0ZWQgb2JqZWN0cyAvIHByb3BlcnRpZXMuIGBkYXRhYCBjYW4gYmUgZ2l2ZW4gaW4gYVxuXHRcdCAqIG51bWJlciBvZiBkaWZmZXJlbnQgd2F5cyB3aGljaCBlZmZlY3QgaXRzIGJlaGF2aW91cjpcblx0XHQgKlxuXHRcdCAqICogYGludGVnZXJgIC0gdHJlYXRlZCBhcyBhbiBhcnJheSBpbmRleCBmb3IgdGhlIGRhdGEgc291cmNlLiBUaGlzIGlzIHRoZVxuXHRcdCAqICAgZGVmYXVsdCB0aGF0IERhdGFUYWJsZXMgdXNlcyAoaW5jcmVtZW50YWxseSBpbmNyZWFzZWQgZm9yIGVhY2ggY29sdW1uKS5cblx0XHQgKiAqIGBzdHJpbmdgIC0gcmVhZCBhbiBvYmplY3QgcHJvcGVydHkgZnJvbSB0aGUgZGF0YSBzb3VyY2UuIFRoZXJlIGFyZVxuXHRcdCAqICAgdGhyZWUgJ3NwZWNpYWwnIG9wdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCBpbiB0aGUgc3RyaW5nIHRvIGFsdGVyIGhvd1xuXHRcdCAqICAgRGF0YVRhYmxlcyByZWFkcyB0aGUgZGF0YSBmcm9tIHRoZSBzb3VyY2Ugb2JqZWN0OlxuXHRcdCAqICAgICogYC5gIC0gRG90dGVkIEphdmFzY3JpcHQgbm90YXRpb24uIEp1c3QgYXMgeW91IHVzZSBhIGAuYCBpblxuXHRcdCAqICAgICAgSmF2YXNjcmlwdCB0byByZWFkIGZyb20gbmVzdGVkIG9iamVjdHMsIHNvIHRvIGNhbiB0aGUgb3B0aW9uc1xuXHRcdCAqICAgICAgc3BlY2lmaWVkIGluIGBkYXRhYC4gRm9yIGV4YW1wbGU6IGBicm93c2VyLnZlcnNpb25gIG9yXG5cdFx0ICogICAgICBgYnJvd3Nlci5uYW1lYC4gSWYgeW91ciBvYmplY3QgcGFyYW1ldGVyIG5hbWUgY29udGFpbnMgYSBwZXJpb2QsIHVzZVxuXHRcdCAqICAgICAgYFxcXFxgIHRvIGVzY2FwZSBpdCAtIGkuZS4gYGZpcnN0XFxcXC5uYW1lYC5cblx0XHQgKiAgICAqIGBbXWAgLSBBcnJheSBub3RhdGlvbi4gRGF0YVRhYmxlcyBjYW4gYXV0b21hdGljYWxseSBjb21iaW5lIGRhdGFcblx0XHQgKiAgICAgIGZyb20gYW5kIGFycmF5IHNvdXJjZSwgam9pbmluZyB0aGUgZGF0YSB3aXRoIHRoZSBjaGFyYWN0ZXJzIHByb3ZpZGVkXG5cdFx0ICogICAgICBiZXR3ZWVuIHRoZSB0d28gYnJhY2tldHMuIEZvciBleGFtcGxlOiBgbmFtZVssIF1gIHdvdWxkIHByb3ZpZGUgYVxuXHRcdCAqICAgICAgY29tbWEtc3BhY2Ugc2VwYXJhdGVkIGxpc3QgZnJvbSB0aGUgc291cmNlIGFycmF5LiBJZiBubyBjaGFyYWN0ZXJzXG5cdFx0ICogICAgICBhcmUgcHJvdmlkZWQgYmV0d2VlbiB0aGUgYnJhY2tldHMsIHRoZSBvcmlnaW5hbCBhcnJheSBzb3VyY2UgaXNcblx0XHQgKiAgICAgIHJldHVybmVkLlxuXHRcdCAqICAgICogYCgpYCAtIEZ1bmN0aW9uIG5vdGF0aW9uLiBBZGRpbmcgYCgpYCB0byB0aGUgZW5kIG9mIGEgcGFyYW1ldGVyIHdpbGxcblx0XHQgKiAgICAgIGV4ZWN1dGUgYSBmdW5jdGlvbiBvZiB0aGUgbmFtZSBnaXZlbi4gRm9yIGV4YW1wbGU6IGBicm93c2VyKClgIGZvciBhXG5cdFx0ICogICAgICBzaW1wbGUgZnVuY3Rpb24gb24gdGhlIGRhdGEgc291cmNlLCBgYnJvd3Nlci52ZXJzaW9uKClgIGZvciBhXG5cdFx0ICogICAgICBmdW5jdGlvbiBpbiBhIG5lc3RlZCBwcm9wZXJ0eSBvciBldmVuIGBicm93c2VyKCkudmVyc2lvbmAgdG8gZ2V0IGFuXG5cdFx0ICogICAgICBvYmplY3QgcHJvcGVydHkgaWYgdGhlIGZ1bmN0aW9uIGNhbGxlZCByZXR1cm5zIGFuIG9iamVjdC4gTm90ZSB0aGF0XG5cdFx0ICogICAgICBmdW5jdGlvbiBub3RhdGlvbiBpcyByZWNvbW1lbmRlZCBmb3IgdXNlIGluIGByZW5kZXJgIHJhdGhlciB0aGFuXG5cdFx0ICogICAgICBgZGF0YWAgYXMgaXQgaXMgbXVjaCBzaW1wbGVyIHRvIHVzZSBhcyBhIHJlbmRlcmVyLlxuXHRcdCAqICogYG51bGxgIC0gdXNlIHRoZSBvcmlnaW5hbCBkYXRhIHNvdXJjZSBmb3IgdGhlIHJvdyByYXRoZXIgdGhhbiBwbHVja2luZ1xuXHRcdCAqICAgZGF0YSBkaXJlY3RseSBmcm9tIGl0LiBUaGlzIGFjdGlvbiBoYXMgZWZmZWN0cyBvbiB0d28gb3RoZXJcblx0XHQgKiAgIGluaXRpYWxpc2F0aW9uIG9wdGlvbnM6XG5cdFx0ICogICAgKiBgZGVmYXVsdENvbnRlbnRgIC0gV2hlbiBudWxsIGlzIGdpdmVuIGFzIHRoZSBgZGF0YWAgb3B0aW9uIGFuZFxuXHRcdCAqICAgICAgYGRlZmF1bHRDb250ZW50YCBpcyBzcGVjaWZpZWQgZm9yIHRoZSBjb2x1bW4sIHRoZSB2YWx1ZSBkZWZpbmVkIGJ5XG5cdFx0ICogICAgICBgZGVmYXVsdENvbnRlbnRgIHdpbGwgYmUgdXNlZCBmb3IgdGhlIGNlbGwuXG5cdFx0ICogICAgKiBgcmVuZGVyYCAtIFdoZW4gbnVsbCBpcyB1c2VkIGZvciB0aGUgYGRhdGFgIG9wdGlvbiBhbmQgdGhlIGByZW5kZXJgXG5cdFx0ICogICAgICBvcHRpb24gaXMgc3BlY2lmaWVkIGZvciB0aGUgY29sdW1uLCB0aGUgd2hvbGUgZGF0YSBzb3VyY2UgZm9yIHRoZVxuXHRcdCAqICAgICAgcm93IGlzIHVzZWQgZm9yIHRoZSByZW5kZXJlci5cblx0XHQgKiAqIGBmdW5jdGlvbmAgLSB0aGUgZnVuY3Rpb24gZ2l2ZW4gd2lsbCBiZSBleGVjdXRlZCB3aGVuZXZlciBEYXRhVGFibGVzXG5cdFx0ICogICBuZWVkcyB0byBzZXQgb3IgZ2V0IHRoZSBkYXRhIGZvciBhIGNlbGwgaW4gdGhlIGNvbHVtbi4gVGhlIGZ1bmN0aW9uXG5cdFx0ICogICB0YWtlcyB0aHJlZSBwYXJhbWV0ZXJzOlxuXHRcdCAqICAgICogUGFyYW1ldGVyczpcblx0XHQgKiAgICAgICogYHthcnJheXxvYmplY3R9YCBUaGUgZGF0YSBzb3VyY2UgZm9yIHRoZSByb3dcblx0XHQgKiAgICAgICogYHtzdHJpbmd9YCBUaGUgdHlwZSBjYWxsIGRhdGEgcmVxdWVzdGVkIC0gdGhpcyB3aWxsIGJlICdzZXQnIHdoZW5cblx0XHQgKiAgICAgICAgc2V0dGluZyBkYXRhIG9yICdmaWx0ZXInLCAnZGlzcGxheScsICd0eXBlJywgJ3NvcnQnIG9yIHVuZGVmaW5lZFxuXHRcdCAqICAgICAgICB3aGVuIGdhdGhlcmluZyBkYXRhLiBOb3RlIHRoYXQgd2hlbiBgdW5kZWZpbmVkYCBpcyBnaXZlbiBmb3IgdGhlXG5cdFx0ICogICAgICAgIHR5cGUgRGF0YVRhYmxlcyBleHBlY3RzIHRvIGdldCB0aGUgcmF3IGRhdGEgZm9yIHRoZSBvYmplY3QgYmFjazxcblx0XHQgKiAgICAgICogYHsqfWAgRGF0YSB0byBzZXQgd2hlbiB0aGUgc2Vjb25kIHBhcmFtZXRlciBpcyAnc2V0Jy5cblx0XHQgKiAgICAqIFJldHVybjpcblx0XHQgKiAgICAgICogVGhlIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBmdW5jdGlvbiBpcyBub3QgcmVxdWlyZWQgd2hlbiAnc2V0JyBpc1xuXHRcdCAqICAgICAgICB0aGUgdHlwZSBvZiBjYWxsLCBidXQgb3RoZXJ3aXNlIHRoZSByZXR1cm4gaXMgd2hhdCB3aWxsIGJlIHVzZWRcblx0XHQgKiAgICAgICAgZm9yIHRoZSBkYXRhIHJlcXVlc3RlZC5cblx0XHQgKlxuXHRcdCAqIE5vdGUgdGhhdCBgZGF0YWAgaXMgYSBnZXR0ZXIgYW5kIHNldHRlciBvcHRpb24uIElmIHlvdSBqdXN0IHJlcXVpcmVcblx0XHQgKiBmb3JtYXR0aW5nIG9mIGRhdGEgZm9yIG91dHB1dCwgeW91IHdpbGwgbGlrZWx5IHdhbnQgdG8gdXNlIGByZW5kZXJgIHdoaWNoXG5cdFx0ICogaXMgc2ltcGx5IGEgZ2V0dGVyIGFuZCB0aHVzIHNpbXBsZXIgdG8gdXNlLlxuXHRcdCAqXG5cdFx0ICogTm90ZSB0aGF0IHByaW9yIHRvIERhdGFUYWJsZXMgMS45LjIgYGRhdGFgIHdhcyBjYWxsZWQgYG1EYXRhUHJvcGAuIFRoZVxuXHRcdCAqIG5hbWUgY2hhbmdlIHJlZmxlY3RzIHRoZSBmbGV4aWJpbGl0eSBvZiB0aGlzIHByb3BlcnR5IGFuZCBpcyBjb25zaXN0ZW50XG5cdFx0ICogd2l0aCB0aGUgbmFtaW5nIG9mIG1SZW5kZXIuIElmICdtRGF0YVByb3AnIGlzIGdpdmVuLCB0aGVuIGl0IHdpbGwgc3RpbGxcblx0XHQgKiBiZSB1c2VkIGJ5IERhdGFUYWJsZXMsIGFzIGl0IGF1dG9tYXRpY2FsbHkgbWFwcyB0aGUgb2xkIG5hbWUgdG8gdGhlIG5ld1xuXHRcdCAqIGlmIHJlcXVpcmVkLlxuXHRcdCAqXG5cdFx0ICogIEB0eXBlIHN0cmluZ3xpbnR8ZnVuY3Rpb258bnVsbFxuXHRcdCAqICBAZGVmYXVsdCBudWxsIDxpPlVzZSBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZWQgY29sdW1uIGluZGV4PC9pPlxuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4uZGF0YVxuXHRcdCAqICBAZHRvcHQgQ29sdW1uc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gUmVhZCB0YWJsZSBkYXRhIGZyb20gb2JqZWN0c1xuXHRcdCAqICAgIC8vIEpTT04gc3RydWN0dXJlIGZvciBlYWNoIHJvdzpcblx0XHQgKiAgICAvLyAgIHtcblx0XHQgKiAgICAvLyAgICAgIFwiZW5naW5lXCI6IHt2YWx1ZX0sXG5cdFx0ICogICAgLy8gICAgICBcImJyb3dzZXJcIjoge3ZhbHVlfSxcblx0XHQgKiAgICAvLyAgICAgIFwicGxhdGZvcm1cIjoge3ZhbHVlfSxcblx0XHQgKiAgICAvLyAgICAgIFwidmVyc2lvblwiOiB7dmFsdWV9LFxuXHRcdCAqICAgIC8vICAgICAgXCJncmFkZVwiOiB7dmFsdWV9XG5cdFx0ICogICAgLy8gICB9XG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJhamF4U291cmNlXCI6IFwic291cmNlcy9vYmplY3RzLnR4dFwiLFxuXHRcdCAqICAgICAgICBcImNvbHVtbnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwiZW5naW5lXCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwiZGF0YVwiOiBcImJyb3dzZXJcIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwicGxhdGZvcm1cIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwidmVyc2lvblwiIH0sXG5cdFx0ICogICAgICAgICAgeyBcImRhdGFcIjogXCJncmFkZVwiIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFJlYWQgaW5mb3JtYXRpb24gZnJvbSBkZWVwbHkgbmVzdGVkIG9iamVjdHNcblx0XHQgKiAgICAvLyBKU09OIHN0cnVjdHVyZSBmb3IgZWFjaCByb3c6XG5cdFx0ICogICAgLy8gICB7XG5cdFx0ICogICAgLy8gICAgICBcImVuZ2luZVwiOiB7dmFsdWV9LFxuXHRcdCAqICAgIC8vICAgICAgXCJicm93c2VyXCI6IHt2YWx1ZX0sXG5cdFx0ICogICAgLy8gICAgICBcInBsYXRmb3JtXCI6IHtcblx0XHQgKiAgICAvLyAgICAgICAgIFwiaW5uZXJcIjoge3ZhbHVlfVxuXHRcdCAqICAgIC8vICAgICAgfSxcblx0XHQgKiAgICAvLyAgICAgIFwiZGV0YWlsc1wiOiBbXG5cdFx0ICogICAgLy8gICAgICAgICB7dmFsdWV9LCB7dmFsdWV9XG5cdFx0ICogICAgLy8gICAgICBdXG5cdFx0ICogICAgLy8gICB9XG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJhamF4U291cmNlXCI6IFwic291cmNlcy9kZWVwLnR4dFwiLFxuXHRcdCAqICAgICAgICBcImNvbHVtbnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwiZW5naW5lXCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwiZGF0YVwiOiBcImJyb3dzZXJcIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwicGxhdGZvcm0uaW5uZXJcIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwicGxhdGZvcm0uZGV0YWlscy4wXCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwiZGF0YVwiOiBcInBsYXRmb3JtLmRldGFpbHMuMVwiIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGBkYXRhYCBhcyBhIGZ1bmN0aW9uIHRvIHByb3ZpZGUgZGlmZmVyZW50IGluZm9ybWF0aW9uIGZvclxuXHRcdCAqICAgIC8vIHNvcnRpbmcsIGZpbHRlcmluZyBhbmQgZGlzcGxheS4gSW4gdGhpcyBjYXNlLCBjdXJyZW5jeSAocHJpY2UpXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFsge1xuXHRcdCAqICAgICAgICAgIFwidGFyZ2V0c1wiOiBbIDAgXSxcblx0XHQgKiAgICAgICAgICBcImRhdGFcIjogZnVuY3Rpb24gKCBzb3VyY2UsIHR5cGUsIHZhbCApIHtcblx0XHQgKiAgICAgICAgICAgIGlmICh0eXBlID09PSAnc2V0Jykge1xuXHRcdCAqICAgICAgICAgICAgICBzb3VyY2UucHJpY2UgPSB2YWw7XG5cdFx0ICogICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBjb21wdXRlZCBkaXNsYXkgYW5kIGZpbHRlciB2YWx1ZXMgZm9yIGVmZmljaWVuY3lcblx0XHQgKiAgICAgICAgICAgICAgc291cmNlLnByaWNlX2Rpc3BsYXkgPSB2YWw9PVwiXCIgPyBcIlwiIDogXCIkXCIrbnVtYmVyRm9ybWF0KHZhbCk7XG5cdFx0ICogICAgICAgICAgICAgIHNvdXJjZS5wcmljZV9maWx0ZXIgID0gdmFsPT1cIlwiID8gXCJcIiA6IFwiJFwiK251bWJlckZvcm1hdCh2YWwpK1wiIFwiK3ZhbDtcblx0XHQgKiAgICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAqICAgICAgICAgICAgfVxuXHRcdCAqICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2Rpc3BsYXknKSB7XG5cdFx0ICogICAgICAgICAgICAgIHJldHVybiBzb3VyY2UucHJpY2VfZGlzcGxheTtcblx0XHQgKiAgICAgICAgICAgIH1cblx0XHQgKiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdmaWx0ZXInKSB7XG5cdFx0ICogICAgICAgICAgICAgIHJldHVybiBzb3VyY2UucHJpY2VfZmlsdGVyO1xuXHRcdCAqICAgICAgICAgICAgfVxuXHRcdCAqICAgICAgICAgICAgLy8gJ3NvcnQnLCAndHlwZScgYW5kIHVuZGVmaW5lZCBhbGwganVzdCB1c2UgdGhlIGludGVnZXJcblx0XHQgKiAgICAgICAgICAgIHJldHVybiBzb3VyY2UucHJpY2U7XG5cdFx0ICogICAgICAgICAgfVxuXHRcdCAqICAgICAgICB9IF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBkZWZhdWx0IGNvbnRlbnRcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogWyB7XG5cdFx0ICogICAgICAgICAgXCJ0YXJnZXRzXCI6IFsgMCBdLFxuXHRcdCAqICAgICAgICAgIFwiZGF0YVwiOiBudWxsLFxuXHRcdCAqICAgICAgICAgIFwiZGVmYXVsdENvbnRlbnRcIjogXCJDbGljayB0byBlZGl0XCJcblx0XHQgKiAgICAgICAgfSBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYXJyYXkgbm90YXRpb24gLSBvdXRwdXR0aW5nIGEgbGlzdCBmcm9tIGFuIGFycmF5XG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFsge1xuXHRcdCAqICAgICAgICAgIFwidGFyZ2V0c1wiOiBbIDAgXSxcblx0XHQgKiAgICAgICAgICBcImRhdGFcIjogXCJuYW1lWywgXVwiXG5cdFx0ICogICAgICAgIH0gXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqL1xuXHRcdFwibURhdGFcIjogbnVsbCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgcHJvcGVydHkgaXMgdGhlIHJlbmRlcmluZyBwYXJ0bmVyIHRvIGBkYXRhYCBhbmQgaXQgaXMgc3VnZ2VzdGVkIHRoYXRcblx0XHQgKiB3aGVuIHlvdSB3YW50IHRvIG1hbmlwdWxhdGUgZGF0YSBmb3IgZGlzcGxheSAoaW5jbHVkaW5nIGZpbHRlcmluZyxcblx0XHQgKiBzb3J0aW5nIGV0Yykgd2l0aG91dCBhbHRlcmluZyB0aGUgdW5kZXJseWluZyBkYXRhIGZvciB0aGUgdGFibGUsIHVzZSB0aGlzXG5cdFx0ICogcHJvcGVydHkuIGByZW5kZXJgIGNhbiBiZSBjb25zaWRlcmVkIHRvIGJlIHRoZSB0aGUgcmVhZCBvbmx5IGNvbXBhbmlvbiB0b1xuXHRcdCAqIGBkYXRhYCB3aGljaCBpcyByZWFkIC8gd3JpdGUgKHRoZW4gYXMgc3VjaCBtb3JlIGNvbXBsZXgpLiBMaWtlIGBkYXRhYFxuXHRcdCAqIHRoaXMgb3B0aW9uIGNhbiBiZSBnaXZlbiBpbiBhIG51bWJlciBvZiBkaWZmZXJlbnQgd2F5cyB0byBlZmZlY3QgaXRzXG5cdFx0ICogYmVoYXZpb3VyOlxuXHRcdCAqXG5cdFx0ICogKiBgaW50ZWdlcmAgLSB0cmVhdGVkIGFzIGFuIGFycmF5IGluZGV4IGZvciB0aGUgZGF0YSBzb3VyY2UuIFRoaXMgaXMgdGhlXG5cdFx0ICogICBkZWZhdWx0IHRoYXQgRGF0YVRhYmxlcyB1c2VzIChpbmNyZW1lbnRhbGx5IGluY3JlYXNlZCBmb3IgZWFjaCBjb2x1bW4pLlxuXHRcdCAqICogYHN0cmluZ2AgLSByZWFkIGFuIG9iamVjdCBwcm9wZXJ0eSBmcm9tIHRoZSBkYXRhIHNvdXJjZS4gVGhlcmUgYXJlXG5cdFx0ICogICB0aHJlZSAnc3BlY2lhbCcgb3B0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIGluIHRoZSBzdHJpbmcgdG8gYWx0ZXIgaG93XG5cdFx0ICogICBEYXRhVGFibGVzIHJlYWRzIHRoZSBkYXRhIGZyb20gdGhlIHNvdXJjZSBvYmplY3Q6XG5cdFx0ICogICAgKiBgLmAgLSBEb3R0ZWQgSmF2YXNjcmlwdCBub3RhdGlvbi4gSnVzdCBhcyB5b3UgdXNlIGEgYC5gIGluXG5cdFx0ICogICAgICBKYXZhc2NyaXB0IHRvIHJlYWQgZnJvbSBuZXN0ZWQgb2JqZWN0cywgc28gdG8gY2FuIHRoZSBvcHRpb25zXG5cdFx0ICogICAgICBzcGVjaWZpZWQgaW4gYGRhdGFgLiBGb3IgZXhhbXBsZTogYGJyb3dzZXIudmVyc2lvbmAgb3Jcblx0XHQgKiAgICAgIGBicm93c2VyLm5hbWVgLiBJZiB5b3VyIG9iamVjdCBwYXJhbWV0ZXIgbmFtZSBjb250YWlucyBhIHBlcmlvZCwgdXNlXG5cdFx0ICogICAgICBgXFxcXGAgdG8gZXNjYXBlIGl0IC0gaS5lLiBgZmlyc3RcXFxcLm5hbWVgLlxuXHRcdCAqICAgICogYFtdYCAtIEFycmF5IG5vdGF0aW9uLiBEYXRhVGFibGVzIGNhbiBhdXRvbWF0aWNhbGx5IGNvbWJpbmUgZGF0YVxuXHRcdCAqICAgICAgZnJvbSBhbmQgYXJyYXkgc291cmNlLCBqb2luaW5nIHRoZSBkYXRhIHdpdGggdGhlIGNoYXJhY3RlcnMgcHJvdmlkZWRcblx0XHQgKiAgICAgIGJldHdlZW4gdGhlIHR3byBicmFja2V0cy4gRm9yIGV4YW1wbGU6IGBuYW1lWywgXWAgd291bGQgcHJvdmlkZSBhXG5cdFx0ICogICAgICBjb21tYS1zcGFjZSBzZXBhcmF0ZWQgbGlzdCBmcm9tIHRoZSBzb3VyY2UgYXJyYXkuIElmIG5vIGNoYXJhY3RlcnNcblx0XHQgKiAgICAgIGFyZSBwcm92aWRlZCBiZXR3ZWVuIHRoZSBicmFja2V0cywgdGhlIG9yaWdpbmFsIGFycmF5IHNvdXJjZSBpc1xuXHRcdCAqICAgICAgcmV0dXJuZWQuXG5cdFx0ICogICAgKiBgKClgIC0gRnVuY3Rpb24gbm90YXRpb24uIEFkZGluZyBgKClgIHRvIHRoZSBlbmQgb2YgYSBwYXJhbWV0ZXIgd2lsbFxuXHRcdCAqICAgICAgZXhlY3V0ZSBhIGZ1bmN0aW9uIG9mIHRoZSBuYW1lIGdpdmVuLiBGb3IgZXhhbXBsZTogYGJyb3dzZXIoKWAgZm9yIGFcblx0XHQgKiAgICAgIHNpbXBsZSBmdW5jdGlvbiBvbiB0aGUgZGF0YSBzb3VyY2UsIGBicm93c2VyLnZlcnNpb24oKWAgZm9yIGFcblx0XHQgKiAgICAgIGZ1bmN0aW9uIGluIGEgbmVzdGVkIHByb3BlcnR5IG9yIGV2ZW4gYGJyb3dzZXIoKS52ZXJzaW9uYCB0byBnZXQgYW5cblx0XHQgKiAgICAgIG9iamVjdCBwcm9wZXJ0eSBpZiB0aGUgZnVuY3Rpb24gY2FsbGVkIHJldHVybnMgYW4gb2JqZWN0LlxuXHRcdCAqICogYG9iamVjdGAgLSB1c2UgZGlmZmVyZW50IGRhdGEgZm9yIHRoZSBkaWZmZXJlbnQgZGF0YSB0eXBlcyByZXF1ZXN0ZWQgYnlcblx0XHQgKiAgIERhdGFUYWJsZXMgKCdmaWx0ZXInLCAnZGlzcGxheScsICd0eXBlJyBvciAnc29ydCcpLiBUaGUgcHJvcGVydHkgbmFtZXNcblx0XHQgKiAgIG9mIHRoZSBvYmplY3QgaXMgdGhlIGRhdGEgdHlwZSB0aGUgcHJvcGVydHkgcmVmZXJzIHRvIGFuZCB0aGUgdmFsdWUgY2FuXG5cdFx0ICogICBkZWZpbmVkIHVzaW5nIGFuIGludGVnZXIsIHN0cmluZyBvciBmdW5jdGlvbiB1c2luZyB0aGUgc2FtZSBydWxlcyBhc1xuXHRcdCAqICAgYHJlbmRlcmAgbm9ybWFsbHkgZG9lcy4gTm90ZSB0aGF0IGFuIGBfYCBvcHRpb24gX211c3RfIGJlIHNwZWNpZmllZC5cblx0XHQgKiAgIFRoaXMgaXMgdGhlIGRlZmF1bHQgdmFsdWUgdG8gdXNlIGlmIHlvdSBoYXZlbid0IHNwZWNpZmllZCBhIHZhbHVlIGZvclxuXHRcdCAqICAgdGhlIGRhdGEgdHlwZSByZXF1ZXN0ZWQgYnkgRGF0YVRhYmxlcy5cblx0XHQgKiAqIGBmdW5jdGlvbmAgLSB0aGUgZnVuY3Rpb24gZ2l2ZW4gd2lsbCBiZSBleGVjdXRlZCB3aGVuZXZlciBEYXRhVGFibGVzXG5cdFx0ICogICBuZWVkcyB0byBzZXQgb3IgZ2V0IHRoZSBkYXRhIGZvciBhIGNlbGwgaW4gdGhlIGNvbHVtbi4gVGhlIGZ1bmN0aW9uXG5cdFx0ICogICB0YWtlcyB0aHJlZSBwYXJhbWV0ZXJzOlxuXHRcdCAqICAgICogUGFyYW1ldGVyczpcblx0XHQgKiAgICAgICoge2FycmF5fG9iamVjdH0gVGhlIGRhdGEgc291cmNlIGZvciB0aGUgcm93IChiYXNlZCBvbiBgZGF0YWApXG5cdFx0ICogICAgICAqIHtzdHJpbmd9IFRoZSB0eXBlIGNhbGwgZGF0YSByZXF1ZXN0ZWQgLSB0aGlzIHdpbGwgYmUgJ2ZpbHRlcicsXG5cdFx0ICogICAgICAgICdkaXNwbGF5JywgJ3R5cGUnIG9yICdzb3J0Jy5cblx0XHQgKiAgICAgICoge2FycmF5fG9iamVjdH0gVGhlIGZ1bGwgZGF0YSBzb3VyY2UgZm9yIHRoZSByb3cgKG5vdCBiYXNlZCBvblxuXHRcdCAqICAgICAgICBgZGF0YWApXG5cdFx0ICogICAgKiBSZXR1cm46XG5cdFx0ICogICAgICAqIFRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgZnVuY3Rpb24gaXMgd2hhdCB3aWxsIGJlIHVzZWQgZm9yIHRoZVxuXHRcdCAqICAgICAgICBkYXRhIHJlcXVlc3RlZC5cblx0XHQgKlxuXHRcdCAqICBAdHlwZSBzdHJpbmd8aW50fGZ1bmN0aW9ufG9iamVjdHxudWxsXG5cdFx0ICogIEBkZWZhdWx0IG51bGwgVXNlIHRoZSBkYXRhIHNvdXJjZSB2YWx1ZS5cblx0XHQgKlxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLnJlbmRlclxuXHRcdCAqICBAZHRvcHQgQ29sdW1uc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gQ3JlYXRlIGEgY29tbWEgc2VwYXJhdGVkIGxpc3QgZnJvbSBhbiBhcnJheSBvZiBvYmplY3RzXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJhamF4U291cmNlXCI6IFwic291cmNlcy9kZWVwLnR4dFwiLFxuXHRcdCAqICAgICAgICBcImNvbHVtbnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwiZW5naW5lXCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwiZGF0YVwiOiBcImJyb3dzZXJcIiB9LFxuXHRcdCAqICAgICAgICAgIHtcblx0XHQgKiAgICAgICAgICAgIFwiZGF0YVwiOiBcInBsYXRmb3JtXCIsXG5cdFx0ICogICAgICAgICAgICBcInJlbmRlclwiOiBcIlssIF0ubmFtZVwiXG5cdFx0ICogICAgICAgICAgfVxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gRXhlY3V0ZSBhIGZ1bmN0aW9uIHRvIG9idGFpbiBkYXRhXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFsge1xuXHRcdCAqICAgICAgICAgIFwidGFyZ2V0c1wiOiBbIDAgXSxcblx0XHQgKiAgICAgICAgICBcImRhdGFcIjogbnVsbCwgLy8gVXNlIHRoZSBmdWxsIGRhdGEgc291cmNlIG9iamVjdCBmb3IgdGhlIHJlbmRlcmVyJ3Mgc291cmNlXG5cdFx0ICogICAgICAgICAgXCJyZW5kZXJcIjogXCJicm93c2VyTmFtZSgpXCJcblx0XHQgKiAgICAgICAgfSBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gQXMgYW4gb2JqZWN0LCBleHRyYWN0aW5nIGRpZmZlcmVudCBkYXRhIGZvciB0aGUgZGlmZmVyZW50IHR5cGVzXG5cdFx0ICogICAgLy8gVGhpcyB3b3VsZCBiZSB1c2VkIHdpdGggYSBkYXRhIHNvdXJjZSBzdWNoIGFzOlxuXHRcdCAqICAgIC8vICAgeyBcInBob25lXCI6IDU1NTIzNjgsIFwicGhvbmVfZmlsdGVyXCI6IFwiNTU1MjM2OCA1NTUtMjM2OFwiLCBcInBob25lX2Rpc3BsYXlcIjogXCI1NTUtMjM2OFwiIH1cblx0XHQgKiAgICAvLyBIZXJlIHRoZSBgcGhvbmVgIGludGVnZXIgaXMgdXNlZCBmb3Igc29ydGluZyBhbmQgdHlwZSBkZXRlY3Rpb24sIHdoaWxlIGBwaG9uZV9maWx0ZXJgXG5cdFx0ICogICAgLy8gKHdoaWNoIGhhcyBib3RoIGZvcm1zKSBpcyB1c2VkIGZvciBmaWx0ZXJpbmcgZm9yIGlmIGEgdXNlciBpbnB1dHMgZWl0aGVyIGZvcm1hdCwgd2hpbGVcblx0XHQgKiAgICAvLyB0aGUgZm9ybWF0dGVkIHBob25lIG51bWJlciBpcyB0aGUgb25lIHRoYXQgaXMgc2hvd24gaW4gdGhlIHRhYmxlLlxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbIHtcblx0XHQgKiAgICAgICAgICBcInRhcmdldHNcIjogWyAwIF0sXG5cdFx0ICogICAgICAgICAgXCJkYXRhXCI6IG51bGwsIC8vIFVzZSB0aGUgZnVsbCBkYXRhIHNvdXJjZSBvYmplY3QgZm9yIHRoZSByZW5kZXJlcidzIHNvdXJjZVxuXHRcdCAqICAgICAgICAgIFwicmVuZGVyXCI6IHtcblx0XHQgKiAgICAgICAgICAgIFwiX1wiOiBcInBob25lXCIsXG5cdFx0ICogICAgICAgICAgICBcImZpbHRlclwiOiBcInBob25lX2ZpbHRlclwiLFxuXHRcdCAqICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwicGhvbmVfZGlzcGxheVwiXG5cdFx0ICogICAgICAgICAgfVxuXHRcdCAqICAgICAgICB9IF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2UgYXMgYSBmdW5jdGlvbiB0byBjcmVhdGUgYSBsaW5rIGZyb20gdGhlIGRhdGEgc291cmNlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFsge1xuXHRcdCAqICAgICAgICAgIFwidGFyZ2V0c1wiOiBbIDAgXSxcblx0XHQgKiAgICAgICAgICBcImRhdGFcIjogXCJkb3dubG9hZF9saW5rXCIsXG5cdFx0ICogICAgICAgICAgXCJyZW5kZXJcIjogZnVuY3Rpb24gKCBkYXRhLCB0eXBlLCBmdWxsICkge1xuXHRcdCAqICAgICAgICAgICAgcmV0dXJuICc8YSBocmVmPVwiJytkYXRhKydcIj5Eb3dubG9hZDwvYT4nO1xuXHRcdCAqICAgICAgICAgIH1cblx0XHQgKiAgICAgICAgfSBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwibVJlbmRlclwiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2hhbmdlIHRoZSBjZWxsIHR5cGUgY3JlYXRlZCBmb3IgdGhlIGNvbHVtbiAtIGVpdGhlciBURCBjZWxscyBvciBUSCBjZWxscy4gVGhpc1xuXHRcdCAqIGNhbiBiZSB1c2VmdWwgYXMgVEggY2VsbHMgaGF2ZSBzZW1hbnRpYyBtZWFuaW5nIGluIHRoZSB0YWJsZSBib2R5LCBhbGxvd2luZyB0aGVtXG5cdFx0ICogdG8gYWN0IGFzIGEgaGVhZGVyIGZvciBhIHJvdyAoeW91IG1heSB3aXNoIHRvIGFkZCBzY29wZT0ncm93JyB0byB0aGUgVEggZWxlbWVudHMpLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgdGRcblx0XHQgKlxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLmNlbGxUeXBlXG5cdFx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBNYWtlIHRoZSBmaXJzdCBjb2x1bW4gdXNlIFRIIGNlbGxzXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFsge1xuXHRcdCAqICAgICAgICAgIFwidGFyZ2V0c1wiOiBbIDAgXSxcblx0XHQgKiAgICAgICAgICBcImNlbGxUeXBlXCI6IFwidGhcIlxuXHRcdCAqICAgICAgICB9IF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJzQ2VsbFR5cGVcIjogXCJ0ZFwiLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2xhc3MgdG8gZ2l2ZSB0byBlYWNoIGNlbGwgaW4gdGhpcyBjb2x1bW4uXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCA8aT5FbXB0eSBzdHJpbmc8L2k+XG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5jbGFzc1xuXHRcdCAqICBAZHRvcHQgQ29sdW1uc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwiY2xhc3NcIjogXCJteV9jbGFzc1wiLCBcInRhcmdldHNcIjogWyAwIF0gfVxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwiY2xhc3NcIjogXCJteV9jbGFzc1wiIH0sXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbFxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwic0NsYXNzXCI6IFwiXCIsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFdoZW4gRGF0YVRhYmxlcyBjYWxjdWxhdGVzIHRoZSBjb2x1bW4gd2lkdGhzIHRvIGFzc2lnbiB0byBlYWNoIGNvbHVtbixcblx0XHQgKiBpdCBmaW5kcyB0aGUgbG9uZ2VzdCBzdHJpbmcgaW4gZWFjaCBjb2x1bW4gYW5kIHRoZW4gY29uc3RydWN0cyBhXG5cdFx0ICogdGVtcG9yYXJ5IHRhYmxlIGFuZCByZWFkcyB0aGUgd2lkdGhzIGZyb20gdGhhdC4gVGhlIHByb2JsZW0gd2l0aCB0aGlzXG5cdFx0ICogaXMgdGhhdCBcIm1tbVwiIGlzIG11Y2ggd2lkZXIgdGhlbiBcImlpaWlcIiwgYnV0IHRoZSBsYXR0ZXIgaXMgYSBsb25nZXJcblx0XHQgKiBzdHJpbmcgLSB0aHVzIHRoZSBjYWxjdWxhdGlvbiBjYW4gZ28gd3JvbmcgKGRvaW5nIGl0IHByb3Blcmx5IGFuZCBwdXR0aW5nXG5cdFx0ICogaXQgaW50byBhbiBET00gb2JqZWN0IGFuZCBtZWFzdXJpbmcgdGhhdCBpcyBob3JyaWJseSghKSBzbG93KS4gVGh1cyBhc1xuXHRcdCAqIGEgXCJ3b3JrIGFyb3VuZFwiIHdlIHByb3ZpZGUgdGhpcyBvcHRpb24uIEl0IHdpbGwgYXBwZW5kIGl0cyB2YWx1ZSB0byB0aGVcblx0XHQgKiB0ZXh0IHRoYXQgaXMgZm91bmQgdG8gYmUgdGhlIGxvbmdlc3Qgc3RyaW5nIGZvciB0aGUgY29sdW1uIC0gaS5lLiBwYWRkaW5nLlxuXHRcdCAqIEdlbmVyYWxseSB5b3Ugc2hvdWxkbid0IG5lZWQgdGhpcyFcblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IDxpPkVtcHR5IHN0cmluZzxpPlxuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4uY29udGVudFBhZGRpbmdcblx0XHQgKiAgQGR0b3B0IENvbHVtbnNcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAge1xuXHRcdCAqICAgICAgICAgICAgXCJjb250ZW50UGFkZGluZ1wiOiBcIm1tbVwiXG5cdFx0ICogICAgICAgICAgfVxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwic0NvbnRlbnRQYWRkaW5nXCI6IFwiXCIsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBBbGxvd3MgYSBkZWZhdWx0IHZhbHVlIHRvIGJlIGdpdmVuIGZvciBhIGNvbHVtbidzIGRhdGEsIGFuZCB3aWxsIGJlIHVzZWRcblx0XHQgKiB3aGVuZXZlciBhIG51bGwgZGF0YSBzb3VyY2UgaXMgZW5jb3VudGVyZWQgKHRoaXMgY2FuIGJlIGJlY2F1c2UgYGRhdGFgXG5cdFx0ICogaXMgc2V0IHRvIG51bGwsIG9yIGJlY2F1c2UgdGhlIGRhdGEgc291cmNlIGl0c2VsZiBpcyBudWxsKS5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKlxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLmRlZmF1bHRDb250ZW50XG5cdFx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xuXHRcdCAqICAgICAgICAgIHtcblx0XHQgKiAgICAgICAgICAgIFwiZGF0YVwiOiBudWxsLFxuXHRcdCAqICAgICAgICAgICAgXCJkZWZhdWx0Q29udGVudFwiOiBcIkVkaXRcIixcblx0XHQgKiAgICAgICAgICAgIFwidGFyZ2V0c1wiOiBbIC0xIF1cblx0XHQgKiAgICAgICAgICB9XG5cdFx0ICogICAgICAgIF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbnNcIjogW1xuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIHtcblx0XHQgKiAgICAgICAgICAgIFwiZGF0YVwiOiBudWxsLFxuXHRcdCAqICAgICAgICAgICAgXCJkZWZhdWx0Q29udGVudFwiOiBcIkVkaXRcIlxuXHRcdCAqICAgICAgICAgIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcInNEZWZhdWx0Q29udGVudFwiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhpcyBwYXJhbWV0ZXIgaXMgb25seSB1c2VkIGluIERhdGFUYWJsZXMnIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcuIEl0IGNhblxuXHRcdCAqIGJlIGV4Y2VwdGlvbmFsbHkgdXNlZnVsIHRvIGtub3cgd2hhdCBjb2x1bW5zIGFyZSBiZWluZyBkaXNwbGF5ZWQgb24gdGhlXG5cdFx0ICogY2xpZW50IHNpZGUsIGFuZCB0byBtYXAgdGhlc2UgdG8gZGF0YWJhc2UgZmllbGRzLiBXaGVuIGRlZmluZWQsIHRoZSBuYW1lc1xuXHRcdCAqIGFsc28gYWxsb3cgRGF0YVRhYmxlcyB0byByZW9yZGVyIGluZm9ybWF0aW9uIGZyb20gdGhlIHNlcnZlciBpZiBpdCBjb21lc1xuXHRcdCAqIGJhY2sgaW4gYW4gdW5leHBlY3RlZCBvcmRlciAoaS5lLiBpZiB5b3Ugc3dpdGNoIHlvdXIgY29sdW1ucyBhcm91bmQgb24gdGhlXG5cdFx0ICogY2xpZW50LXNpZGUsIHlvdXIgc2VydmVyLXNpZGUgY29kZSBkb2VzIG5vdCBhbHNvIG5lZWQgdXBkYXRpbmcpLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgPGk+RW1wdHkgc3RyaW5nPC9pPlxuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4ubmFtZVxuXHRcdCAqICBAZHRvcHQgQ29sdW1uc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwibmFtZVwiOiBcImVuZ2luZVwiLCBcInRhcmdldHNcIjogWyAwIF0gfSxcblx0XHQgKiAgICAgICAgICB7IFwibmFtZVwiOiBcImJyb3dzZXJcIiwgXCJ0YXJnZXRzXCI6IFsgMSBdIH0sXG5cdFx0ICogICAgICAgICAgeyBcIm5hbWVcIjogXCJwbGF0Zm9ybVwiLCBcInRhcmdldHNcIjogWyAyIF0gfSxcblx0XHQgKiAgICAgICAgICB7IFwibmFtZVwiOiBcInZlcnNpb25cIiwgXCJ0YXJnZXRzXCI6IFsgMyBdIH0sXG5cdFx0ICogICAgICAgICAgeyBcIm5hbWVcIjogXCJncmFkZVwiLCBcInRhcmdldHNcIjogWyA0IF0gfVxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwibmFtZVwiOiBcImVuZ2luZVwiIH0sXG5cdFx0ICogICAgICAgICAgeyBcIm5hbWVcIjogXCJicm93c2VyXCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwibmFtZVwiOiBcInBsYXRmb3JtXCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwibmFtZVwiOiBcInZlcnNpb25cIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJuYW1lXCI6IFwiZ3JhZGVcIiB9XG5cdFx0ICogICAgICAgIF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJzTmFtZVwiOiBcIlwiLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRGVmaW5lcyBhIGRhdGEgc291cmNlIHR5cGUgZm9yIHRoZSBvcmRlcmluZyB3aGljaCBjYW4gYmUgdXNlZCB0byByZWFkXG5cdFx0ICogcmVhbC10aW1lIGluZm9ybWF0aW9uIGZyb20gdGhlIHRhYmxlICh1cGRhdGluZyB0aGUgaW50ZXJuYWxseSBjYWNoZWRcblx0XHQgKiB2ZXJzaW9uKSBwcmlvciB0byBvcmRlcmluZy4gVGhpcyBhbGxvd3Mgb3JkZXJpbmcgdG8gb2NjdXIgb24gdXNlclxuXHRcdCAqIGVkaXRhYmxlIGVsZW1lbnRzIHN1Y2ggYXMgZm9ybSBpbnB1dHMuXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBzdGRcblx0XHQgKlxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLm9yZGVyRGF0YVR5cGVcblx0XHQgKiAgQGR0b3B0IENvbHVtbnNcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5EZWZzYFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbXG5cdFx0ICogICAgICAgICAgeyBcIm9yZGVyRGF0YVR5cGVcIjogXCJkb20tdGV4dFwiLCBcInRhcmdldHNcIjogWyAyLCAzIF0gfSxcblx0XHQgKiAgICAgICAgICB7IFwidHlwZVwiOiBcIm51bWVyaWNcIiwgXCJ0YXJnZXRzXCI6IFsgMyBdIH0sXG5cdFx0ICogICAgICAgICAgeyBcIm9yZGVyRGF0YVR5cGVcIjogXCJkb20tc2VsZWN0XCIsIFwidGFyZ2V0c1wiOiBbIDQgXSB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlckRhdGFUeXBlXCI6IFwiZG9tLWNoZWNrYm94XCIsIFwidGFyZ2V0c1wiOiBbIDUgXSB9XG5cdFx0ICogICAgICAgIF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbnNcIjogW1xuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICB7IFwib3JkZXJEYXRhVHlwZVwiOiBcImRvbS10ZXh0XCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwib3JkZXJEYXRhVHlwZVwiOiBcImRvbS10ZXh0XCIsIFwidHlwZVwiOiBcIm51bWVyaWNcIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlckRhdGFUeXBlXCI6IFwiZG9tLXNlbGVjdFwiIH0sXG5cdFx0ICogICAgICAgICAgeyBcIm9yZGVyRGF0YVR5cGVcIjogXCJkb20tY2hlY2tib3hcIiB9XG5cdFx0ICogICAgICAgIF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJzU29ydERhdGFUeXBlXCI6IFwic3RkXCIsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgdGl0bGUgb2YgdGhpcyBjb2x1bW4uXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBudWxsIDxpPkRlcml2ZWQgZnJvbSB0aGUgJ1RIJyB2YWx1ZSBmb3IgdGhpcyBjb2x1bW4gaW4gdGhlXG5cdFx0ICogICAgb3JpZ2luYWwgSFRNTCB0YWJsZS48L2k+XG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi50aXRsZVxuXHRcdCAqICBAZHRvcHQgQ29sdW1uc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJNeSBjb2x1bW4gdGl0bGVcIiwgXCJ0YXJnZXRzXCI6IFsgMCBdIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdFx0ICogICAgICAgICAgeyBcInRpdGxlXCI6IFwiTXkgY29sdW1uIHRpdGxlXCIgfSxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsXG5cdFx0ICogICAgICAgIF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJzVGl0bGVcIjogbnVsbCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0eXBlIGFsbG93cyB5b3UgdG8gc3BlY2lmeSBob3cgdGhlIGRhdGEgZm9yIHRoaXMgY29sdW1uIHdpbGwgYmVcblx0XHQgKiBvcmRlcmVkLiBGb3VyIHR5cGVzIChzdHJpbmcsIG51bWVyaWMsIGRhdGUgYW5kIGh0bWwgKHdoaWNoIHdpbGwgc3RyaXBcblx0XHQgKiBIVE1MIHRhZ3MgYmVmb3JlIG9yZGVyaW5nKSkgYXJlIGN1cnJlbnRseSBhdmFpbGFibGUuIE5vdGUgdGhhdCBvbmx5IGRhdGVcblx0XHQgKiBmb3JtYXRzIHVuZGVyc3Rvb2QgYnkgSmF2YXNjcmlwdCdzIERhdGUoKSBvYmplY3Qgd2lsbCBiZSBhY2NlcHRlZCBhcyB0eXBlXG5cdFx0ICogZGF0ZS4gRm9yIGV4YW1wbGU6IFwiTWFyIDI2LCAyMDA4IDU6MDMgUE1cIi4gTWF5IHRha2UgdGhlIHZhbHVlczogJ3N0cmluZycsXG5cdFx0ICogJ251bWVyaWMnLCAnZGF0ZScgb3IgJ2h0bWwnIChieSBkZWZhdWx0KS4gRnVydGhlciB0eXBlcyBjYW4gYmUgYWRkaW5nXG5cdFx0ICogdGhyb3VnaCBwbHVnLWlucy5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IG51bGwgPGk+QXV0by1kZXRlY3RlZCBmcm9tIHJhdyBkYXRhPC9pPlxuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4udHlwZVxuXHRcdCAqICBAZHRvcHQgQ29sdW1uc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwidHlwZVwiOiBcImh0bWxcIiwgXCJ0YXJnZXRzXCI6IFsgMCBdIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdFx0ICogICAgICAgICAgeyBcInR5cGVcIjogXCJodG1sXCIgfSxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsXG5cdFx0ICogICAgICAgIF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJzVHlwZVwiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRGVmaW5pbmcgdGhlIHdpZHRoIG9mIHRoZSBjb2x1bW4sIHRoaXMgcGFyYW1ldGVyIG1heSB0YWtlIGFueSBDU1MgdmFsdWVcblx0XHQgKiAoM2VtLCAyMHB4IGV0YykuIERhdGFUYWJsZXMgYXBwbGllcyAnc21hcnQnIHdpZHRocyB0byBjb2x1bW5zIHdoaWNoIGhhdmUgbm90XG5cdFx0ICogYmVlbiBnaXZlbiBhIHNwZWNpZmljIHdpZHRoIHRocm91Z2ggdGhpcyBpbnRlcmZhY2UgZW5zdXJpbmcgdGhhdCB0aGUgdGFibGVcblx0XHQgKiByZW1haW5zIHJlYWRhYmxlLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgbnVsbCA8aT5BdXRvbWF0aWM8L2k+XG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi53aWR0aFxuXHRcdCAqICBAZHRvcHQgQ29sdW1uc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwid2lkdGhcIjogXCIyMCVcIiwgXCJ0YXJnZXRzXCI6IFsgMCBdIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdFx0ICogICAgICAgICAgeyBcIndpZHRoXCI6IFwiMjAlXCIgfSxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsXG5cdFx0ICogICAgICAgIF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJzV2lkdGhcIjogbnVsbFxuXHR9O1xuXHRcblx0X2ZuSHVuZ2FyaWFuTWFwKCBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uICk7XG5cdFxuXHRcblx0XG5cdC8qKlxuXHQgKiBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdCAtIHRoaXMgaG9sZHMgYWxsIHRoZSBpbmZvcm1hdGlvbiBuZWVkZWQgZm9yIGFcblx0ICogZ2l2ZW4gdGFibGUsIGluY2x1ZGluZyBjb25maWd1cmF0aW9uLCBkYXRhIGFuZCBjdXJyZW50IGFwcGxpY2F0aW9uIG9mIHRoZVxuXHQgKiB0YWJsZSBvcHRpb25zLiBEYXRhVGFibGVzIGRvZXMgbm90IGhhdmUgYSBzaW5nbGUgaW5zdGFuY2UgZm9yIGVhY2ggRGF0YVRhYmxlXG5cdCAqIHdpdGggdGhlIHNldHRpbmdzIGF0dGFjaGVkIHRvIHRoYXQgaW5zdGFuY2UsIGJ1dCByYXRoZXIgaW5zdGFuY2VzIG9mIHRoZVxuXHQgKiBEYXRhVGFibGUgXCJjbGFzc1wiIGFyZSBjcmVhdGVkIG9uLXRoZS1mbHkgYXMgbmVlZGVkICh0eXBpY2FsbHkgYnkgYVxuXHQgKiAkKCkuZGF0YVRhYmxlKCkgY2FsbCkgYW5kIHRoZSBzZXR0aW5ncyBvYmplY3QgaXMgdGhlbiBhcHBsaWVkIHRvIHRoYXRcblx0ICogaW5zdGFuY2UuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCB0aGlzIG9iamVjdCBpcyByZWxhdGVkIHRvIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9IGJ1dCB0aGlzXG5cdCAqIG9uZSBpcyB0aGUgaW50ZXJuYWwgZGF0YSBzdG9yZSBmb3IgRGF0YVRhYmxlcydzIGNhY2hlIG9mIGNvbHVtbnMuIEl0IHNob3VsZFxuXHQgKiBOT1QgYmUgbWFuaXB1bGF0ZWQgb3V0c2lkZSBvZiBEYXRhVGFibGVzLiBBbnkgY29uZmlndXJhdGlvbiBzaG91bGQgYmUgZG9uZVxuXHQgKiB0aHJvdWdoIHRoZSBpbml0aWFsaXNhdGlvbiBvcHRpb25zLlxuXHQgKiAgQG5hbWVzcGFjZVxuXHQgKiAgQHRvZG8gUmVhbGx5IHNob3VsZCBhdHRhY2ggdGhlIHNldHRpbmdzIG9iamVjdCB0byBpbmRpdmlkdWFsIGluc3RhbmNlcyBzbyB3ZVxuXHQgKiAgICBkb24ndCBuZWVkIHRvIGNyZWF0ZSBuZXcgaW5zdGFuY2VzIG9uIGVhY2ggJCgpLmRhdGFUYWJsZSgpIGNhbGwgKGlmIHRoZVxuXHQgKiAgICB0YWJsZSBhbHJlYWR5IGV4aXN0cykuIEl0IHdvdWxkIGFsc28gc2F2ZSBwYXNzaW5nIG9TZXR0aW5ncyBhcm91bmQgYW5kXG5cdCAqICAgIGludG8gZXZlcnkgc2luZ2xlIGZ1bmN0aW9uLiBIb3dldmVyLCB0aGlzIGlzIGEgdmVyeSBzaWduaWZpY2FudFxuXHQgKiAgICBhcmNoaXRlY3R1cmUgY2hhbmdlIGZvciBEYXRhVGFibGVzIGFuZCB3aWxsIGFsbW9zdCBjZXJ0YWlubHkgYnJlYWtcblx0ICogICAgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCBvbGRlciBpbnN0YWxsYXRpb25zLiBUaGlzIGlzIHNvbWV0aGluZyB0aGF0XG5cdCAqICAgIHdpbGwgYmUgZG9uZSBpbiAyLjAuXG5cdCAqL1xuXHREYXRhVGFibGUubW9kZWxzLm9TZXR0aW5ncyA9IHtcblx0XHQvKipcblx0XHQgKiBQcmltYXJ5IGZlYXR1cmVzIG9mIERhdGFUYWJsZXMgYW5kIHRoZWlyIGVuYWJsZW1lbnQgc3RhdGUuXG5cdFx0ICogIEBuYW1lc3BhY2Vcblx0XHQgKi9cblx0XHRcIm9GZWF0dXJlc1wiOiB7XG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBGbGFnIHRvIHNheSBpZiBEYXRhVGFibGVzIHNob3VsZCBhdXRvbWF0aWNhbGx5IHRyeSB0byBjYWxjdWxhdGUgdGhlXG5cdFx0XHQgKiBvcHRpbXVtIHRhYmxlIGFuZCBjb2x1bW5zIHdpZHRocyAodHJ1ZSkgb3Igbm90IChmYWxzZSkuXG5cdFx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0XHQgKi9cblx0XHRcdFwiYkF1dG9XaWR0aFwiOiBudWxsLFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogRGVsYXkgdGhlIGNyZWF0aW9uIG9mIFRSIGFuZCBURCBlbGVtZW50cyB1bnRpbCB0aGV5IGFyZSBhY3R1YWxseVxuXHRcdFx0ICogbmVlZGVkIGJ5IGEgZHJpdmVuIHBhZ2UgZHJhdy4gVGhpcyBjYW4gZ2l2ZSBhIHNpZ25pZmljYW50IHNwZWVkXG5cdFx0XHQgKiBpbmNyZWFzZSBmb3IgQWpheCBzb3VyY2UgYW5kIEphdmFzY3JpcHQgc291cmNlIGRhdGEsIGJ1dCBtYWtlcyBub1xuXHRcdFx0ICogZGlmZmVyZW5jZSBhdCBhbGwgZnJvIERPTSBhbmQgc2VydmVyLXNpZGUgcHJvY2Vzc2luZyB0YWJsZXMuXG5cdFx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0XHQgKi9cblx0XHRcdFwiYkRlZmVyUmVuZGVyXCI6IG51bGwsXG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBFbmFibGUgZmlsdGVyaW5nIG9uIHRoZSB0YWJsZSBvciBub3QuIE5vdGUgdGhhdCBpZiB0aGlzIGlzIGRpc2FibGVkXG5cdFx0XHQgKiB0aGVuIHRoZXJlIGlzIG5vIGZpbHRlcmluZyBhdCBhbGwgb24gdGhlIHRhYmxlLCBpbmNsdWRpbmcgZm5GaWx0ZXIuXG5cdFx0XHQgKiBUbyBqdXN0IHJlbW92ZSB0aGUgZmlsdGVyaW5nIGlucHV0IHVzZSBzRG9tIGFuZCByZW1vdmUgdGhlICdmJyBvcHRpb24uXG5cdFx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0XHQgKi9cblx0XHRcdFwiYkZpbHRlclwiOiBudWxsLFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogVGFibGUgaW5mb3JtYXRpb24gZWxlbWVudCAodGhlICdTaG93aW5nIHggb2YgeSByZWNvcmRzJyBkaXYpIGVuYWJsZVxuXHRcdFx0ICogZmxhZy5cblx0XHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHRcdCAqL1xuXHRcdFx0XCJiSW5mb1wiOiBudWxsLFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogUHJlc2VudCBhIHVzZXIgY29udHJvbCBhbGxvd2luZyB0aGUgZW5kIHVzZXIgdG8gY2hhbmdlIHRoZSBwYWdlIHNpemVcblx0XHRcdCAqIHdoZW4gcGFnaW5hdGlvbiBpcyBlbmFibGVkLlxuXHRcdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdFx0ICovXG5cdFx0XHRcImJMZW5ndGhDaGFuZ2VcIjogbnVsbCxcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFBhZ2luYXRpb24gZW5hYmxlZCBvciBub3QuIE5vdGUgdGhhdCBpZiB0aGlzIGlzIGRpc2FibGVkIHRoZW4gbGVuZ3RoXG5cdFx0XHQgKiBjaGFuZ2luZyBtdXN0IGFsc28gYmUgZGlzYWJsZWQuXG5cdFx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0XHQgKi9cblx0XHRcdFwiYlBhZ2luYXRlXCI6IG51bGwsXG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBQcm9jZXNzaW5nIGluZGljYXRvciBlbmFibGUgZmxhZyB3aGVuZXZlciBEYXRhVGFibGVzIGlzIGVuYWN0aW5nIGFcblx0XHRcdCAqIHVzZXIgcmVxdWVzdCAtIHR5cGljYWxseSBhbiBBamF4IHJlcXVlc3QgZm9yIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcuXG5cdFx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0XHQgKi9cblx0XHRcdFwiYlByb2Nlc3NpbmdcIjogbnVsbCxcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFNlcnZlci1zaWRlIHByb2Nlc3NpbmcgZW5hYmxlZCBmbGFnIC0gd2hlbiBlbmFibGVkIERhdGFUYWJsZXMgd2lsbFxuXHRcdFx0ICogZ2V0IGFsbCBkYXRhIGZyb20gdGhlIHNlcnZlciBmb3IgZXZlcnkgZHJhdyAtIHRoZXJlIGlzIG5vIGZpbHRlcmluZyxcblx0XHRcdCAqIHNvcnRpbmcgb3IgcGFnaW5nIGRvbmUgb24gdGhlIGNsaWVudC1zaWRlLlxuXHRcdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdFx0ICovXG5cdFx0XHRcImJTZXJ2ZXJTaWRlXCI6IG51bGwsXG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTb3J0aW5nIGVuYWJsZW1lbnQgZmxhZy5cblx0XHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHRcdCAqL1xuXHRcdFx0XCJiU29ydFwiOiBudWxsLFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogTXVsdGktY29sdW1uIHNvcnRpbmdcblx0XHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHRcdCAqL1xuXHRcdFx0XCJiU29ydE11bHRpXCI6IG51bGwsXG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBcHBseSBhIGNsYXNzIHRvIHRoZSBjb2x1bW5zIHdoaWNoIGFyZSBiZWluZyBzb3J0ZWQgdG8gcHJvdmlkZSBhXG5cdFx0XHQgKiB2aXN1YWwgaGlnaGxpZ2h0IG9yIG5vdC4gVGhpcyBjYW4gc2xvdyB0aGluZ3MgZG93biB3aGVuIGVuYWJsZWQgc2luY2Vcblx0XHRcdCAqIHRoZXJlIGlzIGEgbG90IG9mIERPTSBpbnRlcmFjdGlvbi5cblx0XHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHRcdCAqL1xuXHRcdFx0XCJiU29ydENsYXNzZXNcIjogbnVsbCxcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFN0YXRlIHNhdmluZyBlbmFibGVtZW50IGZsYWcuXG5cdFx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0XHQgKi9cblx0XHRcdFwiYlN0YXRlU2F2ZVwiOiBudWxsXG5cdFx0fSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNjcm9sbGluZyBzZXR0aW5ncyBmb3IgYSB0YWJsZS5cblx0XHQgKiAgQG5hbWVzcGFjZVxuXHRcdCAqL1xuXHRcdFwib1Njcm9sbFwiOiB7XG5cdFx0XHQvKipcblx0XHRcdCAqIFdoZW4gdGhlIHRhYmxlIGlzIHNob3J0ZXIgaW4gaGVpZ2h0IHRoYW4gc1Njcm9sbFksIGNvbGxhcHNlIHRoZVxuXHRcdFx0ICogdGFibGUgY29udGFpbmVyIGRvd24gdG8gdGhlIGhlaWdodCBvZiB0aGUgdGFibGUgKHdoZW4gdHJ1ZSkuXG5cdFx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0XHQgKi9cblx0XHRcdFwiYkNvbGxhcHNlXCI6IG51bGwsXG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBXaWR0aCBvZiB0aGUgc2Nyb2xsYmFyIGZvciB0aGUgd2ViLWJyb3dzZXIncyBwbGF0Zm9ybS4gQ2FsY3VsYXRlZFxuXHRcdFx0ICogZHVyaW5nIHRhYmxlIGluaXRpYWxpc2F0aW9uLlxuXHRcdFx0ICogIEB0eXBlIGludFxuXHRcdFx0ICogIEBkZWZhdWx0IDBcblx0XHRcdCAqL1xuXHRcdFx0XCJpQmFyV2lkdGhcIjogMCxcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFZpZXdwb3J0IHdpZHRoIGZvciBob3Jpem9udGFsIHNjcm9sbGluZy4gSG9yaXpvbnRhbCBzY3JvbGxpbmcgaXNcblx0XHRcdCAqIGRpc2FibGVkIGlmIGFuIGVtcHR5IHN0cmluZy5cblx0XHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdFx0ICovXG5cdFx0XHRcInNYXCI6IG51bGwsXG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBXaWR0aCB0byBleHBhbmQgdGhlIHRhYmxlIHRvIHdoZW4gdXNpbmcgeC1zY3JvbGxpbmcuIFR5cGljYWxseSB5b3Vcblx0XHRcdCAqIHNob3VsZCBub3QgbmVlZCB0byB1c2UgdGhpcy5cblx0XHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdFx0ICogIEBkZXByZWNhdGVkXG5cdFx0XHQgKi9cblx0XHRcdFwic1hJbm5lclwiOiBudWxsLFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogVmlld3BvcnQgaGVpZ2h0IGZvciB2ZXJ0aWNhbCBzY3JvbGxpbmcuIFZlcnRpY2FsIHNjcm9sbGluZyBpcyBkaXNhYmxlZFxuXHRcdFx0ICogaWYgYW4gZW1wdHkgc3RyaW5nLlxuXHRcdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHQgKi9cblx0XHRcdFwic1lcIjogbnVsbFxuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIExhbmd1YWdlIGluZm9ybWF0aW9uIGZvciB0aGUgdGFibGUuXG5cdFx0ICogIEBuYW1lc3BhY2Vcblx0XHQgKiAgQGV4dGVuZHMgRGF0YVRhYmxlLmRlZmF1bHRzLm9MYW5ndWFnZVxuXHRcdCAqL1xuXHRcdFwib0xhbmd1YWdlXCI6IHtcblx0XHRcdC8qKlxuXHRcdFx0ICogSW5mb3JtYXRpb24gY2FsbGJhY2sgZnVuY3Rpb24uIFNlZVxuXHRcdFx0ICoge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0cy5mbkluZm9DYWxsYmFja31cblx0XHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHRcdCAqL1xuXHRcdFx0XCJmbkluZm9DYWxsYmFja1wiOiBudWxsXG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQnJvd3NlciBzdXBwb3J0IHBhcmFtZXRlcnNcblx0XHQgKiAgQG5hbWVzcGFjZVxuXHRcdCAqL1xuXHRcdFwib0Jyb3dzZXJcIjoge1xuXHRcdFx0LyoqXG5cdFx0XHQgKiBJbmRpY2F0ZSBpZiB0aGUgYnJvd3NlciBpbmNvcnJlY3RseSBjYWxjdWxhdGVzIHdpZHRoOjEwMCUgaW5zaWRlIGFcblx0XHRcdCAqIHNjcm9sbGluZyBlbGVtZW50IChJRTYvNylcblx0XHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0XHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0XHRcdCAqL1xuXHRcdFx0XCJiU2Nyb2xsT3ZlcnNpemVcIjogZmFsc2UsXG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBEZXRlcm1pbmUgaWYgdGhlIHZlcnRpY2FsIHNjcm9sbGJhciBpcyBvbiB0aGUgcmlnaHQgb3IgbGVmdCBvZiB0aGVcblx0XHRcdCAqIHNjcm9sbGluZyBjb250YWluZXIgLSBuZWVkZWQgZm9yIHJ0bCBsYW5ndWFnZSBsYXlvdXQsIGFsdGhvdWdoIG5vdFxuXHRcdFx0ICogYWxsIGJyb3dzZXJzIG1vdmUgdGhlIHNjcm9sbGJhciAoU2FmYXJpKS5cblx0XHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0XHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0XHRcdCAqL1xuXHRcdFx0XCJiU2Nyb2xsYmFyTGVmdFwiOiBmYWxzZVxuXHRcdH0sXG5cdFxuXHRcblx0XHRcImFqYXhcIjogbnVsbCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEFycmF5IHJlZmVyZW5jaW5nIHRoZSBub2RlcyB3aGljaCBhcmUgdXNlZCBmb3IgdGhlIGZlYXR1cmVzLiBUaGVcblx0XHQgKiBwYXJhbWV0ZXJzIG9mIHRoaXMgb2JqZWN0IG1hdGNoIHdoYXQgaXMgYWxsb3dlZCBieSBzRG9tIC0gaS5lLlxuXHRcdCAqICAgPHVsPlxuXHRcdCAqICAgICA8bGk+J2wnIC0gTGVuZ3RoIGNoYW5naW5nPC9saT5cblx0XHQgKiAgICAgPGxpPidmJyAtIEZpbHRlcmluZyBpbnB1dDwvbGk+XG5cdFx0ICogICAgIDxsaT4ndCcgLSBUaGUgdGFibGUhPC9saT5cblx0XHQgKiAgICAgPGxpPidpJyAtIEluZm9ybWF0aW9uPC9saT5cblx0XHQgKiAgICAgPGxpPidwJyAtIFBhZ2luYXRpb248L2xpPlxuXHRcdCAqICAgICA8bGk+J3InIC0gcFJvY2Vzc2luZzwvbGk+XG5cdFx0ICogICA8L3VsPlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYWFuRmVhdHVyZXNcIjogW10sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFN0b3JlIGRhdGEgaW5mb3JtYXRpb24gLSBzZWUge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1Jvd30gZm9yIGRldGFpbGVkXG5cdFx0ICogaW5mb3JtYXRpb24uXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhb0RhdGFcIjogW10sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEFycmF5IG9mIGluZGV4ZXMgd2hpY2ggYXJlIGluIHRoZSBjdXJyZW50IGRpc3BsYXkgKGFmdGVyIGZpbHRlcmluZyBldGMpXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhaURpc3BsYXlcIjogW10sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEFycmF5IG9mIGluZGV4ZXMgZm9yIGRpc3BsYXkgLSBubyBmaWx0ZXJpbmdcblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFpRGlzcGxheU1hc3RlclwiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmUgaW5mb3JtYXRpb24gYWJvdXQgZWFjaCBjb2x1bW4gdGhhdCBpcyBpbiB1c2Vcblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvQ29sdW1uc1wiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHRhYmxlJ3MgaGVhZGVyXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhb0hlYWRlclwiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHRhYmxlJ3MgZm9vdGVyXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhb0Zvb3RlclwiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmUgdGhlIGFwcGxpZWQgZ2xvYmFsIHNlYXJjaCBpbmZvcm1hdGlvbiBpbiBjYXNlIHdlIHdhbnQgdG8gZm9yY2UgYVxuXHRcdCAqIHJlc2VhcmNoIG9yIGNvbXBhcmUgdGhlIG9sZCBzZWFyY2ggdG8gYSBuZXcgb25lLlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKiAgQG5hbWVzcGFjZVxuXHRcdCAqICBAZXh0ZW5kcyBEYXRhVGFibGUubW9kZWxzLm9TZWFyY2hcblx0XHQgKi9cblx0XHRcIm9QcmV2aW91c1NlYXJjaFwiOiB7fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmUgdGhlIGFwcGxpZWQgc2VhcmNoIGZvciBlYWNoIGNvbHVtbiAtIHNlZVxuXHRcdCAqIHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZWFyY2h9IGZvciB0aGUgZm9ybWF0IHRoYXQgaXMgdXNlZCBmb3IgdGhlXG5cdFx0ICogZmlsdGVyaW5nIGluZm9ybWF0aW9uIGZvciBlYWNoIGNvbHVtbi5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvUHJlU2VhcmNoQ29sc1wiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogU29ydGluZyB0aGF0IGlzIGFwcGxpZWQgdG8gdGhlIHRhYmxlLiBOb3RlIHRoYXQgdGhlIGlubmVyIGFycmF5cyBhcmVcblx0XHQgKiB1c2VkIGluIHRoZSBmb2xsb3dpbmcgbWFubmVyOlxuXHRcdCAqIDx1bD5cblx0XHQgKiAgIDxsaT5JbmRleCAwIC0gY29sdW1uIG51bWJlcjwvbGk+XG5cdFx0ICogICA8bGk+SW5kZXggMSAtIGN1cnJlbnQgc29ydGluZyBkaXJlY3Rpb248L2xpPlxuXHRcdCAqIDwvdWw+XG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAdG9kbyBUaGVzZSBpbm5lciBhcnJheXMgc2hvdWxkIHJlYWxseSBiZSBvYmplY3RzXG5cdFx0ICovXG5cdFx0XCJhYVNvcnRpbmdcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogU29ydGluZyB0aGF0IGlzIGFsd2F5cyBhcHBsaWVkIHRvIHRoZSB0YWJsZSAoaS5lLiBwcmVmaXhlZCBpbiBmcm9udCBvZlxuXHRcdCAqIGFhU29ydGluZykuXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYWFTb3J0aW5nRml4ZWRcIjogW10sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIENsYXNzZXMgdG8gdXNlIGZvciB0aGUgc3RyaXBpbmcgb2YgYSB0YWJsZS5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhc1N0cmlwZUNsYXNzZXNcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogSWYgcmVzdG9yaW5nIGEgdGFibGUgLSB3ZSBzaG91bGQgcmVzdG9yZSBpdHMgc3RyaXBpbmcgY2xhc3NlcyBhcyB3ZWxsXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhc0Rlc3Ryb3lTdHJpcGVzXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBJZiByZXN0b3JpbmcgYSB0YWJsZSAtIHdlIHNob3VsZCByZXN0b3JlIGl0cyB3aWR0aFxuXHRcdCAqICBAdHlwZSBpbnRcblx0XHQgKiAgQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdFwic0Rlc3Ryb3lXaWR0aFwiOiAwLFxuXHRcblx0XHQvKipcblx0XHQgKiBDYWxsYmFjayBmdW5jdGlvbnMgYXJyYXkgZm9yIGV2ZXJ5IHRpbWUgYSByb3cgaXMgaW5zZXJ0ZWQgKGkuZS4gb24gYSBkcmF3KS5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvUm93Q2FsbGJhY2tcIjogW10sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIENhbGxiYWNrIGZ1bmN0aW9ucyBmb3IgdGhlIGhlYWRlciBvbiBlYWNoIGRyYXcuXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhb0hlYWRlckNhbGxiYWNrXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBDYWxsYmFjayBmdW5jdGlvbiBmb3IgdGhlIGZvb3RlciBvbiBlYWNoIGRyYXcuXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhb0Zvb3RlckNhbGxiYWNrXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBBcnJheSBvZiBjYWxsYmFjayBmdW5jdGlvbnMgZm9yIGRyYXcgY2FsbGJhY2sgZnVuY3Rpb25zXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhb0RyYXdDYWxsYmFja1wiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQXJyYXkgb2YgY2FsbGJhY2sgZnVuY3Rpb25zIGZvciByb3cgY3JlYXRlZCBmdW5jdGlvblxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYW9Sb3dDcmVhdGVkQ2FsbGJhY2tcIjogW10sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIENhbGxiYWNrIGZ1bmN0aW9ucyBmb3IganVzdCBiZWZvcmUgdGhlIHRhYmxlIGlzIHJlZHJhd24uIEEgcmV0dXJuIG9mXG5cdFx0ICogZmFsc2Ugd2lsbCBiZSB1c2VkIHRvIGNhbmNlbCB0aGUgZHJhdy5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvUHJlRHJhd0NhbGxiYWNrXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBDYWxsYmFjayBmdW5jdGlvbnMgZm9yIHdoZW4gdGhlIHRhYmxlIGhhcyBiZWVuIGluaXRpYWxpc2VkLlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYW9Jbml0Q29tcGxldGVcIjogW10sXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBDYWxsYmFja3MgZm9yIG1vZGlmeWluZyB0aGUgc2V0dGluZ3MgdG8gYmUgc3RvcmVkIGZvciBzdGF0ZSBzYXZpbmcsIHByaW9yIHRvXG5cdFx0ICogc2F2aW5nIHN0YXRlLlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYW9TdGF0ZVNhdmVQYXJhbXNcIjogW10sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIENhbGxiYWNrcyBmb3IgbW9kaWZ5aW5nIHRoZSBzZXR0aW5ncyB0aGF0IGhhdmUgYmVlbiBzdG9yZWQgZm9yIHN0YXRlIHNhdmluZ1xuXHRcdCAqIHByaW9yIHRvIHVzaW5nIHRoZSBzdG9yZWQgdmFsdWVzIHRvIHJlc3RvcmUgdGhlIHN0YXRlLlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYW9TdGF0ZUxvYWRQYXJhbXNcIjogW10sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIENhbGxiYWNrcyBmb3Igb3BlcmF0aW5nIG9uIHRoZSBzZXR0aW5ncyBvYmplY3Qgb25jZSB0aGUgc2F2ZWQgc3RhdGUgaGFzIGJlZW5cblx0XHQgKiBsb2FkZWRcblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvU3RhdGVMb2FkZWRcIjogW10sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIENhY2hlIHRoZSB0YWJsZSBJRCBmb3IgcXVpY2sgYWNjZXNzXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCA8aT5FbXB0eSBzdHJpbmc8L2k+XG5cdFx0ICovXG5cdFx0XCJzVGFibGVJZFwiOiBcIlwiLFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgVEFCTEUgbm9kZSBmb3IgdGhlIG1haW4gdGFibGVcblx0XHQgKiAgQHR5cGUgbm9kZVxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJuVGFibGVcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogUGVybWFuZW50IHJlZiB0byB0aGUgdGhlYWQgZWxlbWVudFxuXHRcdCAqICBAdHlwZSBub2RlXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcIm5USGVhZFwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBQZXJtYW5lbnQgcmVmIHRvIHRoZSB0Zm9vdCBlbGVtZW50IC0gaWYgaXQgZXhpc3RzXG5cdFx0ICogIEB0eXBlIG5vZGVcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwiblRGb290XCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFBlcm1hbmVudCByZWYgdG8gdGhlIHRib2R5IGVsZW1lbnRcblx0XHQgKiAgQHR5cGUgbm9kZVxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJuVEJvZHlcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2FjaGUgdGhlIHdyYXBwZXIgbm9kZSAoY29udGFpbnMgYWxsIERhdGFUYWJsZXMgY29udHJvbGxlZCBlbGVtZW50cylcblx0XHQgKiAgQHR5cGUgbm9kZVxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJuVGFibGVXcmFwcGVyXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlIGlmIHdoZW4gdXNpbmcgc2VydmVyLXNpZGUgcHJvY2Vzc2luZyB0aGUgbG9hZGluZyBvZiBkYXRhXG5cdFx0ICogc2hvdWxkIGJlIGRlZmVycmVkIHVudGlsIHRoZSBzZWNvbmQgZHJhdy5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHRcImJEZWZlckxvYWRpbmdcIjogZmFsc2UsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlIGlmIGFsbCByZXF1aXJlZCBpbmZvcm1hdGlvbiBoYXMgYmVlbiByZWFkIGluXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHRcImJJbml0aWFsaXNlZFwiOiBmYWxzZSxcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5mb3JtYXRpb24gYWJvdXQgb3BlbiByb3dzLiBFYWNoIG9iamVjdCBpbiB0aGUgYXJyYXkgaGFzIHRoZSBwYXJhbWV0ZXJzXG5cdFx0ICogJ25UcicgYW5kICduUGFyZW50J1xuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYW9PcGVuUm93c1wiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogRGljdGF0ZSB0aGUgcG9zaXRpb25pbmcgb2YgRGF0YVRhYmxlcycgY29udHJvbCBlbGVtZW50cyAtIHNlZVxuXHRcdCAqIHtAbGluayBEYXRhVGFibGUubW9kZWwub0luaXQuc0RvbX0uXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwic0RvbVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBTZWFyY2ggZGVsYXkgKGluIG1TKVxuXHRcdCAqICBAdHlwZSBpbnRlZ2VyXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcInNlYXJjaERlbGF5XCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFdoaWNoIHR5cGUgb2YgcGFnaW5hdGlvbiBzaG91bGQgYmUgdXNlZC5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCB0d29fYnV0dG9uXG5cdFx0ICovXG5cdFx0XCJzUGFnaW5hdGlvblR5cGVcIjogXCJ0d29fYnV0dG9uXCIsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBzdGF0ZSBkdXJhdGlvbiAoZm9yIGBzdGF0ZVNhdmVgKSBpbiBzZWNvbmRzLlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKiAgQHR5cGUgaW50XG5cdFx0ICogIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHRcImlTdGF0ZUR1cmF0aW9uXCI6IDAsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEFycmF5IG9mIGNhbGxiYWNrIGZ1bmN0aW9ucyBmb3Igc3RhdGUgc2F2aW5nLiBFYWNoIGFycmF5IGVsZW1lbnQgaXMgYW5cblx0XHQgKiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG5cdFx0ICogICA8dWw+XG5cdFx0ICogICAgIDxsaT5mdW5jdGlvbjpmbiAtIGZ1bmN0aW9uIHRvIGNhbGwuIFRha2VzIHR3byBwYXJhbWV0ZXJzLCBvU2V0dGluZ3Ncblx0XHQgKiAgICAgICBhbmQgdGhlIEpTT04gc3RyaW5nIHRvIHNhdmUgdGhhdCBoYXMgYmVlbiB0aHVzIGZhciBjcmVhdGVkLiBSZXR1cm5zXG5cdFx0ICogICAgICAgYSBKU09OIHN0cmluZyB0byBiZSBpbnNlcnRlZCBpbnRvIGEganNvbiBvYmplY3Rcblx0XHQgKiAgICAgICAoaS5lLiAnXCJwYXJhbVwiOiBbIDAsIDEsIDJdJyk8L2xpPlxuXHRcdCAqICAgICA8bGk+c3RyaW5nOnNOYW1lIC0gbmFtZSBvZiBjYWxsYmFjazwvbGk+XG5cdFx0ICogICA8L3VsPlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYW9TdGF0ZVNhdmVcIjogW10sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEFycmF5IG9mIGNhbGxiYWNrIGZ1bmN0aW9ucyBmb3Igc3RhdGUgbG9hZGluZy4gRWFjaCBhcnJheSBlbGVtZW50IGlzIGFuXG5cdFx0ICogb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuXHRcdCAqICAgPHVsPlxuXHRcdCAqICAgICA8bGk+ZnVuY3Rpb246Zm4gLSBmdW5jdGlvbiB0byBjYWxsLiBUYWtlcyB0d28gcGFyYW1ldGVycywgb1NldHRpbmdzXG5cdFx0ICogICAgICAgYW5kIHRoZSBvYmplY3Qgc3RvcmVkLiBNYXkgcmV0dXJuIGZhbHNlIHRvIGNhbmNlbCBzdGF0ZSBsb2FkaW5nPC9saT5cblx0XHQgKiAgICAgPGxpPnN0cmluZzpzTmFtZSAtIG5hbWUgb2YgY2FsbGJhY2s8L2xpPlxuXHRcdCAqICAgPC91bD5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvU3RhdGVMb2FkXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBTdGF0ZSB0aGF0IHdhcyBzYXZlZC4gVXNlZnVsIGZvciBiYWNrIHJlZmVyZW5jZVxuXHRcdCAqICBAdHlwZSBvYmplY3Rcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwib1NhdmVkU3RhdGVcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogU3RhdGUgdGhhdCB3YXMgbG9hZGVkLiBVc2VmdWwgZm9yIGJhY2sgcmVmZXJlbmNlXG5cdFx0ICogIEB0eXBlIG9iamVjdFxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJvTG9hZGVkU3RhdGVcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogU291cmNlIHVybCBmb3IgQUpBWCBkYXRhIGZvciB0aGUgdGFibGUuXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwic0FqYXhTb3VyY2VcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogUHJvcGVydHkgZnJvbSBhIGdpdmVuIG9iamVjdCBmcm9tIHdoaWNoIHRvIHJlYWQgdGhlIHRhYmxlIGRhdGEgZnJvbS4gVGhpc1xuXHRcdCAqIGNhbiBiZSBhbiBlbXB0eSBzdHJpbmcgKHdoZW4gbm90IHNlcnZlci1zaWRlIHByb2Nlc3NpbmcpLCBpbiB3aGljaCBjYXNlXG5cdFx0ICogaXQgaXMgIGFzc3VtZWQgYW4gYW4gYXJyYXkgaXMgZ2l2ZW4gZGlyZWN0bHkuXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKi9cblx0XHRcInNBamF4RGF0YVByb3BcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogTm90ZSBpZiBkcmF3IHNob3VsZCBiZSBibG9ja2VkIHdoaWxlIGdldHRpbmcgZGF0YVxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHRcImJBamF4RGF0YUdldFwiOiB0cnVlLFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgbGFzdCBqUXVlcnkgWEhSIG9iamVjdCB0aGF0IHdhcyB1c2VkIGZvciBzZXJ2ZXItc2lkZSBkYXRhIGdhdGhlcmluZy5cblx0XHQgKiBUaGlzIGNhbiBiZSB1c2VkIGZvciB3b3JraW5nIHdpdGggdGhlIFhIUiBpbmZvcm1hdGlvbiBpbiBvbmUgb2YgdGhlXG5cdFx0ICogY2FsbGJhY2tzXG5cdFx0ICogIEB0eXBlIG9iamVjdFxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJqcVhIUlwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBKU09OIHJldHVybmVkIGZyb20gdGhlIHNlcnZlciBpbiB0aGUgbGFzdCBBamF4IHJlcXVlc3Rcblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICogIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdCAqL1xuXHRcdFwianNvblwiOiB1bmRlZmluZWQsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIERhdGEgc3VibWl0dGVkIGFzIHBhcnQgb2YgdGhlIGxhc3QgQWpheCByZXF1ZXN0XG5cdFx0ICogIEB0eXBlIG9iamVjdFxuXHRcdCAqICBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHQgKi9cblx0XHRcIm9BamF4RGF0YVwiOiB1bmRlZmluZWQsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEZ1bmN0aW9uIHRvIGdldCB0aGUgc2VydmVyLXNpZGUgZGF0YS5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICovXG5cdFx0XCJmblNlcnZlckRhdGFcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogRnVuY3Rpb25zIHdoaWNoIGFyZSBjYWxsZWQgcHJpb3IgdG8gc2VuZGluZyBhbiBBamF4IHJlcXVlc3Qgc28gZXh0cmFcblx0XHQgKiBwYXJhbWV0ZXJzIGNhbiBlYXNpbHkgYmUgc2VudCB0byB0aGUgc2VydmVyXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhb1NlcnZlclBhcmFtc1wiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogU2VuZCB0aGUgWEhSIEhUVFAgbWV0aG9kIC0gR0VUIG9yIFBPU1QgKGNvdWxkIGJlIFBVVCBvciBERUxFVEUgaWZcblx0XHQgKiByZXF1aXJlZCkuXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKi9cblx0XHRcInNTZXJ2ZXJNZXRob2RcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogRm9ybWF0IG51bWJlcnMgZm9yIGRpc3BsYXkuXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqL1xuXHRcdFwiZm5Gb3JtYXROdW1iZXJcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogTGlzdCBvZiBvcHRpb25zIHRoYXQgY2FuIGJlIHVzZWQgZm9yIHRoZSB1c2VyIHNlbGVjdGFibGUgbGVuZ3RoIG1lbnUuXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYUxlbmd0aE1lbnVcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogQ291bnRlciBmb3IgdGhlIGRyYXdzIHRoYXQgdGhlIHRhYmxlIGRvZXMuIEFsc28gdXNlZCBhcyBhIHRyYWNrZXIgZm9yXG5cdFx0ICogc2VydmVyLXNpZGUgcHJvY2Vzc2luZ1xuXHRcdCAqICBAdHlwZSBpbnRcblx0XHQgKiAgQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdFwiaURyYXdcIjogMCxcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGUgaWYgYSByZWRyYXcgaXMgYmVpbmcgZG9uZSAtIHVzZWZ1bCBmb3IgQWpheFxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0XCJiRHJhd2luZ1wiOiBmYWxzZSxcblx0XG5cdFx0LyoqXG5cdFx0ICogRHJhdyBpbmRleCAoaURyYXcpIG9mIHRoZSBsYXN0IGVycm9yIHdoZW4gcGFyc2luZyB0aGUgcmV0dXJuZWQgZGF0YVxuXHRcdCAqICBAdHlwZSBpbnRcblx0XHQgKiAgQGRlZmF1bHQgLTFcblx0XHQgKi9cblx0XHRcImlEcmF3RXJyb3JcIjogLTEsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFBhZ2luZyBkaXNwbGF5IGxlbmd0aFxuXHRcdCAqICBAdHlwZSBpbnRcblx0XHQgKiAgQGRlZmF1bHQgMTBcblx0XHQgKi9cblx0XHRcIl9pRGlzcGxheUxlbmd0aFwiOiAxMCxcblx0XG5cdFx0LyoqXG5cdFx0ICogUGFnaW5nIHN0YXJ0IHBvaW50IC0gYWlEaXNwbGF5IGluZGV4XG5cdFx0ICogIEB0eXBlIGludFxuXHRcdCAqICBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0XCJfaURpc3BsYXlTdGFydFwiOiAwLFxuXHRcblx0XHQvKipcblx0XHQgKiBTZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIC0gbnVtYmVyIG9mIHJlY29yZHMgaW4gdGhlIHJlc3VsdCBzZXRcblx0XHQgKiAoaS5lLiBiZWZvcmUgZmlsdGVyaW5nKSwgVXNlIGZuUmVjb3Jkc1RvdGFsIHJhdGhlciB0aGFuXG5cdFx0ICogdGhpcyBwcm9wZXJ0eSB0byBnZXQgdGhlIHZhbHVlIG9mIHRoZSBudW1iZXIgb2YgcmVjb3JkcywgcmVnYXJkbGVzcyBvZlxuXHRcdCAqIHRoZSBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIHNldHRpbmcuXG5cdFx0ICogIEB0eXBlIGludFxuXHRcdCAqICBAZGVmYXVsdCAwXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0XCJfaVJlY29yZHNUb3RhbFwiOiAwLFxuXHRcblx0XHQvKipcblx0XHQgKiBTZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIC0gbnVtYmVyIG9mIHJlY29yZHMgaW4gdGhlIGN1cnJlbnQgZGlzcGxheSBzZXRcblx0XHQgKiAoaS5lLiBhZnRlciBmaWx0ZXJpbmcpLiBVc2UgZm5SZWNvcmRzRGlzcGxheSByYXRoZXIgdGhhblxuXHRcdCAqIHRoaXMgcHJvcGVydHkgdG8gZ2V0IHRoZSB2YWx1ZSBvZiB0aGUgbnVtYmVyIG9mIHJlY29yZHMsIHJlZ2FyZGxlc3Mgb2Zcblx0XHQgKiB0aGUgc2VydmVyLXNpZGUgcHJvY2Vzc2luZyBzZXR0aW5nLlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IDBcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0XHRcIl9pUmVjb3Jkc0Rpc3BsYXlcIjogMCxcblx0XG5cdFx0LyoqXG5cdFx0ICogRmxhZyB0byBpbmRpY2F0ZSBpZiBqUXVlcnkgVUkgbWFya2luZyBhbmQgY2xhc3NlcyBzaG91bGQgYmUgdXNlZC5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKi9cblx0XHRcImJKVUlcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGNsYXNzZXMgdG8gdXNlIGZvciB0aGUgdGFibGVcblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICogIEBkZWZhdWx0IHt9XG5cdFx0ICovXG5cdFx0XCJvQ2xhc3Nlc1wiOiB7fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogRmxhZyBhdHRhY2hlZCB0byB0aGUgc2V0dGluZ3Mgb2JqZWN0IHNvIHlvdSBjYW4gY2hlY2sgaW4gdGhlIGRyYXdcblx0XHQgKiBjYWxsYmFjayBpZiBmaWx0ZXJpbmcgaGFzIGJlZW4gZG9uZSBpbiB0aGUgZHJhdy4gRGVwcmVjYXRlZCBpbiBmYXZvdXIgb2Zcblx0XHQgKiBldmVudHMuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiAgQGRlcHJlY2F0ZWRcblx0XHQgKi9cblx0XHRcImJGaWx0ZXJlZFwiOiBmYWxzZSxcblx0XG5cdFx0LyoqXG5cdFx0ICogRmxhZyBhdHRhY2hlZCB0byB0aGUgc2V0dGluZ3Mgb2JqZWN0IHNvIHlvdSBjYW4gY2hlY2sgaW4gdGhlIGRyYXdcblx0XHQgKiBjYWxsYmFjayBpZiBzb3J0aW5nIGhhcyBiZWVuIGRvbmUgaW4gdGhlIGRyYXcuIERlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mXG5cdFx0ICogZXZlbnRzLlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogIEBkZXByZWNhdGVkXG5cdFx0ICovXG5cdFx0XCJiU29ydGVkXCI6IGZhbHNlLFxuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZSB0aGF0IGlmIG11bHRpcGxlIHJvd3MgYXJlIGluIHRoZSBoZWFkZXIgYW5kIHRoZXJlIGlzIG1vcmUgdGhhblxuXHRcdCAqIG9uZSB1bmlxdWUgY2VsbCBwZXIgY29sdW1uLCBpZiB0aGUgdG9wIG9uZSAodHJ1ZSkgb3IgYm90dG9tIG9uZSAoZmFsc2UpXG5cdFx0ICogc2hvdWxkIGJlIHVzZWQgZm9yIHNvcnRpbmcgLyB0aXRsZSBieSBEYXRhVGFibGVzLlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqL1xuXHRcdFwiYlNvcnRDZWxsc1RvcFwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBJbml0aWFsaXNhdGlvbiBvYmplY3QgdGhhdCBpcyB1c2VkIGZvciB0aGUgdGFibGVcblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcIm9Jbml0XCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIERlc3Ryb3kgY2FsbGJhY2sgZnVuY3Rpb25zIC0gZm9yIHBsdWctaW5zIHRvIGF0dGFjaCB0aGVtc2VsdmVzIHRvIHRoZVxuXHRcdCAqIGRlc3Ryb3kgc28gdGhleSBjYW4gY2xlYW4gdXAgbWFya3VwIGFuZCBldmVudHMuXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhb0Rlc3Ryb3lDYWxsYmFja1wiOiBbXSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgbnVtYmVyIG9mIHJlY29yZHMgaW4gdGhlIGN1cnJlbnQgcmVjb3JkIHNldCwgYmVmb3JlIGZpbHRlcmluZ1xuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqL1xuXHRcdFwiZm5SZWNvcmRzVG90YWxcIjogZnVuY3Rpb24gKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gX2ZuRGF0YVNvdXJjZSggdGhpcyApID09ICdzc3AnID9cblx0XHRcdFx0dGhpcy5faVJlY29yZHNUb3RhbCAqIDEgOlxuXHRcdFx0XHR0aGlzLmFpRGlzcGxheU1hc3Rlci5sZW5ndGg7XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogR2V0IHRoZSBudW1iZXIgb2YgcmVjb3JkcyBpbiB0aGUgY3VycmVudCByZWNvcmQgc2V0LCBhZnRlciBmaWx0ZXJpbmdcblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKi9cblx0XHRcImZuUmVjb3Jkc0Rpc3BsYXlcIjogZnVuY3Rpb24gKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gX2ZuRGF0YVNvdXJjZSggdGhpcyApID09ICdzc3AnID9cblx0XHRcdFx0dGhpcy5faVJlY29yZHNEaXNwbGF5ICogMSA6XG5cdFx0XHRcdHRoaXMuYWlEaXNwbGF5Lmxlbmd0aDtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBHZXQgdGhlIGRpc3BsYXkgZW5kIHBvaW50IC0gYWlEaXNwbGF5IGluZGV4XG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICovXG5cdFx0XCJmbkRpc3BsYXlFbmRcIjogZnVuY3Rpb24gKClcblx0XHR7XG5cdFx0XHR2YXJcblx0XHRcdFx0bGVuICAgICAgPSB0aGlzLl9pRGlzcGxheUxlbmd0aCxcblx0XHRcdFx0c3RhcnQgICAgPSB0aGlzLl9pRGlzcGxheVN0YXJ0LFxuXHRcdFx0XHRjYWxjICAgICA9IHN0YXJ0ICsgbGVuLFxuXHRcdFx0XHRyZWNvcmRzICA9IHRoaXMuYWlEaXNwbGF5Lmxlbmd0aCxcblx0XHRcdFx0ZmVhdHVyZXMgPSB0aGlzLm9GZWF0dXJlcyxcblx0XHRcdFx0cGFnaW5hdGUgPSBmZWF0dXJlcy5iUGFnaW5hdGU7XG5cdFxuXHRcdFx0aWYgKCBmZWF0dXJlcy5iU2VydmVyU2lkZSApIHtcblx0XHRcdFx0cmV0dXJuIHBhZ2luYXRlID09PSBmYWxzZSB8fCBsZW4gPT09IC0xID9cblx0XHRcdFx0XHRzdGFydCArIHJlY29yZHMgOlxuXHRcdFx0XHRcdE1hdGgubWluKCBzdGFydCtsZW4sIHRoaXMuX2lSZWNvcmRzRGlzcGxheSApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHJldHVybiAhIHBhZ2luYXRlIHx8IGNhbGM+cmVjb3JkcyB8fCBsZW49PT0tMSA/XG5cdFx0XHRcdFx0cmVjb3JkcyA6XG5cdFx0XHRcdFx0Y2FsYztcblx0XHRcdH1cblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgRGF0YVRhYmxlcyBvYmplY3QgZm9yIHRoaXMgdGFibGVcblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcIm9JbnN0YW5jZVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBVbmlxdWUgaWRlbnRpZmllciBmb3IgZWFjaCBpbnN0YW5jZSBvZiB0aGUgRGF0YVRhYmxlcyBvYmplY3QuIElmIHRoZXJlXG5cdFx0ICogaXMgYW4gSUQgb24gdGhlIHRhYmxlIG5vZGUsIHRoZW4gaXQgdGFrZXMgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGFuXG5cdFx0ICogaW5jcmVtZW50aW5nIGludGVybmFsIGNvdW50ZXIgaXMgdXNlZC5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcInNJbnN0YW5jZVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiB0YWJpbmRleCBhdHRyaWJ1dGUgdmFsdWUgdGhhdCBpcyBhZGRlZCB0byBEYXRhVGFibGVzIGNvbnRyb2wgZWxlbWVudHMsIGFsbG93aW5nXG5cdFx0ICoga2V5Ym9hcmQgbmF2aWdhdGlvbiBvZiB0aGUgdGFibGUgYW5kIGl0cyBjb250cm9scy5cblx0XHQgKi9cblx0XHRcImlUYWJJbmRleFwiOiAwLFxuXHRcblx0XHQvKipcblx0XHQgKiBESVYgY29udGFpbmVyIGZvciB0aGUgZm9vdGVyIHNjcm9sbGluZyB0YWJsZSBpZiBzY3JvbGxpbmdcblx0XHQgKi9cblx0XHRcIm5TY3JvbGxIZWFkXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIERJViBjb250YWluZXIgZm9yIHRoZSBmb290ZXIgc2Nyb2xsaW5nIHRhYmxlIGlmIHNjcm9sbGluZ1xuXHRcdCAqL1xuXHRcdFwiblNjcm9sbEZvb3RcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogTGFzdCBhcHBsaWVkIHNvcnRcblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFMYXN0U29ydFwiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmVkIHBsdWctaW4gaW5zdGFuY2VzXG5cdFx0ICogIEB0eXBlIG9iamVjdFxuXHRcdCAqICBAZGVmYXVsdCB7fVxuXHRcdCAqL1xuXHRcdFwib1BsdWdpbnNcIjoge31cblx0fTtcblxuXHQvKipcblx0ICogRXh0ZW5zaW9uIG9iamVjdCBmb3IgRGF0YVRhYmxlcyB0aGF0IGlzIHVzZWQgdG8gcHJvdmlkZSBhbGwgZXh0ZW5zaW9uXG5cdCAqIG9wdGlvbnMuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCB0aGUgYERhdGFUYWJsZS5leHRgIG9iamVjdCBpcyBhdmFpbGFibGUgdGhyb3VnaFxuXHQgKiBgalF1ZXJ5LmZuLmRhdGFUYWJsZS5leHRgIHdoZXJlIGl0IG1heSBiZSBhY2Nlc3NlZCBhbmQgbWFuaXB1bGF0ZWQuIEl0IGlzXG5cdCAqIGFsc28gYWxpYXNlZCB0byBgalF1ZXJ5LmZuLmRhdGFUYWJsZUV4dGAgZm9yIGhpc3RvcmljIHJlYXNvbnMuXG5cdCAqICBAbmFtZXNwYWNlXG5cdCAqICBAZXh0ZW5kcyBEYXRhVGFibGUubW9kZWxzLmV4dFxuXHQgKi9cblx0XG5cdFxuXHQvKipcblx0ICogRGF0YVRhYmxlcyBleHRlbnNpb25zXG5cdCAqIFxuXHQgKiBUaGlzIG5hbWVzcGFjZSBhY3RzIGFzIGEgY29sbGVjdGlvbiBhcmVhIGZvciBwbHVnLWlucyB0aGF0IGNhbiBiZSB1c2VkIHRvXG5cdCAqIGV4dGVuZCBEYXRhVGFibGVzIGNhcGFiaWxpdGllcy4gSW5kZWVkIG1hbnkgb2YgdGhlIGJ1aWxkIGluIG1ldGhvZHNcblx0ICogdXNlIHRoaXMgbWV0aG9kIHRvIHByb3ZpZGUgdGhlaXIgb3duIGNhcGFiaWxpdGllcyAoc29ydGluZyBtZXRob2RzIGZvclxuXHQgKiBleGFtcGxlKS5cblx0ICpcblx0ICogTm90ZSB0aGF0IHRoaXMgbmFtZXNwYWNlIGlzIGFsaWFzZWQgdG8gYGpRdWVyeS5mbi5kYXRhVGFibGVFeHRgIGZvciBsZWdhY3lcblx0ICogcmVhc29uc1xuXHQgKlxuXHQgKiAgQG5hbWVzcGFjZVxuXHQgKi9cblx0RGF0YVRhYmxlLmV4dCA9IF9leHQgPSB7XG5cdFx0LyoqXG5cdFx0ICogQnV0dG9ucy4gRm9yIHVzZSB3aXRoIHRoZSBCdXR0b25zIGV4dGVuc2lvbiBmb3IgRGF0YVRhYmxlcy4gVGhpcyBpc1xuXHRcdCAqIGRlZmluZWQgaGVyZSBzbyBvdGhlciBleHRlbnNpb25zIGNhbiBkZWZpbmUgYnV0dG9ucyByZWdhcmRsZXNzIG9mIGxvYWRcblx0XHQgKiBvcmRlci4gSXQgaXMgX25vdF8gdXNlZCBieSBEYXRhVGFibGVzIGNvcmUuXG5cdFx0ICpcblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICogIEBkZWZhdWx0IHt9XG5cdFx0ICovXG5cdFx0YnV0dG9uczoge30sXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBFbGVtZW50IGNsYXNzIG5hbWVzXG5cdFx0ICpcblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICogIEBkZWZhdWx0IHt9XG5cdFx0ICovXG5cdFx0Y2xhc3Nlczoge30sXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBFcnJvciByZXBvcnRpbmcuXG5cdFx0ICogXG5cdFx0ICogSG93IHNob3VsZCBEYXRhVGFibGVzIHJlcG9ydCBhbiBlcnJvci4gQ2FuIHRha2UgdGhlIHZhbHVlICdhbGVydCcsXG5cdFx0ICogJ3Rocm93JywgJ25vbmUnIG9yIGEgZnVuY3Rpb24uXG5cdFx0ICpcblx0XHQgKiAgQHR5cGUgc3RyaW5nfGZ1bmN0aW9uXG5cdFx0ICogIEBkZWZhdWx0IGFsZXJ0XG5cdFx0ICovXG5cdFx0ZXJyTW9kZTogXCJhbGVydFwiLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRmVhdHVyZSBwbHVnLWlucy5cblx0XHQgKiBcblx0XHQgKiBUaGlzIGlzIGFuIGFycmF5IG9mIG9iamVjdHMgd2hpY2ggZGVzY3JpYmUgdGhlIGZlYXR1cmUgcGx1Zy1pbnMgdGhhdCBhcmVcblx0XHQgKiBhdmFpbGFibGUgdG8gRGF0YVRhYmxlcy4gVGhlc2UgZmVhdHVyZSBwbHVnLWlucyBhcmUgdGhlbiBhdmFpbGFibGUgZm9yXG5cdFx0ICogdXNlIHRocm91Z2ggdGhlIGBkb21gIGluaXRpYWxpc2F0aW9uIG9wdGlvbi5cblx0XHQgKiBcblx0XHQgKiBFYWNoIGZlYXR1cmUgcGx1Zy1pbiBpcyBkZXNjcmliZWQgYnkgYW4gb2JqZWN0IHdoaWNoIG11c3QgaGF2ZSB0aGVcblx0XHQgKiBmb2xsb3dpbmcgcHJvcGVydGllczpcblx0XHQgKiBcblx0XHQgKiAqIGBmbkluaXRgIC0gZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIGluaXRpYWxpc2UgdGhlIHBsdWctaW4sXG5cdFx0ICogKiBgY0ZlYXR1cmVgIC0gYSBjaGFyYWN0ZXIgc28gdGhlIGZlYXR1cmUgY2FuIGJlIGVuYWJsZWQgYnkgdGhlIGBkb21gXG5cdFx0ICogICBpbnN0aWxsYXRpb24gb3B0aW9uLiBUaGlzIGlzIGNhc2Ugc2Vuc2l0aXZlLlxuXHRcdCAqXG5cdFx0ICogVGhlIGBmbkluaXRgIGZ1bmN0aW9uIGhhcyB0aGUgZm9sbG93aW5nIGlucHV0IHBhcmFtZXRlcnM6XG5cdFx0ICpcblx0XHQgKiAxLiBge29iamVjdH1gIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0OiBzZWVcblx0XHQgKiAgICB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XG5cdFx0ICpcblx0XHQgKiBBbmQgdGhlIGZvbGxvd2luZyByZXR1cm4gaXMgZXhwZWN0ZWQ6XG5cdFx0ICogXG5cdFx0ICogKiB7bm9kZXxudWxsfSBUaGUgZWxlbWVudCB3aGljaCBjb250YWlucyB5b3VyIGZlYXR1cmUuIE5vdGUgdGhhdCB0aGVcblx0XHQgKiAgIHJldHVybiBtYXkgYWxzbyBiZSB2b2lkIGlmIHlvdXIgcGx1Zy1pbiBkb2VzIG5vdCByZXF1aXJlIHRvIGluamVjdCBhbnlcblx0XHQgKiAgIERPTSBlbGVtZW50cyBpbnRvIERhdGFUYWJsZXMgY29udHJvbCAoYGRvbWApIC0gZm9yIGV4YW1wbGUgdGhpcyBtaWdodFxuXHRcdCAqICAgYmUgdXNlZnVsIHdoZW4gZGV2ZWxvcGluZyBhIHBsdWctaW4gd2hpY2ggYWxsb3dzIHRhYmxlIGNvbnRyb2wgdmlhXG5cdFx0ICogICBrZXlib2FyZCBlbnRyeVxuXHRcdCAqXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkLmZuLmRhdGFUYWJsZS5leHQuZmVhdHVyZXMucHVzaCgge1xuXHRcdCAqICAgICAgXCJmbkluaXRcIjogZnVuY3Rpb24oIG9TZXR0aW5ncyApIHtcblx0XHQgKiAgICAgICAgcmV0dXJuIG5ldyBUYWJsZVRvb2xzKCB7IFwib0RUU2V0dGluZ3NcIjogb1NldHRpbmdzIH0gKTtcblx0XHQgKiAgICAgIH0sXG5cdFx0ICogICAgICBcImNGZWF0dXJlXCI6IFwiVFwiXG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdGZlYXR1cmU6IFtdLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogUm93IHNlYXJjaGluZy5cblx0XHQgKiBcblx0XHQgKiBUaGlzIG1ldGhvZCBvZiBzZWFyY2hpbmcgaXMgY29tcGxpbWVudGFyeSB0byB0aGUgZGVmYXVsdCB0eXBlIGJhc2VkXG5cdFx0ICogc2VhcmNoaW5nLCBhbmQgYSBsb3QgbW9yZSBjb21wcmVoZW5zaXZlIGFzIGl0IGFsbG93cyB5b3UgY29tcGxldGUgY29udHJvbFxuXHRcdCAqIG92ZXIgdGhlIHNlYXJjaGluZyBsb2dpYy4gRWFjaCBlbGVtZW50IGluIHRoaXMgYXJyYXkgaXMgYSBmdW5jdGlvblxuXHRcdCAqIChwYXJhbWV0ZXJzIGRlc2NyaWJlZCBiZWxvdykgdGhhdCBpcyBjYWxsZWQgZm9yIGV2ZXJ5IHJvdyBpbiB0aGUgdGFibGUsXG5cdFx0ICogYW5kIHlvdXIgbG9naWMgZGVjaWRlcyBpZiBpdCBzaG91bGQgYmUgaW5jbHVkZWQgaW4gdGhlIHNlYXJjaGluZyBkYXRhIHNldFxuXHRcdCAqIG9yIG5vdC5cblx0XHQgKlxuXHRcdCAqIFNlYXJjaGluZyBmdW5jdGlvbnMgaGF2ZSB0aGUgZm9sbG93aW5nIGlucHV0IHBhcmFtZXRlcnM6XG5cdFx0ICpcblx0XHQgKiAxLiBge29iamVjdH1gIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0OiBzZWVcblx0XHQgKiAgICB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XG5cdFx0ICogMi4gYHthcnJheXxvYmplY3R9YCBEYXRhIGZvciB0aGUgcm93IHRvIGJlIHByb2Nlc3NlZCAoc2FtZSBhcyB0aGVcblx0XHQgKiAgICBvcmlnaW5hbCBmb3JtYXQgdGhhdCB3YXMgcGFzc2VkIGluIGFzIHRoZSBkYXRhIHNvdXJjZSwgb3IgYW4gYXJyYXlcblx0XHQgKiAgICBmcm9tIGEgRE9NIGRhdGEgc291cmNlXG5cdFx0ICogMy4gYHtpbnR9YCBSb3cgaW5kZXggKHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5ncy5hb0RhdGF9KSwgd2hpY2hcblx0XHQgKiAgICBjYW4gYmUgdXNlZnVsIHRvIHJldHJpZXZlIHRoZSBgVFJgIGVsZW1lbnQgaWYgeW91IG5lZWQgRE9NIGludGVyYWN0aW9uLlxuXHRcdCAqXG5cdFx0ICogQW5kIHRoZSBmb2xsb3dpbmcgcmV0dXJuIGlzIGV4cGVjdGVkOlxuXHRcdCAqXG5cdFx0ICogKiB7Ym9vbGVhbn0gSW5jbHVkZSB0aGUgcm93IGluIHRoZSBzZWFyY2hlZCByZXN1bHQgc2V0ICh0cnVlKSBvciBub3Rcblx0XHQgKiAgIChmYWxzZSlcblx0XHQgKlxuXHRcdCAqIE5vdGUgdGhhdCBhcyB3aXRoIHRoZSBtYWluIHNlYXJjaCBhYmlsaXR5IGluIERhdGFUYWJsZXMsIHRlY2huaWNhbGx5IHRoaXNcblx0XHQgKiBpcyBcImZpbHRlcmluZ1wiLCBzaW5jZSBpdCBpcyBzdWJ0cmFjdGl2ZS4gSG93ZXZlciwgZm9yIGNvbnNpc3RlbmN5IGluXG5cdFx0ICogbmFtaW5nIHdlIGNhbGwgaXQgc2VhcmNoaW5nIGhlcmUuXG5cdFx0ICpcblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBzaG93cyBjdXN0b20gc2VhcmNoIGJlaW5nIGFwcGxpZWQgdG8gdGhlXG5cdFx0ICogICAgLy8gZm91cnRoIGNvbHVtbiAoaS5lLiB0aGUgZGF0YVszXSBpbmRleCkgYmFzZWQgb24gdHdvIGlucHV0IHZhbHVlc1xuXHRcdCAqICAgIC8vIGZyb20gdGhlIGVuZC11c2VyLCBtYXRjaGluZyB0aGUgZGF0YSBpbiBhIGNlcnRhaW4gcmFuZ2UuXG5cdFx0ICogICAgJC5mbi5kYXRhVGFibGUuZXh0LnNlYXJjaC5wdXNoKFxuXHRcdCAqICAgICAgZnVuY3Rpb24oIHNldHRpbmdzLCBkYXRhLCBkYXRhSW5kZXggKSB7XG5cdFx0ICogICAgICAgIHZhciBtaW4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWluJykudmFsdWUgKiAxO1xuXHRcdCAqICAgICAgICB2YXIgbWF4ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21heCcpLnZhbHVlICogMTtcblx0XHQgKiAgICAgICAgdmFyIHZlcnNpb24gPSBkYXRhWzNdID09IFwiLVwiID8gMCA6IGRhdGFbM10qMTtcblx0XHQgKlxuXHRcdCAqICAgICAgICBpZiAoIG1pbiA9PSBcIlwiICYmIG1heCA9PSBcIlwiICkge1xuXHRcdCAqICAgICAgICAgIHJldHVybiB0cnVlO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICAgIGVsc2UgaWYgKCBtaW4gPT0gXCJcIiAmJiB2ZXJzaW9uIDwgbWF4ICkge1xuXHRcdCAqICAgICAgICAgIHJldHVybiB0cnVlO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICAgIGVsc2UgaWYgKCBtaW4gPCB2ZXJzaW9uICYmIFwiXCIgPT0gbWF4ICkge1xuXHRcdCAqICAgICAgICAgIHJldHVybiB0cnVlO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICAgIGVsc2UgaWYgKCBtaW4gPCB2ZXJzaW9uICYmIHZlcnNpb24gPCBtYXggKSB7XG5cdFx0ICogICAgICAgICAgcmV0dXJuIHRydWU7XG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAqICAgICAgfVxuXHRcdCAqICAgICk7XG5cdFx0ICovXG5cdFx0c2VhcmNoOiBbXSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNlbGVjdG9yIGV4dGVuc2lvbnNcblx0XHQgKlxuXHRcdCAqIFRoZSBgc2VsZWN0b3JgIG9wdGlvbiBjYW4gYmUgdXNlZCB0byBleHRlbmQgdGhlIG9wdGlvbnMgYXZhaWxhYmxlIGZvciB0aGVcblx0XHQgKiBzZWxlY3RvciBtb2RpZmllciBvcHRpb25zIChgc2VsZWN0b3ItbW9kaWZpZXJgIG9iamVjdCBkYXRhIHR5cGUpIHRoYXRcblx0XHQgKiBlYWNoIG9mIHRoZSB0aHJlZSBidWlsdCBpbiBzZWxlY3RvciB0eXBlcyBvZmZlciAocm93LCBjb2x1bW4gYW5kIGNlbGwgK1xuXHRcdCAqIHRoZWlyIHBsdXJhbCBjb3VudGVycGFydHMpLiBGb3IgZXhhbXBsZSB0aGUgU2VsZWN0IGV4dGVuc2lvbiB1c2VzIHRoaXNcblx0XHQgKiBtZWNoYW5pc20gdG8gcHJvdmlkZSBhbiBvcHRpb24gdG8gc2VsZWN0IG9ubHkgcm93cywgY29sdW1ucyBhbmQgY2VsbHNcblx0XHQgKiB0aGF0IGhhdmUgYmVlbiBtYXJrZWQgYXMgc2VsZWN0ZWQgYnkgdGhlIGVuZCB1c2VyIChge3NlbGVjdGVkOiB0cnVlfWApLFxuXHRcdCAqIHdoaWNoIGNhbiBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIGV4aXN0aW5nIGJ1aWx0IGluIHNlbGVjdG9yXG5cdFx0ICogb3B0aW9ucy5cblx0XHQgKlxuXHRcdCAqIEVhY2ggcHJvcGVydHkgaXMgYW4gYXJyYXkgdG8gd2hpY2ggZnVuY3Rpb25zIGNhbiBiZSBwdXNoZWQuIFRoZSBmdW5jdGlvbnNcblx0XHQgKiB0YWtlIHRocmVlIGF0dHJpYnV0ZXM6XG5cdFx0ICpcblx0XHQgKiAqIFNldHRpbmdzIG9iamVjdCBmb3IgdGhlIGhvc3QgdGFibGVcblx0XHQgKiAqIE9wdGlvbnMgb2JqZWN0IChgc2VsZWN0b3ItbW9kaWZpZXJgIG9iamVjdCB0eXBlKVxuXHRcdCAqICogQXJyYXkgb2Ygc2VsZWN0ZWQgaXRlbSBpbmRleGVzXG5cdFx0ICpcblx0XHQgKiBUaGUgcmV0dXJuIGlzIGFuIGFycmF5IG9mIHRoZSByZXN1bHRpbmcgaXRlbSBpbmRleGVzIGFmdGVyIHRoZSBjdXN0b21cblx0XHQgKiBzZWxlY3RvciBoYXMgYmVlbiBhcHBsaWVkLlxuXHRcdCAqXG5cdFx0ICogIEB0eXBlIG9iamVjdFxuXHRcdCAqL1xuXHRcdHNlbGVjdG9yOiB7XG5cdFx0XHRjZWxsOiBbXSxcblx0XHRcdGNvbHVtbjogW10sXG5cdFx0XHRyb3c6IFtdXG5cdFx0fSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEludGVybmFsIGZ1bmN0aW9ucywgZXhwb3NlZCBmb3IgdXNlZCBpbiBwbHVnLWlucy5cblx0XHQgKiBcblx0XHQgKiBQbGVhc2Ugbm90ZSB0aGF0IHlvdSBzaG91bGQgbm90IG5lZWQgdG8gdXNlIHRoZSBpbnRlcm5hbCBtZXRob2RzIGZvclxuXHRcdCAqIGFueXRoaW5nIG90aGVyIHRoYW4gYSBwbHVnLWluIChhbmQgZXZlbiB0aGVuLCB0cnkgdG8gYXZvaWQgaWYgcG9zc2libGUpLlxuXHRcdCAqIFRoZSBpbnRlcm5hbCBmdW5jdGlvbiBtYXkgY2hhbmdlIGJldHdlZW4gcmVsZWFzZXMuXG5cdFx0ICpcblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICogIEBkZWZhdWx0IHt9XG5cdFx0ICovXG5cdFx0aW50ZXJuYWw6IHt9LFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogTGVnYWN5IGNvbmZpZ3VyYXRpb24gb3B0aW9ucy4gRW5hYmxlIGFuZCBkaXNhYmxlIGxlZ2FjeSBvcHRpb25zIHRoYXRcblx0XHQgKiBhcmUgYXZhaWxhYmxlIGluIERhdGFUYWJsZXMuXG5cdFx0ICpcblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICovXG5cdFx0bGVnYWN5OiB7XG5cdFx0XHQvKipcblx0XHRcdCAqIEVuYWJsZSAvIGRpc2FibGUgRGF0YVRhYmxlcyAxLjkgY29tcGF0aWJsZSBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nXG5cdFx0XHQgKiByZXF1ZXN0c1xuXHRcdFx0ICpcblx0XHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdFx0ICovXG5cdFx0XHRhamF4OiBudWxsXG5cdFx0fSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFBhZ2luYXRpb24gcGx1Zy1pbiBtZXRob2RzLlxuXHRcdCAqIFxuXHRcdCAqIEVhY2ggZW50cnkgaW4gdGhpcyBvYmplY3QgaXMgYSBmdW5jdGlvbiBhbmQgZGVmaW5lcyB3aGljaCBidXR0b25zIHNob3VsZFxuXHRcdCAqIGJlIHNob3duIGJ5IHRoZSBwYWdpbmF0aW9uIHJlbmRlcmluZyBtZXRob2QgdGhhdCBpcyB1c2VkIGZvciB0aGUgdGFibGU6XG5cdFx0ICoge0BsaW5rIERhdGFUYWJsZS5leHQucmVuZGVyZXIucGFnZUJ1dHRvbn0uIFRoZSByZW5kZXJlciBhZGRyZXNzZXMgaG93IHRoZVxuXHRcdCAqIGJ1dHRvbnMgYXJlIGRpc3BsYXllZCBpbiB0aGUgZG9jdW1lbnQsIHdoaWxlIHRoZSBmdW5jdGlvbnMgaGVyZSB0ZWxsIGl0XG5cdFx0ICogd2hhdCBidXR0b25zIHRvIGRpc3BsYXkuIFRoaXMgaXMgZG9uZSBieSByZXR1cm5pbmcgYW4gYXJyYXkgb2YgYnV0dG9uXG5cdFx0ICogZGVzY3JpcHRpb25zICh3aGF0IGVhY2ggYnV0dG9uIHdpbGwgZG8pLlxuXHRcdCAqXG5cdFx0ICogUGFnaW5hdGlvbiB0eXBlcyAodGhlIGZvdXIgYnVpbHQgaW4gb3B0aW9ucyBhbmQgYW55IGFkZGl0aW9uYWwgcGx1Zy1pblxuXHRcdCAqIG9wdGlvbnMgZGVmaW5lZCBoZXJlKSBjYW4gYmUgdXNlZCB0aHJvdWdoIHRoZSBgcGFnaW5hdGlvblR5cGVgXG5cdFx0ICogaW5pdGlhbGlzYXRpb24gcGFyYW1ldGVyLlxuXHRcdCAqXG5cdFx0ICogVGhlIGZ1bmN0aW9ucyBkZWZpbmVkIHRha2UgdHdvIHBhcmFtZXRlcnM6XG5cdFx0ICpcblx0XHQgKiAxLiBge2ludH0gcGFnZWAgVGhlIGN1cnJlbnQgcGFnZSBpbmRleFxuXHRcdCAqIDIuIGB7aW50fSBwYWdlc2AgVGhlIG51bWJlciBvZiBwYWdlcyBpbiB0aGUgdGFibGVcblx0XHQgKlxuXHRcdCAqIEVhY2ggZnVuY3Rpb24gaXMgZXhwZWN0ZWQgdG8gcmV0dXJuIGFuIGFycmF5IHdoZXJlIGVhY2ggZWxlbWVudCBvZiB0aGVcblx0XHQgKiBhcnJheSBjYW4gYmUgb25lIG9mOlxuXHRcdCAqXG5cdFx0ICogKiBgZmlyc3RgIC0gSnVtcCB0byBmaXJzdCBwYWdlIHdoZW4gYWN0aXZhdGVkXG5cdFx0ICogKiBgbGFzdGAgLSBKdW1wIHRvIGxhc3QgcGFnZSB3aGVuIGFjdGl2YXRlZFxuXHRcdCAqICogYHByZXZpb3VzYCAtIFNob3cgcHJldmlvdXMgcGFnZSB3aGVuIGFjdGl2YXRlZFxuXHRcdCAqICogYG5leHRgIC0gU2hvdyBuZXh0IHBhZ2Ugd2hlbiBhY3RpdmF0ZWRcblx0XHQgKiAqIGB7aW50fWAgLSBTaG93IHBhZ2Ugb2YgdGhlIGluZGV4IGdpdmVuXG5cdFx0ICogKiBge2FycmF5fWAgLSBBIG5lc3RlZCBhcnJheSBjb250YWluaW5nIHRoZSBhYm92ZSBlbGVtZW50cyB0byBhZGQgYVxuXHRcdCAqICAgY29udGFpbmluZyAnRElWJyBlbGVtZW50IChtaWdodCBiZSB1c2VmdWwgZm9yIHN0eWxpbmcpLlxuXHRcdCAqXG5cdFx0ICogTm90ZSB0aGF0IERhdGFUYWJsZXMgdjEuOS0gdXNlZCB0aGlzIG9iamVjdCBzbGlnaHRseSBkaWZmZXJlbnRseSB3aGVyZWJ5XG5cdFx0ICogYW4gb2JqZWN0IHdpdGggdHdvIGZ1bmN0aW9ucyB3b3VsZCBiZSBkZWZpbmVkIGZvciBlYWNoIHBsdWctaW4uIFRoYXRcblx0XHQgKiBhYmlsaXR5IGlzIHN0aWxsIHN1cHBvcnRlZCBieSBEYXRhVGFibGVzIDEuMTArIHRvIHByb3ZpZGUgYmFja3dhcmRzXG5cdFx0ICogY29tcGF0aWJpbGl0eSwgYnV0IHRoaXMgb3B0aW9uIG9mIHVzZSBpcyBub3cgZGVjcmVtZW50ZWQgYW5kIG5vIGxvbmdlclxuXHRcdCAqIGRvY3VtZW50ZWQgaW4gRGF0YVRhYmxlcyAxLjEwKy5cblx0XHQgKlxuXHRcdCAqICBAdHlwZSBvYmplY3Rcblx0XHQgKiAgQGRlZmF1bHQge31cblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFNob3cgcHJldmlvdXMsIG5leHQgYW5kIGN1cnJlbnQgcGFnZSBidXR0b25zIG9ubHlcblx0XHQgKiAgICAkLmZuLmRhdGFUYWJsZUV4dC5vUGFnaW5hdGlvbi5jdXJyZW50ID0gZnVuY3Rpb24gKCBwYWdlLCBwYWdlcyApIHtcblx0XHQgKiAgICAgIHJldHVybiBbICdwcmV2aW91cycsIHBhZ2UsICduZXh0JyBdO1xuXHRcdCAqICAgIH07XG5cdFx0ICovXG5cdFx0cGFnZXI6IHt9LFxuXHRcblx0XG5cdFx0cmVuZGVyZXI6IHtcblx0XHRcdHBhZ2VCdXR0b246IHt9LFxuXHRcdFx0aGVhZGVyOiB7fVxuXHRcdH0sXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBPcmRlcmluZyBwbHVnLWlucyAtIGN1c3RvbSBkYXRhIHNvdXJjZVxuXHRcdCAqIFxuXHRcdCAqIFRoZSBleHRlbnNpb24gb3B0aW9ucyBmb3Igb3JkZXJpbmcgb2YgZGF0YSBhdmFpbGFibGUgaGVyZSBpcyBjb21wbGltZW50YXJ5XG5cdFx0ICogdG8gdGhlIGRlZmF1bHQgdHlwZSBiYXNlZCBvcmRlcmluZyB0aGF0IERhdGFUYWJsZXMgdHlwaWNhbGx5IHVzZXMuIEl0XG5cdFx0ICogYWxsb3dzIG11Y2ggZ3JlYXRlciBjb250cm9sIG92ZXIgdGhlIHRoZSBkYXRhIHRoYXQgaXMgYmVpbmcgdXNlZCB0b1xuXHRcdCAqIG9yZGVyIGEgY29sdW1uLCBidXQgaXMgbmVjZXNzYXJpbHkgdGhlcmVmb3JlIG1vcmUgY29tcGxleC5cblx0XHQgKiBcblx0XHQgKiBUaGlzIHR5cGUgb2Ygb3JkZXJpbmcgaXMgdXNlZnVsIGlmIHlvdSB3YW50IHRvIGRvIG9yZGVyaW5nIGJhc2VkIG9uIGRhdGFcblx0XHQgKiBsaXZlIGZyb20gdGhlIERPTSAoZm9yIGV4YW1wbGUgdGhlIGNvbnRlbnRzIG9mIGFuICdpbnB1dCcgZWxlbWVudCkgcmF0aGVyXG5cdFx0ICogdGhhbiBqdXN0IHRoZSBzdGF0aWMgc3RyaW5nIHRoYXQgRGF0YVRhYmxlcyBrbm93cyBvZi5cblx0XHQgKiBcblx0XHQgKiBUaGUgd2F5IHRoZXNlIHBsdWctaW5zIHdvcmsgaXMgdGhhdCB5b3UgY3JlYXRlIGFuIGFycmF5IG9mIHRoZSB2YWx1ZXMgeW91XG5cdFx0ICogd2lzaCB0byBiZSBvcmRlcmluZyBmb3IgdGhlIGNvbHVtbiBpbiBxdWVzdGlvbiBhbmQgdGhlbiByZXR1cm4gdGhhdFxuXHRcdCAqIGFycmF5LiBUaGUgZGF0YSBpbiB0aGUgYXJyYXkgbXVjaCBiZSBpbiB0aGUgaW5kZXggb3JkZXIgb2YgdGhlIHJvd3MgaW5cblx0XHQgKiB0aGUgdGFibGUgKG5vdCB0aGUgY3VycmVudGx5IG9yZGVyaW5nIG9yZGVyISkuIFdoaWNoIG9yZGVyIGRhdGEgZ2F0aGVyaW5nXG5cdFx0ICogZnVuY3Rpb24gaXMgcnVuIGhlcmUgZGVwZW5kcyBvbiB0aGUgYGR0LWluaXQgY29sdW1ucy5vcmRlckRhdGFUeXBlYFxuXHRcdCAqIHBhcmFtZXRlciB0aGF0IGlzIHVzZWQgZm9yIHRoZSBjb2x1bW4gKGlmIGFueSkuXG5cdFx0ICpcblx0XHQgKiBUaGUgZnVuY3Rpb25zIGRlZmluZWQgdGFrZSB0d28gcGFyYW1ldGVyczpcblx0XHQgKlxuXHRcdCAqIDEuIGB7b2JqZWN0fWAgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Q6IHNlZVxuXHRcdCAqICAgIHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cblx0XHQgKiAyLiBge2ludH1gIFRhcmdldCBjb2x1bW4gaW5kZXhcblx0XHQgKlxuXHRcdCAqIEVhY2ggZnVuY3Rpb24gaXMgZXhwZWN0ZWQgdG8gcmV0dXJuIGFuIGFycmF5OlxuXHRcdCAqXG5cdFx0ICogKiBge2FycmF5fWAgRGF0YSBmb3IgdGhlIGNvbHVtbiB0byBiZSBvcmRlcmluZyB1cG9uXG5cdFx0ICpcblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIE9yZGVyaW5nIHVzaW5nIGBpbnB1dGAgbm9kZSB2YWx1ZXNcblx0XHQgKiAgICAkLmZuLmRhdGFUYWJsZS5leHQub3JkZXJbJ2RvbS10ZXh0J10gPSBmdW5jdGlvbiAgKCBzZXR0aW5ncywgY29sIClcblx0XHQgKiAgICB7XG5cdFx0ICogICAgICByZXR1cm4gdGhpcy5hcGkoKS5jb2x1bW4oIGNvbCwge29yZGVyOidpbmRleCd9ICkubm9kZXMoKS5tYXAoIGZ1bmN0aW9uICggdGQsIGkgKSB7XG5cdFx0ICogICAgICAgIHJldHVybiAkKCdpbnB1dCcsIHRkKS52YWwoKTtcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9XG5cdFx0ICovXG5cdFx0b3JkZXI6IHt9LFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVHlwZSBiYXNlZCBwbHVnLWlucy5cblx0XHQgKlxuXHRcdCAqIEVhY2ggY29sdW1uIGluIERhdGFUYWJsZXMgaGFzIGEgdHlwZSBhc3NpZ25lZCB0byBpdCwgZWl0aGVyIGJ5IGF1dG9tYXRpY1xuXHRcdCAqIGRldGVjdGlvbiBvciBieSBkaXJlY3QgYXNzaWdubWVudCB1c2luZyB0aGUgYHR5cGVgIG9wdGlvbiBmb3IgdGhlIGNvbHVtbi5cblx0XHQgKiBUaGUgdHlwZSBvZiBhIGNvbHVtbiB3aWxsIGVmZmVjdCBob3cgaXQgaXMgb3JkZXJpbmcgYW5kIHNlYXJjaCAocGx1Zy1pbnNcblx0XHQgKiBjYW4gYWxzbyBtYWtlIHVzZSBvZiB0aGUgY29sdW1uIHR5cGUgaWYgcmVxdWlyZWQpLlxuXHRcdCAqXG5cdFx0ICogQG5hbWVzcGFjZVxuXHRcdCAqL1xuXHRcdHR5cGU6IHtcblx0XHRcdC8qKlxuXHRcdFx0ICogVHlwZSBkZXRlY3Rpb24gZnVuY3Rpb25zLlxuXHRcdFx0ICpcblx0XHRcdCAqIFRoZSBmdW5jdGlvbnMgZGVmaW5lZCBpbiB0aGlzIG9iamVjdCBhcmUgdXNlZCB0byBhdXRvbWF0aWNhbGx5IGRldGVjdFxuXHRcdFx0ICogYSBjb2x1bW4ncyB0eXBlLCBtYWtpbmcgaW5pdGlhbGlzYXRpb24gb2YgRGF0YVRhYmxlcyBzdXBlciBlYXN5LCBldmVuXG5cdFx0XHQgKiB3aGVuIGNvbXBsZXggZGF0YSBpcyBpbiB0aGUgdGFibGUuXG5cdFx0XHQgKlxuXHRcdFx0ICogVGhlIGZ1bmN0aW9ucyBkZWZpbmVkIHRha2UgdHdvIHBhcmFtZXRlcnM6XG5cdFx0XHQgKlxuXHRcdCAgICAgKiAgMS4gYHsqfWAgRGF0YSBmcm9tIHRoZSBjb2x1bW4gY2VsbCB0byBiZSBhbmFseXNlZFxuXHRcdCAgICAgKiAgMi4gYHtzZXR0aW5nc31gIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VkIHRvXG5cdFx0ICAgICAqICAgICBwZXJmb3JtIGNvbnRleHQgc3BlY2lmaWMgdHlwZSBkZXRlY3Rpb24gLSBmb3IgZXhhbXBsZSBkZXRlY3Rpb25cblx0XHQgICAgICogICAgIGJhc2VkIG9uIGxhbmd1YWdlIHNldHRpbmdzIHN1Y2ggYXMgdXNpbmcgYSBjb21tYSBmb3IgYSBkZWNpbWFsXG5cdFx0ICAgICAqICAgICBwbGFjZS4gR2VuZXJhbGx5IHNwZWFraW5nIHRoZSBvcHRpb25zIGZyb20gdGhlIHNldHRpbmdzIHdpbGwgbm90XG5cdFx0ICAgICAqICAgICBiZSByZXF1aXJlZFxuXHRcdFx0ICpcblx0XHRcdCAqIEVhY2ggZnVuY3Rpb24gaXMgZXhwZWN0ZWQgdG8gcmV0dXJuOlxuXHRcdFx0ICpcblx0XHRcdCAqICogYHtzdHJpbmd8bnVsbH1gIERhdGEgdHlwZSBkZXRlY3RlZCwgb3IgbnVsbCBpZiB1bmtub3duIChhbmQgdGh1c1xuXHRcdFx0ICogICBwYXNzIGl0IG9uIHRvIHRoZSBvdGhlciB0eXBlIGRldGVjdGlvbiBmdW5jdGlvbnMuXG5cdFx0XHQgKlxuXHRcdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0XHQgKlxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAgICAvLyBDdXJyZW5jeSB0eXBlIGRldGVjdGlvbiBwbHVnLWluOlxuXHRcdFx0ICogICAgJC5mbi5kYXRhVGFibGUuZXh0LnR5cGUuZGV0ZWN0LnB1c2goXG5cdFx0XHQgKiAgICAgIGZ1bmN0aW9uICggZGF0YSwgc2V0dGluZ3MgKSB7XG5cdFx0XHQgKiAgICAgICAgLy8gQ2hlY2sgdGhlIG51bWVyaWMgcGFydFxuXHRcdFx0ICogICAgICAgIGlmICggISAkLmlzTnVtZXJpYyggZGF0YS5zdWJzdHJpbmcoMSkgKSApIHtcblx0XHRcdCAqICAgICAgICAgIHJldHVybiBudWxsO1xuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgICAgLy8gQ2hlY2sgcHJlZml4ZWQgYnkgY3VycmVuY3lcblx0XHRcdCAqICAgICAgICBpZiAoIGRhdGEuY2hhckF0KDApID09ICckJyB8fCBkYXRhLmNoYXJBdCgwKSA9PSAnJnBvdW5kOycgKSB7XG5cdFx0XHQgKiAgICAgICAgICByZXR1cm4gJ2N1cnJlbmN5Jztcblx0XHRcdCAqICAgICAgICB9XG5cdFx0XHQgKiAgICAgICAgcmV0dXJuIG51bGw7XG5cdFx0XHQgKiAgICAgIH1cblx0XHRcdCAqICAgICk7XG5cdFx0XHQgKi9cblx0XHRcdGRldGVjdDogW10sXG5cdFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogVHlwZSBiYXNlZCBzZWFyY2ggZm9ybWF0dGluZy5cblx0XHRcdCAqXG5cdFx0XHQgKiBUaGUgdHlwZSBiYXNlZCBzZWFyY2hpbmcgZnVuY3Rpb25zIGNhbiBiZSB1c2VkIHRvIHByZS1mb3JtYXQgdGhlXG5cdFx0XHQgKiBkYXRhIHRvIGJlIHNlYXJjaCBvbi4gRm9yIGV4YW1wbGUsIGl0IGNhbiBiZSB1c2VkIHRvIHN0cmlwIEhUTUxcblx0XHRcdCAqIHRhZ3Mgb3IgdG8gZGUtZm9ybWF0IHRlbGVwaG9uZSBudW1iZXJzIGZvciBudW1lcmljIG9ubHkgc2VhcmNoaW5nLlxuXHRcdFx0ICpcblx0XHRcdCAqIE5vdGUgdGhhdCBpcyBhIHNlYXJjaCBpcyBub3QgZGVmaW5lZCBmb3IgYSBjb2x1bW4gb2YgYSBnaXZlbiB0eXBlLFxuXHRcdFx0ICogbm8gc2VhcmNoIGZvcm1hdHRpbmcgd2lsbCBiZSBwZXJmb3JtZWQuXG5cdFx0XHQgKiBcblx0XHRcdCAqIFByZS1wcm9jZXNzaW5nIG9mIHNlYXJjaGluZyBkYXRhIHBsdWctaW5zIC0gV2hlbiB5b3UgYXNzaWduIHRoZSBzVHlwZVxuXHRcdFx0ICogZm9yIGEgY29sdW1uIChvciBoYXZlIGl0IGF1dG9tYXRpY2FsbHkgZGV0ZWN0ZWQgZm9yIHlvdSBieSBEYXRhVGFibGVzXG5cdFx0XHQgKiBvciBhIHR5cGUgZGV0ZWN0aW9uIHBsdWctaW4pLCB5b3Ugd2lsbCB0eXBpY2FsbHkgYmUgdXNpbmcgdGhpcyBmb3Jcblx0XHRcdCAqIGN1c3RvbSBzb3J0aW5nLCBidXQgaXQgY2FuIGFsc28gYmUgdXNlZCB0byBwcm92aWRlIGN1c3RvbSBzZWFyY2hpbmdcblx0XHRcdCAqIGJ5IGFsbG93aW5nIHlvdSB0byBwcmUtcHJvY2Vzc2luZyB0aGUgZGF0YSBhbmQgcmV0dXJuaW5nIHRoZSBkYXRhIGluXG5cdFx0XHQgKiB0aGUgZm9ybWF0IHRoYXQgc2hvdWxkIGJlIHNlYXJjaGVkIHVwb24uIFRoaXMgaXMgZG9uZSBieSBhZGRpbmdcblx0XHRcdCAqIGZ1bmN0aW9ucyB0aGlzIG9iamVjdCB3aXRoIGEgcGFyYW1ldGVyIG5hbWUgd2hpY2ggbWF0Y2hlcyB0aGUgc1R5cGVcblx0XHRcdCAqIGZvciB0aGF0IHRhcmdldCBjb2x1bW4uIFRoaXMgaXMgdGhlIGNvcm9sbGFyeSBvZiA8aT5hZm5Tb3J0RGF0YTwvaT5cblx0XHRcdCAqIGZvciBzZWFyY2hpbmcgZGF0YS5cblx0XHRcdCAqXG5cdFx0XHQgKiBUaGUgZnVuY3Rpb25zIGRlZmluZWQgdGFrZSBhIHNpbmdsZSBwYXJhbWV0ZXI6XG5cdFx0XHQgKlxuXHRcdCAgICAgKiAgMS4gYHsqfWAgRGF0YSBmcm9tIHRoZSBjb2x1bW4gY2VsbCB0byBiZSBwcmVwYXJlZCBmb3Igc2VhcmNoaW5nXG5cdFx0XHQgKlxuXHRcdFx0ICogRWFjaCBmdW5jdGlvbiBpcyBleHBlY3RlZCB0byByZXR1cm46XG5cdFx0XHQgKlxuXHRcdFx0ICogKiBge3N0cmluZ3xudWxsfWAgRm9ybWF0dGVkIHN0cmluZyB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgdGhlIHNlYXJjaGluZy5cblx0XHRcdCAqXG5cdFx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0XHQgKiAgQGRlZmF1bHQge31cblx0XHRcdCAqXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqICAgICQuZm4uZGF0YVRhYmxlLmV4dC50eXBlLnNlYXJjaFsndGl0bGUtbnVtZXJpYyddID0gZnVuY3Rpb24gKCBkICkge1xuXHRcdFx0ICogICAgICByZXR1cm4gZC5yZXBsYWNlKC9cXG4vZyxcIiBcIikucmVwbGFjZSggLzwuKj8+L2csIFwiXCIgKTtcblx0XHRcdCAqICAgIH1cblx0XHRcdCAqL1xuXHRcdFx0c2VhcmNoOiB7fSxcblx0XG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUeXBlIGJhc2VkIG9yZGVyaW5nLlxuXHRcdFx0ICpcblx0XHRcdCAqIFRoZSBjb2x1bW4gdHlwZSB0ZWxscyBEYXRhVGFibGVzIHdoYXQgb3JkZXJpbmcgdG8gYXBwbHkgdG8gdGhlIHRhYmxlXG5cdFx0XHQgKiB3aGVuIGEgY29sdW1uIGlzIHNvcnRlZCB1cG9uLiBUaGUgb3JkZXIgZm9yIGVhY2ggdHlwZSB0aGF0IGlzIGRlZmluZWQsXG5cdFx0XHQgKiBpcyBkZWZpbmVkIGJ5IHRoZSBmdW5jdGlvbnMgYXZhaWxhYmxlIGluIHRoaXMgb2JqZWN0LlxuXHRcdFx0ICpcblx0XHRcdCAqIEVhY2ggb3JkZXJpbmcgb3B0aW9uIGNhbiBiZSBkZXNjcmliZWQgYnkgdGhyZWUgcHJvcGVydGllcyBhZGRlZCB0b1xuXHRcdFx0ICogdGhpcyBvYmplY3Q6XG5cdFx0XHQgKlxuXHRcdFx0ICogKiBge3R5cGV9LXByZWAgLSBQcmUtZm9ybWF0dGluZyBmdW5jdGlvblxuXHRcdFx0ICogKiBge3R5cGV9LWFzY2AgLSBBc2NlbmRpbmcgb3JkZXIgZnVuY3Rpb25cblx0XHRcdCAqICogYHt0eXBlfS1kZXNjYCAtIERlc2NlbmRpbmcgb3JkZXIgZnVuY3Rpb25cblx0XHRcdCAqXG5cdFx0XHQgKiBBbGwgdGhyZWUgY2FuIGJlIHVzZWQgdG9nZXRoZXIsIG9ubHkgYHt0eXBlfS1wcmVgIG9yIG9ubHlcblx0XHRcdCAqIGB7dHlwZX0tYXNjYCBhbmQgYHt0eXBlfS1kZXNjYCB0b2dldGhlci4gSXQgaXMgZ2VuZXJhbGx5IHJlY29tbWVuZGVkXG5cdFx0XHQgKiB0aGF0IG9ubHkgYHt0eXBlfS1wcmVgIGlzIHVzZWQsIGFzIHRoaXMgcHJvdmlkZXMgdGhlIG9wdGltYWxcblx0XHRcdCAqIGltcGxlbWVudGF0aW9uIGluIHRlcm1zIG9mIHNwZWVkLCBhbHRob3VnaCB0aGUgb3RoZXJzIGFyZSBwcm92aWRlZFxuXHRcdFx0ICogZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBleGlzdGluZyBKYXZhc2NyaXB0IHNvcnQgZnVuY3Rpb25zLlxuXHRcdFx0ICpcblx0XHRcdCAqIGB7dHlwZX0tcHJlYDogRnVuY3Rpb25zIGRlZmluZWQgdGFrZSBhIHNpbmdsZSBwYXJhbWV0ZXI6XG5cdFx0XHQgKlxuXHRcdCAgICAgKiAgMS4gYHsqfWAgRGF0YSBmcm9tIHRoZSBjb2x1bW4gY2VsbCB0byBiZSBwcmVwYXJlZCBmb3Igb3JkZXJpbmdcblx0XHRcdCAqXG5cdFx0XHQgKiBBbmQgcmV0dXJuOlxuXHRcdFx0ICpcblx0XHRcdCAqICogYHsqfWAgRGF0YSB0byBiZSBzb3J0ZWQgdXBvblxuXHRcdFx0ICpcblx0XHRcdCAqIGB7dHlwZX0tYXNjYCBhbmQgYHt0eXBlfS1kZXNjYDogRnVuY3Rpb25zIGFyZSB0eXBpY2FsIEphdmFzY3JpcHQgc29ydFxuXHRcdFx0ICogZnVuY3Rpb25zLCB0YWtpbmcgdHdvIHBhcmFtZXRlcnM6XG5cdFx0XHQgKlxuXHRcdCAgICAgKiAgMS4gYHsqfWAgRGF0YSB0byBjb21wYXJlIHRvIHRoZSBzZWNvbmQgcGFyYW1ldGVyXG5cdFx0ICAgICAqICAyLiBgeyp9YCBEYXRhIHRvIGNvbXBhcmUgdG8gdGhlIGZpcnN0IHBhcmFtZXRlclxuXHRcdFx0ICpcblx0XHRcdCAqIEFuZCByZXR1cm5pbmc6XG5cdFx0XHQgKlxuXHRcdFx0ICogKiBgeyp9YCBPcmRlcmluZyBtYXRjaDogPDAgaWYgZmlyc3QgcGFyYW1ldGVyIHNob3VsZCBiZSBzb3J0ZWQgbG93ZXJcblx0XHRcdCAqICAgdGhhbiB0aGUgc2Vjb25kIHBhcmFtZXRlciwgPT09MCBpZiB0aGUgdHdvIHBhcmFtZXRlcnMgYXJlIGVxdWFsIGFuZFxuXHRcdFx0ICogICA+MCBpZiB0aGUgZmlyc3QgcGFyYW1ldGVyIHNob3VsZCBiZSBzb3J0ZWQgaGVpZ2h0IHRoYW4gdGhlIHNlY29uZFxuXHRcdFx0ICogICBwYXJhbWV0ZXIuXG5cdFx0XHQgKiBcblx0XHRcdCAqICBAdHlwZSBvYmplY3Rcblx0XHRcdCAqICBAZGVmYXVsdCB7fVxuXHRcdFx0ICpcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogICAgLy8gTnVtZXJpYyBvcmRlcmluZyBvZiBmb3JtYXR0ZWQgbnVtYmVycyB3aXRoIGEgcHJlLWZvcm1hdHRlclxuXHRcdFx0ICogICAgJC5leHRlbmQoICQuZm4uZGF0YVRhYmxlLmV4dC50eXBlLm9yZGVyLCB7XG5cdFx0XHQgKiAgICAgIFwic3RyaW5nLXByZVwiOiBmdW5jdGlvbih4KSB7XG5cdFx0XHQgKiAgICAgICAgYSA9IChhID09PSBcIi1cIiB8fCBhID09PSBcIlwiKSA/IDAgOiBhLnJlcGxhY2UoIC9bXlxcZFxcLVxcLl0vZywgXCJcIiApO1xuXHRcdFx0ICogICAgICAgIHJldHVybiBwYXJzZUZsb2F0KCBhICk7XG5cdFx0XHQgKiAgICAgIH1cblx0XHRcdCAqICAgIH0gKTtcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqICAgIC8vIENhc2Utc2Vuc2l0aXZlIHN0cmluZyBvcmRlcmluZywgd2l0aCBubyBwcmUtZm9ybWF0dGluZyBtZXRob2Rcblx0XHRcdCAqICAgICQuZXh0ZW5kKCAkLmZuLmRhdGFUYWJsZS5leHQub3JkZXIsIHtcblx0XHRcdCAqICAgICAgXCJzdHJpbmctY2FzZS1hc2NcIjogZnVuY3Rpb24oeCx5KSB7XG5cdFx0XHQgKiAgICAgICAgcmV0dXJuICgoeCA8IHkpID8gLTEgOiAoKHggPiB5KSA/IDEgOiAwKSk7XG5cdFx0XHQgKiAgICAgIH0sXG5cdFx0XHQgKiAgICAgIFwic3RyaW5nLWNhc2UtZGVzY1wiOiBmdW5jdGlvbih4LHkpIHtcblx0XHRcdCAqICAgICAgICByZXR1cm4gKCh4IDwgeSkgPyAxIDogKCh4ID4geSkgPyAtMSA6IDApKTtcblx0XHRcdCAqICAgICAgfVxuXHRcdFx0ICogICAgfSApO1xuXHRcdFx0ICovXG5cdFx0XHRvcmRlcjoge31cblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBVbmlxdWUgRGF0YVRhYmxlcyBpbnN0YW5jZSBjb3VudGVyXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBpbnRcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdF91bmlxdWU6IDAsXG5cdFxuXHRcblx0XHQvL1xuXHRcdC8vIERlcHJlY2lhdGVkXG5cdFx0Ly8gVGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGFyZSByZXRhaW5lZCBmb3IgYmFja3dhcmRzIGNvbXBhdGlibGl0eSBvbmx5LlxuXHRcdC8vIFRoZSBzaG91bGQgbm90IGJlIHVzZWQgaW4gbmV3IHByb2plY3RzIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmVcblx0XHQvLyB2ZXJzaW9uXG5cdFx0Ly9cblx0XG5cdFx0LyoqXG5cdFx0ICogVmVyc2lvbiBjaGVjayBmdW5jdGlvbi5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQGRlcHJlY2lhdGVkIFNpbmNlIDEuMTBcblx0XHQgKi9cblx0XHRmblZlcnNpb25DaGVjazogRGF0YVRhYmxlLmZuVmVyc2lvbkNoZWNrLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kZXggZm9yIHdoYXQgJ3RoaXMnIGluZGV4IEFQSSBmdW5jdGlvbnMgc2hvdWxkIHVzZVxuXHRcdCAqICBAdHlwZSBpbnRcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKi9cblx0XHRpQXBpSW5kZXg6IDAsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBqUXVlcnkgVUkgY2xhc3MgY29udGFpbmVyXG5cdFx0ICogIEB0eXBlIG9iamVjdFxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqL1xuXHRcdG9KVUlDbGFzc2VzOiB7fSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNvZnR3YXJlIHZlcnNpb25cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICovXG5cdFx0c1ZlcnNpb246IERhdGFUYWJsZS52ZXJzaW9uXG5cdH07XG5cdFxuXHRcblx0Ly9cblx0Ly8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIEFsaWFzIHRvIHByZSAxLjEwIEh1bmdhcmlhbiBub3RhdGlvbiBjb3VudGVyIHBhcnRzXG5cdC8vXG5cdCQuZXh0ZW5kKCBfZXh0LCB7XG5cdFx0YWZuRmlsdGVyaW5nOiBfZXh0LnNlYXJjaCxcblx0XHRhVHlwZXM6ICAgICAgIF9leHQudHlwZS5kZXRlY3QsXG5cdFx0b2ZuU2VhcmNoOiAgICBfZXh0LnR5cGUuc2VhcmNoLFxuXHRcdG9Tb3J0OiAgICAgICAgX2V4dC50eXBlLm9yZGVyLFxuXHRcdGFmblNvcnREYXRhOiAgX2V4dC5vcmRlcixcblx0XHRhb0ZlYXR1cmVzOiAgIF9leHQuZmVhdHVyZSxcblx0XHRvQXBpOiAgICAgICAgIF9leHQuaW50ZXJuYWwsXG5cdFx0b1N0ZENsYXNzZXM6ICBfZXh0LmNsYXNzZXMsXG5cdFx0b1BhZ2luYXRpb246ICBfZXh0LnBhZ2VyXG5cdH0gKTtcblx0XG5cdFxuXHQkLmV4dGVuZCggRGF0YVRhYmxlLmV4dC5jbGFzc2VzLCB7XG5cdFx0XCJzVGFibGVcIjogXCJkYXRhVGFibGVcIixcblx0XHRcInNOb0Zvb3RlclwiOiBcIm5vLWZvb3RlclwiLFxuXHRcblx0XHQvKiBQYWdpbmcgYnV0dG9ucyAqL1xuXHRcdFwic1BhZ2VCdXR0b25cIjogXCJwYWdpbmF0ZV9idXR0b25cIixcblx0XHRcInNQYWdlQnV0dG9uQWN0aXZlXCI6IFwiY3VycmVudFwiLFxuXHRcdFwic1BhZ2VCdXR0b25EaXNhYmxlZFwiOiBcImRpc2FibGVkXCIsXG5cdFxuXHRcdC8qIFN0cmlwaW5nIGNsYXNzZXMgKi9cblx0XHRcInNTdHJpcGVPZGRcIjogXCJvZGRcIixcblx0XHRcInNTdHJpcGVFdmVuXCI6IFwiZXZlblwiLFxuXHRcblx0XHQvKiBFbXB0eSByb3cgKi9cblx0XHRcInNSb3dFbXB0eVwiOiBcImRhdGFUYWJsZXNfZW1wdHlcIixcblx0XG5cdFx0LyogRmVhdHVyZXMgKi9cblx0XHRcInNXcmFwcGVyXCI6IFwiZGF0YVRhYmxlc193cmFwcGVyXCIsXG5cdFx0XCJzRmlsdGVyXCI6IFwiZGF0YVRhYmxlc19maWx0ZXJcIixcblx0XHRcInNJbmZvXCI6IFwiZGF0YVRhYmxlc19pbmZvXCIsXG5cdFx0XCJzUGFnaW5nXCI6IFwiZGF0YVRhYmxlc19wYWdpbmF0ZSBwYWdpbmdfXCIsIC8qIE5vdGUgdGhhdCB0aGUgdHlwZSBpcyBwb3N0Zml4ZWQgKi9cblx0XHRcInNMZW5ndGhcIjogXCJkYXRhVGFibGVzX2xlbmd0aFwiLFxuXHRcdFwic1Byb2Nlc3NpbmdcIjogXCJkYXRhVGFibGVzX3Byb2Nlc3NpbmdcIixcblx0XG5cdFx0LyogU29ydGluZyAqL1xuXHRcdFwic1NvcnRBc2NcIjogXCJzb3J0aW5nX2FzY1wiLFxuXHRcdFwic1NvcnREZXNjXCI6IFwic29ydGluZ19kZXNjXCIsXG5cdFx0XCJzU29ydGFibGVcIjogXCJzb3J0aW5nXCIsIC8qIFNvcnRhYmxlIGluIGJvdGggZGlyZWN0aW9ucyAqL1xuXHRcdFwic1NvcnRhYmxlQXNjXCI6IFwic29ydGluZ19hc2NfZGlzYWJsZWRcIixcblx0XHRcInNTb3J0YWJsZURlc2NcIjogXCJzb3J0aW5nX2Rlc2NfZGlzYWJsZWRcIixcblx0XHRcInNTb3J0YWJsZU5vbmVcIjogXCJzb3J0aW5nX2Rpc2FibGVkXCIsXG5cdFx0XCJzU29ydENvbHVtblwiOiBcInNvcnRpbmdfXCIsIC8qIE5vdGUgdGhhdCBhbiBpbnQgaXMgcG9zdGZpeGVkIGZvciB0aGUgc29ydGluZyBvcmRlciAqL1xuXHRcblx0XHQvKiBGaWx0ZXJpbmcgKi9cblx0XHRcInNGaWx0ZXJJbnB1dFwiOiBcIlwiLFxuXHRcblx0XHQvKiBQYWdlIGxlbmd0aCAqL1xuXHRcdFwic0xlbmd0aFNlbGVjdFwiOiBcIlwiLFxuXHRcblx0XHQvKiBTY3JvbGxpbmcgKi9cblx0XHRcInNTY3JvbGxXcmFwcGVyXCI6IFwiZGF0YVRhYmxlc19zY3JvbGxcIixcblx0XHRcInNTY3JvbGxIZWFkXCI6IFwiZGF0YVRhYmxlc19zY3JvbGxIZWFkXCIsXG5cdFx0XCJzU2Nyb2xsSGVhZElubmVyXCI6IFwiZGF0YVRhYmxlc19zY3JvbGxIZWFkSW5uZXJcIixcblx0XHRcInNTY3JvbGxCb2R5XCI6IFwiZGF0YVRhYmxlc19zY3JvbGxCb2R5XCIsXG5cdFx0XCJzU2Nyb2xsRm9vdFwiOiBcImRhdGFUYWJsZXNfc2Nyb2xsRm9vdFwiLFxuXHRcdFwic1Njcm9sbEZvb3RJbm5lclwiOiBcImRhdGFUYWJsZXNfc2Nyb2xsRm9vdElubmVyXCIsXG5cdFxuXHRcdC8qIE1pc2MgKi9cblx0XHRcInNIZWFkZXJUSFwiOiBcIlwiLFxuXHRcdFwic0Zvb3RlclRIXCI6IFwiXCIsXG5cdFxuXHRcdC8vIERlcHJlY2F0ZWRcblx0XHRcInNTb3J0SlVJQXNjXCI6IFwiXCIsXG5cdFx0XCJzU29ydEpVSURlc2NcIjogXCJcIixcblx0XHRcInNTb3J0SlVJXCI6IFwiXCIsXG5cdFx0XCJzU29ydEpVSUFzY0FsbG93ZWRcIjogXCJcIixcblx0XHRcInNTb3J0SlVJRGVzY0FsbG93ZWRcIjogXCJcIixcblx0XHRcInNTb3J0SlVJV3JhcHBlclwiOiBcIlwiLFxuXHRcdFwic1NvcnRJY29uXCI6IFwiXCIsXG5cdFx0XCJzSlVJSGVhZGVyXCI6IFwiXCIsXG5cdFx0XCJzSlVJRm9vdGVyXCI6IFwiXCJcblx0fSApO1xuXHRcblx0XG5cdChmdW5jdGlvbigpIHtcblx0XG5cdC8vIFJldXNlZCBzdHJpbmdzIGZvciBiZXR0ZXIgY29tcHJlc3Npb24uIENsb3N1cmUgY29tcGlsZXIgYXBwZWFycyB0byBoYXZlIGFcblx0Ly8gd2VpcmQgZWRnZSBjYXNlIHdoZXJlIGl0IGlzIHRyeWluZyB0byBleHBhbmQgc3RyaW5ncyByYXRoZXIgdGhhbiB1c2UgdGhlXG5cdC8vIHZhcmlhYmxlIHZlcnNpb24uIFRoaXMgcmVzdWx0cyBpbiBhYm91dCAyMDAgYnl0ZXMgYmVpbmcgYWRkZWQsIGZvciB2ZXJ5XG5cdC8vIGxpdHRsZSBwcmVmZXJlbmNlIGJlbmVmaXQgc2luY2UgaXQgdGhpcyBydW4gb24gc2NyaXB0IGxvYWQgb25seS5cblx0dmFyIF9lbXB0eSA9ICcnO1xuXHRfZW1wdHkgPSAnJztcblx0XG5cdHZhciBfc3RhdGVEZWZhdWx0ID0gX2VtcHR5ICsgJ3VpLXN0YXRlLWRlZmF1bHQnO1xuXHR2YXIgX3NvcnRJY29uICAgICA9IF9lbXB0eSArICdjc3NfcmlnaHQgdWktaWNvbiB1aS1pY29uLSc7XG5cdHZhciBfaGVhZGVyRm9vdGVyID0gX2VtcHR5ICsgJ2ZnLXRvb2xiYXIgdWktdG9vbGJhciB1aS13aWRnZXQtaGVhZGVyIHVpLWhlbHBlci1jbGVhcmZpeCc7XG5cdFxuXHQkLmV4dGVuZCggRGF0YVRhYmxlLmV4dC5vSlVJQ2xhc3NlcywgRGF0YVRhYmxlLmV4dC5jbGFzc2VzLCB7XG5cdFx0LyogRnVsbCBudW1iZXJzIHBhZ2luZyBidXR0b25zICovXG5cdFx0XCJzUGFnZUJ1dHRvblwiOiAgICAgICAgIFwiZmctYnV0dG9uIHVpLWJ1dHRvbiBcIitfc3RhdGVEZWZhdWx0LFxuXHRcdFwic1BhZ2VCdXR0b25BY3RpdmVcIjogICBcInVpLXN0YXRlLWRpc2FibGVkXCIsXG5cdFx0XCJzUGFnZUJ1dHRvbkRpc2FibGVkXCI6IFwidWktc3RhdGUtZGlzYWJsZWRcIixcblx0XG5cdFx0LyogRmVhdHVyZXMgKi9cblx0XHRcInNQYWdpbmdcIjogXCJkYXRhVGFibGVzX3BhZ2luYXRlIGZnLWJ1dHRvbnNldCB1aS1idXR0b25zZXQgZmctYnV0dG9uc2V0LW11bHRpIFwiK1xuXHRcdFx0XCJ1aS1idXR0b25zZXQtbXVsdGkgcGFnaW5nX1wiLCAvKiBOb3RlIHRoYXQgdGhlIHR5cGUgaXMgcG9zdGZpeGVkICovXG5cdFxuXHRcdC8qIFNvcnRpbmcgKi9cblx0XHRcInNTb3J0QXNjXCI6ICAgICAgICAgICAgX3N0YXRlRGVmYXVsdCtcIiBzb3J0aW5nX2FzY1wiLFxuXHRcdFwic1NvcnREZXNjXCI6ICAgICAgICAgICBfc3RhdGVEZWZhdWx0K1wiIHNvcnRpbmdfZGVzY1wiLFxuXHRcdFwic1NvcnRhYmxlXCI6ICAgICAgICAgICBfc3RhdGVEZWZhdWx0K1wiIHNvcnRpbmdcIixcblx0XHRcInNTb3J0YWJsZUFzY1wiOiAgICAgICAgX3N0YXRlRGVmYXVsdCtcIiBzb3J0aW5nX2FzY19kaXNhYmxlZFwiLFxuXHRcdFwic1NvcnRhYmxlRGVzY1wiOiAgICAgICBfc3RhdGVEZWZhdWx0K1wiIHNvcnRpbmdfZGVzY19kaXNhYmxlZFwiLFxuXHRcdFwic1NvcnRhYmxlTm9uZVwiOiAgICAgICBfc3RhdGVEZWZhdWx0K1wiIHNvcnRpbmdfZGlzYWJsZWRcIixcblx0XHRcInNTb3J0SlVJQXNjXCI6ICAgICAgICAgX3NvcnRJY29uK1widHJpYW5nbGUtMS1uXCIsXG5cdFx0XCJzU29ydEpVSURlc2NcIjogICAgICAgIF9zb3J0SWNvbitcInRyaWFuZ2xlLTEtc1wiLFxuXHRcdFwic1NvcnRKVUlcIjogICAgICAgICAgICBfc29ydEljb24rXCJjYXJhdC0yLW4tc1wiLFxuXHRcdFwic1NvcnRKVUlBc2NBbGxvd2VkXCI6ICBfc29ydEljb24rXCJjYXJhdC0xLW5cIixcblx0XHRcInNTb3J0SlVJRGVzY0FsbG93ZWRcIjogX3NvcnRJY29uK1wiY2FyYXQtMS1zXCIsXG5cdFx0XCJzU29ydEpVSVdyYXBwZXJcIjogICAgIFwiRGF0YVRhYmxlc19zb3J0X3dyYXBwZXJcIixcblx0XHRcInNTb3J0SWNvblwiOiAgICAgICAgICAgXCJEYXRhVGFibGVzX3NvcnRfaWNvblwiLFxuXHRcblx0XHQvKiBTY3JvbGxpbmcgKi9cblx0XHRcInNTY3JvbGxIZWFkXCI6IFwiZGF0YVRhYmxlc19zY3JvbGxIZWFkIFwiK19zdGF0ZURlZmF1bHQsXG5cdFx0XCJzU2Nyb2xsRm9vdFwiOiBcImRhdGFUYWJsZXNfc2Nyb2xsRm9vdCBcIitfc3RhdGVEZWZhdWx0LFxuXHRcblx0XHQvKiBNaXNjICovXG5cdFx0XCJzSGVhZGVyVEhcIjogIF9zdGF0ZURlZmF1bHQsXG5cdFx0XCJzRm9vdGVyVEhcIjogIF9zdGF0ZURlZmF1bHQsXG5cdFx0XCJzSlVJSGVhZGVyXCI6IF9oZWFkZXJGb290ZXIrXCIgdWktY29ybmVyLXRsIHVpLWNvcm5lci10clwiLFxuXHRcdFwic0pVSUZvb3RlclwiOiBfaGVhZGVyRm9vdGVyK1wiIHVpLWNvcm5lci1ibCB1aS1jb3JuZXItYnJcIlxuXHR9ICk7XG5cdFxuXHR9KCkpO1xuXHRcblx0XG5cdFxuXHR2YXIgZXh0UGFnaW5hdGlvbiA9IERhdGFUYWJsZS5leHQucGFnZXI7XG5cdFxuXHRmdW5jdGlvbiBfbnVtYmVycyAoIHBhZ2UsIHBhZ2VzICkge1xuXHRcdHZhclxuXHRcdFx0bnVtYmVycyA9IFtdLFxuXHRcdFx0YnV0dG9ucyA9IGV4dFBhZ2luYXRpb24ubnVtYmVyc19sZW5ndGgsXG5cdFx0XHRoYWxmID0gTWF0aC5mbG9vciggYnV0dG9ucyAvIDIgKSxcblx0XHRcdGkgPSAxO1xuXHRcblx0XHRpZiAoIHBhZ2VzIDw9IGJ1dHRvbnMgKSB7XG5cdFx0XHRudW1iZXJzID0gX3JhbmdlKCAwLCBwYWdlcyApO1xuXHRcdH1cblx0XHRlbHNlIGlmICggcGFnZSA8PSBoYWxmICkge1xuXHRcdFx0bnVtYmVycyA9IF9yYW5nZSggMCwgYnV0dG9ucy0yICk7XG5cdFx0XHRudW1iZXJzLnB1c2goICdlbGxpcHNpcycgKTtcblx0XHRcdG51bWJlcnMucHVzaCggcGFnZXMtMSApO1xuXHRcdH1cblx0XHRlbHNlIGlmICggcGFnZSA+PSBwYWdlcyAtIDEgLSBoYWxmICkge1xuXHRcdFx0bnVtYmVycyA9IF9yYW5nZSggcGFnZXMtKGJ1dHRvbnMtMiksIHBhZ2VzICk7XG5cdFx0XHRudW1iZXJzLnNwbGljZSggMCwgMCwgJ2VsbGlwc2lzJyApOyAvLyBubyB1bnNoaWZ0IGluIGllNlxuXHRcdFx0bnVtYmVycy5zcGxpY2UoIDAsIDAsIDAgKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRudW1iZXJzID0gX3JhbmdlKCBwYWdlLWhhbGYrMiwgcGFnZStoYWxmLTEgKTtcblx0XHRcdG51bWJlcnMucHVzaCggJ2VsbGlwc2lzJyApO1xuXHRcdFx0bnVtYmVycy5wdXNoKCBwYWdlcy0xICk7XG5cdFx0XHRudW1iZXJzLnNwbGljZSggMCwgMCwgJ2VsbGlwc2lzJyApO1xuXHRcdFx0bnVtYmVycy5zcGxpY2UoIDAsIDAsIDAgKTtcblx0XHR9XG5cdFxuXHRcdG51bWJlcnMuRFRfZWwgPSAnc3Bhbic7XG5cdFx0cmV0dXJuIG51bWJlcnM7XG5cdH1cblx0XG5cdFxuXHQkLmV4dGVuZCggZXh0UGFnaW5hdGlvbiwge1xuXHRcdHNpbXBsZTogZnVuY3Rpb24gKCBwYWdlLCBwYWdlcyApIHtcblx0XHRcdHJldHVybiBbICdwcmV2aW91cycsICduZXh0JyBdO1xuXHRcdH0sXG5cdFxuXHRcdGZ1bGw6IGZ1bmN0aW9uICggcGFnZSwgcGFnZXMgKSB7XG5cdFx0XHRyZXR1cm4gWyAgJ2ZpcnN0JywgJ3ByZXZpb3VzJywgJ25leHQnLCAnbGFzdCcgXTtcblx0XHR9LFxuXHRcblx0XHRzaW1wbGVfbnVtYmVyczogZnVuY3Rpb24gKCBwYWdlLCBwYWdlcyApIHtcblx0XHRcdHJldHVybiBbICdwcmV2aW91cycsIF9udW1iZXJzKHBhZ2UsIHBhZ2VzKSwgJ25leHQnIF07XG5cdFx0fSxcblx0XG5cdFx0ZnVsbF9udW1iZXJzOiBmdW5jdGlvbiAoIHBhZ2UsIHBhZ2VzICkge1xuXHRcdFx0cmV0dXJuIFsgJ2ZpcnN0JywgJ3ByZXZpb3VzJywgX251bWJlcnMocGFnZSwgcGFnZXMpLCAnbmV4dCcsICdsYXN0JyBdO1xuXHRcdH0sXG5cdFxuXHRcdC8vIEZvciB0ZXN0aW5nIGFuZCBwbHVnLWlucyB0byB1c2Vcblx0XHRfbnVtYmVyczogX251bWJlcnMsXG5cdFxuXHRcdC8vIE51bWJlciBvZiBudW1iZXIgYnV0dG9ucyAoaW5jbHVkaW5nIGVsbGlwc2lzKSB0byBzaG93LiBfTXVzdCBiZSBvZGQhX1xuXHRcdG51bWJlcnNfbGVuZ3RoOiA3XG5cdH0gKTtcblx0XG5cdFxuXHQkLmV4dGVuZCggdHJ1ZSwgRGF0YVRhYmxlLmV4dC5yZW5kZXJlciwge1xuXHRcdHBhZ2VCdXR0b246IHtcblx0XHRcdF86IGZ1bmN0aW9uICggc2V0dGluZ3MsIGhvc3QsIGlkeCwgYnV0dG9ucywgcGFnZSwgcGFnZXMgKSB7XG5cdFx0XHRcdHZhciBjbGFzc2VzID0gc2V0dGluZ3Mub0NsYXNzZXM7XG5cdFx0XHRcdHZhciBsYW5nID0gc2V0dGluZ3Mub0xhbmd1YWdlLm9QYWdpbmF0ZTtcblx0XHRcdFx0dmFyIGJ0bkRpc3BsYXksIGJ0bkNsYXNzLCBjb3VudGVyPTA7XG5cdFxuXHRcdFx0XHR2YXIgYXR0YWNoID0gZnVuY3Rpb24oIGNvbnRhaW5lciwgYnV0dG9ucyApIHtcblx0XHRcdFx0XHR2YXIgaSwgaWVuLCBub2RlLCBidXR0b247XG5cdFx0XHRcdFx0dmFyIGNsaWNrSGFuZGxlciA9IGZ1bmN0aW9uICggZSApIHtcblx0XHRcdFx0XHRcdF9mblBhZ2VDaGFuZ2UoIHNldHRpbmdzLCBlLmRhdGEuYWN0aW9uLCB0cnVlICk7XG5cdFx0XHRcdFx0fTtcblx0XG5cdFx0XHRcdFx0Zm9yICggaT0wLCBpZW49YnV0dG9ucy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0XHRcdGJ1dHRvbiA9IGJ1dHRvbnNbaV07XG5cdFxuXHRcdFx0XHRcdFx0aWYgKCAkLmlzQXJyYXkoIGJ1dHRvbiApICkge1xuXHRcdFx0XHRcdFx0XHR2YXIgaW5uZXIgPSAkKCAnPCcrKGJ1dHRvbi5EVF9lbCB8fCAnZGl2JykrJy8+JyApXG5cdFx0XHRcdFx0XHRcdFx0LmFwcGVuZFRvKCBjb250YWluZXIgKTtcblx0XHRcdFx0XHRcdFx0YXR0YWNoKCBpbm5lciwgYnV0dG9uICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0YnRuRGlzcGxheSA9ICcnO1xuXHRcdFx0XHRcdFx0XHRidG5DbGFzcyA9ICcnO1xuXHRcblx0XHRcdFx0XHRcdFx0c3dpdGNoICggYnV0dG9uICkge1xuXHRcdFx0XHRcdFx0XHRcdGNhc2UgJ2VsbGlwc2lzJzpcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnRhaW5lci5hcHBlbmQoJzxzcGFuIGNsYXNzPVwiZWxsaXBzaXNcIj4mI3gyMDI2Ozwvc3Bhbj4nKTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcblx0XHRcdFx0XHRcdFx0XHRjYXNlICdmaXJzdCc6XG5cdFx0XHRcdFx0XHRcdFx0XHRidG5EaXNwbGF5ID0gbGFuZy5zRmlyc3Q7XG5cdFx0XHRcdFx0XHRcdFx0XHRidG5DbGFzcyA9IGJ1dHRvbiArIChwYWdlID4gMCA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCcnIDogJyAnK2NsYXNzZXMuc1BhZ2VCdXR0b25EaXNhYmxlZCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAncHJldmlvdXMnOlxuXHRcdFx0XHRcdFx0XHRcdFx0YnRuRGlzcGxheSA9IGxhbmcuc1ByZXZpb3VzO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnRuQ2xhc3MgPSBidXR0b24gKyAocGFnZSA+IDAgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQnJyA6ICcgJytjbGFzc2VzLnNQYWdlQnV0dG9uRGlzYWJsZWQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgJ25leHQnOlxuXHRcdFx0XHRcdFx0XHRcdFx0YnRuRGlzcGxheSA9IGxhbmcuc05leHQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRidG5DbGFzcyA9IGJ1dHRvbiArIChwYWdlIDwgcGFnZXMtMSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCcnIDogJyAnK2NsYXNzZXMuc1BhZ2VCdXR0b25EaXNhYmxlZCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAnbGFzdCc6XG5cdFx0XHRcdFx0XHRcdFx0XHRidG5EaXNwbGF5ID0gbGFuZy5zTGFzdDtcblx0XHRcdFx0XHRcdFx0XHRcdGJ0bkNsYXNzID0gYnV0dG9uICsgKHBhZ2UgPCBwYWdlcy0xID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0JycgOiAnICcrY2xhc3Nlcy5zUGFnZUJ1dHRvbkRpc2FibGVkKTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcblx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRcdFx0YnRuRGlzcGxheSA9IGJ1dHRvbiArIDE7XG5cdFx0XHRcdFx0XHRcdFx0XHRidG5DbGFzcyA9IHBhZ2UgPT09IGJ1dHRvbiA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNsYXNzZXMuc1BhZ2VCdXR0b25BY3RpdmUgOiAnJztcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdFx0XHRpZiAoIGJ0bkRpc3BsYXkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9ICQoJzxhPicsIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0J2NsYXNzJzogY2xhc3Nlcy5zUGFnZUJ1dHRvbisnICcrYnRuQ2xhc3MsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCdhcmlhLWNvbnRyb2xzJzogc2V0dGluZ3Muc1RhYmxlSWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCdkYXRhLWR0LWlkeCc6IGNvdW50ZXIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCd0YWJpbmRleCc6IHNldHRpbmdzLmlUYWJJbmRleCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0J2lkJzogaWR4ID09PSAwICYmIHR5cGVvZiBidXR0b24gPT09ICdzdHJpbmcnID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzZXR0aW5ncy5zVGFibGVJZCArJ18nKyBidXR0b24gOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG51bGxcblx0XHRcdFx0XHRcdFx0XHRcdH0gKVxuXHRcdFx0XHRcdFx0XHRcdFx0Lmh0bWwoIGJ0bkRpc3BsYXkgKVxuXHRcdFx0XHRcdFx0XHRcdFx0LmFwcGVuZFRvKCBjb250YWluZXIgKTtcblx0XG5cdFx0XHRcdFx0XHRcdFx0X2ZuQmluZEFjdGlvbihcblx0XHRcdFx0XHRcdFx0XHRcdG5vZGUsIHthY3Rpb246IGJ1dHRvbn0sIGNsaWNrSGFuZGxlclxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFxuXHRcdFx0XHRcdFx0XHRcdGNvdW50ZXIrKztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XG5cdFx0XHRcdC8vIElFOSB0aHJvd3MgYW4gJ3Vua25vd24gZXJyb3InIGlmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaXMgdXNlZFxuXHRcdFx0XHQvLyBpbnNpZGUgYW4gaWZyYW1lIG9yIGZyYW1lLiBUcnkgLyBjYXRjaCB0aGUgZXJyb3IuIE5vdCBnb29kIGZvclxuXHRcdFx0XHQvLyBhY2Nlc3NpYmlsaXR5LCBidXQgbmVpdGhlciBhcmUgZnJhbWVzLlxuXHRcdFx0XHR2YXIgYWN0aXZlRWw7XG5cdFxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdC8vIEJlY2F1c2UgdGhpcyBhcHByb2FjaCBpcyBkZXN0cm95aW5nIGFuZCByZWNyZWF0aW5nIHRoZSBwYWdpbmdcblx0XHRcdFx0XHQvLyBlbGVtZW50cywgZm9jdXMgaXMgbG9zdCBvbiB0aGUgc2VsZWN0IGJ1dHRvbiB3aGljaCBpcyBiYWQgZm9yXG5cdFx0XHRcdFx0Ly8gYWNjZXNzaWJpbGl0eS4gU28gd2Ugd2FudCB0byByZXN0b3JlIGZvY3VzIG9uY2UgdGhlIGRyYXcgaGFzXG5cdFx0XHRcdFx0Ly8gY29tcGxldGVkXG5cdFx0XHRcdFx0YWN0aXZlRWwgPSAkKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpLmRhdGEoJ2R0LWlkeCcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhdGNoIChlKSB7fVxuXHRcblx0XHRcdFx0YXR0YWNoKCAkKGhvc3QpLmVtcHR5KCksIGJ1dHRvbnMgKTtcblx0XG5cdFx0XHRcdGlmICggYWN0aXZlRWwgKSB7XG5cdFx0XHRcdFx0JChob3N0KS5maW5kKCAnW2RhdGEtZHQtaWR4PScrYWN0aXZlRWwrJ10nICkuZm9jdXMoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSApO1xuXHRcblx0XG5cdFxuXHQvLyBCdWlsdCBpbiB0eXBlIGRldGVjdGlvbi4gU2VlIG1vZGVsLmV4dC5hVHlwZXMgZm9yIGluZm9ybWF0aW9uIGFib3V0XG5cdC8vIHdoYXQgaXMgcmVxdWlyZWQgZnJvbSB0aGlzIG1ldGhvZHMuXG5cdCQuZXh0ZW5kKCBEYXRhVGFibGUuZXh0LnR5cGUuZGV0ZWN0LCBbXG5cdFx0Ly8gUGxhaW4gbnVtYmVycyAtIGZpcnN0IHNpbmNlIFY4IGRldGVjdHMgc29tZSBwbGFpbiBudW1iZXJzIGFzIGRhdGVzXG5cdFx0Ly8gZS5nLiBEYXRlLnBhcnNlKCc1NScpIChidXQgbm90IGFsbCwgZS5nLiBEYXRlLnBhcnNlKCcyMicpLi4uKS5cblx0XHRmdW5jdGlvbiAoIGQsIHNldHRpbmdzIClcblx0XHR7XG5cdFx0XHR2YXIgZGVjaW1hbCA9IHNldHRpbmdzLm9MYW5ndWFnZS5zRGVjaW1hbDtcblx0XHRcdHJldHVybiBfaXNOdW1iZXIoIGQsIGRlY2ltYWwgKSA/ICdudW0nK2RlY2ltYWwgOiBudWxsO1xuXHRcdH0sXG5cdFxuXHRcdC8vIERhdGVzIChvbmx5IHRob3NlIHJlY29nbmlzZWQgYnkgdGhlIGJyb3dzZXIncyBEYXRlLnBhcnNlKVxuXHRcdGZ1bmN0aW9uICggZCwgc2V0dGluZ3MgKVxuXHRcdHtcblx0XHRcdC8vIFY4IHdpbGwgcmVtb3ZlIGFueSB1bmtub3duIGNoYXJhY3RlcnMgYXQgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgdGhlXG5cdFx0XHQvLyBleHByZXNzaW9uLCBsZWFkaW5nIHRvIGZhbHNlIG1hdGNoZXMgc3VjaCBhcyBgJDI0NS4xMmAgb3IgYDEwJWAgYmVpbmdcblx0XHRcdC8vIGEgdmFsaWQgZGF0ZS4gU2VlIGZvcnVtIHRocmVhZCAxODk0MSBmb3IgZGV0YWlsLlxuXHRcdFx0aWYgKCBkICYmICEoZCBpbnN0YW5jZW9mIERhdGUpICYmICggISBfcmVfZGF0ZV9zdGFydC50ZXN0KGQpIHx8ICEgX3JlX2RhdGVfZW5kLnRlc3QoZCkgKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHR2YXIgcGFyc2VkID0gRGF0ZS5wYXJzZShkKTtcblx0XHRcdHJldHVybiAocGFyc2VkICE9PSBudWxsICYmICFpc05hTihwYXJzZWQpKSB8fCBfZW1wdHkoZCkgPyAnZGF0ZScgOiBudWxsO1xuXHRcdH0sXG5cdFxuXHRcdC8vIEZvcm1hdHRlZCBudW1iZXJzXG5cdFx0ZnVuY3Rpb24gKCBkLCBzZXR0aW5ncyApXG5cdFx0e1xuXHRcdFx0dmFyIGRlY2ltYWwgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uuc0RlY2ltYWw7XG5cdFx0XHRyZXR1cm4gX2lzTnVtYmVyKCBkLCBkZWNpbWFsLCB0cnVlICkgPyAnbnVtLWZtdCcrZGVjaW1hbCA6IG51bGw7XG5cdFx0fSxcblx0XG5cdFx0Ly8gSFRNTCBudW1lcmljXG5cdFx0ZnVuY3Rpb24gKCBkLCBzZXR0aW5ncyApXG5cdFx0e1xuXHRcdFx0dmFyIGRlY2ltYWwgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uuc0RlY2ltYWw7XG5cdFx0XHRyZXR1cm4gX2h0bWxOdW1lcmljKCBkLCBkZWNpbWFsICkgPyAnaHRtbC1udW0nK2RlY2ltYWwgOiBudWxsO1xuXHRcdH0sXG5cdFxuXHRcdC8vIEhUTUwgbnVtZXJpYywgZm9ybWF0dGVkXG5cdFx0ZnVuY3Rpb24gKCBkLCBzZXR0aW5ncyApXG5cdFx0e1xuXHRcdFx0dmFyIGRlY2ltYWwgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uuc0RlY2ltYWw7XG5cdFx0XHRyZXR1cm4gX2h0bWxOdW1lcmljKCBkLCBkZWNpbWFsLCB0cnVlICkgPyAnaHRtbC1udW0tZm10JytkZWNpbWFsIDogbnVsbDtcblx0XHR9LFxuXHRcblx0XHQvLyBIVE1MICh0aGlzIGlzIHN0cmljdCBjaGVja2luZyAtIHRoZXJlIG11c3QgYmUgaHRtbClcblx0XHRmdW5jdGlvbiAoIGQsIHNldHRpbmdzIClcblx0XHR7XG5cdFx0XHRyZXR1cm4gX2VtcHR5KCBkICkgfHwgKHR5cGVvZiBkID09PSAnc3RyaW5nJyAmJiBkLmluZGV4T2YoJzwnKSAhPT0gLTEpID9cblx0XHRcdFx0J2h0bWwnIDogbnVsbDtcblx0XHR9XG5cdF0gKTtcblx0XG5cdFxuXHRcblx0Ly8gRmlsdGVyIGZvcm1hdHRpbmcgZnVuY3Rpb25zLiBTZWUgbW9kZWwuZXh0Lm9mblNlYXJjaCBmb3IgaW5mb3JtYXRpb24gYWJvdXRcblx0Ly8gd2hhdCBpcyByZXF1aXJlZCBmcm9tIHRoZXNlIG1ldGhvZHMuXG5cdC8vIFxuXHQvLyBOb3RlIHRoYXQgYWRkaXRpb25hbCBzZWFyY2ggbWV0aG9kcyBhcmUgYWRkZWQgZm9yIHRoZSBodG1sIG51bWJlcnMgYW5kXG5cdC8vIGh0bWwgZm9ybWF0dGVkIG51bWJlcnMgYnkgYF9hZGROdW1lcmljU29ydCgpYCB3aGVuIHdlIGtub3cgd2hhdCB0aGUgZGVjaW1hbFxuXHQvLyBwbGFjZSBpc1xuXHRcblx0XG5cdCQuZXh0ZW5kKCBEYXRhVGFibGUuZXh0LnR5cGUuc2VhcmNoLCB7XG5cdFx0aHRtbDogZnVuY3Rpb24gKCBkYXRhICkge1xuXHRcdFx0cmV0dXJuIF9lbXB0eShkYXRhKSA/XG5cdFx0XHRcdGRhdGEgOlxuXHRcdFx0XHR0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgP1xuXHRcdFx0XHRcdGRhdGFcblx0XHRcdFx0XHRcdC5yZXBsYWNlKCBfcmVfbmV3X2xpbmVzLCBcIiBcIiApXG5cdFx0XHRcdFx0XHQucmVwbGFjZSggX3JlX2h0bWwsIFwiXCIgKSA6XG5cdFx0XHRcdFx0Jyc7XG5cdFx0fSxcblx0XG5cdFx0c3RyaW5nOiBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cdFx0XHRyZXR1cm4gX2VtcHR5KGRhdGEpID9cblx0XHRcdFx0ZGF0YSA6XG5cdFx0XHRcdHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/XG5cdFx0XHRcdFx0ZGF0YS5yZXBsYWNlKCBfcmVfbmV3X2xpbmVzLCBcIiBcIiApIDpcblx0XHRcdFx0XHRkYXRhO1xuXHRcdH1cblx0fSApO1xuXHRcblx0XG5cdFxuXHR2YXIgX19udW1lcmljUmVwbGFjZSA9IGZ1bmN0aW9uICggZCwgZGVjaW1hbFBsYWNlLCByZTEsIHJlMiApIHtcblx0XHRpZiAoIGQgIT09IDAgJiYgKCFkIHx8IGQgPT09ICctJykgKSB7XG5cdFx0XHRyZXR1cm4gLUluZmluaXR5O1xuXHRcdH1cblx0XG5cdFx0Ly8gSWYgYSBkZWNpbWFsIHBsYWNlIG90aGVyIHRoYW4gYC5gIGlzIHVzZWQsIGl0IG5lZWRzIHRvIGJlIGdpdmVuIHRvIHRoZVxuXHRcdC8vIGZ1bmN0aW9uIHNvIHdlIGNhbiBkZXRlY3QgaXQgYW5kIHJlcGxhY2Ugd2l0aCBhIGAuYCB3aGljaCBpcyB0aGUgb25seVxuXHRcdC8vIGRlY2ltYWwgcGxhY2UgSmF2YXNjcmlwdCByZWNvZ25pc2VzIC0gaXQgaXMgbm90IGxvY2FsZSBhd2FyZS5cblx0XHRpZiAoIGRlY2ltYWxQbGFjZSApIHtcblx0XHRcdGQgPSBfbnVtVG9EZWNpbWFsKCBkLCBkZWNpbWFsUGxhY2UgKTtcblx0XHR9XG5cdFxuXHRcdGlmICggZC5yZXBsYWNlICkge1xuXHRcdFx0aWYgKCByZTEgKSB7XG5cdFx0XHRcdGQgPSBkLnJlcGxhY2UoIHJlMSwgJycgKTtcblx0XHRcdH1cblx0XG5cdFx0XHRpZiAoIHJlMiApIHtcblx0XHRcdFx0ZCA9IGQucmVwbGFjZSggcmUyLCAnJyApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0cmV0dXJuIGQgKiAxO1xuXHR9O1xuXHRcblx0XG5cdC8vIEFkZCB0aGUgbnVtZXJpYyAnZGVmb3JtYXR0aW5nJyBmdW5jdGlvbnMgZm9yIHNvcnRpbmcgYW5kIHNlYXJjaC4gVGhpcyBpcyBkb25lXG5cdC8vIGluIGEgZnVuY3Rpb24gdG8gcHJvdmlkZSBhbiBlYXN5IGFiaWxpdHkgZm9yIHRoZSBsYW5ndWFnZSBvcHRpb25zIHRvIGFkZFxuXHQvLyBhZGRpdGlvbmFsIG1ldGhvZHMgaWYgYSBub24tcGVyaW9kIGRlY2ltYWwgcGxhY2UgaXMgdXNlZC5cblx0ZnVuY3Rpb24gX2FkZE51bWVyaWNTb3J0ICggZGVjaW1hbFBsYWNlICkge1xuXHRcdCQuZWFjaChcblx0XHRcdHtcblx0XHRcdFx0Ly8gUGxhaW4gbnVtYmVyc1xuXHRcdFx0XHRcIm51bVwiOiBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIF9fbnVtZXJpY1JlcGxhY2UoIGQsIGRlY2ltYWxQbGFjZSApO1xuXHRcdFx0XHR9LFxuXHRcblx0XHRcdFx0Ly8gRm9ybWF0dGVkIG51bWJlcnNcblx0XHRcdFx0XCJudW0tZm10XCI6IGZ1bmN0aW9uICggZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gX19udW1lcmljUmVwbGFjZSggZCwgZGVjaW1hbFBsYWNlLCBfcmVfZm9ybWF0dGVkX251bWVyaWMgKTtcblx0XHRcdFx0fSxcblx0XG5cdFx0XHRcdC8vIEhUTUwgbnVtZXJpY1xuXHRcdFx0XHRcImh0bWwtbnVtXCI6IGZ1bmN0aW9uICggZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gX19udW1lcmljUmVwbGFjZSggZCwgZGVjaW1hbFBsYWNlLCBfcmVfaHRtbCApO1xuXHRcdFx0XHR9LFxuXHRcblx0XHRcdFx0Ly8gSFRNTCBudW1lcmljLCBmb3JtYXR0ZWRcblx0XHRcdFx0XCJodG1sLW51bS1mbXRcIjogZnVuY3Rpb24gKCBkICkge1xuXHRcdFx0XHRcdHJldHVybiBfX251bWVyaWNSZXBsYWNlKCBkLCBkZWNpbWFsUGxhY2UsIF9yZV9odG1sLCBfcmVfZm9ybWF0dGVkX251bWVyaWMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGZ1bmN0aW9uICgga2V5LCBmbiApIHtcblx0XHRcdFx0Ly8gQWRkIHRoZSBvcmRlcmluZyBtZXRob2Rcblx0XHRcdFx0X2V4dC50eXBlLm9yZGVyWyBrZXkrZGVjaW1hbFBsYWNlKyctcHJlJyBdID0gZm47XG5cdFxuXHRcdFx0XHQvLyBGb3IgSFRNTCB0eXBlcyBhZGQgYSBzZWFyY2ggZm9ybWF0dGVyIHRoYXQgd2lsbCBzdHJpcCB0aGUgSFRNTFxuXHRcdFx0XHRpZiAoIGtleS5tYXRjaCgvXmh0bWxcXC0vKSApIHtcblx0XHRcdFx0XHRfZXh0LnR5cGUuc2VhcmNoWyBrZXkrZGVjaW1hbFBsYWNlIF0gPSBfZXh0LnR5cGUuc2VhcmNoLmh0bWw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHQpO1xuXHR9XG5cdFxuXHRcblx0Ly8gRGVmYXVsdCBzb3J0IG1ldGhvZHNcblx0JC5leHRlbmQoIF9leHQudHlwZS5vcmRlciwge1xuXHRcdC8vIERhdGVzXG5cdFx0XCJkYXRlLXByZVwiOiBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0XHRyZXR1cm4gRGF0ZS5wYXJzZSggZCApIHx8IDA7XG5cdFx0fSxcblx0XG5cdFx0Ly8gaHRtbFxuXHRcdFwiaHRtbC1wcmVcIjogZnVuY3Rpb24gKCBhICkge1xuXHRcdFx0cmV0dXJuIF9lbXB0eShhKSA/XG5cdFx0XHRcdCcnIDpcblx0XHRcdFx0YS5yZXBsYWNlID9cblx0XHRcdFx0XHRhLnJlcGxhY2UoIC88Lio/Pi9nLCBcIlwiICkudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdFx0YSsnJztcblx0XHR9LFxuXHRcblx0XHQvLyBzdHJpbmdcblx0XHRcInN0cmluZy1wcmVcIjogZnVuY3Rpb24gKCBhICkge1xuXHRcdFx0Ly8gVGhpcyBpcyBhIGxpdHRsZSBjb21wbGV4LCBidXQgZmFzdGVyIHRoYW4gYWx3YXlzIGNhbGxpbmcgdG9TdHJpbmcsXG5cdFx0XHQvLyBodHRwOi8vanNwZXJmLmNvbS90b3N0cmluZy12LWNoZWNrXG5cdFx0XHRyZXR1cm4gX2VtcHR5KGEpID9cblx0XHRcdFx0JycgOlxuXHRcdFx0XHR0eXBlb2YgYSA9PT0gJ3N0cmluZycgP1xuXHRcdFx0XHRcdGEudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdFx0ISBhLnRvU3RyaW5nID9cblx0XHRcdFx0XHRcdCcnIDpcblx0XHRcdFx0XHRcdGEudG9TdHJpbmcoKTtcblx0XHR9LFxuXHRcblx0XHQvLyBzdHJpbmctYXNjIGFuZCAtZGVzYyBhcmUgcmV0YWluZWQgb25seSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIHRoZSBvbGRcblx0XHQvLyBzb3J0IG1ldGhvZHNcblx0XHRcInN0cmluZy1hc2NcIjogZnVuY3Rpb24gKCB4LCB5ICkge1xuXHRcdFx0cmV0dXJuICgoeCA8IHkpID8gLTEgOiAoKHggPiB5KSA/IDEgOiAwKSk7XG5cdFx0fSxcblx0XG5cdFx0XCJzdHJpbmctZGVzY1wiOiBmdW5jdGlvbiAoIHgsIHkgKSB7XG5cdFx0XHRyZXR1cm4gKCh4IDwgeSkgPyAxIDogKCh4ID4geSkgPyAtMSA6IDApKTtcblx0XHR9XG5cdH0gKTtcblx0XG5cdFxuXHQvLyBOdW1lcmljIHNvcnRpbmcgdHlwZXMgLSBvcmRlciBkb2Vzbid0IG1hdHRlciBoZXJlXG5cdF9hZGROdW1lcmljU29ydCggJycgKTtcblx0XG5cdFxuXHQkLmV4dGVuZCggdHJ1ZSwgRGF0YVRhYmxlLmV4dC5yZW5kZXJlciwge1xuXHRcdGhlYWRlcjoge1xuXHRcdFx0XzogZnVuY3Rpb24gKCBzZXR0aW5ncywgY2VsbCwgY29sdW1uLCBjbGFzc2VzICkge1xuXHRcdFx0XHQvLyBObyBhZGRpdGlvbmFsIG1hcmstdXAgcmVxdWlyZWRcblx0XHRcdFx0Ly8gQXR0YWNoIGEgc29ydCBsaXN0ZW5lciB0byB1cGRhdGUgb24gc29ydCAtIG5vdGUgdGhhdCB1c2luZyB0aGVcblx0XHRcdFx0Ly8gYERUYCBuYW1lc3BhY2Ugd2lsbCBhbGxvdyB0aGUgZXZlbnQgdG8gYmUgcmVtb3ZlZCBhdXRvbWF0aWNhbGx5XG5cdFx0XHRcdC8vIG9uIGRlc3Ryb3ksIHdoaWxlIHRoZSBgZHRgIG5hbWVzcGFjZWQgZXZlbnQgaXMgdGhlIG9uZSB3ZSBhcmVcblx0XHRcdFx0Ly8gbGlzdGVuaW5nIGZvclxuXHRcdFx0XHQkKHNldHRpbmdzLm5UYWJsZSkub24oICdvcmRlci5kdC5EVCcsIGZ1bmN0aW9uICggZSwgY3R4LCBzb3J0aW5nLCBjb2x1bW5zICkge1xuXHRcdFx0XHRcdGlmICggc2V0dGluZ3MgIT09IGN0eCApIHsgLy8gbmVlZCB0byBjaGVjayB0aGlzIHRoaXMgaXMgdGhlIGhvc3Rcblx0XHRcdFx0XHRcdHJldHVybjsgICAgICAgICAgICAgICAvLyB0YWJsZSwgbm90IGEgbmVzdGVkIG9uZVxuXHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0dmFyIGNvbElkeCA9IGNvbHVtbi5pZHg7XG5cdFxuXHRcdFx0XHRcdGNlbGxcblx0XHRcdFx0XHRcdC5yZW1vdmVDbGFzcyhcblx0XHRcdFx0XHRcdFx0Y29sdW1uLnNTb3J0aW5nQ2xhc3MgKycgJytcblx0XHRcdFx0XHRcdFx0Y2xhc3Nlcy5zU29ydEFzYyArJyAnK1xuXHRcdFx0XHRcdFx0XHRjbGFzc2VzLnNTb3J0RGVzY1xuXHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0LmFkZENsYXNzKCBjb2x1bW5zWyBjb2xJZHggXSA9PSAnYXNjJyA/XG5cdFx0XHRcdFx0XHRcdGNsYXNzZXMuc1NvcnRBc2MgOiBjb2x1bW5zWyBjb2xJZHggXSA9PSAnZGVzYycgP1xuXHRcdFx0XHRcdFx0XHRcdGNsYXNzZXMuc1NvcnREZXNjIDpcblx0XHRcdFx0XHRcdFx0XHRjb2x1bW4uc1NvcnRpbmdDbGFzc1xuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fSxcblx0XG5cdFx0XHRqcXVlcnl1aTogZnVuY3Rpb24gKCBzZXR0aW5ncywgY2VsbCwgY29sdW1uLCBjbGFzc2VzICkge1xuXHRcdFx0XHQkKCc8ZGl2Lz4nKVxuXHRcdFx0XHRcdC5hZGRDbGFzcyggY2xhc3Nlcy5zU29ydEpVSVdyYXBwZXIgKVxuXHRcdFx0XHRcdC5hcHBlbmQoIGNlbGwuY29udGVudHMoKSApXG5cdFx0XHRcdFx0LmFwcGVuZCggJCgnPHNwYW4vPicpXG5cdFx0XHRcdFx0XHQuYWRkQ2xhc3MoIGNsYXNzZXMuc1NvcnRJY29uKycgJytjb2x1bW4uc1NvcnRpbmdDbGFzc0pVSSApXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHRcdC5hcHBlbmRUbyggY2VsbCApO1xuXHRcblx0XHRcdFx0Ly8gQXR0YWNoIGEgc29ydCBsaXN0ZW5lciB0byB1cGRhdGUgb24gc29ydFxuXHRcdFx0XHQkKHNldHRpbmdzLm5UYWJsZSkub24oICdvcmRlci5kdC5EVCcsIGZ1bmN0aW9uICggZSwgY3R4LCBzb3J0aW5nLCBjb2x1bW5zICkge1xuXHRcdFx0XHRcdGlmICggc2V0dGluZ3MgIT09IGN0eCApIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdHZhciBjb2xJZHggPSBjb2x1bW4uaWR4O1xuXHRcblx0XHRcdFx0XHRjZWxsXG5cdFx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoIGNsYXNzZXMuc1NvcnRBc2MgK1wiIFwiK2NsYXNzZXMuc1NvcnREZXNjIClcblx0XHRcdFx0XHRcdC5hZGRDbGFzcyggY29sdW1uc1sgY29sSWR4IF0gPT0gJ2FzYycgP1xuXHRcdFx0XHRcdFx0XHRjbGFzc2VzLnNTb3J0QXNjIDogY29sdW1uc1sgY29sSWR4IF0gPT0gJ2Rlc2MnID9cblx0XHRcdFx0XHRcdFx0XHRjbGFzc2VzLnNTb3J0RGVzYyA6XG5cdFx0XHRcdFx0XHRcdFx0Y29sdW1uLnNTb3J0aW5nQ2xhc3Ncblx0XHRcdFx0XHRcdCk7XG5cdFxuXHRcdFx0XHRcdGNlbGxcblx0XHRcdFx0XHRcdC5maW5kKCAnc3Bhbi4nK2NsYXNzZXMuc1NvcnRJY29uIClcblx0XHRcdFx0XHRcdC5yZW1vdmVDbGFzcyhcblx0XHRcdFx0XHRcdFx0Y2xhc3Nlcy5zU29ydEpVSUFzYyArXCIgXCIrXG5cdFx0XHRcdFx0XHRcdGNsYXNzZXMuc1NvcnRKVUlEZXNjICtcIiBcIitcblx0XHRcdFx0XHRcdFx0Y2xhc3Nlcy5zU29ydEpVSSArXCIgXCIrXG5cdFx0XHRcdFx0XHRcdGNsYXNzZXMuc1NvcnRKVUlBc2NBbGxvd2VkICtcIiBcIitcblx0XHRcdFx0XHRcdFx0Y2xhc3Nlcy5zU29ydEpVSURlc2NBbGxvd2VkXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQuYWRkQ2xhc3MoIGNvbHVtbnNbIGNvbElkeCBdID09ICdhc2MnID9cblx0XHRcdFx0XHRcdFx0Y2xhc3Nlcy5zU29ydEpVSUFzYyA6IGNvbHVtbnNbIGNvbElkeCBdID09ICdkZXNjJyA/XG5cdFx0XHRcdFx0XHRcdFx0Y2xhc3Nlcy5zU29ydEpVSURlc2MgOlxuXHRcdFx0XHRcdFx0XHRcdGNvbHVtbi5zU29ydGluZ0NsYXNzSlVJXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9ICk7XG5cdFxuXHQvKlxuXHQgKiBQdWJsaWMgaGVscGVyIGZ1bmN0aW9ucy4gVGhlc2UgYXJlbid0IHVzZWQgaW50ZXJuYWxseSBieSBEYXRhVGFibGVzLCBvclxuXHQgKiBjYWxsZWQgYnkgYW55IG9mIHRoZSBvcHRpb25zIHBhc3NlZCBpbnRvIERhdGFUYWJsZXMsIGJ1dCB0aGV5IGNhbiBiZSB1c2VkXG5cdCAqIGV4dGVybmFsbHkgYnkgZGV2ZWxvcGVycyB3b3JraW5nIHdpdGggRGF0YVRhYmxlcy4gVGhleSBhcmUgaGVscGVyIGZ1bmN0aW9uc1xuXHQgKiB0byBtYWtlIHdvcmtpbmcgd2l0aCBEYXRhVGFibGVzIGEgbGl0dGxlIGJpdCBlYXNpZXIuXG5cdCAqL1xuXHRcblx0LyoqXG5cdCAqIEhlbHBlcnMgZm9yIGBjb2x1bW5zLnJlbmRlcmAuXG5cdCAqXG5cdCAqIFRoZSBvcHRpb25zIGRlZmluZWQgaGVyZSBjYW4gYmUgdXNlZCB3aXRoIHRoZSBgY29sdW1ucy5yZW5kZXJgIGluaXRpYWxpc2F0aW9uXG5cdCAqIG9wdGlvbiB0byBwcm92aWRlIGEgZGlzcGxheSByZW5kZXJlci4gVGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgYXJlIGRlZmluZWQ6XG5cdCAqXG5cdCAqICogYG51bWJlcmAgLSBXaWxsIGZvcm1hdCBudW1lcmljIGRhdGEgKGRlZmluZWQgYnkgYGNvbHVtbnMuZGF0YWApIGZvclxuXHQgKiAgIGRpc3BsYXksIHJldGFpbmluZyB0aGUgb3JpZ2luYWwgdW5mb3JtYXR0ZWQgZGF0YSBmb3Igc29ydGluZyBhbmQgZmlsdGVyaW5nLlxuXHQgKiAgIEl0IHRha2VzIDQgcGFyYW1ldGVyczpcblx0ICogICAqIGBzdHJpbmdgIC0gVGhvdXNhbmRzIGdyb3VwaW5nIHNlcGFyYXRvclxuXHQgKiAgICogYHN0cmluZ2AgLSBEZWNpbWFsIHBvaW50IGluZGljYXRvclxuXHQgKiAgICogYGludGVnZXJgIC0gTnVtYmVyIG9mIGRlY2ltYWwgcG9pbnRzIHRvIHNob3dcblx0ICogICAqIGBzdHJpbmdgIChvcHRpb25hbCkgLSBQcmVmaXguXG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqICAgLy8gQ29sdW1uIGRlZmluaXRpb24gdXNpbmcgdGhlIG51bWJlciByZW5kZXJlclxuXHQgKiAgIHtcblx0ICogICAgIGRhdGE6IFwic2FsYXJ5XCIsXG5cdCAqICAgICByZW5kZXI6ICQuZm4uZGF0YVRhYmxlLnJlbmRlci5udW1iZXIoICdcXCcnLCAnLicsIDAsICckJyApXG5cdCAqICAgfVxuXHQgKlxuXHQgKiBAbmFtZXNwYWNlXG5cdCAqL1xuXHREYXRhVGFibGUucmVuZGVyID0ge1xuXHRcdG51bWJlcjogZnVuY3Rpb24gKCB0aG91c2FuZHMsIGRlY2ltYWwsIHByZWNpc2lvbiwgcHJlZml4ICkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGlzcGxheTogZnVuY3Rpb24gKCBkICkge1xuXHRcdFx0XHRcdGlmICggdHlwZW9mIGQgIT09ICdudW1iZXInICYmIHR5cGVvZiBkICE9PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHRcdHJldHVybiBkO1xuXHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0dmFyIG5lZ2F0aXZlID0gZCA8IDAgPyAnLScgOiAnJztcblx0XHRcdFx0XHRkID0gTWF0aC5hYnMoIHBhcnNlRmxvYXQoIGQgKSApO1xuXHRcblx0XHRcdFx0XHR2YXIgaW50UGFydCA9IHBhcnNlSW50KCBkLCAxMCApO1xuXHRcdFx0XHRcdHZhciBmbG9hdFBhcnQgPSBwcmVjaXNpb24gP1xuXHRcdFx0XHRcdFx0ZGVjaW1hbCsoZCAtIGludFBhcnQpLnRvRml4ZWQoIHByZWNpc2lvbiApLnN1YnN0cmluZyggMiApOlxuXHRcdFx0XHRcdFx0Jyc7XG5cdFxuXHRcdFx0XHRcdHJldHVybiBuZWdhdGl2ZSArIChwcmVmaXh8fCcnKSArXG5cdFx0XHRcdFx0XHRpbnRQYXJ0LnRvU3RyaW5nKCkucmVwbGFjZShcblx0XHRcdFx0XHRcdFx0L1xcQig/PShcXGR7M30pKyg/IVxcZCkpL2csIHRob3VzYW5kc1xuXHRcdFx0XHRcdFx0KSArXG5cdFx0XHRcdFx0XHRmbG9hdFBhcnQ7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHR9O1xuXHRcblx0XG5cdC8qXG5cdCAqIFRoaXMgaXMgcmVhbGx5IGEgZ29vZCBiaXQgcnViYmlzaCB0aGlzIG1ldGhvZCBvZiBleHBvc2luZyB0aGUgaW50ZXJuYWwgbWV0aG9kc1xuXHQgKiBwdWJsaWNseS4uLiAtIFRvIGJlIGZpeGVkIGluIDIuMCB1c2luZyBtZXRob2RzIG9uIHRoZSBwcm90b3R5cGVcblx0ICovXG5cdFxuXHRcblx0LyoqXG5cdCAqIENyZWF0ZSBhIHdyYXBwZXIgZnVuY3Rpb24gZm9yIGV4cG9ydGluZyBhbiBpbnRlcm5hbCBmdW5jdGlvbnMgdG8gYW4gZXh0ZXJuYWwgQVBJLlxuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IGZuIEFQSSBmdW5jdGlvbiBuYW1lXG5cdCAqICBAcmV0dXJucyB7ZnVuY3Rpb259IHdyYXBwZWQgZnVuY3Rpb25cblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjaW50ZXJuYWxcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkV4dGVybkFwaUZ1bmMgKGZuKVxuXHR7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGFyZ3MgPSBbX2ZuU2V0dGluZ3NGcm9tTm9kZSggdGhpc1tEYXRhVGFibGUuZXh0LmlBcGlJbmRleF0gKV0uY29uY2F0KFxuXHRcdFx0XHRBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuIERhdGFUYWJsZS5leHQuaW50ZXJuYWxbZm5dLmFwcGx5KCB0aGlzLCBhcmdzICk7XG5cdFx0fTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBSZWZlcmVuY2UgdG8gaW50ZXJuYWwgZnVuY3Rpb25zIGZvciB1c2UgYnkgcGx1Zy1pbiBkZXZlbG9wZXJzLiBOb3RlIHRoYXRcblx0ICogdGhlc2UgbWV0aG9kcyBhcmUgcmVmZXJlbmNlcyB0byBpbnRlcm5hbCBmdW5jdGlvbnMgYW5kIGFyZSBjb25zaWRlcmVkIHRvIGJlXG5cdCAqIHByaXZhdGUuIElmIHlvdSB1c2UgdGhlc2UgbWV0aG9kcywgYmUgYXdhcmUgdGhhdCB0aGV5IGFyZSBsaWFibGUgdG8gY2hhbmdlXG5cdCAqIGJldHdlZW4gdmVyc2lvbnMuXG5cdCAqICBAbmFtZXNwYWNlXG5cdCAqL1xuXHQkLmV4dGVuZCggRGF0YVRhYmxlLmV4dC5pbnRlcm5hbCwge1xuXHRcdF9mbkV4dGVybkFwaUZ1bmM6IF9mbkV4dGVybkFwaUZ1bmMsXG5cdFx0X2ZuQnVpbGRBamF4OiBfZm5CdWlsZEFqYXgsXG5cdFx0X2ZuQWpheFVwZGF0ZTogX2ZuQWpheFVwZGF0ZSxcblx0XHRfZm5BamF4UGFyYW1ldGVyczogX2ZuQWpheFBhcmFtZXRlcnMsXG5cdFx0X2ZuQWpheFVwZGF0ZURyYXc6IF9mbkFqYXhVcGRhdGVEcmF3LFxuXHRcdF9mbkFqYXhEYXRhU3JjOiBfZm5BamF4RGF0YVNyYyxcblx0XHRfZm5BZGRDb2x1bW46IF9mbkFkZENvbHVtbixcblx0XHRfZm5Db2x1bW5PcHRpb25zOiBfZm5Db2x1bW5PcHRpb25zLFxuXHRcdF9mbkFkanVzdENvbHVtblNpemluZzogX2ZuQWRqdXN0Q29sdW1uU2l6aW5nLFxuXHRcdF9mblZpc2libGVUb0NvbHVtbkluZGV4OiBfZm5WaXNpYmxlVG9Db2x1bW5JbmRleCxcblx0XHRfZm5Db2x1bW5JbmRleFRvVmlzaWJsZTogX2ZuQ29sdW1uSW5kZXhUb1Zpc2libGUsXG5cdFx0X2ZuVmlzYmxlQ29sdW1uczogX2ZuVmlzYmxlQ29sdW1ucyxcblx0XHRfZm5HZXRDb2x1bW5zOiBfZm5HZXRDb2x1bW5zLFxuXHRcdF9mbkNvbHVtblR5cGVzOiBfZm5Db2x1bW5UeXBlcyxcblx0XHRfZm5BcHBseUNvbHVtbkRlZnM6IF9mbkFwcGx5Q29sdW1uRGVmcyxcblx0XHRfZm5IdW5nYXJpYW5NYXA6IF9mbkh1bmdhcmlhbk1hcCxcblx0XHRfZm5DYW1lbFRvSHVuZ2FyaWFuOiBfZm5DYW1lbFRvSHVuZ2FyaWFuLFxuXHRcdF9mbkxhbmd1YWdlQ29tcGF0OiBfZm5MYW5ndWFnZUNvbXBhdCxcblx0XHRfZm5Ccm93c2VyRGV0ZWN0OiBfZm5Ccm93c2VyRGV0ZWN0LFxuXHRcdF9mbkFkZERhdGE6IF9mbkFkZERhdGEsXG5cdFx0X2ZuQWRkVHI6IF9mbkFkZFRyLFxuXHRcdF9mbk5vZGVUb0RhdGFJbmRleDogX2ZuTm9kZVRvRGF0YUluZGV4LFxuXHRcdF9mbk5vZGVUb0NvbHVtbkluZGV4OiBfZm5Ob2RlVG9Db2x1bW5JbmRleCxcblx0XHRfZm5HZXRDZWxsRGF0YTogX2ZuR2V0Q2VsbERhdGEsXG5cdFx0X2ZuU2V0Q2VsbERhdGE6IF9mblNldENlbGxEYXRhLFxuXHRcdF9mblNwbGl0T2JqTm90YXRpb246IF9mblNwbGl0T2JqTm90YXRpb24sXG5cdFx0X2ZuR2V0T2JqZWN0RGF0YUZuOiBfZm5HZXRPYmplY3REYXRhRm4sXG5cdFx0X2ZuU2V0T2JqZWN0RGF0YUZuOiBfZm5TZXRPYmplY3REYXRhRm4sXG5cdFx0X2ZuR2V0RGF0YU1hc3RlcjogX2ZuR2V0RGF0YU1hc3Rlcixcblx0XHRfZm5DbGVhclRhYmxlOiBfZm5DbGVhclRhYmxlLFxuXHRcdF9mbkRlbGV0ZUluZGV4OiBfZm5EZWxldGVJbmRleCxcblx0XHRfZm5JbnZhbGlkYXRlOiBfZm5JbnZhbGlkYXRlLFxuXHRcdF9mbkdldFJvd0VsZW1lbnRzOiBfZm5HZXRSb3dFbGVtZW50cyxcblx0XHRfZm5DcmVhdGVUcjogX2ZuQ3JlYXRlVHIsXG5cdFx0X2ZuQnVpbGRIZWFkOiBfZm5CdWlsZEhlYWQsXG5cdFx0X2ZuRHJhd0hlYWQ6IF9mbkRyYXdIZWFkLFxuXHRcdF9mbkRyYXc6IF9mbkRyYXcsXG5cdFx0X2ZuUmVEcmF3OiBfZm5SZURyYXcsXG5cdFx0X2ZuQWRkT3B0aW9uc0h0bWw6IF9mbkFkZE9wdGlvbnNIdG1sLFxuXHRcdF9mbkRldGVjdEhlYWRlcjogX2ZuRGV0ZWN0SGVhZGVyLFxuXHRcdF9mbkdldFVuaXF1ZVRoczogX2ZuR2V0VW5pcXVlVGhzLFxuXHRcdF9mbkZlYXR1cmVIdG1sRmlsdGVyOiBfZm5GZWF0dXJlSHRtbEZpbHRlcixcblx0XHRfZm5GaWx0ZXJDb21wbGV0ZTogX2ZuRmlsdGVyQ29tcGxldGUsXG5cdFx0X2ZuRmlsdGVyQ3VzdG9tOiBfZm5GaWx0ZXJDdXN0b20sXG5cdFx0X2ZuRmlsdGVyQ29sdW1uOiBfZm5GaWx0ZXJDb2x1bW4sXG5cdFx0X2ZuRmlsdGVyOiBfZm5GaWx0ZXIsXG5cdFx0X2ZuRmlsdGVyQ3JlYXRlU2VhcmNoOiBfZm5GaWx0ZXJDcmVhdGVTZWFyY2gsXG5cdFx0X2ZuRXNjYXBlUmVnZXg6IF9mbkVzY2FwZVJlZ2V4LFxuXHRcdF9mbkZpbHRlckRhdGE6IF9mbkZpbHRlckRhdGEsXG5cdFx0X2ZuRmVhdHVyZUh0bWxJbmZvOiBfZm5GZWF0dXJlSHRtbEluZm8sXG5cdFx0X2ZuVXBkYXRlSW5mbzogX2ZuVXBkYXRlSW5mbyxcblx0XHRfZm5JbmZvTWFjcm9zOiBfZm5JbmZvTWFjcm9zLFxuXHRcdF9mbkluaXRpYWxpc2U6IF9mbkluaXRpYWxpc2UsXG5cdFx0X2ZuSW5pdENvbXBsZXRlOiBfZm5Jbml0Q29tcGxldGUsXG5cdFx0X2ZuTGVuZ3RoQ2hhbmdlOiBfZm5MZW5ndGhDaGFuZ2UsXG5cdFx0X2ZuRmVhdHVyZUh0bWxMZW5ndGg6IF9mbkZlYXR1cmVIdG1sTGVuZ3RoLFxuXHRcdF9mbkZlYXR1cmVIdG1sUGFnaW5hdGU6IF9mbkZlYXR1cmVIdG1sUGFnaW5hdGUsXG5cdFx0X2ZuUGFnZUNoYW5nZTogX2ZuUGFnZUNoYW5nZSxcblx0XHRfZm5GZWF0dXJlSHRtbFByb2Nlc3Npbmc6IF9mbkZlYXR1cmVIdG1sUHJvY2Vzc2luZyxcblx0XHRfZm5Qcm9jZXNzaW5nRGlzcGxheTogX2ZuUHJvY2Vzc2luZ0Rpc3BsYXksXG5cdFx0X2ZuRmVhdHVyZUh0bWxUYWJsZTogX2ZuRmVhdHVyZUh0bWxUYWJsZSxcblx0XHRfZm5TY3JvbGxEcmF3OiBfZm5TY3JvbGxEcmF3LFxuXHRcdF9mbkFwcGx5VG9DaGlsZHJlbjogX2ZuQXBwbHlUb0NoaWxkcmVuLFxuXHRcdF9mbkNhbGN1bGF0ZUNvbHVtbldpZHRoczogX2ZuQ2FsY3VsYXRlQ29sdW1uV2lkdGhzLFxuXHRcdF9mblRocm90dGxlOiBfZm5UaHJvdHRsZSxcblx0XHRfZm5Db252ZXJ0VG9XaWR0aDogX2ZuQ29udmVydFRvV2lkdGgsXG5cdFx0X2ZuU2Nyb2xsaW5nV2lkdGhBZGp1c3Q6IF9mblNjcm9sbGluZ1dpZHRoQWRqdXN0LFxuXHRcdF9mbkdldFdpZGVzdE5vZGU6IF9mbkdldFdpZGVzdE5vZGUsXG5cdFx0X2ZuR2V0TWF4TGVuU3RyaW5nOiBfZm5HZXRNYXhMZW5TdHJpbmcsXG5cdFx0X2ZuU3RyaW5nVG9Dc3M6IF9mblN0cmluZ1RvQ3NzLFxuXHRcdF9mblNjcm9sbEJhcldpZHRoOiBfZm5TY3JvbGxCYXJXaWR0aCxcblx0XHRfZm5Tb3J0RmxhdHRlbjogX2ZuU29ydEZsYXR0ZW4sXG5cdFx0X2ZuU29ydDogX2ZuU29ydCxcblx0XHRfZm5Tb3J0QXJpYTogX2ZuU29ydEFyaWEsXG5cdFx0X2ZuU29ydExpc3RlbmVyOiBfZm5Tb3J0TGlzdGVuZXIsXG5cdFx0X2ZuU29ydEF0dGFjaExpc3RlbmVyOiBfZm5Tb3J0QXR0YWNoTGlzdGVuZXIsXG5cdFx0X2ZuU29ydGluZ0NsYXNzZXM6IF9mblNvcnRpbmdDbGFzc2VzLFxuXHRcdF9mblNvcnREYXRhOiBfZm5Tb3J0RGF0YSxcblx0XHRfZm5TYXZlU3RhdGU6IF9mblNhdmVTdGF0ZSxcblx0XHRfZm5Mb2FkU3RhdGU6IF9mbkxvYWRTdGF0ZSxcblx0XHRfZm5TZXR0aW5nc0Zyb21Ob2RlOiBfZm5TZXR0aW5nc0Zyb21Ob2RlLFxuXHRcdF9mbkxvZzogX2ZuTG9nLFxuXHRcdF9mbk1hcDogX2ZuTWFwLFxuXHRcdF9mbkJpbmRBY3Rpb246IF9mbkJpbmRBY3Rpb24sXG5cdFx0X2ZuQ2FsbGJhY2tSZWc6IF9mbkNhbGxiYWNrUmVnLFxuXHRcdF9mbkNhbGxiYWNrRmlyZTogX2ZuQ2FsbGJhY2tGaXJlLFxuXHRcdF9mbkxlbmd0aE92ZXJmbG93OiBfZm5MZW5ndGhPdmVyZmxvdyxcblx0XHRfZm5SZW5kZXJlcjogX2ZuUmVuZGVyZXIsXG5cdFx0X2ZuRGF0YVNvdXJjZTogX2ZuRGF0YVNvdXJjZSxcblx0XHRfZm5Sb3dBdHRyaWJ1dGVzOiBfZm5Sb3dBdHRyaWJ1dGVzLFxuXHRcdF9mbkNhbGN1bGF0ZUVuZDogZnVuY3Rpb24gKCkge30gLy8gVXNlZCBieSBhIGxvdCBvZiBwbHVnLWlucywgYnV0IHJlZHVuZGFudFxuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gMS4xMCwgc28gdGhpcyBkZWFkLWVuZCBmdW5jdGlvbiBpc1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkZWQgdG8gcHJldmVudCBlcnJvcnNcblx0fSApO1xuXHRcblxuXHQvLyBqUXVlcnkgYWNjZXNzXG5cdCQuZm4uZGF0YVRhYmxlID0gRGF0YVRhYmxlO1xuXG5cdC8vIExlZ2FjeSBhbGlhc2VzXG5cdCQuZm4uZGF0YVRhYmxlU2V0dGluZ3MgPSBEYXRhVGFibGUuc2V0dGluZ3M7XG5cdCQuZm4uZGF0YVRhYmxlRXh0ID0gRGF0YVRhYmxlLmV4dDtcblxuXHQvLyBXaXRoIGEgY2FwaXRhbCBgRGAgd2UgcmV0dXJuIGEgRGF0YVRhYmxlcyBBUEkgaW5zdGFuY2UgcmF0aGVyIHRoYW4gYVxuXHQvLyBqUXVlcnkgb2JqZWN0XG5cdCQuZm4uRGF0YVRhYmxlID0gZnVuY3Rpb24gKCBvcHRzICkge1xuXHRcdHJldHVybiAkKHRoaXMpLmRhdGFUYWJsZSggb3B0cyApLmFwaSgpO1xuXHR9O1xuXG5cdC8vIEFsbCBwcm9wZXJ0aWVzIHRoYXQgYXJlIGF2YWlsYWJsZSB0byAkLmZuLmRhdGFUYWJsZSBzaG91bGQgYWxzbyBiZVxuXHQvLyBhdmFpbGFibGUgb24gJC5mbi5EYXRhVGFibGVcblx0JC5lYWNoKCBEYXRhVGFibGUsIGZ1bmN0aW9uICggcHJvcCwgdmFsICkge1xuXHRcdCQuZm4uRGF0YVRhYmxlWyBwcm9wIF0gPSB2YWw7XG5cdH0gKTtcblxuXG5cdC8vIEluZm9ybWF0aW9uIGFib3V0IGV2ZW50cyBmaXJlZCBieSBEYXRhVGFibGVzIC0gZm9yIGRvY3VtZW50YXRpb24uXG5cdC8qKlxuXHQgKiBEcmF3IGV2ZW50LCBmaXJlZCB3aGVuZXZlciB0aGUgdGFibGUgaXMgcmVkcmF3biBvbiB0aGUgcGFnZSwgYXQgdGhlIHNhbWVcblx0ICogcG9pbnQgYXMgZm5EcmF3Q2FsbGJhY2suIFRoaXMgbWF5IGJlIHVzZWZ1bCBmb3IgYmluZGluZyBldmVudHMgb3Jcblx0ICogcGVyZm9ybWluZyBjYWxjdWxhdGlvbnMgd2hlbiB0aGUgdGFibGUgaXMgYWx0ZXJlZCBhdCBhbGwuXG5cdCAqICBAbmFtZSBEYXRhVGFibGUjZHJhdy5kdFxuXHQgKiAgQGV2ZW50XG5cdCAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cblx0ICovXG5cblx0LyoqXG5cdCAqIFNlYXJjaCBldmVudCwgZmlyZWQgd2hlbiB0aGUgc2VhcmNoaW5nIGFwcGxpZWQgdG8gdGhlIHRhYmxlICh1c2luZyB0aGVcblx0ICogYnVpbHQtaW4gZ2xvYmFsIHNlYXJjaCwgb3IgY29sdW1uIGZpbHRlcnMpIGlzIGFsdGVyZWQuXG5cdCAqICBAbmFtZSBEYXRhVGFibGUjc2VhcmNoLmR0XG5cdCAqICBAZXZlbnRcblx0ICogIEBwYXJhbSB7ZXZlbnR9IGUgalF1ZXJ5IGV2ZW50IG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG8gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Qge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzfVxuXHQgKi9cblxuXHQvKipcblx0ICogUGFnZSBjaGFuZ2UgZXZlbnQsIGZpcmVkIHdoZW4gdGhlIHBhZ2luZyBvZiB0aGUgdGFibGUgaXMgYWx0ZXJlZC5cblx0ICogIEBuYW1lIERhdGFUYWJsZSNwYWdlLmR0XG5cdCAqICBAZXZlbnRcblx0ICogIEBwYXJhbSB7ZXZlbnR9IGUgalF1ZXJ5IGV2ZW50IG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG8gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Qge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzfVxuXHQgKi9cblxuXHQvKipcblx0ICogT3JkZXIgZXZlbnQsIGZpcmVkIHdoZW4gdGhlIG9yZGVyaW5nIGFwcGxpZWQgdG8gdGhlIHRhYmxlIGlzIGFsdGVyZWQuXG5cdCAqICBAbmFtZSBEYXRhVGFibGUjb3JkZXIuZHRcblx0ICogIEBldmVudFxuXHQgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0gbyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdCB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBEYXRhVGFibGVzIGluaXRpYWxpc2F0aW9uIGNvbXBsZXRlIGV2ZW50LCBmaXJlZCB3aGVuIHRoZSB0YWJsZSBpcyBmdWxseVxuXHQgKiBkcmF3biwgaW5jbHVkaW5nIEFqYXggZGF0YSBsb2FkZWQsIGlmIEFqYXggZGF0YSBpcyByZXF1aXJlZC5cblx0ICogIEBuYW1lIERhdGFUYWJsZSNpbml0LmR0XG5cdCAqICBAZXZlbnRcblx0ICogIEBwYXJhbSB7ZXZlbnR9IGUgalF1ZXJ5IGV2ZW50IG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IGpzb24gVGhlIEpTT04gb2JqZWN0IHJlcXVlc3QgZnJvbSB0aGUgc2VydmVyIC0gb25seVxuXHQgKiAgICBwcmVzZW50IGlmIGNsaWVudC1zaWRlIEFqYXggc291cmNlZCBkYXRhIGlzIHVzZWQ8L2xpPjwvb2w+XG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBTdGF0ZSBzYXZlIGV2ZW50LCBmaXJlZCB3aGVuIHRoZSB0YWJsZSBoYXMgY2hhbmdlZCBzdGF0ZSBhIG5ldyBzdGF0ZSBzYXZlXG5cdCAqIGlzIHJlcXVpcmVkLiBUaGlzIGV2ZW50IGFsbG93cyBtb2RpZmljYXRpb24gb2YgdGhlIHN0YXRlIHNhdmluZyBvYmplY3Rcblx0ICogcHJpb3IgdG8gYWN0dWFsbHkgZG9pbmcgdGhlIHNhdmUsIGluY2x1ZGluZyBhZGRpdGlvbiBvciBvdGhlciBzdGF0ZVxuXHQgKiBwcm9wZXJ0aWVzIChmb3IgcGx1Zy1pbnMpIG9yIG1vZGlmaWNhdGlvbiBvZiBhIERhdGFUYWJsZXMgY29yZSBwcm9wZXJ0eS5cblx0ICogIEBuYW1lIERhdGFUYWJsZSNzdGF0ZVNhdmVQYXJhbXMuZHRcblx0ICogIEBldmVudFxuXHQgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0ganNvbiBUaGUgc3RhdGUgaW5mb3JtYXRpb24gdG8gYmUgc2F2ZWRcblx0ICovXG5cblx0LyoqXG5cdCAqIFN0YXRlIGxvYWQgZXZlbnQsIGZpcmVkIHdoZW4gdGhlIHRhYmxlIGlzIGxvYWRpbmcgc3RhdGUgZnJvbSB0aGUgc3RvcmVkXG5cdCAqIGRhdGEsIGJ1dCBwcmlvciB0byB0aGUgc2V0dGluZ3Mgb2JqZWN0IGJlaW5nIG1vZGlmaWVkIGJ5IHRoZSBzYXZlZCBzdGF0ZVxuXHQgKiAtIGFsbG93aW5nIG1vZGlmaWNhdGlvbiBvZiB0aGUgc2F2ZWQgc3RhdGUgaXMgcmVxdWlyZWQgb3IgbG9hZGluZyBvZlxuXHQgKiBzdGF0ZSBmb3IgYSBwbHVnLWluLlxuXHQgKiAgQG5hbWUgRGF0YVRhYmxlI3N0YXRlTG9hZFBhcmFtcy5kdFxuXHQgKiAgQGV2ZW50XG5cdCAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBqc29uIFRoZSBzYXZlZCBzdGF0ZSBpbmZvcm1hdGlvblxuXHQgKi9cblxuXHQvKipcblx0ICogU3RhdGUgbG9hZGVkIGV2ZW50LCBmaXJlZCB3aGVuIHN0YXRlIGhhcyBiZWVuIGxvYWRlZCBmcm9tIHN0b3JlZCBkYXRhIGFuZFxuXHQgKiB0aGUgc2V0dGluZ3Mgb2JqZWN0IGhhcyBiZWVuIG1vZGlmaWVkIGJ5IHRoZSBsb2FkZWQgZGF0YS5cblx0ICogIEBuYW1lIERhdGFUYWJsZSNzdGF0ZUxvYWRlZC5kdFxuXHQgKiAgQGV2ZW50XG5cdCAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBqc29uIFRoZSBzYXZlZCBzdGF0ZSBpbmZvcm1hdGlvblxuXHQgKi9cblxuXHQvKipcblx0ICogUHJvY2Vzc2luZyBldmVudCwgZmlyZWQgd2hlbiBEYXRhVGFibGVzIGlzIGRvaW5nIHNvbWUga2luZCBvZiBwcm9jZXNzaW5nXG5cdCAqIChiZSBpdCwgb3JkZXIsIHNlYXJjZyBvciBhbnl0aGluZyBlbHNlKS4gSXQgY2FuIGJlIHVzZWQgdG8gaW5kaWNhdGUgdG9cblx0ICogdGhlIGVuZCB1c2VyIHRoYXQgdGhlcmUgaXMgc29tZXRoaW5nIGhhcHBlbmluZywgb3IgdGhhdCBzb21ldGhpbmcgaGFzXG5cdCAqIGZpbmlzaGVkLlxuXHQgKiAgQG5hbWUgRGF0YVRhYmxlI3Byb2Nlc3NpbmcuZHRcblx0ICogIEBldmVudFxuXHQgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge2Jvb2xlYW59IGJTaG93IEZsYWcgZm9yIGlmIERhdGFUYWJsZXMgaXMgZG9pbmcgcHJvY2Vzc2luZyBvciBub3Rcblx0ICovXG5cblx0LyoqXG5cdCAqIEFqYXggKFhIUikgZXZlbnQsIGZpcmVkIHdoZW5ldmVyIGFuIEFqYXggcmVxdWVzdCBpcyBjb21wbGV0ZWQgZnJvbSBhXG5cdCAqIHJlcXVlc3QgdG8gbWFkZSB0byB0aGUgc2VydmVyIGZvciBuZXcgZGF0YS4gVGhpcyBldmVudCBpcyBjYWxsZWQgYmVmb3JlXG5cdCAqIERhdGFUYWJsZXMgcHJvY2Vzc2VkIHRoZSByZXR1cm5lZCBkYXRhLCBzbyBpdCBjYW4gYWxzbyBiZSB1c2VkIHRvIHByZS1cblx0ICogcHJvY2VzcyB0aGUgZGF0YSByZXR1cm5lZCBmcm9tIHRoZSBzZXJ2ZXIsIGlmIG5lZWRlZC5cblx0ICpcblx0ICogTm90ZSB0aGF0IHRoaXMgdHJpZ2dlciBpcyBjYWxsZWQgaW4gYGZuU2VydmVyRGF0YWAsIGlmIHlvdSBvdmVycmlkZVxuXHQgKiBgZm5TZXJ2ZXJEYXRhYCBhbmQgd2hpY2ggdG8gdXNlIHRoaXMgZXZlbnQsIHlvdSBuZWVkIHRvIHRyaWdnZXIgaXQgaW4geW91XG5cdCAqIHN1Y2Nlc3MgZnVuY3Rpb24uXG5cdCAqICBAbmFtZSBEYXRhVGFibGUjeGhyLmR0XG5cdCAqICBAZXZlbnRcblx0ICogIEBwYXJhbSB7ZXZlbnR9IGUgalF1ZXJ5IGV2ZW50IG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG8gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Qge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzfVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IGpzb24gSlNPTiByZXR1cm5lZCBmcm9tIHRoZSBzZXJ2ZXJcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgICAvLyBVc2UgYSBjdXN0b20gcHJvcGVydHkgcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyIGluIGFub3RoZXIgRE9NIGVsZW1lbnRcblx0ICogICAgICQoJyN0YWJsZScpLmRhdGFUYWJsZSgpLm9uKCd4aHIuZHQnLCBmdW5jdGlvbiAoZSwgc2V0dGluZ3MsIGpzb24pIHtcblx0ICogICAgICAgJCgnI3N0YXR1cycpLmh0bWwoIGpzb24uc3RhdHVzICk7XG5cdCAqICAgICB9ICk7XG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAgLy8gUHJlLXByb2Nlc3MgdGhlIGRhdGEgcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyXG5cdCAqICAgICAkKCcjdGFibGUnKS5kYXRhVGFibGUoKS5vbigneGhyLmR0JywgZnVuY3Rpb24gKGUsIHNldHRpbmdzLCBqc29uKSB7XG5cdCAqICAgICAgIGZvciAoIHZhciBpPTAsIGllbj1qc29uLmFhRGF0YS5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0ICogICAgICAgICBqc29uLmFhRGF0YVtpXS5zdW0gPSBqc29uLmFhRGF0YVtpXS5vbmUgKyBqc29uLmFhRGF0YVtpXS50d287XG5cdCAqICAgICAgIH1cblx0ICogICAgICAgLy8gTm90ZSBubyByZXR1cm4gLSBtYW5pcHVsYXRlIHRoZSBkYXRhIGRpcmVjdGx5IGluIHRoZSBKU09OIG9iamVjdC5cblx0ICogICAgIH0gKTtcblx0ICovXG5cblx0LyoqXG5cdCAqIERlc3Ryb3kgZXZlbnQsIGZpcmVkIHdoZW4gdGhlIERhdGFUYWJsZSBpcyBkZXN0cm95ZWQgYnkgY2FsbGluZyBmbkRlc3Ryb3lcblx0ICogb3IgcGFzc2luZyB0aGUgYkRlc3Ryb3k6dHJ1ZSBwYXJhbWV0ZXIgaW4gdGhlIGluaXRpYWxpc2F0aW9uIG9iamVjdC4gVGhpc1xuXHQgKiBjYW4gYmUgdXNlZCB0byByZW1vdmUgYm91bmQgZXZlbnRzLCBhZGRlZCBET00gbm9kZXMsIGV0Yy5cblx0ICogIEBuYW1lIERhdGFUYWJsZSNkZXN0cm95LmR0XG5cdCAqICBAZXZlbnRcblx0ICogIEBwYXJhbSB7ZXZlbnR9IGUgalF1ZXJ5IGV2ZW50IG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG8gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Qge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzfVxuXHQgKi9cblxuXHQvKipcblx0ICogUGFnZSBsZW5ndGggY2hhbmdlIGV2ZW50LCBmaXJlZCB3aGVuIG51bWJlciBvZiByZWNvcmRzIHRvIHNob3cgb24gZWFjaFxuXHQgKiBwYWdlICh0aGUgbGVuZ3RoKSBpcyBjaGFuZ2VkLlxuXHQgKiAgQG5hbWUgRGF0YVRhYmxlI2xlbmd0aC5kdFxuXHQgKiAgQGV2ZW50XG5cdCAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cblx0ICogIEBwYXJhbSB7aW50ZWdlcn0gbGVuIE5ldyBsZW5ndGhcblx0ICovXG5cblx0LyoqXG5cdCAqIENvbHVtbiBzaXppbmcgaGFzIGNoYW5nZWQuXG5cdCAqICBAbmFtZSBEYXRhVGFibGUjY29sdW1uLXNpemluZy5kdFxuXHQgKiAgQGV2ZW50XG5cdCAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cblx0ICovXG5cblx0LyoqXG5cdCAqIENvbHVtbiB2aXNpYmlsaXR5IGhhcyBjaGFuZ2VkLlxuXHQgKiAgQG5hbWUgRGF0YVRhYmxlI2NvbHVtbi12aXNpYmlsaXR5LmR0XG5cdCAqICBAZXZlbnRcblx0ICogIEBwYXJhbSB7ZXZlbnR9IGUgalF1ZXJ5IGV2ZW50IG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG8gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Qge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzfVxuXHQgKiAgQHBhcmFtIHtpbnR9IGNvbHVtbiBDb2x1bW4gaW5kZXhcblx0ICogIEBwYXJhbSB7Ym9vbH0gdmlzIGBmYWxzZWAgaWYgY29sdW1uIG5vdyBoaWRkZW4sIG9yIGB0cnVlYCBpZiB2aXNpYmxlXG5cdCAqL1xuXG5cdHJldHVybiAkLmZuLmRhdGFUYWJsZTtcbn0pKTtcblxufSh3aW5kb3csIGRvY3VtZW50KSk7XG5cbiJdLCJzb3VyY2VSb290IjoiIn0=